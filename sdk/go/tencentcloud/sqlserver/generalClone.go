// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sqlserver

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create a sqlserver generalCommunication
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-tencentcloud/sdk/go/tencentcloud/Availability"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Availability"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Security"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Sqlserver"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Subnet"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Vpc"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			zones, err := Availability.GetZonesByProduct(ctx, &availability.GetZonesByProductArgs{
//				Product: "sqlserver",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			vpc, err := Vpc.NewInstance(ctx, "vpc", &Vpc.InstanceArgs{
//				CidrBlock: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			subnet, err := Subnet.NewInstance(ctx, "subnet", &Subnet.InstanceArgs{
//				AvailabilityZone: pulumi.String(zones.Zones[4].Name),
//				VpcId:            vpc.ID(),
//				CidrBlock:        pulumi.String("10.0.0.0/16"),
//				IsMulticast:      pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			securityGroup, err := Security.NewGroup(ctx, "securityGroup", &Security.GroupArgs{
//				Description: pulumi.String("desc."),
//			})
//			if err != nil {
//				return err
//			}
//			exampleBasicInstance, err := Sqlserver.NewBasicInstance(ctx, "exampleBasicInstance", &Sqlserver.BasicInstanceArgs{
//				AvailabilityZone: pulumi.String(zones.Zones[4].Name),
//				ChargeType:       pulumi.String("POSTPAID_BY_HOUR"),
//				VpcId:            vpc.ID(),
//				SubnetId:         subnet.ID(),
//				ProjectId:        pulumi.Int(0),
//				Memory:           pulumi.Int(4),
//				Storage:          pulumi.Int(100),
//				Cpu:              pulumi.Int(2),
//				MachineType:      pulumi.String("CLOUD_PREMIUM"),
//				MaintenanceWeekSets: pulumi.IntArray{
//					pulumi.Int(1),
//					pulumi.Int(2),
//					pulumi.Int(3),
//				},
//				MaintenanceStartTime: pulumi.String("09:00"),
//				MaintenanceTimeSpan:  pulumi.Int(3),
//				SecurityGroups: pulumi.StringArray{
//					securityGroup.ID(),
//				},
//				Tags: pulumi.AnyMap{
//					"test": pulumi.Any("test"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleDb, err := Sqlserver.NewDb(ctx, "exampleDb", &Sqlserver.DbArgs{
//				InstanceId: exampleBasicInstance.ID(),
//				Charset:    pulumi.String("Chinese_PRC_BIN"),
//				Remark:     pulumi.String("test-remark"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = Sqlserver.NewGeneralClone(ctx, "exampleGeneralClone", &Sqlserver.GeneralCloneArgs{
//				InstanceId: exampleDb.InstanceId,
//				OldName:    exampleDb.Name,
//				NewName:    pulumi.String("tf_example_db_clone"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// sqlserver general_communication can be imported using the id, e.g.
//
// ```sh
//
//	$ pulumi import tencentcloud:Sqlserver/generalClone:GeneralClone example mssql-si2823jyl#tf_example_db#tf_example_db_clone
//
// ```
type GeneralClone struct {
	pulumi.CustomResourceState

	// Instance ID.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// New database name. In offline migration, OldName will be used if NewName is left empty (OldName and NewName cannot be both empty). In database cloning, OldName and NewName must be both specified and cannot have the same value.
	NewName pulumi.StringOutput `pulumi:"newName"`
	// Database name. If the OldName database does not exist, a failure will be returned. It can be left empty in offline migration tasks.
	OldName pulumi.StringOutput `pulumi:"oldName"`
}

// NewGeneralClone registers a new resource with the given unique name, arguments, and options.
func NewGeneralClone(ctx *pulumi.Context,
	name string, args *GeneralCloneArgs, opts ...pulumi.ResourceOption) (*GeneralClone, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.NewName == nil {
		return nil, errors.New("invalid value for required argument 'NewName'")
	}
	if args.OldName == nil {
		return nil, errors.New("invalid value for required argument 'OldName'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource GeneralClone
	err := ctx.RegisterResource("tencentcloud:Sqlserver/generalClone:GeneralClone", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGeneralClone gets an existing GeneralClone resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGeneralClone(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GeneralCloneState, opts ...pulumi.ResourceOption) (*GeneralClone, error) {
	var resource GeneralClone
	err := ctx.ReadResource("tencentcloud:Sqlserver/generalClone:GeneralClone", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GeneralClone resources.
type generalCloneState struct {
	// Instance ID.
	InstanceId *string `pulumi:"instanceId"`
	// New database name. In offline migration, OldName will be used if NewName is left empty (OldName and NewName cannot be both empty). In database cloning, OldName and NewName must be both specified and cannot have the same value.
	NewName *string `pulumi:"newName"`
	// Database name. If the OldName database does not exist, a failure will be returned. It can be left empty in offline migration tasks.
	OldName *string `pulumi:"oldName"`
}

type GeneralCloneState struct {
	// Instance ID.
	InstanceId pulumi.StringPtrInput
	// New database name. In offline migration, OldName will be used if NewName is left empty (OldName and NewName cannot be both empty). In database cloning, OldName and NewName must be both specified and cannot have the same value.
	NewName pulumi.StringPtrInput
	// Database name. If the OldName database does not exist, a failure will be returned. It can be left empty in offline migration tasks.
	OldName pulumi.StringPtrInput
}

func (GeneralCloneState) ElementType() reflect.Type {
	return reflect.TypeOf((*generalCloneState)(nil)).Elem()
}

type generalCloneArgs struct {
	// Instance ID.
	InstanceId string `pulumi:"instanceId"`
	// New database name. In offline migration, OldName will be used if NewName is left empty (OldName and NewName cannot be both empty). In database cloning, OldName and NewName must be both specified and cannot have the same value.
	NewName string `pulumi:"newName"`
	// Database name. If the OldName database does not exist, a failure will be returned. It can be left empty in offline migration tasks.
	OldName string `pulumi:"oldName"`
}

// The set of arguments for constructing a GeneralClone resource.
type GeneralCloneArgs struct {
	// Instance ID.
	InstanceId pulumi.StringInput
	// New database name. In offline migration, OldName will be used if NewName is left empty (OldName and NewName cannot be both empty). In database cloning, OldName and NewName must be both specified and cannot have the same value.
	NewName pulumi.StringInput
	// Database name. If the OldName database does not exist, a failure will be returned. It can be left empty in offline migration tasks.
	OldName pulumi.StringInput
}

func (GeneralCloneArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*generalCloneArgs)(nil)).Elem()
}

type GeneralCloneInput interface {
	pulumi.Input

	ToGeneralCloneOutput() GeneralCloneOutput
	ToGeneralCloneOutputWithContext(ctx context.Context) GeneralCloneOutput
}

func (*GeneralClone) ElementType() reflect.Type {
	return reflect.TypeOf((**GeneralClone)(nil)).Elem()
}

func (i *GeneralClone) ToGeneralCloneOutput() GeneralCloneOutput {
	return i.ToGeneralCloneOutputWithContext(context.Background())
}

func (i *GeneralClone) ToGeneralCloneOutputWithContext(ctx context.Context) GeneralCloneOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GeneralCloneOutput)
}

// GeneralCloneArrayInput is an input type that accepts GeneralCloneArray and GeneralCloneArrayOutput values.
// You can construct a concrete instance of `GeneralCloneArrayInput` via:
//
//	GeneralCloneArray{ GeneralCloneArgs{...} }
type GeneralCloneArrayInput interface {
	pulumi.Input

	ToGeneralCloneArrayOutput() GeneralCloneArrayOutput
	ToGeneralCloneArrayOutputWithContext(context.Context) GeneralCloneArrayOutput
}

type GeneralCloneArray []GeneralCloneInput

func (GeneralCloneArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GeneralClone)(nil)).Elem()
}

func (i GeneralCloneArray) ToGeneralCloneArrayOutput() GeneralCloneArrayOutput {
	return i.ToGeneralCloneArrayOutputWithContext(context.Background())
}

func (i GeneralCloneArray) ToGeneralCloneArrayOutputWithContext(ctx context.Context) GeneralCloneArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GeneralCloneArrayOutput)
}

// GeneralCloneMapInput is an input type that accepts GeneralCloneMap and GeneralCloneMapOutput values.
// You can construct a concrete instance of `GeneralCloneMapInput` via:
//
//	GeneralCloneMap{ "key": GeneralCloneArgs{...} }
type GeneralCloneMapInput interface {
	pulumi.Input

	ToGeneralCloneMapOutput() GeneralCloneMapOutput
	ToGeneralCloneMapOutputWithContext(context.Context) GeneralCloneMapOutput
}

type GeneralCloneMap map[string]GeneralCloneInput

func (GeneralCloneMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GeneralClone)(nil)).Elem()
}

func (i GeneralCloneMap) ToGeneralCloneMapOutput() GeneralCloneMapOutput {
	return i.ToGeneralCloneMapOutputWithContext(context.Background())
}

func (i GeneralCloneMap) ToGeneralCloneMapOutputWithContext(ctx context.Context) GeneralCloneMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GeneralCloneMapOutput)
}

type GeneralCloneOutput struct{ *pulumi.OutputState }

func (GeneralCloneOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GeneralClone)(nil)).Elem()
}

func (o GeneralCloneOutput) ToGeneralCloneOutput() GeneralCloneOutput {
	return o
}

func (o GeneralCloneOutput) ToGeneralCloneOutputWithContext(ctx context.Context) GeneralCloneOutput {
	return o
}

// Instance ID.
func (o GeneralCloneOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *GeneralClone) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// New database name. In offline migration, OldName will be used if NewName is left empty (OldName and NewName cannot be both empty). In database cloning, OldName and NewName must be both specified and cannot have the same value.
func (o GeneralCloneOutput) NewName() pulumi.StringOutput {
	return o.ApplyT(func(v *GeneralClone) pulumi.StringOutput { return v.NewName }).(pulumi.StringOutput)
}

// Database name. If the OldName database does not exist, a failure will be returned. It can be left empty in offline migration tasks.
func (o GeneralCloneOutput) OldName() pulumi.StringOutput {
	return o.ApplyT(func(v *GeneralClone) pulumi.StringOutput { return v.OldName }).(pulumi.StringOutput)
}

type GeneralCloneArrayOutput struct{ *pulumi.OutputState }

func (GeneralCloneArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GeneralClone)(nil)).Elem()
}

func (o GeneralCloneArrayOutput) ToGeneralCloneArrayOutput() GeneralCloneArrayOutput {
	return o
}

func (o GeneralCloneArrayOutput) ToGeneralCloneArrayOutputWithContext(ctx context.Context) GeneralCloneArrayOutput {
	return o
}

func (o GeneralCloneArrayOutput) Index(i pulumi.IntInput) GeneralCloneOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GeneralClone {
		return vs[0].([]*GeneralClone)[vs[1].(int)]
	}).(GeneralCloneOutput)
}

type GeneralCloneMapOutput struct{ *pulumi.OutputState }

func (GeneralCloneMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GeneralClone)(nil)).Elem()
}

func (o GeneralCloneMapOutput) ToGeneralCloneMapOutput() GeneralCloneMapOutput {
	return o
}

func (o GeneralCloneMapOutput) ToGeneralCloneMapOutputWithContext(ctx context.Context) GeneralCloneMapOutput {
	return o
}

func (o GeneralCloneMapOutput) MapIndex(k pulumi.StringInput) GeneralCloneOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GeneralClone {
		return vs[0].(map[string]*GeneralClone)[vs[1].(string)]
	}).(GeneralCloneOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GeneralCloneInput)(nil)).Elem(), &GeneralClone{})
	pulumi.RegisterInputType(reflect.TypeOf((*GeneralCloneArrayInput)(nil)).Elem(), GeneralCloneArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GeneralCloneMapInput)(nil)).Elem(), GeneralCloneMap{})
	pulumi.RegisterOutputType(GeneralCloneOutput{})
	pulumi.RegisterOutputType(GeneralCloneArrayOutput{})
	pulumi.RegisterOutputType(GeneralCloneMapOutput{})
}
