// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package redis

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create a redis replicaReadonly
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-tencentcloud/sdk/go/tencentcloud/Redis"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Redis"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Security"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Subnet"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Vpc"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		zone, err := Redis.GetZoneConfig(ctx, &redis.GetZoneConfigArgs{
// 			TypeId: pulumi.IntRef(7),
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		vpc, err := Vpc.NewInstance(ctx, "vpc", &Vpc.InstanceArgs{
// 			CidrBlock: pulumi.String("10.0.0.0/16"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		subnet, err := Subnet.NewInstance(ctx, "subnet", &Subnet.InstanceArgs{
// 			VpcId:            vpc.ID(),
// 			AvailabilityZone: pulumi.String(zone.Lists[1].Zone),
// 			CidrBlock:        pulumi.String("10.0.1.0/24"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		fooGroup, err := Security.NewGroup(ctx, "fooGroup", nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = Security.NewGroupLiteRule(ctx, "fooGroupLiteRule", &Security.GroupLiteRuleArgs{
// 			SecurityGroupId: fooGroup.ID(),
// 			Ingresses: pulumi.StringArray{
// 				pulumi.String("ACCEPT#192.168.1.0/24#80#TCP"),
// 				pulumi.String("DROP#8.8.8.8#80,90#UDP"),
// 				pulumi.String("DROP#0.0.0.0/0#80-90#TCP"),
// 			},
// 			Egresses: pulumi.StringArray{
// 				pulumi.String("ACCEPT#192.168.0.0/16#ALL#TCP"),
// 				pulumi.String("ACCEPT#10.0.0.0/8#ALL#ICMP"),
// 				pulumi.String("DROP#0.0.0.0/0#ALL#ALL"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		fooInstance, err := Redis.NewInstance(ctx, "fooInstance", &Redis.InstanceArgs{
// 			AvailabilityZone: pulumi.String(zone.Lists[0].Zone),
// 			TypeId:           pulumi.Int(zone.Lists[0].TypeId),
// 			Password:         pulumi.String("test12345789"),
// 			MemSize:          pulumi.Int(8192),
// 			RedisShardNum:    pulumi.Int(zone.Lists[0].RedisShardNums[0]),
// 			RedisReplicasNum: pulumi.Int(zone.Lists[0].RedisReplicasNums[0]),
// 			Port:             pulumi.Int(6379),
// 			VpcId:            vpc.ID(),
// 			SubnetId:         subnet.ID(),
// 			SecurityGroups: pulumi.StringArray{
// 				fooGroup.ID(),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = Redis.NewReplicaReadonly(ctx, "replicaReadonly", &Redis.ReplicaReadonlyArgs{
// 			InstanceId: fooInstance.ID(),
// 			ReadonlyPolicies: pulumi.StringArray{
// 				pulumi.String("master"),
// 			},
// 			Operate: pulumi.String("enable"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type ReplicaReadonly struct {
	pulumi.CustomResourceState

	// The ID of instance.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate pulumi.StringOutput `pulumi:"operate"`
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies pulumi.StringArrayOutput `pulumi:"readonlyPolicies"`
}

// NewReplicaReadonly registers a new resource with the given unique name, arguments, and options.
func NewReplicaReadonly(ctx *pulumi.Context,
	name string, args *ReplicaReadonlyArgs, opts ...pulumi.ResourceOption) (*ReplicaReadonly, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.Operate == nil {
		return nil, errors.New("invalid value for required argument 'Operate'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource ReplicaReadonly
	err := ctx.RegisterResource("tencentcloud:Redis/replicaReadonly:ReplicaReadonly", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetReplicaReadonly gets an existing ReplicaReadonly resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetReplicaReadonly(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ReplicaReadonlyState, opts ...pulumi.ResourceOption) (*ReplicaReadonly, error) {
	var resource ReplicaReadonly
	err := ctx.ReadResource("tencentcloud:Redis/replicaReadonly:ReplicaReadonly", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ReplicaReadonly resources.
type replicaReadonlyState struct {
	// The ID of instance.
	InstanceId *string `pulumi:"instanceId"`
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate *string `pulumi:"operate"`
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies []string `pulumi:"readonlyPolicies"`
}

type ReplicaReadonlyState struct {
	// The ID of instance.
	InstanceId pulumi.StringPtrInput
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate pulumi.StringPtrInput
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies pulumi.StringArrayInput
}

func (ReplicaReadonlyState) ElementType() reflect.Type {
	return reflect.TypeOf((*replicaReadonlyState)(nil)).Elem()
}

type replicaReadonlyArgs struct {
	// The ID of instance.
	InstanceId string `pulumi:"instanceId"`
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate string `pulumi:"operate"`
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies []string `pulumi:"readonlyPolicies"`
}

// The set of arguments for constructing a ReplicaReadonly resource.
type ReplicaReadonlyArgs struct {
	// The ID of instance.
	InstanceId pulumi.StringInput
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate pulumi.StringInput
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies pulumi.StringArrayInput
}

func (ReplicaReadonlyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*replicaReadonlyArgs)(nil)).Elem()
}

type ReplicaReadonlyInput interface {
	pulumi.Input

	ToReplicaReadonlyOutput() ReplicaReadonlyOutput
	ToReplicaReadonlyOutputWithContext(ctx context.Context) ReplicaReadonlyOutput
}

func (*ReplicaReadonly) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaReadonly)(nil)).Elem()
}

func (i *ReplicaReadonly) ToReplicaReadonlyOutput() ReplicaReadonlyOutput {
	return i.ToReplicaReadonlyOutputWithContext(context.Background())
}

func (i *ReplicaReadonly) ToReplicaReadonlyOutputWithContext(ctx context.Context) ReplicaReadonlyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaReadonlyOutput)
}

// ReplicaReadonlyArrayInput is an input type that accepts ReplicaReadonlyArray and ReplicaReadonlyArrayOutput values.
// You can construct a concrete instance of `ReplicaReadonlyArrayInput` via:
//
//          ReplicaReadonlyArray{ ReplicaReadonlyArgs{...} }
type ReplicaReadonlyArrayInput interface {
	pulumi.Input

	ToReplicaReadonlyArrayOutput() ReplicaReadonlyArrayOutput
	ToReplicaReadonlyArrayOutputWithContext(context.Context) ReplicaReadonlyArrayOutput
}

type ReplicaReadonlyArray []ReplicaReadonlyInput

func (ReplicaReadonlyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReplicaReadonly)(nil)).Elem()
}

func (i ReplicaReadonlyArray) ToReplicaReadonlyArrayOutput() ReplicaReadonlyArrayOutput {
	return i.ToReplicaReadonlyArrayOutputWithContext(context.Background())
}

func (i ReplicaReadonlyArray) ToReplicaReadonlyArrayOutputWithContext(ctx context.Context) ReplicaReadonlyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaReadonlyArrayOutput)
}

// ReplicaReadonlyMapInput is an input type that accepts ReplicaReadonlyMap and ReplicaReadonlyMapOutput values.
// You can construct a concrete instance of `ReplicaReadonlyMapInput` via:
//
//          ReplicaReadonlyMap{ "key": ReplicaReadonlyArgs{...} }
type ReplicaReadonlyMapInput interface {
	pulumi.Input

	ToReplicaReadonlyMapOutput() ReplicaReadonlyMapOutput
	ToReplicaReadonlyMapOutputWithContext(context.Context) ReplicaReadonlyMapOutput
}

type ReplicaReadonlyMap map[string]ReplicaReadonlyInput

func (ReplicaReadonlyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReplicaReadonly)(nil)).Elem()
}

func (i ReplicaReadonlyMap) ToReplicaReadonlyMapOutput() ReplicaReadonlyMapOutput {
	return i.ToReplicaReadonlyMapOutputWithContext(context.Background())
}

func (i ReplicaReadonlyMap) ToReplicaReadonlyMapOutputWithContext(ctx context.Context) ReplicaReadonlyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaReadonlyMapOutput)
}

type ReplicaReadonlyOutput struct{ *pulumi.OutputState }

func (ReplicaReadonlyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaReadonly)(nil)).Elem()
}

func (o ReplicaReadonlyOutput) ToReplicaReadonlyOutput() ReplicaReadonlyOutput {
	return o
}

func (o ReplicaReadonlyOutput) ToReplicaReadonlyOutputWithContext(ctx context.Context) ReplicaReadonlyOutput {
	return o
}

// The ID of instance.
func (o ReplicaReadonlyOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicaReadonly) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
func (o ReplicaReadonlyOutput) Operate() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicaReadonly) pulumi.StringOutput { return v.Operate }).(pulumi.StringOutput)
}

// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
func (o ReplicaReadonlyOutput) ReadonlyPolicies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ReplicaReadonly) pulumi.StringArrayOutput { return v.ReadonlyPolicies }).(pulumi.StringArrayOutput)
}

type ReplicaReadonlyArrayOutput struct{ *pulumi.OutputState }

func (ReplicaReadonlyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReplicaReadonly)(nil)).Elem()
}

func (o ReplicaReadonlyArrayOutput) ToReplicaReadonlyArrayOutput() ReplicaReadonlyArrayOutput {
	return o
}

func (o ReplicaReadonlyArrayOutput) ToReplicaReadonlyArrayOutputWithContext(ctx context.Context) ReplicaReadonlyArrayOutput {
	return o
}

func (o ReplicaReadonlyArrayOutput) Index(i pulumi.IntInput) ReplicaReadonlyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ReplicaReadonly {
		return vs[0].([]*ReplicaReadonly)[vs[1].(int)]
	}).(ReplicaReadonlyOutput)
}

type ReplicaReadonlyMapOutput struct{ *pulumi.OutputState }

func (ReplicaReadonlyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReplicaReadonly)(nil)).Elem()
}

func (o ReplicaReadonlyMapOutput) ToReplicaReadonlyMapOutput() ReplicaReadonlyMapOutput {
	return o
}

func (o ReplicaReadonlyMapOutput) ToReplicaReadonlyMapOutputWithContext(ctx context.Context) ReplicaReadonlyMapOutput {
	return o
}

func (o ReplicaReadonlyMapOutput) MapIndex(k pulumi.StringInput) ReplicaReadonlyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ReplicaReadonly {
		return vs[0].(map[string]*ReplicaReadonly)[vs[1].(string)]
	}).(ReplicaReadonlyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaReadonlyInput)(nil)).Elem(), &ReplicaReadonly{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaReadonlyArrayInput)(nil)).Elem(), ReplicaReadonlyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaReadonlyMapInput)(nil)).Elem(), ReplicaReadonlyMap{})
	pulumi.RegisterOutputType(ReplicaReadonlyOutput{})
	pulumi.RegisterOutputType(ReplicaReadonlyArrayOutput{})
	pulumi.RegisterOutputType(ReplicaReadonlyMapOutput{})
}
