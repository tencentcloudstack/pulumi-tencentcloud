// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package redis

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/internal"
)

// Provides a resource to create a redis replicaReadonly
type ReplicaReadonly struct {
	pulumi.CustomResourceState

	// The ID of instance.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate pulumi.StringOutput `pulumi:"operate"`
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies pulumi.StringArrayOutput `pulumi:"readonlyPolicies"`
}

// NewReplicaReadonly registers a new resource with the given unique name, arguments, and options.
func NewReplicaReadonly(ctx *pulumi.Context,
	name string, args *ReplicaReadonlyArgs, opts ...pulumi.ResourceOption) (*ReplicaReadonly, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.Operate == nil {
		return nil, errors.New("invalid value for required argument 'Operate'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ReplicaReadonly
	err := ctx.RegisterResource("tencentcloud:Redis/replicaReadonly:ReplicaReadonly", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetReplicaReadonly gets an existing ReplicaReadonly resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetReplicaReadonly(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ReplicaReadonlyState, opts ...pulumi.ResourceOption) (*ReplicaReadonly, error) {
	var resource ReplicaReadonly
	err := ctx.ReadResource("tencentcloud:Redis/replicaReadonly:ReplicaReadonly", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ReplicaReadonly resources.
type replicaReadonlyState struct {
	// The ID of instance.
	InstanceId *string `pulumi:"instanceId"`
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate *string `pulumi:"operate"`
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies []string `pulumi:"readonlyPolicies"`
}

type ReplicaReadonlyState struct {
	// The ID of instance.
	InstanceId pulumi.StringPtrInput
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate pulumi.StringPtrInput
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies pulumi.StringArrayInput
}

func (ReplicaReadonlyState) ElementType() reflect.Type {
	return reflect.TypeOf((*replicaReadonlyState)(nil)).Elem()
}

type replicaReadonlyArgs struct {
	// The ID of instance.
	InstanceId string `pulumi:"instanceId"`
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate string `pulumi:"operate"`
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies []string `pulumi:"readonlyPolicies"`
}

// The set of arguments for constructing a ReplicaReadonly resource.
type ReplicaReadonlyArgs struct {
	// The ID of instance.
	InstanceId pulumi.StringInput
	// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
	Operate pulumi.StringInput
	// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
	ReadonlyPolicies pulumi.StringArrayInput
}

func (ReplicaReadonlyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*replicaReadonlyArgs)(nil)).Elem()
}

type ReplicaReadonlyInput interface {
	pulumi.Input

	ToReplicaReadonlyOutput() ReplicaReadonlyOutput
	ToReplicaReadonlyOutputWithContext(ctx context.Context) ReplicaReadonlyOutput
}

func (*ReplicaReadonly) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaReadonly)(nil)).Elem()
}

func (i *ReplicaReadonly) ToReplicaReadonlyOutput() ReplicaReadonlyOutput {
	return i.ToReplicaReadonlyOutputWithContext(context.Background())
}

func (i *ReplicaReadonly) ToReplicaReadonlyOutputWithContext(ctx context.Context) ReplicaReadonlyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaReadonlyOutput)
}

// ReplicaReadonlyArrayInput is an input type that accepts ReplicaReadonlyArray and ReplicaReadonlyArrayOutput values.
// You can construct a concrete instance of `ReplicaReadonlyArrayInput` via:
//
//	ReplicaReadonlyArray{ ReplicaReadonlyArgs{...} }
type ReplicaReadonlyArrayInput interface {
	pulumi.Input

	ToReplicaReadonlyArrayOutput() ReplicaReadonlyArrayOutput
	ToReplicaReadonlyArrayOutputWithContext(context.Context) ReplicaReadonlyArrayOutput
}

type ReplicaReadonlyArray []ReplicaReadonlyInput

func (ReplicaReadonlyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReplicaReadonly)(nil)).Elem()
}

func (i ReplicaReadonlyArray) ToReplicaReadonlyArrayOutput() ReplicaReadonlyArrayOutput {
	return i.ToReplicaReadonlyArrayOutputWithContext(context.Background())
}

func (i ReplicaReadonlyArray) ToReplicaReadonlyArrayOutputWithContext(ctx context.Context) ReplicaReadonlyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaReadonlyArrayOutput)
}

// ReplicaReadonlyMapInput is an input type that accepts ReplicaReadonlyMap and ReplicaReadonlyMapOutput values.
// You can construct a concrete instance of `ReplicaReadonlyMapInput` via:
//
//	ReplicaReadonlyMap{ "key": ReplicaReadonlyArgs{...} }
type ReplicaReadonlyMapInput interface {
	pulumi.Input

	ToReplicaReadonlyMapOutput() ReplicaReadonlyMapOutput
	ToReplicaReadonlyMapOutputWithContext(context.Context) ReplicaReadonlyMapOutput
}

type ReplicaReadonlyMap map[string]ReplicaReadonlyInput

func (ReplicaReadonlyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReplicaReadonly)(nil)).Elem()
}

func (i ReplicaReadonlyMap) ToReplicaReadonlyMapOutput() ReplicaReadonlyMapOutput {
	return i.ToReplicaReadonlyMapOutputWithContext(context.Background())
}

func (i ReplicaReadonlyMap) ToReplicaReadonlyMapOutputWithContext(ctx context.Context) ReplicaReadonlyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaReadonlyMapOutput)
}

type ReplicaReadonlyOutput struct{ *pulumi.OutputState }

func (ReplicaReadonlyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaReadonly)(nil)).Elem()
}

func (o ReplicaReadonlyOutput) ToReplicaReadonlyOutput() ReplicaReadonlyOutput {
	return o
}

func (o ReplicaReadonlyOutput) ToReplicaReadonlyOutputWithContext(ctx context.Context) ReplicaReadonlyOutput {
	return o
}

// The ID of instance.
func (o ReplicaReadonlyOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicaReadonly) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// The replica is read-only, `enable` - enable read-write splitting, `disable`- disable read-write splitting.
func (o ReplicaReadonlyOutput) Operate() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicaReadonly) pulumi.StringOutput { return v.Operate }).(pulumi.StringOutput)
}

// Routing policy: Enter `master` or `replication`, which indicates the master node or slave node.
func (o ReplicaReadonlyOutput) ReadonlyPolicies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ReplicaReadonly) pulumi.StringArrayOutput { return v.ReadonlyPolicies }).(pulumi.StringArrayOutput)
}

type ReplicaReadonlyArrayOutput struct{ *pulumi.OutputState }

func (ReplicaReadonlyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReplicaReadonly)(nil)).Elem()
}

func (o ReplicaReadonlyArrayOutput) ToReplicaReadonlyArrayOutput() ReplicaReadonlyArrayOutput {
	return o
}

func (o ReplicaReadonlyArrayOutput) ToReplicaReadonlyArrayOutputWithContext(ctx context.Context) ReplicaReadonlyArrayOutput {
	return o
}

func (o ReplicaReadonlyArrayOutput) Index(i pulumi.IntInput) ReplicaReadonlyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ReplicaReadonly {
		return vs[0].([]*ReplicaReadonly)[vs[1].(int)]
	}).(ReplicaReadonlyOutput)
}

type ReplicaReadonlyMapOutput struct{ *pulumi.OutputState }

func (ReplicaReadonlyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReplicaReadonly)(nil)).Elem()
}

func (o ReplicaReadonlyMapOutput) ToReplicaReadonlyMapOutput() ReplicaReadonlyMapOutput {
	return o
}

func (o ReplicaReadonlyMapOutput) ToReplicaReadonlyMapOutputWithContext(ctx context.Context) ReplicaReadonlyMapOutput {
	return o
}

func (o ReplicaReadonlyMapOutput) MapIndex(k pulumi.StringInput) ReplicaReadonlyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ReplicaReadonly {
		return vs[0].(map[string]*ReplicaReadonly)[vs[1].(string)]
	}).(ReplicaReadonlyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaReadonlyInput)(nil)).Elem(), &ReplicaReadonly{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaReadonlyArrayInput)(nil)).Elem(), ReplicaReadonlyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaReadonlyMapInput)(nil)).Elem(), ReplicaReadonlyMap{})
	pulumi.RegisterOutputType(ReplicaReadonlyOutput{})
	pulumi.RegisterOutputType(ReplicaReadonlyArrayOutput{})
	pulumi.RegisterOutputType(ReplicaReadonlyMapOutput{})
}
