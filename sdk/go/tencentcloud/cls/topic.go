// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cls

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/internal"
)

// Provides a resource to create a cls topic.
//
// ## Example Usage
//
// ### Create a standard cls topic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/cls"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := cls.NewLogset(ctx, "example", &cls.LogsetArgs{
//				LogsetName: pulumi.String("tf_example"),
//				Tags: pulumi.StringMap{
//					"tagKey": pulumi.String("tagValue"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cls.NewTopic(ctx, "example", &cls.TopicArgs{
//				TopicName:          pulumi.String("tf_example"),
//				LogsetId:           example.ID(),
//				AutoSplit:          pulumi.Bool(false),
//				MaxSplitPartitions: pulumi.Int(20),
//				PartitionCount:     pulumi.Int(1),
//				Period:             pulumi.Int(30),
//				StorageType:        pulumi.String("hot"),
//				Describes:          pulumi.String("Test Demo."),
//				HotPeriod:          pulumi.Int(10),
//				Tags: pulumi.StringMap{
//					"tagKey": pulumi.String("tagValue"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Create a cls topic with web tracking
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/cls"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := cls.NewLogset(ctx, "example", &cls.LogsetArgs{
//				LogsetName: pulumi.String("tf_example"),
//				Tags: pulumi.StringMap{
//					"tagKey": pulumi.String("tagValue"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cls.NewTopic(ctx, "example", &cls.TopicArgs{
//				TopicName:          pulumi.String("tf_example"),
//				LogsetId:           example.ID(),
//				AutoSplit:          pulumi.Bool(false),
//				MaxSplitPartitions: pulumi.Int(20),
//				PartitionCount:     pulumi.Int(1),
//				Period:             pulumi.Int(30),
//				StorageType:        pulumi.String("hot"),
//				Describes:          pulumi.String("Test Demo."),
//				HotPeriod:          pulumi.Int(10),
//				IsWebTracking:      pulumi.Bool(true),
//				Extends: &cls.TopicExtendsArgs{
//					AnonymousAccess: &cls.TopicExtendsAnonymousAccessArgs{
//						Operations: pulumi.StringArray{
//							pulumi.String("trackLog"),
//							pulumi.String("realtimeProducer"),
//						},
//						Conditions: cls.TopicExtendsAnonymousAccessConditionArray{
//							&cls.TopicExtendsAnonymousAccessConditionArgs{
//								Attributes:     pulumi.String("VpcID"),
//								Rule:           pulumi.Int(1),
//								ConditionValue: pulumi.String("vpc-ahr3xajx"),
//							},
//						},
//					},
//				},
//				Tags: pulumi.StringMap{
//					"tagKey": pulumi.String("tagValue"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// cls topic can be imported using the id, e.g.
//
// ```sh
// $ pulumi import tencentcloud:Cls/topic:Topic example 2f5764c1-c833-44c5-84c7-950979b2a278
// ```
type Topic struct {
	pulumi.CustomResourceState

	// Whether to enable automatic split. Default value: true.
	AutoSplit pulumi.BoolOutput `pulumi:"autoSplit"`
	// Log Topic Description.
	Describes pulumi.StringPtrOutput `pulumi:"describes"`
	// Log Subject Extension Information.
	Extends TopicExtendsPtrOutput `pulumi:"extends"`
	// 0: Turn off log sinking. Non 0: The number of days of standard storage after enabling log settling. HotPeriod needs to be greater than or equal to 7 and less than Period. Only effective when StorageType is hot.
	HotPeriod pulumi.IntOutput `pulumi:"hotPeriod"`
	// No authentication switch. False: closed; True: Enable. The default is false. After activation, anonymous access to the log topic will be supported for specified operations.
	IsWebTracking pulumi.BoolOutput `pulumi:"isWebTracking"`
	// Logset ID.
	LogsetId pulumi.StringOutput `pulumi:"logsetId"`
	// Maximum number of partitions to split into for this topic if automatic split is enabled. Default value: 50.
	MaxSplitPartitions pulumi.IntOutput `pulumi:"maxSplitPartitions"`
	// Number of log topic partitions. Default value: 1. Maximum value: 10.
	PartitionCount pulumi.IntOutput `pulumi:"partitionCount"`
	// lifetime. Unit: days. Standard storage value range: 1 to 3600. Infrequent storage value range: 7 to 3600 days. A value of 3640 indicates permanent retention.If this value is not input, it defaults to the Period value of the log set corresponding to the accessed log topic (defaults to 30 days in case of access failure).
	Period pulumi.IntOutput `pulumi:"period"`
	// Log topic storage class. Valid values: hot: real-time storage; cold: offline storage. Default value: hot. If cold is passed in, please contact the customer service to add the log topic to the allowlist first.
	StorageType pulumi.StringOutput `pulumi:"storageType"`
	// Tag description list. Up to 10 tag key-value pairs are supported and must be unique.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Log topic name.
	TopicName pulumi.StringOutput `pulumi:"topicName"`
}

// NewTopic registers a new resource with the given unique name, arguments, and options.
func NewTopic(ctx *pulumi.Context,
	name string, args *TopicArgs, opts ...pulumi.ResourceOption) (*Topic, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LogsetId == nil {
		return nil, errors.New("invalid value for required argument 'LogsetId'")
	}
	if args.TopicName == nil {
		return nil, errors.New("invalid value for required argument 'TopicName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Topic
	err := ctx.RegisterResource("tencentcloud:Cls/topic:Topic", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTopic gets an existing Topic resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTopic(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TopicState, opts ...pulumi.ResourceOption) (*Topic, error) {
	var resource Topic
	err := ctx.ReadResource("tencentcloud:Cls/topic:Topic", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Topic resources.
type topicState struct {
	// Whether to enable automatic split. Default value: true.
	AutoSplit *bool `pulumi:"autoSplit"`
	// Log Topic Description.
	Describes *string `pulumi:"describes"`
	// Log Subject Extension Information.
	Extends *TopicExtends `pulumi:"extends"`
	// 0: Turn off log sinking. Non 0: The number of days of standard storage after enabling log settling. HotPeriod needs to be greater than or equal to 7 and less than Period. Only effective when StorageType is hot.
	HotPeriod *int `pulumi:"hotPeriod"`
	// No authentication switch. False: closed; True: Enable. The default is false. After activation, anonymous access to the log topic will be supported for specified operations.
	IsWebTracking *bool `pulumi:"isWebTracking"`
	// Logset ID.
	LogsetId *string `pulumi:"logsetId"`
	// Maximum number of partitions to split into for this topic if automatic split is enabled. Default value: 50.
	MaxSplitPartitions *int `pulumi:"maxSplitPartitions"`
	// Number of log topic partitions. Default value: 1. Maximum value: 10.
	PartitionCount *int `pulumi:"partitionCount"`
	// lifetime. Unit: days. Standard storage value range: 1 to 3600. Infrequent storage value range: 7 to 3600 days. A value of 3640 indicates permanent retention.If this value is not input, it defaults to the Period value of the log set corresponding to the accessed log topic (defaults to 30 days in case of access failure).
	Period *int `pulumi:"period"`
	// Log topic storage class. Valid values: hot: real-time storage; cold: offline storage. Default value: hot. If cold is passed in, please contact the customer service to add the log topic to the allowlist first.
	StorageType *string `pulumi:"storageType"`
	// Tag description list. Up to 10 tag key-value pairs are supported and must be unique.
	Tags map[string]string `pulumi:"tags"`
	// Log topic name.
	TopicName *string `pulumi:"topicName"`
}

type TopicState struct {
	// Whether to enable automatic split. Default value: true.
	AutoSplit pulumi.BoolPtrInput
	// Log Topic Description.
	Describes pulumi.StringPtrInput
	// Log Subject Extension Information.
	Extends TopicExtendsPtrInput
	// 0: Turn off log sinking. Non 0: The number of days of standard storage after enabling log settling. HotPeriod needs to be greater than or equal to 7 and less than Period. Only effective when StorageType is hot.
	HotPeriod pulumi.IntPtrInput
	// No authentication switch. False: closed; True: Enable. The default is false. After activation, anonymous access to the log topic will be supported for specified operations.
	IsWebTracking pulumi.BoolPtrInput
	// Logset ID.
	LogsetId pulumi.StringPtrInput
	// Maximum number of partitions to split into for this topic if automatic split is enabled. Default value: 50.
	MaxSplitPartitions pulumi.IntPtrInput
	// Number of log topic partitions. Default value: 1. Maximum value: 10.
	PartitionCount pulumi.IntPtrInput
	// lifetime. Unit: days. Standard storage value range: 1 to 3600. Infrequent storage value range: 7 to 3600 days. A value of 3640 indicates permanent retention.If this value is not input, it defaults to the Period value of the log set corresponding to the accessed log topic (defaults to 30 days in case of access failure).
	Period pulumi.IntPtrInput
	// Log topic storage class. Valid values: hot: real-time storage; cold: offline storage. Default value: hot. If cold is passed in, please contact the customer service to add the log topic to the allowlist first.
	StorageType pulumi.StringPtrInput
	// Tag description list. Up to 10 tag key-value pairs are supported and must be unique.
	Tags pulumi.StringMapInput
	// Log topic name.
	TopicName pulumi.StringPtrInput
}

func (TopicState) ElementType() reflect.Type {
	return reflect.TypeOf((*topicState)(nil)).Elem()
}

type topicArgs struct {
	// Whether to enable automatic split. Default value: true.
	AutoSplit *bool `pulumi:"autoSplit"`
	// Log Topic Description.
	Describes *string `pulumi:"describes"`
	// Log Subject Extension Information.
	Extends *TopicExtends `pulumi:"extends"`
	// 0: Turn off log sinking. Non 0: The number of days of standard storage after enabling log settling. HotPeriod needs to be greater than or equal to 7 and less than Period. Only effective when StorageType is hot.
	HotPeriod *int `pulumi:"hotPeriod"`
	// No authentication switch. False: closed; True: Enable. The default is false. After activation, anonymous access to the log topic will be supported for specified operations.
	IsWebTracking *bool `pulumi:"isWebTracking"`
	// Logset ID.
	LogsetId string `pulumi:"logsetId"`
	// Maximum number of partitions to split into for this topic if automatic split is enabled. Default value: 50.
	MaxSplitPartitions *int `pulumi:"maxSplitPartitions"`
	// Number of log topic partitions. Default value: 1. Maximum value: 10.
	PartitionCount *int `pulumi:"partitionCount"`
	// lifetime. Unit: days. Standard storage value range: 1 to 3600. Infrequent storage value range: 7 to 3600 days. A value of 3640 indicates permanent retention.If this value is not input, it defaults to the Period value of the log set corresponding to the accessed log topic (defaults to 30 days in case of access failure).
	Period *int `pulumi:"period"`
	// Log topic storage class. Valid values: hot: real-time storage; cold: offline storage. Default value: hot. If cold is passed in, please contact the customer service to add the log topic to the allowlist first.
	StorageType *string `pulumi:"storageType"`
	// Tag description list. Up to 10 tag key-value pairs are supported and must be unique.
	Tags map[string]string `pulumi:"tags"`
	// Log topic name.
	TopicName string `pulumi:"topicName"`
}

// The set of arguments for constructing a Topic resource.
type TopicArgs struct {
	// Whether to enable automatic split. Default value: true.
	AutoSplit pulumi.BoolPtrInput
	// Log Topic Description.
	Describes pulumi.StringPtrInput
	// Log Subject Extension Information.
	Extends TopicExtendsPtrInput
	// 0: Turn off log sinking. Non 0: The number of days of standard storage after enabling log settling. HotPeriod needs to be greater than or equal to 7 and less than Period. Only effective when StorageType is hot.
	HotPeriod pulumi.IntPtrInput
	// No authentication switch. False: closed; True: Enable. The default is false. After activation, anonymous access to the log topic will be supported for specified operations.
	IsWebTracking pulumi.BoolPtrInput
	// Logset ID.
	LogsetId pulumi.StringInput
	// Maximum number of partitions to split into for this topic if automatic split is enabled. Default value: 50.
	MaxSplitPartitions pulumi.IntPtrInput
	// Number of log topic partitions. Default value: 1. Maximum value: 10.
	PartitionCount pulumi.IntPtrInput
	// lifetime. Unit: days. Standard storage value range: 1 to 3600. Infrequent storage value range: 7 to 3600 days. A value of 3640 indicates permanent retention.If this value is not input, it defaults to the Period value of the log set corresponding to the accessed log topic (defaults to 30 days in case of access failure).
	Period pulumi.IntPtrInput
	// Log topic storage class. Valid values: hot: real-time storage; cold: offline storage. Default value: hot. If cold is passed in, please contact the customer service to add the log topic to the allowlist first.
	StorageType pulumi.StringPtrInput
	// Tag description list. Up to 10 tag key-value pairs are supported and must be unique.
	Tags pulumi.StringMapInput
	// Log topic name.
	TopicName pulumi.StringInput
}

func (TopicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*topicArgs)(nil)).Elem()
}

type TopicInput interface {
	pulumi.Input

	ToTopicOutput() TopicOutput
	ToTopicOutputWithContext(ctx context.Context) TopicOutput
}

func (*Topic) ElementType() reflect.Type {
	return reflect.TypeOf((**Topic)(nil)).Elem()
}

func (i *Topic) ToTopicOutput() TopicOutput {
	return i.ToTopicOutputWithContext(context.Background())
}

func (i *Topic) ToTopicOutputWithContext(ctx context.Context) TopicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicOutput)
}

// TopicArrayInput is an input type that accepts TopicArray and TopicArrayOutput values.
// You can construct a concrete instance of `TopicArrayInput` via:
//
//	TopicArray{ TopicArgs{...} }
type TopicArrayInput interface {
	pulumi.Input

	ToTopicArrayOutput() TopicArrayOutput
	ToTopicArrayOutputWithContext(context.Context) TopicArrayOutput
}

type TopicArray []TopicInput

func (TopicArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Topic)(nil)).Elem()
}

func (i TopicArray) ToTopicArrayOutput() TopicArrayOutput {
	return i.ToTopicArrayOutputWithContext(context.Background())
}

func (i TopicArray) ToTopicArrayOutputWithContext(ctx context.Context) TopicArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicArrayOutput)
}

// TopicMapInput is an input type that accepts TopicMap and TopicMapOutput values.
// You can construct a concrete instance of `TopicMapInput` via:
//
//	TopicMap{ "key": TopicArgs{...} }
type TopicMapInput interface {
	pulumi.Input

	ToTopicMapOutput() TopicMapOutput
	ToTopicMapOutputWithContext(context.Context) TopicMapOutput
}

type TopicMap map[string]TopicInput

func (TopicMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Topic)(nil)).Elem()
}

func (i TopicMap) ToTopicMapOutput() TopicMapOutput {
	return i.ToTopicMapOutputWithContext(context.Background())
}

func (i TopicMap) ToTopicMapOutputWithContext(ctx context.Context) TopicMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicMapOutput)
}

type TopicOutput struct{ *pulumi.OutputState }

func (TopicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Topic)(nil)).Elem()
}

func (o TopicOutput) ToTopicOutput() TopicOutput {
	return o
}

func (o TopicOutput) ToTopicOutputWithContext(ctx context.Context) TopicOutput {
	return o
}

// Whether to enable automatic split. Default value: true.
func (o TopicOutput) AutoSplit() pulumi.BoolOutput {
	return o.ApplyT(func(v *Topic) pulumi.BoolOutput { return v.AutoSplit }).(pulumi.BoolOutput)
}

// Log Topic Description.
func (o TopicOutput) Describes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringPtrOutput { return v.Describes }).(pulumi.StringPtrOutput)
}

// Log Subject Extension Information.
func (o TopicOutput) Extends() TopicExtendsPtrOutput {
	return o.ApplyT(func(v *Topic) TopicExtendsPtrOutput { return v.Extends }).(TopicExtendsPtrOutput)
}

// 0: Turn off log sinking. Non 0: The number of days of standard storage after enabling log settling. HotPeriod needs to be greater than or equal to 7 and less than Period. Only effective when StorageType is hot.
func (o TopicOutput) HotPeriod() pulumi.IntOutput {
	return o.ApplyT(func(v *Topic) pulumi.IntOutput { return v.HotPeriod }).(pulumi.IntOutput)
}

// No authentication switch. False: closed; True: Enable. The default is false. After activation, anonymous access to the log topic will be supported for specified operations.
func (o TopicOutput) IsWebTracking() pulumi.BoolOutput {
	return o.ApplyT(func(v *Topic) pulumi.BoolOutput { return v.IsWebTracking }).(pulumi.BoolOutput)
}

// Logset ID.
func (o TopicOutput) LogsetId() pulumi.StringOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringOutput { return v.LogsetId }).(pulumi.StringOutput)
}

// Maximum number of partitions to split into for this topic if automatic split is enabled. Default value: 50.
func (o TopicOutput) MaxSplitPartitions() pulumi.IntOutput {
	return o.ApplyT(func(v *Topic) pulumi.IntOutput { return v.MaxSplitPartitions }).(pulumi.IntOutput)
}

// Number of log topic partitions. Default value: 1. Maximum value: 10.
func (o TopicOutput) PartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Topic) pulumi.IntOutput { return v.PartitionCount }).(pulumi.IntOutput)
}

// lifetime. Unit: days. Standard storage value range: 1 to 3600. Infrequent storage value range: 7 to 3600 days. A value of 3640 indicates permanent retention.If this value is not input, it defaults to the Period value of the log set corresponding to the accessed log topic (defaults to 30 days in case of access failure).
func (o TopicOutput) Period() pulumi.IntOutput {
	return o.ApplyT(func(v *Topic) pulumi.IntOutput { return v.Period }).(pulumi.IntOutput)
}

// Log topic storage class. Valid values: hot: real-time storage; cold: offline storage. Default value: hot. If cold is passed in, please contact the customer service to add the log topic to the allowlist first.
func (o TopicOutput) StorageType() pulumi.StringOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringOutput { return v.StorageType }).(pulumi.StringOutput)
}

// Tag description list. Up to 10 tag key-value pairs are supported and must be unique.
func (o TopicOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Log topic name.
func (o TopicOutput) TopicName() pulumi.StringOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringOutput { return v.TopicName }).(pulumi.StringOutput)
}

type TopicArrayOutput struct{ *pulumi.OutputState }

func (TopicArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Topic)(nil)).Elem()
}

func (o TopicArrayOutput) ToTopicArrayOutput() TopicArrayOutput {
	return o
}

func (o TopicArrayOutput) ToTopicArrayOutputWithContext(ctx context.Context) TopicArrayOutput {
	return o
}

func (o TopicArrayOutput) Index(i pulumi.IntInput) TopicOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Topic {
		return vs[0].([]*Topic)[vs[1].(int)]
	}).(TopicOutput)
}

type TopicMapOutput struct{ *pulumi.OutputState }

func (TopicMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Topic)(nil)).Elem()
}

func (o TopicMapOutput) ToTopicMapOutput() TopicMapOutput {
	return o
}

func (o TopicMapOutput) ToTopicMapOutputWithContext(ctx context.Context) TopicMapOutput {
	return o
}

func (o TopicMapOutput) MapIndex(k pulumi.StringInput) TopicOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Topic {
		return vs[0].(map[string]*Topic)[vs[1].(string)]
	}).(TopicOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TopicInput)(nil)).Elem(), &Topic{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicArrayInput)(nil)).Elem(), TopicArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicMapInput)(nil)).Elem(), TopicMap{})
	pulumi.RegisterOutputType(TopicOutput{})
	pulumi.RegisterOutputType(TopicArrayOutput{})
	pulumi.RegisterOutputType(TopicMapOutput{})
}
