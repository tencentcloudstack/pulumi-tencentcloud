// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kubernetes

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/internal"
)

// Provides a resource to create a tke kubernetesLogConfig
//
// ## Example Usage
//
// ### Create a cls log config
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/availability"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/cls"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/kubernetes"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/vpc"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			vpcOne, err := vpc.GetSubnets(ctx, &vpc.GetSubnetsArgs{
//				IsDefault:        pulumi.BoolRef(true),
//				AvailabilityZone: pulumi.StringRef("ap-guangzhou-3"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			firstVpcId := vpcOne.InstanceLists[0].VpcId
//			_ := vpcOne.InstanceLists[0].SubnetId
//			gz, err := availability.GetZonesByProduct(ctx, &availability.GetZonesByProductArgs{
//				Name:    pulumi.StringRef("ap-guangzhou-3"),
//				Product: "ckafka",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_ := gz.Zones[0].Id
//			cfg := config.New(ctx, "")
//			exampleClusterCidr := "10.31.0.0/16"
//			if param := cfg.Get("exampleClusterCidr"); param != "" {
//				exampleClusterCidr = param
//			}
//			example, err := kubernetes.NewCluster(ctx, "example", &kubernetes.ClusterArgs{
//				VpcId:                pulumi.String(firstVpcId),
//				ClusterCidr:          pulumi.String(exampleClusterCidr),
//				ClusterMaxPodNum:     pulumi.Int(32),
//				ClusterName:          pulumi.String("tf_example_cluster"),
//				ClusterDesc:          pulumi.String("example for tke cluster"),
//				ClusterMaxServiceNum: pulumi.Int(32),
//				ClusterInternet:      pulumi.Bool(false),
//				ClusterVersion:       pulumi.String("1.22.5"),
//				ClusterOs:            pulumi.String("tlinux2.2(tkernel3)x86_64"),
//				ClusterDeployType:    pulumi.String("MANAGED_CLUSTER"),
//				LogAgent: &kubernetes.ClusterLogAgentArgs{
//					Enabled: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			logset, err := cls.NewLogset(ctx, "logset", &cls.LogsetArgs{
//				LogsetName: pulumi.String("tf-test-example"),
//				Tags: pulumi.StringMap{
//					"createdBy": pulumi.String("terraform"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"apiVersion": "cls.cloud.tencent.com/v1",
//				"kind":       "LogConfig",
//				"metadata": map[string]interface{}{
//					"name": "tf-test-cls",
//				},
//				"spec": map[string]interface{}{
//					"clsDetail": map[string]interface{}{
//						"extractRule": map[string]interface{}{
//							"backtracking":  "0",
//							"isGBK":         "false",
//							"jsonStandard":  "false",
//							"unMatchUpload": "false",
//						},
//						"indexs": []map[string]interface{}{
//							map[string]interface{}{
//								"indexName": "namespace",
//							},
//							map[string]interface{}{
//								"indexName": "pod_name",
//							},
//							map[string]interface{}{
//								"indexName": "container_name",
//							},
//						},
//						"logFormat":          "default",
//						"logType":            "minimalist_log",
//						"maxSplitPartitions": 0,
//						"region":             "ap-guangzhou",
//						"storageType":        "",
//					},
//					"inputDetail": map[string]interface{}{
//						"containerStdout": map[string]interface{}{
//							"metadataContainer": []string{
//								"namespace",
//								"pod_name",
//								"pod_ip",
//								"pod_uid",
//								"container_id",
//								"container_name",
//								"image_name",
//								"cluster_id",
//							},
//							"nsLabelSelector": "",
//							"workloads": []map[string]interface{}{
//								map[string]interface{}{
//									"kind":      "deployment",
//									"name":      "testlog1",
//									"namespace": "default",
//								},
//							},
//						},
//						"type": "container_stdout",
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			_, err = kubernetes.NewLogConfig(ctx, "kubernetes_log_config_cls", &kubernetes.LogConfigArgs{
//				LogConfigName: pulumi.String("tf-test-cls"),
//				ClusterId:     example.ID(),
//				LogsetId:      logset.ID(),
//				LogConfig:     pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Create a ckafka log config
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/ckafka"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/kubernetes"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := ckafka.NewInstance(ctx, "example", &ckafka.InstanceArgs{
//				InstanceName:     pulumi.String("ckafka-instance-postpaid"),
//				ZoneId:           pulumi.Any(zoneId),
//				VpcId:            pulumi.Any(firstVpcId),
//				SubnetId:         pulumi.Any(firstSubnetId),
//				MsgRetentionTime: pulumi.Int(1300),
//				KafkaVersion:     pulumi.String("1.1.1"),
//				DiskSize:         pulumi.Int(500),
//				BandWidth:        pulumi.Int(20),
//				DiskType:         pulumi.String("CLOUD_BASIC"),
//				Partition:        pulumi.Int(400),
//				ChargeType:       pulumi.String("POSTPAID_BY_HOUR"),
//				Config: &ckafka.InstanceConfigArgs{
//					AutoCreateTopicEnable:    pulumi.Bool(true),
//					DefaultNumPartitions:     pulumi.Int(3),
//					DefaultReplicationFactor: pulumi.Int(3),
//				},
//				DynamicRetentionConfig: &ckafka.InstanceDynamicRetentionConfigArgs{
//					Enable: pulumi.Int(1),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleTopic, err := ckafka.NewTopic(ctx, "example", &ckafka.TopicArgs{
//				InstanceId:                  example.ID(),
//				TopicName:                   pulumi.String("tmp"),
//				Note:                        pulumi.String("topic note"),
//				ReplicaNum:                  pulumi.Int(2),
//				PartitionNum:                pulumi.Int(1),
//				CleanUpPolicy:               pulumi.String("delete"),
//				SyncReplicaMinNum:           pulumi.Int(1),
//				UncleanLeaderElectionEnable: pulumi.Bool(false),
//				Retention:                   pulumi.Int(60000),
//			})
//			if err != nil {
//				return err
//			}
//			ckafkaTopic := exampleTopic.TopicName
//			_, err = kubernetes.NewLogConfig(ctx, "kubernetes_log_config_ckafka", &kubernetes.LogConfigArgs{
//				LogConfigName: pulumi.String("tf-test-ckafka"),
//				ClusterId:     pulumi.Any(exampleTencentcloudKubernetesCluster.Id),
//				LogsetId:      pulumi.Any(logset.Id),
//				LogConfig: ckafkaTopic.ApplyT(func(ckafkaTopic string) (pulumi.String, error) {
//					var _zero pulumi.String
//					tmpJSON0, err := json.Marshal(map[string]interface{}{
//						"apiVersion": "cls.cloud.tencent.com/v1",
//						"kind":       "LogConfig",
//						"metadata": map[string]interface{}{
//							"name": "tf-test-ckafka",
//						},
//						"spec": map[string]interface{}{
//							"inputDetail": map[string]interface{}{
//								"containerStdout": map[string]interface{}{
//									"allContainers":   true,
//									"namespace":       "default",
//									"nsLabelSelector": "",
//								},
//								"type": "container_stdout",
//							},
//							"kafkaDetail": map[string]interface{}{
//								"brokers":     "172.16.0.30:9092",
//								"extractRule": map[string]interface{}{},
//								"instanceId":  "",
//								"kafkaType":   "SelfBuildKafka",
//								"logType":     "minimalist_log",
//								"messageKey": map[string]interface{}{
//									"value": "",
//									"valueFrom": map[string]interface{}{
//										"fieldRef": map[string]interface{}{
//											"fieldPath": "",
//										},
//									},
//								},
//								"metadata":        map[string]interface{}{},
//								"timestampFormat": "double",
//								"timestampKey":    "",
//								"topic":           ckafkaTopic,
//							},
//						},
//					})
//					if err != nil {
//						return _zero, err
//					}
//					json0 := string(tmpJSON0)
//					return pulumi.String(json0), nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type LogConfig struct {
	pulumi.CustomResourceState

	// Cluster ID.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// The current cluster type supports tke and eks, default is tke.
	ClusterType pulumi.StringPtrOutput `pulumi:"clusterType"`
	// JSON expression of log collection configuration.
	LogConfig pulumi.StringOutput `pulumi:"logConfig"`
	// Log config name.
	LogConfigName pulumi.StringOutput `pulumi:"logConfigName"`
	// CLS log set ID.
	LogsetId pulumi.StringPtrOutput `pulumi:"logsetId"`
}

// NewLogConfig registers a new resource with the given unique name, arguments, and options.
func NewLogConfig(ctx *pulumi.Context,
	name string, args *LogConfigArgs, opts ...pulumi.ResourceOption) (*LogConfig, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.LogConfig == nil {
		return nil, errors.New("invalid value for required argument 'LogConfig'")
	}
	if args.LogConfigName == nil {
		return nil, errors.New("invalid value for required argument 'LogConfigName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogConfig
	err := ctx.RegisterResource("tencentcloud:Kubernetes/logConfig:LogConfig", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogConfig gets an existing LogConfig resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogConfig(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogConfigState, opts ...pulumi.ResourceOption) (*LogConfig, error) {
	var resource LogConfig
	err := ctx.ReadResource("tencentcloud:Kubernetes/logConfig:LogConfig", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogConfig resources.
type logConfigState struct {
	// Cluster ID.
	ClusterId *string `pulumi:"clusterId"`
	// The current cluster type supports tke and eks, default is tke.
	ClusterType *string `pulumi:"clusterType"`
	// JSON expression of log collection configuration.
	LogConfig *string `pulumi:"logConfig"`
	// Log config name.
	LogConfigName *string `pulumi:"logConfigName"`
	// CLS log set ID.
	LogsetId *string `pulumi:"logsetId"`
}

type LogConfigState struct {
	// Cluster ID.
	ClusterId pulumi.StringPtrInput
	// The current cluster type supports tke and eks, default is tke.
	ClusterType pulumi.StringPtrInput
	// JSON expression of log collection configuration.
	LogConfig pulumi.StringPtrInput
	// Log config name.
	LogConfigName pulumi.StringPtrInput
	// CLS log set ID.
	LogsetId pulumi.StringPtrInput
}

func (LogConfigState) ElementType() reflect.Type {
	return reflect.TypeOf((*logConfigState)(nil)).Elem()
}

type logConfigArgs struct {
	// Cluster ID.
	ClusterId string `pulumi:"clusterId"`
	// The current cluster type supports tke and eks, default is tke.
	ClusterType *string `pulumi:"clusterType"`
	// JSON expression of log collection configuration.
	LogConfig string `pulumi:"logConfig"`
	// Log config name.
	LogConfigName string `pulumi:"logConfigName"`
	// CLS log set ID.
	LogsetId *string `pulumi:"logsetId"`
}

// The set of arguments for constructing a LogConfig resource.
type LogConfigArgs struct {
	// Cluster ID.
	ClusterId pulumi.StringInput
	// The current cluster type supports tke and eks, default is tke.
	ClusterType pulumi.StringPtrInput
	// JSON expression of log collection configuration.
	LogConfig pulumi.StringInput
	// Log config name.
	LogConfigName pulumi.StringInput
	// CLS log set ID.
	LogsetId pulumi.StringPtrInput
}

func (LogConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logConfigArgs)(nil)).Elem()
}

type LogConfigInput interface {
	pulumi.Input

	ToLogConfigOutput() LogConfigOutput
	ToLogConfigOutputWithContext(ctx context.Context) LogConfigOutput
}

func (*LogConfig) ElementType() reflect.Type {
	return reflect.TypeOf((**LogConfig)(nil)).Elem()
}

func (i *LogConfig) ToLogConfigOutput() LogConfigOutput {
	return i.ToLogConfigOutputWithContext(context.Background())
}

func (i *LogConfig) ToLogConfigOutputWithContext(ctx context.Context) LogConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogConfigOutput)
}

// LogConfigArrayInput is an input type that accepts LogConfigArray and LogConfigArrayOutput values.
// You can construct a concrete instance of `LogConfigArrayInput` via:
//
//	LogConfigArray{ LogConfigArgs{...} }
type LogConfigArrayInput interface {
	pulumi.Input

	ToLogConfigArrayOutput() LogConfigArrayOutput
	ToLogConfigArrayOutputWithContext(context.Context) LogConfigArrayOutput
}

type LogConfigArray []LogConfigInput

func (LogConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogConfig)(nil)).Elem()
}

func (i LogConfigArray) ToLogConfigArrayOutput() LogConfigArrayOutput {
	return i.ToLogConfigArrayOutputWithContext(context.Background())
}

func (i LogConfigArray) ToLogConfigArrayOutputWithContext(ctx context.Context) LogConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogConfigArrayOutput)
}

// LogConfigMapInput is an input type that accepts LogConfigMap and LogConfigMapOutput values.
// You can construct a concrete instance of `LogConfigMapInput` via:
//
//	LogConfigMap{ "key": LogConfigArgs{...} }
type LogConfigMapInput interface {
	pulumi.Input

	ToLogConfigMapOutput() LogConfigMapOutput
	ToLogConfigMapOutputWithContext(context.Context) LogConfigMapOutput
}

type LogConfigMap map[string]LogConfigInput

func (LogConfigMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogConfig)(nil)).Elem()
}

func (i LogConfigMap) ToLogConfigMapOutput() LogConfigMapOutput {
	return i.ToLogConfigMapOutputWithContext(context.Background())
}

func (i LogConfigMap) ToLogConfigMapOutputWithContext(ctx context.Context) LogConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogConfigMapOutput)
}

type LogConfigOutput struct{ *pulumi.OutputState }

func (LogConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogConfig)(nil)).Elem()
}

func (o LogConfigOutput) ToLogConfigOutput() LogConfigOutput {
	return o
}

func (o LogConfigOutput) ToLogConfigOutputWithContext(ctx context.Context) LogConfigOutput {
	return o
}

// Cluster ID.
func (o LogConfigOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *LogConfig) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// The current cluster type supports tke and eks, default is tke.
func (o LogConfigOutput) ClusterType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogConfig) pulumi.StringPtrOutput { return v.ClusterType }).(pulumi.StringPtrOutput)
}

// JSON expression of log collection configuration.
func (o LogConfigOutput) LogConfig() pulumi.StringOutput {
	return o.ApplyT(func(v *LogConfig) pulumi.StringOutput { return v.LogConfig }).(pulumi.StringOutput)
}

// Log config name.
func (o LogConfigOutput) LogConfigName() pulumi.StringOutput {
	return o.ApplyT(func(v *LogConfig) pulumi.StringOutput { return v.LogConfigName }).(pulumi.StringOutput)
}

// CLS log set ID.
func (o LogConfigOutput) LogsetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogConfig) pulumi.StringPtrOutput { return v.LogsetId }).(pulumi.StringPtrOutput)
}

type LogConfigArrayOutput struct{ *pulumi.OutputState }

func (LogConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogConfig)(nil)).Elem()
}

func (o LogConfigArrayOutput) ToLogConfigArrayOutput() LogConfigArrayOutput {
	return o
}

func (o LogConfigArrayOutput) ToLogConfigArrayOutputWithContext(ctx context.Context) LogConfigArrayOutput {
	return o
}

func (o LogConfigArrayOutput) Index(i pulumi.IntInput) LogConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogConfig {
		return vs[0].([]*LogConfig)[vs[1].(int)]
	}).(LogConfigOutput)
}

type LogConfigMapOutput struct{ *pulumi.OutputState }

func (LogConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogConfig)(nil)).Elem()
}

func (o LogConfigMapOutput) ToLogConfigMapOutput() LogConfigMapOutput {
	return o
}

func (o LogConfigMapOutput) ToLogConfigMapOutputWithContext(ctx context.Context) LogConfigMapOutput {
	return o
}

func (o LogConfigMapOutput) MapIndex(k pulumi.StringInput) LogConfigOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogConfig {
		return vs[0].(map[string]*LogConfig)[vs[1].(string)]
	}).(LogConfigOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogConfigInput)(nil)).Elem(), &LogConfig{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogConfigArrayInput)(nil)).Elem(), LogConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogConfigMapInput)(nil)).Elem(), LogConfigMap{})
	pulumi.RegisterOutputType(LogConfigOutput{})
	pulumi.RegisterOutputType(LogConfigArrayOutput{})
	pulumi.RegisterOutputType(LogConfigMapOutput{})
}
