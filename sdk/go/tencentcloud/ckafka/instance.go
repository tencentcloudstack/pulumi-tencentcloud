// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ckafka

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/internal"
)

// Use this resource to create ckafka instance.
//
// ## Example Usage
//
// ### Basic Instance
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Availability"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Ckafka"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			vpcId := "vpc-68vi2d3h"
//			if param := cfg.Get("vpcId"); param != "" {
//				vpcId = param
//			}
//			subnetId := "subnet-ob6clqwk"
//			if param := cfg.Get("subnetId"); param != "" {
//				subnetId = param
//			}
//			gz, err := Availability.GetZonesByProduct(ctx, &availability.GetZonesByProductArgs{
//				Name:    pulumi.StringRef("ap-guangzhou-3"),
//				Product: "ckafka",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = Ckafka.NewInstance(ctx, "kafkaInstancePrepaid", &Ckafka.InstanceArgs{
//				InstanceName:       pulumi.String("ckafka-instance-prepaid"),
//				ZoneId:             pulumi.String(gz.Zones[0].Id),
//				Period:             pulumi.Int(1),
//				VpcId:              pulumi.String(vpcId),
//				SubnetId:           pulumi.String(subnetId),
//				MsgRetentionTime:   pulumi.Int(1300),
//				RenewFlag:          pulumi.Int(0),
//				KafkaVersion:       pulumi.String("2.4.1"),
//				DiskSize:           pulumi.Int(200),
//				DiskType:           pulumi.String("CLOUD_BASIC"),
//				BandWidth:          pulumi.Int(20),
//				Partition:          pulumi.Int(400),
//				SpecificationsType: pulumi.String("standard"),
//				InstanceType:       pulumi.Int(2),
//				Config: &ckafka.InstanceConfigArgs{
//					AutoCreateTopicEnable:    pulumi.Bool(true),
//					DefaultNumPartitions:     pulumi.Int(3),
//					DefaultReplicationFactor: pulumi.Int(3),
//				},
//				DynamicRetentionConfig: &ckafka.InstanceDynamicRetentionConfigArgs{
//					Enable: pulumi.Int(1),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = Ckafka.NewInstance(ctx, "kafkaInstancePostpaid", &Ckafka.InstanceArgs{
//				InstanceName:     pulumi.String("ckafka-instance-postpaid"),
//				ZoneId:           pulumi.String(gz.Zones[0].Id),
//				VpcId:            pulumi.String(vpcId),
//				SubnetId:         pulumi.String(subnetId),
//				MsgRetentionTime: pulumi.Int(1300),
//				KafkaVersion:     pulumi.String("1.1.1"),
//				DiskSize:         pulumi.Int(200),
//				BandWidth:        pulumi.Int(20),
//				DiskType:         pulumi.String("CLOUD_BASIC"),
//				Partition:        pulumi.Int(400),
//				ChargeType:       pulumi.String("POSTPAID_BY_HOUR"),
//				Config: &ckafka.InstanceConfigArgs{
//					AutoCreateTopicEnable:    pulumi.Bool(true),
//					DefaultNumPartitions:     pulumi.Int(3),
//					DefaultReplicationFactor: pulumi.Int(3),
//				},
//				DynamicRetentionConfig: &ckafka.InstanceDynamicRetentionConfigArgs{
//					Enable: pulumi.Int(1),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ### Multi zone Instance
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Availability"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Ckafka"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			vpcId := "vpc-68vi2d3h"
//			if param := cfg.Get("vpcId"); param != "" {
//				vpcId = param
//			}
//			subnetId := "subnet-ob6clqwk"
//			if param := cfg.Get("subnetId"); param != "" {
//				subnetId = param
//			}
//			gz3, err := Availability.GetZonesByProduct(ctx, &availability.GetZonesByProductArgs{
//				Name:    pulumi.StringRef("ap-guangzhou-3"),
//				Product: "ckafka",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			gz6, err := Availability.GetZonesByProduct(ctx, &availability.GetZonesByProductArgs{
//				Name:    pulumi.StringRef("ap-guangzhou-6"),
//				Product: "ckafka",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = Ckafka.NewInstance(ctx, "kafkaInstance", &Ckafka.InstanceArgs{
//				InstanceName:  pulumi.String("ckafka-instance-maz-tf-test"),
//				ZoneId:        pulumi.String(gz3.Zones[0].Id),
//				MultiZoneFlag: pulumi.Bool(true),
//				ZoneIds: pulumi.IntArray{
//					pulumi.String(gz3.Zones[0].Id),
//					pulumi.String(gz6.Zones[0].Id),
//				},
//				Period:           pulumi.Int(1),
//				VpcId:            pulumi.String(vpcId),
//				SubnetId:         pulumi.String(subnetId),
//				MsgRetentionTime: pulumi.Int(1300),
//				RenewFlag:        pulumi.Int(0),
//				KafkaVersion:     pulumi.String("1.1.1"),
//				DiskSize:         pulumi.Int(500),
//				DiskType:         pulumi.String("CLOUD_BASIC"),
//				Config: &ckafka.InstanceConfigArgs{
//					AutoCreateTopicEnable:    pulumi.Bool(true),
//					DefaultNumPartitions:     pulumi.Int(3),
//					DefaultReplicationFactor: pulumi.Int(3),
//				},
//				DynamicRetentionConfig: &ckafka.InstanceDynamicRetentionConfigArgs{
//					Enable: pulumi.Int(1),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// ckafka instance can be imported using the instance_id, e.g.
//
// ```sh
// $ pulumi import tencentcloud:Ckafka/instance:Instance foo ckafka-f9ife4zz
// ```
type Instance struct {
	pulumi.CustomResourceState

	// Instance bandwidth in MBps.
	BandWidth pulumi.IntOutput `pulumi:"bandWidth"`
	// The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. Default value is `PREPAID`.
	ChargeType pulumi.StringPtrOutput `pulumi:"chargeType"`
	// Instance configuration.
	Config InstanceConfigPtrOutput `pulumi:"config"`
	// Disk Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	DiskSize pulumi.IntOutput `pulumi:"diskSize"`
	// Type of disk.
	DiskType pulumi.StringOutput `pulumi:"diskType"`
	// Dynamic message retention policy configuration.
	DynamicRetentionConfig InstanceDynamicRetentionConfigOutput `pulumi:"dynamicRetentionConfig"`
	// Instance name.
	InstanceName pulumi.StringOutput `pulumi:"instanceName"`
	// Description of instance type. `profession`: 1, `standard`:  1(general), 2(standard), 3(advanced), 4(capacity), 5(specialized-1), 6(specialized-2), 7(specialized-3), 8(specialized-4), 9(exclusive).
	InstanceType pulumi.IntOutput `pulumi:"instanceType"`
	// Kafka version (0.10.2/1.1.1/2.4.1).
	KafkaVersion pulumi.StringOutput `pulumi:"kafkaVersion"`
	// The size of a single message in bytes at the instance level. Value range: `1024 - 12*1024*1024 bytes (i.e., 1KB-12MB).
	MaxMessageByte pulumi.IntOutput `pulumi:"maxMessageByte"`
	// The maximum retention time of instance logs, in minutes. the default is 10080 (7 days), the maximum is 30 days, and the default 0 is not filled, which means that the log retention time recovery policy is not enabled.
	MsgRetentionTime pulumi.IntOutput `pulumi:"msgRetentionTime"`
	// Indicates whether the instance is multi zones. NOTE: if set to `true`, `zoneIds` must set together.
	MultiZoneFlag pulumi.BoolPtrOutput `pulumi:"multiZoneFlag"`
	// Partition Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	Partition pulumi.IntOutput `pulumi:"partition"`
	// Prepaid purchase time, such as 1, is one month.
	Period pulumi.IntPtrOutput `pulumi:"period"`
	// Bandwidth of the public network.
	PublicNetwork pulumi.IntOutput `pulumi:"publicNetwork"`
	// Modification of the rebalancing time after upgrade.
	RebalanceTime pulumi.IntPtrOutput `pulumi:"rebalanceTime"`
	// Prepaid automatic renewal mark, 0 means the default state, the initial state, 1 means automatic renewal, 2 means clear no automatic renewal (user setting).
	RenewFlag pulumi.IntOutput `pulumi:"renewFlag"`
	// Specifications type of instance. Allowed values are `standard`, `profession`. Default is `profession`.
	SpecificationsType pulumi.StringPtrOutput `pulumi:"specificationsType"`
	// Subnet id, it will be basic network if not set.
	SubnetId pulumi.StringPtrOutput `pulumi:"subnetId"`
	// Tag set of instance.
	TagSet pulumi.MapOutput `pulumi:"tagSet"`
	// It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead. Tags of instance. Partition size, the professional version does not need tag.
	//
	// Deprecated: It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead.
	Tags InstanceTagArrayOutput `pulumi:"tags"`
	// POSTPAID_BY_HOUR scale-down mode
	// - 1: stable transformation;
	// - 2: High-speed transformer.
	UpgradeStrategy pulumi.IntPtrOutput `pulumi:"upgradeStrategy"`
	// Vip of instance.
	Vip pulumi.StringOutput `pulumi:"vip"`
	// Vpc id, it will be basic network if not set.
	VpcId pulumi.StringPtrOutput `pulumi:"vpcId"`
	// Type of instance.
	Vport pulumi.StringOutput `pulumi:"vport"`
	// Available zone id.
	ZoneId pulumi.IntOutput `pulumi:"zoneId"`
	// List of available zone id. NOTE: this argument must set together with `multiZoneFlag`.
	ZoneIds pulumi.IntArrayOutput `pulumi:"zoneIds"`
}

// NewInstance registers a new resource with the given unique name, arguments, and options.
func NewInstance(ctx *pulumi.Context,
	name string, args *InstanceArgs, opts ...pulumi.ResourceOption) (*Instance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceName == nil {
		return nil, errors.New("invalid value for required argument 'InstanceName'")
	}
	if args.ZoneId == nil {
		return nil, errors.New("invalid value for required argument 'ZoneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Instance
	err := ctx.RegisterResource("tencentcloud:Ckafka/instance:Instance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstance gets an existing Instance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceState, opts ...pulumi.ResourceOption) (*Instance, error) {
	var resource Instance
	err := ctx.ReadResource("tencentcloud:Ckafka/instance:Instance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Instance resources.
type instanceState struct {
	// Instance bandwidth in MBps.
	BandWidth *int `pulumi:"bandWidth"`
	// The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. Default value is `PREPAID`.
	ChargeType *string `pulumi:"chargeType"`
	// Instance configuration.
	Config *InstanceConfig `pulumi:"config"`
	// Disk Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	DiskSize *int `pulumi:"diskSize"`
	// Type of disk.
	DiskType *string `pulumi:"diskType"`
	// Dynamic message retention policy configuration.
	DynamicRetentionConfig *InstanceDynamicRetentionConfig `pulumi:"dynamicRetentionConfig"`
	// Instance name.
	InstanceName *string `pulumi:"instanceName"`
	// Description of instance type. `profession`: 1, `standard`:  1(general), 2(standard), 3(advanced), 4(capacity), 5(specialized-1), 6(specialized-2), 7(specialized-3), 8(specialized-4), 9(exclusive).
	InstanceType *int `pulumi:"instanceType"`
	// Kafka version (0.10.2/1.1.1/2.4.1).
	KafkaVersion *string `pulumi:"kafkaVersion"`
	// The size of a single message in bytes at the instance level. Value range: `1024 - 12*1024*1024 bytes (i.e., 1KB-12MB).
	MaxMessageByte *int `pulumi:"maxMessageByte"`
	// The maximum retention time of instance logs, in minutes. the default is 10080 (7 days), the maximum is 30 days, and the default 0 is not filled, which means that the log retention time recovery policy is not enabled.
	MsgRetentionTime *int `pulumi:"msgRetentionTime"`
	// Indicates whether the instance is multi zones. NOTE: if set to `true`, `zoneIds` must set together.
	MultiZoneFlag *bool `pulumi:"multiZoneFlag"`
	// Partition Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	Partition *int `pulumi:"partition"`
	// Prepaid purchase time, such as 1, is one month.
	Period *int `pulumi:"period"`
	// Bandwidth of the public network.
	PublicNetwork *int `pulumi:"publicNetwork"`
	// Modification of the rebalancing time after upgrade.
	RebalanceTime *int `pulumi:"rebalanceTime"`
	// Prepaid automatic renewal mark, 0 means the default state, the initial state, 1 means automatic renewal, 2 means clear no automatic renewal (user setting).
	RenewFlag *int `pulumi:"renewFlag"`
	// Specifications type of instance. Allowed values are `standard`, `profession`. Default is `profession`.
	SpecificationsType *string `pulumi:"specificationsType"`
	// Subnet id, it will be basic network if not set.
	SubnetId *string `pulumi:"subnetId"`
	// Tag set of instance.
	TagSet map[string]interface{} `pulumi:"tagSet"`
	// It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead. Tags of instance. Partition size, the professional version does not need tag.
	//
	// Deprecated: It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead.
	Tags []InstanceTag `pulumi:"tags"`
	// POSTPAID_BY_HOUR scale-down mode
	// - 1: stable transformation;
	// - 2: High-speed transformer.
	UpgradeStrategy *int `pulumi:"upgradeStrategy"`
	// Vip of instance.
	Vip *string `pulumi:"vip"`
	// Vpc id, it will be basic network if not set.
	VpcId *string `pulumi:"vpcId"`
	// Type of instance.
	Vport *string `pulumi:"vport"`
	// Available zone id.
	ZoneId *int `pulumi:"zoneId"`
	// List of available zone id. NOTE: this argument must set together with `multiZoneFlag`.
	ZoneIds []int `pulumi:"zoneIds"`
}

type InstanceState struct {
	// Instance bandwidth in MBps.
	BandWidth pulumi.IntPtrInput
	// The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. Default value is `PREPAID`.
	ChargeType pulumi.StringPtrInput
	// Instance configuration.
	Config InstanceConfigPtrInput
	// Disk Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	DiskSize pulumi.IntPtrInput
	// Type of disk.
	DiskType pulumi.StringPtrInput
	// Dynamic message retention policy configuration.
	DynamicRetentionConfig InstanceDynamicRetentionConfigPtrInput
	// Instance name.
	InstanceName pulumi.StringPtrInput
	// Description of instance type. `profession`: 1, `standard`:  1(general), 2(standard), 3(advanced), 4(capacity), 5(specialized-1), 6(specialized-2), 7(specialized-3), 8(specialized-4), 9(exclusive).
	InstanceType pulumi.IntPtrInput
	// Kafka version (0.10.2/1.1.1/2.4.1).
	KafkaVersion pulumi.StringPtrInput
	// The size of a single message in bytes at the instance level. Value range: `1024 - 12*1024*1024 bytes (i.e., 1KB-12MB).
	MaxMessageByte pulumi.IntPtrInput
	// The maximum retention time of instance logs, in minutes. the default is 10080 (7 days), the maximum is 30 days, and the default 0 is not filled, which means that the log retention time recovery policy is not enabled.
	MsgRetentionTime pulumi.IntPtrInput
	// Indicates whether the instance is multi zones. NOTE: if set to `true`, `zoneIds` must set together.
	MultiZoneFlag pulumi.BoolPtrInput
	// Partition Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	Partition pulumi.IntPtrInput
	// Prepaid purchase time, such as 1, is one month.
	Period pulumi.IntPtrInput
	// Bandwidth of the public network.
	PublicNetwork pulumi.IntPtrInput
	// Modification of the rebalancing time after upgrade.
	RebalanceTime pulumi.IntPtrInput
	// Prepaid automatic renewal mark, 0 means the default state, the initial state, 1 means automatic renewal, 2 means clear no automatic renewal (user setting).
	RenewFlag pulumi.IntPtrInput
	// Specifications type of instance. Allowed values are `standard`, `profession`. Default is `profession`.
	SpecificationsType pulumi.StringPtrInput
	// Subnet id, it will be basic network if not set.
	SubnetId pulumi.StringPtrInput
	// Tag set of instance.
	TagSet pulumi.MapInput
	// It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead. Tags of instance. Partition size, the professional version does not need tag.
	//
	// Deprecated: It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead.
	Tags InstanceTagArrayInput
	// POSTPAID_BY_HOUR scale-down mode
	// - 1: stable transformation;
	// - 2: High-speed transformer.
	UpgradeStrategy pulumi.IntPtrInput
	// Vip of instance.
	Vip pulumi.StringPtrInput
	// Vpc id, it will be basic network if not set.
	VpcId pulumi.StringPtrInput
	// Type of instance.
	Vport pulumi.StringPtrInput
	// Available zone id.
	ZoneId pulumi.IntPtrInput
	// List of available zone id. NOTE: this argument must set together with `multiZoneFlag`.
	ZoneIds pulumi.IntArrayInput
}

func (InstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceState)(nil)).Elem()
}

type instanceArgs struct {
	// Instance bandwidth in MBps.
	BandWidth *int `pulumi:"bandWidth"`
	// The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. Default value is `PREPAID`.
	ChargeType *string `pulumi:"chargeType"`
	// Instance configuration.
	Config *InstanceConfig `pulumi:"config"`
	// Disk Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	DiskSize *int `pulumi:"diskSize"`
	// Type of disk.
	DiskType *string `pulumi:"diskType"`
	// Dynamic message retention policy configuration.
	DynamicRetentionConfig *InstanceDynamicRetentionConfig `pulumi:"dynamicRetentionConfig"`
	// Instance name.
	InstanceName string `pulumi:"instanceName"`
	// Description of instance type. `profession`: 1, `standard`:  1(general), 2(standard), 3(advanced), 4(capacity), 5(specialized-1), 6(specialized-2), 7(specialized-3), 8(specialized-4), 9(exclusive).
	InstanceType *int `pulumi:"instanceType"`
	// Kafka version (0.10.2/1.1.1/2.4.1).
	KafkaVersion *string `pulumi:"kafkaVersion"`
	// The size of a single message in bytes at the instance level. Value range: `1024 - 12*1024*1024 bytes (i.e., 1KB-12MB).
	MaxMessageByte *int `pulumi:"maxMessageByte"`
	// The maximum retention time of instance logs, in minutes. the default is 10080 (7 days), the maximum is 30 days, and the default 0 is not filled, which means that the log retention time recovery policy is not enabled.
	MsgRetentionTime *int `pulumi:"msgRetentionTime"`
	// Indicates whether the instance is multi zones. NOTE: if set to `true`, `zoneIds` must set together.
	MultiZoneFlag *bool `pulumi:"multiZoneFlag"`
	// Partition Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	Partition *int `pulumi:"partition"`
	// Prepaid purchase time, such as 1, is one month.
	Period *int `pulumi:"period"`
	// Bandwidth of the public network.
	PublicNetwork *int `pulumi:"publicNetwork"`
	// Modification of the rebalancing time after upgrade.
	RebalanceTime *int `pulumi:"rebalanceTime"`
	// Prepaid automatic renewal mark, 0 means the default state, the initial state, 1 means automatic renewal, 2 means clear no automatic renewal (user setting).
	RenewFlag *int `pulumi:"renewFlag"`
	// Specifications type of instance. Allowed values are `standard`, `profession`. Default is `profession`.
	SpecificationsType *string `pulumi:"specificationsType"`
	// Subnet id, it will be basic network if not set.
	SubnetId *string `pulumi:"subnetId"`
	// Tag set of instance.
	TagSet map[string]interface{} `pulumi:"tagSet"`
	// It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead. Tags of instance. Partition size, the professional version does not need tag.
	//
	// Deprecated: It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead.
	Tags []InstanceTag `pulumi:"tags"`
	// POSTPAID_BY_HOUR scale-down mode
	// - 1: stable transformation;
	// - 2: High-speed transformer.
	UpgradeStrategy *int `pulumi:"upgradeStrategy"`
	// Vpc id, it will be basic network if not set.
	VpcId *string `pulumi:"vpcId"`
	// Available zone id.
	ZoneId int `pulumi:"zoneId"`
	// List of available zone id. NOTE: this argument must set together with `multiZoneFlag`.
	ZoneIds []int `pulumi:"zoneIds"`
}

// The set of arguments for constructing a Instance resource.
type InstanceArgs struct {
	// Instance bandwidth in MBps.
	BandWidth pulumi.IntPtrInput
	// The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. Default value is `PREPAID`.
	ChargeType pulumi.StringPtrInput
	// Instance configuration.
	Config InstanceConfigPtrInput
	// Disk Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	DiskSize pulumi.IntPtrInput
	// Type of disk.
	DiskType pulumi.StringPtrInput
	// Dynamic message retention policy configuration.
	DynamicRetentionConfig InstanceDynamicRetentionConfigPtrInput
	// Instance name.
	InstanceName pulumi.StringInput
	// Description of instance type. `profession`: 1, `standard`:  1(general), 2(standard), 3(advanced), 4(capacity), 5(specialized-1), 6(specialized-2), 7(specialized-3), 8(specialized-4), 9(exclusive).
	InstanceType pulumi.IntPtrInput
	// Kafka version (0.10.2/1.1.1/2.4.1).
	KafkaVersion pulumi.StringPtrInput
	// The size of a single message in bytes at the instance level. Value range: `1024 - 12*1024*1024 bytes (i.e., 1KB-12MB).
	MaxMessageByte pulumi.IntPtrInput
	// The maximum retention time of instance logs, in minutes. the default is 10080 (7 days), the maximum is 30 days, and the default 0 is not filled, which means that the log retention time recovery policy is not enabled.
	MsgRetentionTime pulumi.IntPtrInput
	// Indicates whether the instance is multi zones. NOTE: if set to `true`, `zoneIds` must set together.
	MultiZoneFlag pulumi.BoolPtrInput
	// Partition Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
	Partition pulumi.IntPtrInput
	// Prepaid purchase time, such as 1, is one month.
	Period pulumi.IntPtrInput
	// Bandwidth of the public network.
	PublicNetwork pulumi.IntPtrInput
	// Modification of the rebalancing time after upgrade.
	RebalanceTime pulumi.IntPtrInput
	// Prepaid automatic renewal mark, 0 means the default state, the initial state, 1 means automatic renewal, 2 means clear no automatic renewal (user setting).
	RenewFlag pulumi.IntPtrInput
	// Specifications type of instance. Allowed values are `standard`, `profession`. Default is `profession`.
	SpecificationsType pulumi.StringPtrInput
	// Subnet id, it will be basic network if not set.
	SubnetId pulumi.StringPtrInput
	// Tag set of instance.
	TagSet pulumi.MapInput
	// It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead. Tags of instance. Partition size, the professional version does not need tag.
	//
	// Deprecated: It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead.
	Tags InstanceTagArrayInput
	// POSTPAID_BY_HOUR scale-down mode
	// - 1: stable transformation;
	// - 2: High-speed transformer.
	UpgradeStrategy pulumi.IntPtrInput
	// Vpc id, it will be basic network if not set.
	VpcId pulumi.StringPtrInput
	// Available zone id.
	ZoneId pulumi.IntInput
	// List of available zone id. NOTE: this argument must set together with `multiZoneFlag`.
	ZoneIds pulumi.IntArrayInput
}

func (InstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceArgs)(nil)).Elem()
}

type InstanceInput interface {
	pulumi.Input

	ToInstanceOutput() InstanceOutput
	ToInstanceOutputWithContext(ctx context.Context) InstanceOutput
}

func (*Instance) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (i *Instance) ToInstanceOutput() InstanceOutput {
	return i.ToInstanceOutputWithContext(context.Background())
}

func (i *Instance) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceOutput)
}

// InstanceArrayInput is an input type that accepts InstanceArray and InstanceArrayOutput values.
// You can construct a concrete instance of `InstanceArrayInput` via:
//
//	InstanceArray{ InstanceArgs{...} }
type InstanceArrayInput interface {
	pulumi.Input

	ToInstanceArrayOutput() InstanceArrayOutput
	ToInstanceArrayOutputWithContext(context.Context) InstanceArrayOutput
}

type InstanceArray []InstanceInput

func (InstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (i InstanceArray) ToInstanceArrayOutput() InstanceArrayOutput {
	return i.ToInstanceArrayOutputWithContext(context.Background())
}

func (i InstanceArray) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceArrayOutput)
}

// InstanceMapInput is an input type that accepts InstanceMap and InstanceMapOutput values.
// You can construct a concrete instance of `InstanceMapInput` via:
//
//	InstanceMap{ "key": InstanceArgs{...} }
type InstanceMapInput interface {
	pulumi.Input

	ToInstanceMapOutput() InstanceMapOutput
	ToInstanceMapOutputWithContext(context.Context) InstanceMapOutput
}

type InstanceMap map[string]InstanceInput

func (InstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (i InstanceMap) ToInstanceMapOutput() InstanceMapOutput {
	return i.ToInstanceMapOutputWithContext(context.Background())
}

func (i InstanceMap) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceMapOutput)
}

type InstanceOutput struct{ *pulumi.OutputState }

func (InstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (o InstanceOutput) ToInstanceOutput() InstanceOutput {
	return o
}

func (o InstanceOutput) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return o
}

// Instance bandwidth in MBps.
func (o InstanceOutput) BandWidth() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.BandWidth }).(pulumi.IntOutput)
}

// The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. Default value is `PREPAID`.
func (o InstanceOutput) ChargeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.ChargeType }).(pulumi.StringPtrOutput)
}

// Instance configuration.
func (o InstanceOutput) Config() InstanceConfigPtrOutput {
	return o.ApplyT(func(v *Instance) InstanceConfigPtrOutput { return v.Config }).(InstanceConfigPtrOutput)
}

// Disk Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
func (o InstanceOutput) DiskSize() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.DiskSize }).(pulumi.IntOutput)
}

// Type of disk.
func (o InstanceOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.DiskType }).(pulumi.StringOutput)
}

// Dynamic message retention policy configuration.
func (o InstanceOutput) DynamicRetentionConfig() InstanceDynamicRetentionConfigOutput {
	return o.ApplyT(func(v *Instance) InstanceDynamicRetentionConfigOutput { return v.DynamicRetentionConfig }).(InstanceDynamicRetentionConfigOutput)
}

// Instance name.
func (o InstanceOutput) InstanceName() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.InstanceName }).(pulumi.StringOutput)
}

// Description of instance type. `profession`: 1, `standard`:  1(general), 2(standard), 3(advanced), 4(capacity), 5(specialized-1), 6(specialized-2), 7(specialized-3), 8(specialized-4), 9(exclusive).
func (o InstanceOutput) InstanceType() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.InstanceType }).(pulumi.IntOutput)
}

// Kafka version (0.10.2/1.1.1/2.4.1).
func (o InstanceOutput) KafkaVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.KafkaVersion }).(pulumi.StringOutput)
}

// The size of a single message in bytes at the instance level. Value range: `1024 - 12*1024*1024 bytes (i.e., 1KB-12MB).
func (o InstanceOutput) MaxMessageByte() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.MaxMessageByte }).(pulumi.IntOutput)
}

// The maximum retention time of instance logs, in minutes. the default is 10080 (7 days), the maximum is 30 days, and the default 0 is not filled, which means that the log retention time recovery policy is not enabled.
func (o InstanceOutput) MsgRetentionTime() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.MsgRetentionTime }).(pulumi.IntOutput)
}

// Indicates whether the instance is multi zones. NOTE: if set to `true`, `zoneIds` must set together.
func (o InstanceOutput) MultiZoneFlag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.MultiZoneFlag }).(pulumi.BoolPtrOutput)
}

// Partition Size. Its interval varies with bandwidth, and the input must be within the interval, which can be viewed through the control. If it is not within the interval, the plan will cause a change when first created.
func (o InstanceOutput) Partition() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.Partition }).(pulumi.IntOutput)
}

// Prepaid purchase time, such as 1, is one month.
func (o InstanceOutput) Period() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntPtrOutput { return v.Period }).(pulumi.IntPtrOutput)
}

// Bandwidth of the public network.
func (o InstanceOutput) PublicNetwork() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.PublicNetwork }).(pulumi.IntOutput)
}

// Modification of the rebalancing time after upgrade.
func (o InstanceOutput) RebalanceTime() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntPtrOutput { return v.RebalanceTime }).(pulumi.IntPtrOutput)
}

// Prepaid automatic renewal mark, 0 means the default state, the initial state, 1 means automatic renewal, 2 means clear no automatic renewal (user setting).
func (o InstanceOutput) RenewFlag() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.RenewFlag }).(pulumi.IntOutput)
}

// Specifications type of instance. Allowed values are `standard`, `profession`. Default is `profession`.
func (o InstanceOutput) SpecificationsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.SpecificationsType }).(pulumi.StringPtrOutput)
}

// Subnet id, it will be basic network if not set.
func (o InstanceOutput) SubnetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.SubnetId }).(pulumi.StringPtrOutput)
}

// Tag set of instance.
func (o InstanceOutput) TagSet() pulumi.MapOutput {
	return o.ApplyT(func(v *Instance) pulumi.MapOutput { return v.TagSet }).(pulumi.MapOutput)
}

// It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead. Tags of instance. Partition size, the professional version does not need tag.
//
// Deprecated: It has been deprecated from version 1.78.5, because it do not support change. Use `tagSet` instead.
func (o InstanceOutput) Tags() InstanceTagArrayOutput {
	return o.ApplyT(func(v *Instance) InstanceTagArrayOutput { return v.Tags }).(InstanceTagArrayOutput)
}

// POSTPAID_BY_HOUR scale-down mode
// - 1: stable transformation;
// - 2: High-speed transformer.
func (o InstanceOutput) UpgradeStrategy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntPtrOutput { return v.UpgradeStrategy }).(pulumi.IntPtrOutput)
}

// Vip of instance.
func (o InstanceOutput) Vip() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Vip }).(pulumi.StringOutput)
}

// Vpc id, it will be basic network if not set.
func (o InstanceOutput) VpcId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.VpcId }).(pulumi.StringPtrOutput)
}

// Type of instance.
func (o InstanceOutput) Vport() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Vport }).(pulumi.StringOutput)
}

// Available zone id.
func (o InstanceOutput) ZoneId() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.ZoneId }).(pulumi.IntOutput)
}

// List of available zone id. NOTE: this argument must set together with `multiZoneFlag`.
func (o InstanceOutput) ZoneIds() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntArrayOutput { return v.ZoneIds }).(pulumi.IntArrayOutput)
}

type InstanceArrayOutput struct{ *pulumi.OutputState }

func (InstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (o InstanceArrayOutput) ToInstanceArrayOutput() InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) Index(i pulumi.IntInput) InstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].([]*Instance)[vs[1].(int)]
	}).(InstanceOutput)
}

type InstanceMapOutput struct{ *pulumi.OutputState }

func (InstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (o InstanceMapOutput) ToInstanceMapOutput() InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) MapIndex(k pulumi.StringInput) InstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].(map[string]*Instance)[vs[1].(string)]
	}).(InstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceInput)(nil)).Elem(), &Instance{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceArrayInput)(nil)).Elem(), InstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceMapInput)(nil)).Elem(), InstanceMap{})
	pulumi.RegisterOutputType(InstanceOutput{})
	pulumi.RegisterOutputType(InstanceArrayOutput{})
	pulumi.RegisterOutputType(InstanceMapOutput{})
}
