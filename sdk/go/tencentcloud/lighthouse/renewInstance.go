// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package lighthouse

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create a lighthouse renewInstance
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-tencentcloud/sdk/go/tencentcloud/Lighthouse"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Lighthouse"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := Lighthouse.NewRenewInstance(ctx, "renewInstance", &Lighthouse.RenewInstanceArgs{
// 			AutoVoucher: pulumi.Bool(false),
// 			InstanceChargePrepaid: &lighthouse.RenewInstanceInstanceChargePrepaidArgs{
// 				Period:    pulumi.Int(1),
// 				RenewFlag: pulumi.String("NOTIFY_AND_MANUAL_RENEW"),
// 			},
// 			InstanceId:    pulumi.String(""),
// 			RenewDataDisk: pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type RenewInstance struct {
	pulumi.CustomResourceState

	// Whether to automatically deduct vouchers. Valid values:
	// - true: Automatically deduct vouchers.
	//   -false:Do not automatically deduct vouchers. Default value: false.
	AutoVoucher pulumi.BoolPtrOutput `pulumi:"autoVoucher"`
	// Prepaid mode, that is, yearly and monthly subscription related parameter settings. Through this parameter, you can specify attributes such as the purchase duration of the Subscription instance and whether to set automatic renewal.
	InstanceChargePrepaid RenewInstanceInstanceChargePrepaidOutput `pulumi:"instanceChargePrepaid"`
	// Instance ID.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// Whether to renew the data disk. Valid values:true: Indicates that the renewal instance also renews the data disk attached to it.false: Indicates that the instance will be renewed and the data disk attached to it will not be renewed at the same time.Default value: true.
	RenewDataDisk pulumi.BoolPtrOutput `pulumi:"renewDataDisk"`
}

// NewRenewInstance registers a new resource with the given unique name, arguments, and options.
func NewRenewInstance(ctx *pulumi.Context,
	name string, args *RenewInstanceArgs, opts ...pulumi.ResourceOption) (*RenewInstance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceChargePrepaid == nil {
		return nil, errors.New("invalid value for required argument 'InstanceChargePrepaid'")
	}
	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource RenewInstance
	err := ctx.RegisterResource("tencentcloud:Lighthouse/renewInstance:RenewInstance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRenewInstance gets an existing RenewInstance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRenewInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RenewInstanceState, opts ...pulumi.ResourceOption) (*RenewInstance, error) {
	var resource RenewInstance
	err := ctx.ReadResource("tencentcloud:Lighthouse/renewInstance:RenewInstance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RenewInstance resources.
type renewInstanceState struct {
	// Whether to automatically deduct vouchers. Valid values:
	// - true: Automatically deduct vouchers.
	//   -false:Do not automatically deduct vouchers. Default value: false.
	AutoVoucher *bool `pulumi:"autoVoucher"`
	// Prepaid mode, that is, yearly and monthly subscription related parameter settings. Through this parameter, you can specify attributes such as the purchase duration of the Subscription instance and whether to set automatic renewal.
	InstanceChargePrepaid *RenewInstanceInstanceChargePrepaid `pulumi:"instanceChargePrepaid"`
	// Instance ID.
	InstanceId *string `pulumi:"instanceId"`
	// Whether to renew the data disk. Valid values:true: Indicates that the renewal instance also renews the data disk attached to it.false: Indicates that the instance will be renewed and the data disk attached to it will not be renewed at the same time.Default value: true.
	RenewDataDisk *bool `pulumi:"renewDataDisk"`
}

type RenewInstanceState struct {
	// Whether to automatically deduct vouchers. Valid values:
	// - true: Automatically deduct vouchers.
	//   -false:Do not automatically deduct vouchers. Default value: false.
	AutoVoucher pulumi.BoolPtrInput
	// Prepaid mode, that is, yearly and monthly subscription related parameter settings. Through this parameter, you can specify attributes such as the purchase duration of the Subscription instance and whether to set automatic renewal.
	InstanceChargePrepaid RenewInstanceInstanceChargePrepaidPtrInput
	// Instance ID.
	InstanceId pulumi.StringPtrInput
	// Whether to renew the data disk. Valid values:true: Indicates that the renewal instance also renews the data disk attached to it.false: Indicates that the instance will be renewed and the data disk attached to it will not be renewed at the same time.Default value: true.
	RenewDataDisk pulumi.BoolPtrInput
}

func (RenewInstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*renewInstanceState)(nil)).Elem()
}

type renewInstanceArgs struct {
	// Whether to automatically deduct vouchers. Valid values:
	// - true: Automatically deduct vouchers.
	//   -false:Do not automatically deduct vouchers. Default value: false.
	AutoVoucher *bool `pulumi:"autoVoucher"`
	// Prepaid mode, that is, yearly and monthly subscription related parameter settings. Through this parameter, you can specify attributes such as the purchase duration of the Subscription instance and whether to set automatic renewal.
	InstanceChargePrepaid RenewInstanceInstanceChargePrepaid `pulumi:"instanceChargePrepaid"`
	// Instance ID.
	InstanceId string `pulumi:"instanceId"`
	// Whether to renew the data disk. Valid values:true: Indicates that the renewal instance also renews the data disk attached to it.false: Indicates that the instance will be renewed and the data disk attached to it will not be renewed at the same time.Default value: true.
	RenewDataDisk *bool `pulumi:"renewDataDisk"`
}

// The set of arguments for constructing a RenewInstance resource.
type RenewInstanceArgs struct {
	// Whether to automatically deduct vouchers. Valid values:
	// - true: Automatically deduct vouchers.
	//   -false:Do not automatically deduct vouchers. Default value: false.
	AutoVoucher pulumi.BoolPtrInput
	// Prepaid mode, that is, yearly and monthly subscription related parameter settings. Through this parameter, you can specify attributes such as the purchase duration of the Subscription instance and whether to set automatic renewal.
	InstanceChargePrepaid RenewInstanceInstanceChargePrepaidInput
	// Instance ID.
	InstanceId pulumi.StringInput
	// Whether to renew the data disk. Valid values:true: Indicates that the renewal instance also renews the data disk attached to it.false: Indicates that the instance will be renewed and the data disk attached to it will not be renewed at the same time.Default value: true.
	RenewDataDisk pulumi.BoolPtrInput
}

func (RenewInstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*renewInstanceArgs)(nil)).Elem()
}

type RenewInstanceInput interface {
	pulumi.Input

	ToRenewInstanceOutput() RenewInstanceOutput
	ToRenewInstanceOutputWithContext(ctx context.Context) RenewInstanceOutput
}

func (*RenewInstance) ElementType() reflect.Type {
	return reflect.TypeOf((**RenewInstance)(nil)).Elem()
}

func (i *RenewInstance) ToRenewInstanceOutput() RenewInstanceOutput {
	return i.ToRenewInstanceOutputWithContext(context.Background())
}

func (i *RenewInstance) ToRenewInstanceOutputWithContext(ctx context.Context) RenewInstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RenewInstanceOutput)
}

// RenewInstanceArrayInput is an input type that accepts RenewInstanceArray and RenewInstanceArrayOutput values.
// You can construct a concrete instance of `RenewInstanceArrayInput` via:
//
//          RenewInstanceArray{ RenewInstanceArgs{...} }
type RenewInstanceArrayInput interface {
	pulumi.Input

	ToRenewInstanceArrayOutput() RenewInstanceArrayOutput
	ToRenewInstanceArrayOutputWithContext(context.Context) RenewInstanceArrayOutput
}

type RenewInstanceArray []RenewInstanceInput

func (RenewInstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RenewInstance)(nil)).Elem()
}

func (i RenewInstanceArray) ToRenewInstanceArrayOutput() RenewInstanceArrayOutput {
	return i.ToRenewInstanceArrayOutputWithContext(context.Background())
}

func (i RenewInstanceArray) ToRenewInstanceArrayOutputWithContext(ctx context.Context) RenewInstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RenewInstanceArrayOutput)
}

// RenewInstanceMapInput is an input type that accepts RenewInstanceMap and RenewInstanceMapOutput values.
// You can construct a concrete instance of `RenewInstanceMapInput` via:
//
//          RenewInstanceMap{ "key": RenewInstanceArgs{...} }
type RenewInstanceMapInput interface {
	pulumi.Input

	ToRenewInstanceMapOutput() RenewInstanceMapOutput
	ToRenewInstanceMapOutputWithContext(context.Context) RenewInstanceMapOutput
}

type RenewInstanceMap map[string]RenewInstanceInput

func (RenewInstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RenewInstance)(nil)).Elem()
}

func (i RenewInstanceMap) ToRenewInstanceMapOutput() RenewInstanceMapOutput {
	return i.ToRenewInstanceMapOutputWithContext(context.Background())
}

func (i RenewInstanceMap) ToRenewInstanceMapOutputWithContext(ctx context.Context) RenewInstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RenewInstanceMapOutput)
}

type RenewInstanceOutput struct{ *pulumi.OutputState }

func (RenewInstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RenewInstance)(nil)).Elem()
}

func (o RenewInstanceOutput) ToRenewInstanceOutput() RenewInstanceOutput {
	return o
}

func (o RenewInstanceOutput) ToRenewInstanceOutputWithContext(ctx context.Context) RenewInstanceOutput {
	return o
}

// Whether to automatically deduct vouchers. Valid values:
// - true: Automatically deduct vouchers.
//   -false:Do not automatically deduct vouchers. Default value: false.
func (o RenewInstanceOutput) AutoVoucher() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RenewInstance) pulumi.BoolPtrOutput { return v.AutoVoucher }).(pulumi.BoolPtrOutput)
}

// Prepaid mode, that is, yearly and monthly subscription related parameter settings. Through this parameter, you can specify attributes such as the purchase duration of the Subscription instance and whether to set automatic renewal.
func (o RenewInstanceOutput) InstanceChargePrepaid() RenewInstanceInstanceChargePrepaidOutput {
	return o.ApplyT(func(v *RenewInstance) RenewInstanceInstanceChargePrepaidOutput { return v.InstanceChargePrepaid }).(RenewInstanceInstanceChargePrepaidOutput)
}

// Instance ID.
func (o RenewInstanceOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *RenewInstance) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// Whether to renew the data disk. Valid values:true: Indicates that the renewal instance also renews the data disk attached to it.false: Indicates that the instance will be renewed and the data disk attached to it will not be renewed at the same time.Default value: true.
func (o RenewInstanceOutput) RenewDataDisk() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RenewInstance) pulumi.BoolPtrOutput { return v.RenewDataDisk }).(pulumi.BoolPtrOutput)
}

type RenewInstanceArrayOutput struct{ *pulumi.OutputState }

func (RenewInstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RenewInstance)(nil)).Elem()
}

func (o RenewInstanceArrayOutput) ToRenewInstanceArrayOutput() RenewInstanceArrayOutput {
	return o
}

func (o RenewInstanceArrayOutput) ToRenewInstanceArrayOutputWithContext(ctx context.Context) RenewInstanceArrayOutput {
	return o
}

func (o RenewInstanceArrayOutput) Index(i pulumi.IntInput) RenewInstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RenewInstance {
		return vs[0].([]*RenewInstance)[vs[1].(int)]
	}).(RenewInstanceOutput)
}

type RenewInstanceMapOutput struct{ *pulumi.OutputState }

func (RenewInstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RenewInstance)(nil)).Elem()
}

func (o RenewInstanceMapOutput) ToRenewInstanceMapOutput() RenewInstanceMapOutput {
	return o
}

func (o RenewInstanceMapOutput) ToRenewInstanceMapOutputWithContext(ctx context.Context) RenewInstanceMapOutput {
	return o
}

func (o RenewInstanceMapOutput) MapIndex(k pulumi.StringInput) RenewInstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RenewInstance {
		return vs[0].(map[string]*RenewInstance)[vs[1].(string)]
	}).(RenewInstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RenewInstanceInput)(nil)).Elem(), &RenewInstance{})
	pulumi.RegisterInputType(reflect.TypeOf((*RenewInstanceArrayInput)(nil)).Elem(), RenewInstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RenewInstanceMapInput)(nil)).Elem(), RenewInstanceMap{})
	pulumi.RegisterOutputType(RenewInstanceOutput{})
	pulumi.RegisterOutputType(RenewInstanceArrayOutput{})
	pulumi.RegisterOutputType(RenewInstanceMapOutput{})
}
