// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mdl

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create a mdl streamliveInput
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Mdl"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := Mdl.NewStreamLiveInput(ctx, "streamLiveInput", &Mdl.StreamLiveInputArgs{
//				SecurityGroupIds: pulumi.StringArray{
//					pulumi.String("6405DF9D000007DFB4EC"),
//				},
//				Type: pulumi.String("RTP_PUSH"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// mdl stream_live_input can be imported using the id, e.g.
//
// ```sh
//
//	$ pulumi import tencentcloud:Mdl/streamLiveInput:StreamLiveInput stream_live_input id
//
// ```
type StreamLiveInput struct {
	pulumi.CustomResourceState

	// Input settings. For the type `RTMP_PUSH`, `RTMP_PULL`, `HLS_PULL`, or `MP4_PULL`, 1 or 2 inputs of the corresponding type can be configured.
	InputSettings StreamLiveInputInputSettingArrayOutput `pulumi:"inputSettings"`
	// Input name, which can contain 1-32 case-sensitive letters, digits, and underscores and must be unique at the region level.
	Name pulumi.StringOutput `pulumi:"name"`
	// ID of the input security group to attachYou can attach only one security group to an input.
	SecurityGroupIds pulumi.StringArrayOutput `pulumi:"securityGroupIds"`
	// Input typeValid values: `RTMP_PUSH`, `RTP_PUSH`, `UDP_PUSH`, `RTMP_PULL`, `HLS_PULL`, `MP4_PULL`.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewStreamLiveInput registers a new resource with the given unique name, arguments, and options.
func NewStreamLiveInput(ctx *pulumi.Context,
	name string, args *StreamLiveInputArgs, opts ...pulumi.ResourceOption) (*StreamLiveInput, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource StreamLiveInput
	err := ctx.RegisterResource("tencentcloud:Mdl/streamLiveInput:StreamLiveInput", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetStreamLiveInput gets an existing StreamLiveInput resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetStreamLiveInput(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *StreamLiveInputState, opts ...pulumi.ResourceOption) (*StreamLiveInput, error) {
	var resource StreamLiveInput
	err := ctx.ReadResource("tencentcloud:Mdl/streamLiveInput:StreamLiveInput", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering StreamLiveInput resources.
type streamLiveInputState struct {
	// Input settings. For the type `RTMP_PUSH`, `RTMP_PULL`, `HLS_PULL`, or `MP4_PULL`, 1 or 2 inputs of the corresponding type can be configured.
	InputSettings []StreamLiveInputInputSetting `pulumi:"inputSettings"`
	// Input name, which can contain 1-32 case-sensitive letters, digits, and underscores and must be unique at the region level.
	Name *string `pulumi:"name"`
	// ID of the input security group to attachYou can attach only one security group to an input.
	SecurityGroupIds []string `pulumi:"securityGroupIds"`
	// Input typeValid values: `RTMP_PUSH`, `RTP_PUSH`, `UDP_PUSH`, `RTMP_PULL`, `HLS_PULL`, `MP4_PULL`.
	Type *string `pulumi:"type"`
}

type StreamLiveInputState struct {
	// Input settings. For the type `RTMP_PUSH`, `RTMP_PULL`, `HLS_PULL`, or `MP4_PULL`, 1 or 2 inputs of the corresponding type can be configured.
	InputSettings StreamLiveInputInputSettingArrayInput
	// Input name, which can contain 1-32 case-sensitive letters, digits, and underscores and must be unique at the region level.
	Name pulumi.StringPtrInput
	// ID of the input security group to attachYou can attach only one security group to an input.
	SecurityGroupIds pulumi.StringArrayInput
	// Input typeValid values: `RTMP_PUSH`, `RTP_PUSH`, `UDP_PUSH`, `RTMP_PULL`, `HLS_PULL`, `MP4_PULL`.
	Type pulumi.StringPtrInput
}

func (StreamLiveInputState) ElementType() reflect.Type {
	return reflect.TypeOf((*streamLiveInputState)(nil)).Elem()
}

type streamLiveInputArgs struct {
	// Input settings. For the type `RTMP_PUSH`, `RTMP_PULL`, `HLS_PULL`, or `MP4_PULL`, 1 or 2 inputs of the corresponding type can be configured.
	InputSettings []StreamLiveInputInputSetting `pulumi:"inputSettings"`
	// Input name, which can contain 1-32 case-sensitive letters, digits, and underscores and must be unique at the region level.
	Name *string `pulumi:"name"`
	// ID of the input security group to attachYou can attach only one security group to an input.
	SecurityGroupIds []string `pulumi:"securityGroupIds"`
	// Input typeValid values: `RTMP_PUSH`, `RTP_PUSH`, `UDP_PUSH`, `RTMP_PULL`, `HLS_PULL`, `MP4_PULL`.
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a StreamLiveInput resource.
type StreamLiveInputArgs struct {
	// Input settings. For the type `RTMP_PUSH`, `RTMP_PULL`, `HLS_PULL`, or `MP4_PULL`, 1 or 2 inputs of the corresponding type can be configured.
	InputSettings StreamLiveInputInputSettingArrayInput
	// Input name, which can contain 1-32 case-sensitive letters, digits, and underscores and must be unique at the region level.
	Name pulumi.StringPtrInput
	// ID of the input security group to attachYou can attach only one security group to an input.
	SecurityGroupIds pulumi.StringArrayInput
	// Input typeValid values: `RTMP_PUSH`, `RTP_PUSH`, `UDP_PUSH`, `RTMP_PULL`, `HLS_PULL`, `MP4_PULL`.
	Type pulumi.StringInput
}

func (StreamLiveInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*streamLiveInputArgs)(nil)).Elem()
}

type StreamLiveInputInput interface {
	pulumi.Input

	ToStreamLiveInputOutput() StreamLiveInputOutput
	ToStreamLiveInputOutputWithContext(ctx context.Context) StreamLiveInputOutput
}

func (*StreamLiveInput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamLiveInput)(nil)).Elem()
}

func (i *StreamLiveInput) ToStreamLiveInputOutput() StreamLiveInputOutput {
	return i.ToStreamLiveInputOutputWithContext(context.Background())
}

func (i *StreamLiveInput) ToStreamLiveInputOutputWithContext(ctx context.Context) StreamLiveInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamLiveInputOutput)
}

// StreamLiveInputArrayInput is an input type that accepts StreamLiveInputArray and StreamLiveInputArrayOutput values.
// You can construct a concrete instance of `StreamLiveInputArrayInput` via:
//
//	StreamLiveInputArray{ StreamLiveInputArgs{...} }
type StreamLiveInputArrayInput interface {
	pulumi.Input

	ToStreamLiveInputArrayOutput() StreamLiveInputArrayOutput
	ToStreamLiveInputArrayOutputWithContext(context.Context) StreamLiveInputArrayOutput
}

type StreamLiveInputArray []StreamLiveInputInput

func (StreamLiveInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*StreamLiveInput)(nil)).Elem()
}

func (i StreamLiveInputArray) ToStreamLiveInputArrayOutput() StreamLiveInputArrayOutput {
	return i.ToStreamLiveInputArrayOutputWithContext(context.Background())
}

func (i StreamLiveInputArray) ToStreamLiveInputArrayOutputWithContext(ctx context.Context) StreamLiveInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamLiveInputArrayOutput)
}

// StreamLiveInputMapInput is an input type that accepts StreamLiveInputMap and StreamLiveInputMapOutput values.
// You can construct a concrete instance of `StreamLiveInputMapInput` via:
//
//	StreamLiveInputMap{ "key": StreamLiveInputArgs{...} }
type StreamLiveInputMapInput interface {
	pulumi.Input

	ToStreamLiveInputMapOutput() StreamLiveInputMapOutput
	ToStreamLiveInputMapOutputWithContext(context.Context) StreamLiveInputMapOutput
}

type StreamLiveInputMap map[string]StreamLiveInputInput

func (StreamLiveInputMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*StreamLiveInput)(nil)).Elem()
}

func (i StreamLiveInputMap) ToStreamLiveInputMapOutput() StreamLiveInputMapOutput {
	return i.ToStreamLiveInputMapOutputWithContext(context.Background())
}

func (i StreamLiveInputMap) ToStreamLiveInputMapOutputWithContext(ctx context.Context) StreamLiveInputMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamLiveInputMapOutput)
}

type StreamLiveInputOutput struct{ *pulumi.OutputState }

func (StreamLiveInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamLiveInput)(nil)).Elem()
}

func (o StreamLiveInputOutput) ToStreamLiveInputOutput() StreamLiveInputOutput {
	return o
}

func (o StreamLiveInputOutput) ToStreamLiveInputOutputWithContext(ctx context.Context) StreamLiveInputOutput {
	return o
}

// Input settings. For the type `RTMP_PUSH`, `RTMP_PULL`, `HLS_PULL`, or `MP4_PULL`, 1 or 2 inputs of the corresponding type can be configured.
func (o StreamLiveInputOutput) InputSettings() StreamLiveInputInputSettingArrayOutput {
	return o.ApplyT(func(v *StreamLiveInput) StreamLiveInputInputSettingArrayOutput { return v.InputSettings }).(StreamLiveInputInputSettingArrayOutput)
}

// Input name, which can contain 1-32 case-sensitive letters, digits, and underscores and must be unique at the region level.
func (o StreamLiveInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamLiveInput) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// ID of the input security group to attachYou can attach only one security group to an input.
func (o StreamLiveInputOutput) SecurityGroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *StreamLiveInput) pulumi.StringArrayOutput { return v.SecurityGroupIds }).(pulumi.StringArrayOutput)
}

// Input typeValid values: `RTMP_PUSH`, `RTP_PUSH`, `UDP_PUSH`, `RTMP_PULL`, `HLS_PULL`, `MP4_PULL`.
func (o StreamLiveInputOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamLiveInput) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type StreamLiveInputArrayOutput struct{ *pulumi.OutputState }

func (StreamLiveInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*StreamLiveInput)(nil)).Elem()
}

func (o StreamLiveInputArrayOutput) ToStreamLiveInputArrayOutput() StreamLiveInputArrayOutput {
	return o
}

func (o StreamLiveInputArrayOutput) ToStreamLiveInputArrayOutputWithContext(ctx context.Context) StreamLiveInputArrayOutput {
	return o
}

func (o StreamLiveInputArrayOutput) Index(i pulumi.IntInput) StreamLiveInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *StreamLiveInput {
		return vs[0].([]*StreamLiveInput)[vs[1].(int)]
	}).(StreamLiveInputOutput)
}

type StreamLiveInputMapOutput struct{ *pulumi.OutputState }

func (StreamLiveInputMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*StreamLiveInput)(nil)).Elem()
}

func (o StreamLiveInputMapOutput) ToStreamLiveInputMapOutput() StreamLiveInputMapOutput {
	return o
}

func (o StreamLiveInputMapOutput) ToStreamLiveInputMapOutputWithContext(ctx context.Context) StreamLiveInputMapOutput {
	return o
}

func (o StreamLiveInputMapOutput) MapIndex(k pulumi.StringInput) StreamLiveInputOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *StreamLiveInput {
		return vs[0].(map[string]*StreamLiveInput)[vs[1].(string)]
	}).(StreamLiveInputOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*StreamLiveInputInput)(nil)).Elem(), &StreamLiveInput{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamLiveInputArrayInput)(nil)).Elem(), StreamLiveInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamLiveInputMapInput)(nil)).Elem(), StreamLiveInputMap{})
	pulumi.RegisterOutputType(StreamLiveInputOutput{})
	pulumi.RegisterOutputType(StreamLiveInputArrayOutput{})
	pulumi.RegisterOutputType(StreamLiveInputMapOutput{})
}
