// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package security

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provide a resource to create security group some lite rules quickly.
//
// > **NOTE:** It can't be used with tencentcloud_security_group_rule, and don't create multiple tencentcloudSecurityGroupRule resources, otherwise it may cause problems.
//
// ## Import
//
// Security group lite rule can be imported using the id, e.g.
//
// ```sh
//
//	$ pulumi import tencentcloud:Security/groupLiteRule:GroupLiteRule tencentcloud_security_group_lite_rule.foo sg-ey3wmiz1
//
// ```
type GroupLiteRule struct {
	pulumi.CustomResourceState

	// Egress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Egresses pulumi.StringArrayOutput `pulumi:"egresses"`
	// Ingress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Ingresses pulumi.StringArrayOutput `pulumi:"ingresses"`
	// ID of the security group.
	SecurityGroupId pulumi.StringOutput `pulumi:"securityGroupId"`
}

// NewGroupLiteRule registers a new resource with the given unique name, arguments, and options.
func NewGroupLiteRule(ctx *pulumi.Context,
	name string, args *GroupLiteRuleArgs, opts ...pulumi.ResourceOption) (*GroupLiteRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SecurityGroupId == nil {
		return nil, errors.New("invalid value for required argument 'SecurityGroupId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource GroupLiteRule
	err := ctx.RegisterResource("tencentcloud:Security/groupLiteRule:GroupLiteRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGroupLiteRule gets an existing GroupLiteRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGroupLiteRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GroupLiteRuleState, opts ...pulumi.ResourceOption) (*GroupLiteRule, error) {
	var resource GroupLiteRule
	err := ctx.ReadResource("tencentcloud:Security/groupLiteRule:GroupLiteRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GroupLiteRule resources.
type groupLiteRuleState struct {
	// Egress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Egresses []string `pulumi:"egresses"`
	// Ingress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Ingresses []string `pulumi:"ingresses"`
	// ID of the security group.
	SecurityGroupId *string `pulumi:"securityGroupId"`
}

type GroupLiteRuleState struct {
	// Egress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Egresses pulumi.StringArrayInput
	// Ingress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Ingresses pulumi.StringArrayInput
	// ID of the security group.
	SecurityGroupId pulumi.StringPtrInput
}

func (GroupLiteRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*groupLiteRuleState)(nil)).Elem()
}

type groupLiteRuleArgs struct {
	// Egress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Egresses []string `pulumi:"egresses"`
	// Ingress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Ingresses []string `pulumi:"ingresses"`
	// ID of the security group.
	SecurityGroupId string `pulumi:"securityGroupId"`
}

// The set of arguments for constructing a GroupLiteRule resource.
type GroupLiteRuleArgs struct {
	// Egress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Egresses pulumi.StringArrayInput
	// Ingress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
	Ingresses pulumi.StringArrayInput
	// ID of the security group.
	SecurityGroupId pulumi.StringInput
}

func (GroupLiteRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*groupLiteRuleArgs)(nil)).Elem()
}

type GroupLiteRuleInput interface {
	pulumi.Input

	ToGroupLiteRuleOutput() GroupLiteRuleOutput
	ToGroupLiteRuleOutputWithContext(ctx context.Context) GroupLiteRuleOutput
}

func (*GroupLiteRule) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupLiteRule)(nil)).Elem()
}

func (i *GroupLiteRule) ToGroupLiteRuleOutput() GroupLiteRuleOutput {
	return i.ToGroupLiteRuleOutputWithContext(context.Background())
}

func (i *GroupLiteRule) ToGroupLiteRuleOutputWithContext(ctx context.Context) GroupLiteRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupLiteRuleOutput)
}

// GroupLiteRuleArrayInput is an input type that accepts GroupLiteRuleArray and GroupLiteRuleArrayOutput values.
// You can construct a concrete instance of `GroupLiteRuleArrayInput` via:
//
//	GroupLiteRuleArray{ GroupLiteRuleArgs{...} }
type GroupLiteRuleArrayInput interface {
	pulumi.Input

	ToGroupLiteRuleArrayOutput() GroupLiteRuleArrayOutput
	ToGroupLiteRuleArrayOutputWithContext(context.Context) GroupLiteRuleArrayOutput
}

type GroupLiteRuleArray []GroupLiteRuleInput

func (GroupLiteRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupLiteRule)(nil)).Elem()
}

func (i GroupLiteRuleArray) ToGroupLiteRuleArrayOutput() GroupLiteRuleArrayOutput {
	return i.ToGroupLiteRuleArrayOutputWithContext(context.Background())
}

func (i GroupLiteRuleArray) ToGroupLiteRuleArrayOutputWithContext(ctx context.Context) GroupLiteRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupLiteRuleArrayOutput)
}

// GroupLiteRuleMapInput is an input type that accepts GroupLiteRuleMap and GroupLiteRuleMapOutput values.
// You can construct a concrete instance of `GroupLiteRuleMapInput` via:
//
//	GroupLiteRuleMap{ "key": GroupLiteRuleArgs{...} }
type GroupLiteRuleMapInput interface {
	pulumi.Input

	ToGroupLiteRuleMapOutput() GroupLiteRuleMapOutput
	ToGroupLiteRuleMapOutputWithContext(context.Context) GroupLiteRuleMapOutput
}

type GroupLiteRuleMap map[string]GroupLiteRuleInput

func (GroupLiteRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupLiteRule)(nil)).Elem()
}

func (i GroupLiteRuleMap) ToGroupLiteRuleMapOutput() GroupLiteRuleMapOutput {
	return i.ToGroupLiteRuleMapOutputWithContext(context.Background())
}

func (i GroupLiteRuleMap) ToGroupLiteRuleMapOutputWithContext(ctx context.Context) GroupLiteRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupLiteRuleMapOutput)
}

type GroupLiteRuleOutput struct{ *pulumi.OutputState }

func (GroupLiteRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupLiteRule)(nil)).Elem()
}

func (o GroupLiteRuleOutput) ToGroupLiteRuleOutput() GroupLiteRuleOutput {
	return o
}

func (o GroupLiteRuleOutput) ToGroupLiteRuleOutputWithContext(ctx context.Context) GroupLiteRuleOutput {
	return o
}

// Egress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
func (o GroupLiteRuleOutput) Egresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GroupLiteRule) pulumi.StringArrayOutput { return v.Egresses }).(pulumi.StringArrayOutput)
}

// Ingress rules set. A rule must match the following format: [action]#[source]#[port]#[protocol]. The available value of 'action' is `ACCEPT` and `DROP`. The 'source' can be an IP address network, segment, security group ID and Address Template ID. The 'port' valid format is `80`, `80,443`, `80-90` or `ALL`. The available value of 'protocol' is `TCP`, `UDP`, `ICMP`, `ALL` and `ppm(g?)-xxxxxxxx`. When 'protocol' is `ICMP` or `ALL`, the 'port' must be `ALL`.
func (o GroupLiteRuleOutput) Ingresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GroupLiteRule) pulumi.StringArrayOutput { return v.Ingresses }).(pulumi.StringArrayOutput)
}

// ID of the security group.
func (o GroupLiteRuleOutput) SecurityGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupLiteRule) pulumi.StringOutput { return v.SecurityGroupId }).(pulumi.StringOutput)
}

type GroupLiteRuleArrayOutput struct{ *pulumi.OutputState }

func (GroupLiteRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupLiteRule)(nil)).Elem()
}

func (o GroupLiteRuleArrayOutput) ToGroupLiteRuleArrayOutput() GroupLiteRuleArrayOutput {
	return o
}

func (o GroupLiteRuleArrayOutput) ToGroupLiteRuleArrayOutputWithContext(ctx context.Context) GroupLiteRuleArrayOutput {
	return o
}

func (o GroupLiteRuleArrayOutput) Index(i pulumi.IntInput) GroupLiteRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GroupLiteRule {
		return vs[0].([]*GroupLiteRule)[vs[1].(int)]
	}).(GroupLiteRuleOutput)
}

type GroupLiteRuleMapOutput struct{ *pulumi.OutputState }

func (GroupLiteRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupLiteRule)(nil)).Elem()
}

func (o GroupLiteRuleMapOutput) ToGroupLiteRuleMapOutput() GroupLiteRuleMapOutput {
	return o
}

func (o GroupLiteRuleMapOutput) ToGroupLiteRuleMapOutputWithContext(ctx context.Context) GroupLiteRuleMapOutput {
	return o
}

func (o GroupLiteRuleMapOutput) MapIndex(k pulumi.StringInput) GroupLiteRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GroupLiteRule {
		return vs[0].(map[string]*GroupLiteRule)[vs[1].(string)]
	}).(GroupLiteRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GroupLiteRuleInput)(nil)).Elem(), &GroupLiteRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupLiteRuleArrayInput)(nil)).Elem(), GroupLiteRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupLiteRuleMapInput)(nil)).Elem(), GroupLiteRuleMap{})
	pulumi.RegisterOutputType(GroupLiteRuleOutput{})
	pulumi.RegisterOutputType(GroupLiteRuleArrayOutput{})
	pulumi.RegisterOutputType(GroupLiteRuleMapOutput{})
}
