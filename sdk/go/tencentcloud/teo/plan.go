// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package teo

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/internal"
)

type Plan struct {
	pulumi.CustomResourceState

	// Service area, possible values are: <li>mainland: Mainland China; </li><li>overseas: Worldwide (excluding Mainland China); </li><li>global: Worldwide (including Mainland China). </li>.
	Area pulumi.StringOutput `pulumi:"area"`
	// The time when the package takes effect.
	EnabledTime pulumi.StringOutput `pulumi:"enabledTime"`
	// The expiration date of the package.
	ExpiredTime pulumi.StringOutput `pulumi:"expiredTime"`
	// Payment type, possible values: <li>0: post-payment; </li><li>1: pre-payment. </li>.
	PayMode pulumi.StringOutput `pulumi:"payMode"`
	// Plan ID.
	PlanId pulumi.StringOutput `pulumi:"planId"`
	// The subscription package type, the possible values are: `personal`: personal package, prepaid package; `basic`: basic package, prepaid package; `standard`: standard package, prepaid package; `enterprise`: enterprise package, postpaid package.
	PlanType pulumi.StringOutput `pulumi:"planType"`
	// Subscription prepaid package parameters. When PlanType is personal, basic, or standard, this parameter is optional and is used to enter the subscription duration of the package and whether to enable automatic renewal. If this parameter is not filled in, the default subscription duration is 1 month and automatic renewal is not enabled.
	PrepaidPlanParam PlanPrepaidPlanParamPtrOutput `pulumi:"prepaidPlanParam"`
	// Package status, the values are: <li>normal: normal status; </li><li>expiring-soon: about to expire; </li><li>expired: expired; </li><li>isolated: isolated; </li><li>overdue-isolated: overdue isolated. </li>.
	Status pulumi.StringOutput `pulumi:"status"`
}

// NewPlan registers a new resource with the given unique name, arguments, and options.
func NewPlan(ctx *pulumi.Context,
	name string, args *PlanArgs, opts ...pulumi.ResourceOption) (*Plan, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PlanType == nil {
		return nil, errors.New("invalid value for required argument 'PlanType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Plan
	err := ctx.RegisterResource("tencentcloud:Teo/plan:Plan", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPlan gets an existing Plan resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPlan(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PlanState, opts ...pulumi.ResourceOption) (*Plan, error) {
	var resource Plan
	err := ctx.ReadResource("tencentcloud:Teo/plan:Plan", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Plan resources.
type planState struct {
	// Service area, possible values are: <li>mainland: Mainland China; </li><li>overseas: Worldwide (excluding Mainland China); </li><li>global: Worldwide (including Mainland China). </li>.
	Area *string `pulumi:"area"`
	// The time when the package takes effect.
	EnabledTime *string `pulumi:"enabledTime"`
	// The expiration date of the package.
	ExpiredTime *string `pulumi:"expiredTime"`
	// Payment type, possible values: <li>0: post-payment; </li><li>1: pre-payment. </li>.
	PayMode *string `pulumi:"payMode"`
	// Plan ID.
	PlanId *string `pulumi:"planId"`
	// The subscription package type, the possible values are: `personal`: personal package, prepaid package; `basic`: basic package, prepaid package; `standard`: standard package, prepaid package; `enterprise`: enterprise package, postpaid package.
	PlanType *string `pulumi:"planType"`
	// Subscription prepaid package parameters. When PlanType is personal, basic, or standard, this parameter is optional and is used to enter the subscription duration of the package and whether to enable automatic renewal. If this parameter is not filled in, the default subscription duration is 1 month and automatic renewal is not enabled.
	PrepaidPlanParam *PlanPrepaidPlanParam `pulumi:"prepaidPlanParam"`
	// Package status, the values are: <li>normal: normal status; </li><li>expiring-soon: about to expire; </li><li>expired: expired; </li><li>isolated: isolated; </li><li>overdue-isolated: overdue isolated. </li>.
	Status *string `pulumi:"status"`
}

type PlanState struct {
	// Service area, possible values are: <li>mainland: Mainland China; </li><li>overseas: Worldwide (excluding Mainland China); </li><li>global: Worldwide (including Mainland China). </li>.
	Area pulumi.StringPtrInput
	// The time when the package takes effect.
	EnabledTime pulumi.StringPtrInput
	// The expiration date of the package.
	ExpiredTime pulumi.StringPtrInput
	// Payment type, possible values: <li>0: post-payment; </li><li>1: pre-payment. </li>.
	PayMode pulumi.StringPtrInput
	// Plan ID.
	PlanId pulumi.StringPtrInput
	// The subscription package type, the possible values are: `personal`: personal package, prepaid package; `basic`: basic package, prepaid package; `standard`: standard package, prepaid package; `enterprise`: enterprise package, postpaid package.
	PlanType pulumi.StringPtrInput
	// Subscription prepaid package parameters. When PlanType is personal, basic, or standard, this parameter is optional and is used to enter the subscription duration of the package and whether to enable automatic renewal. If this parameter is not filled in, the default subscription duration is 1 month and automatic renewal is not enabled.
	PrepaidPlanParam PlanPrepaidPlanParamPtrInput
	// Package status, the values are: <li>normal: normal status; </li><li>expiring-soon: about to expire; </li><li>expired: expired; </li><li>isolated: isolated; </li><li>overdue-isolated: overdue isolated. </li>.
	Status pulumi.StringPtrInput
}

func (PlanState) ElementType() reflect.Type {
	return reflect.TypeOf((*planState)(nil)).Elem()
}

type planArgs struct {
	// The subscription package type, the possible values are: `personal`: personal package, prepaid package; `basic`: basic package, prepaid package; `standard`: standard package, prepaid package; `enterprise`: enterprise package, postpaid package.
	PlanType string `pulumi:"planType"`
	// Subscription prepaid package parameters. When PlanType is personal, basic, or standard, this parameter is optional and is used to enter the subscription duration of the package and whether to enable automatic renewal. If this parameter is not filled in, the default subscription duration is 1 month and automatic renewal is not enabled.
	PrepaidPlanParam *PlanPrepaidPlanParam `pulumi:"prepaidPlanParam"`
}

// The set of arguments for constructing a Plan resource.
type PlanArgs struct {
	// The subscription package type, the possible values are: `personal`: personal package, prepaid package; `basic`: basic package, prepaid package; `standard`: standard package, prepaid package; `enterprise`: enterprise package, postpaid package.
	PlanType pulumi.StringInput
	// Subscription prepaid package parameters. When PlanType is personal, basic, or standard, this parameter is optional and is used to enter the subscription duration of the package and whether to enable automatic renewal. If this parameter is not filled in, the default subscription duration is 1 month and automatic renewal is not enabled.
	PrepaidPlanParam PlanPrepaidPlanParamPtrInput
}

func (PlanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*planArgs)(nil)).Elem()
}

type PlanInput interface {
	pulumi.Input

	ToPlanOutput() PlanOutput
	ToPlanOutputWithContext(ctx context.Context) PlanOutput
}

func (*Plan) ElementType() reflect.Type {
	return reflect.TypeOf((**Plan)(nil)).Elem()
}

func (i *Plan) ToPlanOutput() PlanOutput {
	return i.ToPlanOutputWithContext(context.Background())
}

func (i *Plan) ToPlanOutputWithContext(ctx context.Context) PlanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlanOutput)
}

// PlanArrayInput is an input type that accepts PlanArray and PlanArrayOutput values.
// You can construct a concrete instance of `PlanArrayInput` via:
//
//	PlanArray{ PlanArgs{...} }
type PlanArrayInput interface {
	pulumi.Input

	ToPlanArrayOutput() PlanArrayOutput
	ToPlanArrayOutputWithContext(context.Context) PlanArrayOutput
}

type PlanArray []PlanInput

func (PlanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Plan)(nil)).Elem()
}

func (i PlanArray) ToPlanArrayOutput() PlanArrayOutput {
	return i.ToPlanArrayOutputWithContext(context.Background())
}

func (i PlanArray) ToPlanArrayOutputWithContext(ctx context.Context) PlanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlanArrayOutput)
}

// PlanMapInput is an input type that accepts PlanMap and PlanMapOutput values.
// You can construct a concrete instance of `PlanMapInput` via:
//
//	PlanMap{ "key": PlanArgs{...} }
type PlanMapInput interface {
	pulumi.Input

	ToPlanMapOutput() PlanMapOutput
	ToPlanMapOutputWithContext(context.Context) PlanMapOutput
}

type PlanMap map[string]PlanInput

func (PlanMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Plan)(nil)).Elem()
}

func (i PlanMap) ToPlanMapOutput() PlanMapOutput {
	return i.ToPlanMapOutputWithContext(context.Background())
}

func (i PlanMap) ToPlanMapOutputWithContext(ctx context.Context) PlanMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlanMapOutput)
}

type PlanOutput struct{ *pulumi.OutputState }

func (PlanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Plan)(nil)).Elem()
}

func (o PlanOutput) ToPlanOutput() PlanOutput {
	return o
}

func (o PlanOutput) ToPlanOutputWithContext(ctx context.Context) PlanOutput {
	return o
}

// Service area, possible values are: <li>mainland: Mainland China; </li><li>overseas: Worldwide (excluding Mainland China); </li><li>global: Worldwide (including Mainland China). </li>.
func (o PlanOutput) Area() pulumi.StringOutput {
	return o.ApplyT(func(v *Plan) pulumi.StringOutput { return v.Area }).(pulumi.StringOutput)
}

// The time when the package takes effect.
func (o PlanOutput) EnabledTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Plan) pulumi.StringOutput { return v.EnabledTime }).(pulumi.StringOutput)
}

// The expiration date of the package.
func (o PlanOutput) ExpiredTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Plan) pulumi.StringOutput { return v.ExpiredTime }).(pulumi.StringOutput)
}

// Payment type, possible values: <li>0: post-payment; </li><li>1: pre-payment. </li>.
func (o PlanOutput) PayMode() pulumi.StringOutput {
	return o.ApplyT(func(v *Plan) pulumi.StringOutput { return v.PayMode }).(pulumi.StringOutput)
}

// Plan ID.
func (o PlanOutput) PlanId() pulumi.StringOutput {
	return o.ApplyT(func(v *Plan) pulumi.StringOutput { return v.PlanId }).(pulumi.StringOutput)
}

// The subscription package type, the possible values are: `personal`: personal package, prepaid package; `basic`: basic package, prepaid package; `standard`: standard package, prepaid package; `enterprise`: enterprise package, postpaid package.
func (o PlanOutput) PlanType() pulumi.StringOutput {
	return o.ApplyT(func(v *Plan) pulumi.StringOutput { return v.PlanType }).(pulumi.StringOutput)
}

// Subscription prepaid package parameters. When PlanType is personal, basic, or standard, this parameter is optional and is used to enter the subscription duration of the package and whether to enable automatic renewal. If this parameter is not filled in, the default subscription duration is 1 month and automatic renewal is not enabled.
func (o PlanOutput) PrepaidPlanParam() PlanPrepaidPlanParamPtrOutput {
	return o.ApplyT(func(v *Plan) PlanPrepaidPlanParamPtrOutput { return v.PrepaidPlanParam }).(PlanPrepaidPlanParamPtrOutput)
}

// Package status, the values are: <li>normal: normal status; </li><li>expiring-soon: about to expire; </li><li>expired: expired; </li><li>isolated: isolated; </li><li>overdue-isolated: overdue isolated. </li>.
func (o PlanOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Plan) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

type PlanArrayOutput struct{ *pulumi.OutputState }

func (PlanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Plan)(nil)).Elem()
}

func (o PlanArrayOutput) ToPlanArrayOutput() PlanArrayOutput {
	return o
}

func (o PlanArrayOutput) ToPlanArrayOutputWithContext(ctx context.Context) PlanArrayOutput {
	return o
}

func (o PlanArrayOutput) Index(i pulumi.IntInput) PlanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Plan {
		return vs[0].([]*Plan)[vs[1].(int)]
	}).(PlanOutput)
}

type PlanMapOutput struct{ *pulumi.OutputState }

func (PlanMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Plan)(nil)).Elem()
}

func (o PlanMapOutput) ToPlanMapOutput() PlanMapOutput {
	return o
}

func (o PlanMapOutput) ToPlanMapOutputWithContext(ctx context.Context) PlanMapOutput {
	return o
}

func (o PlanMapOutput) MapIndex(k pulumi.StringInput) PlanOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Plan {
		return vs[0].(map[string]*Plan)[vs[1].(string)]
	}).(PlanOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PlanInput)(nil)).Elem(), &Plan{})
	pulumi.RegisterInputType(reflect.TypeOf((*PlanArrayInput)(nil)).Elem(), PlanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PlanMapInput)(nil)).Elem(), PlanMap{})
	pulumi.RegisterOutputType(PlanOutput{})
	pulumi.RegisterOutputType(PlanArrayOutput{})
	pulumi.RegisterOutputType(PlanMapOutput{})
}
