// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package oceanus

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/internal"
)

// Provides a resource to create a oceanus job
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/oceanus"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := oceanus.NewJob(ctx, "example", &oceanus.JobArgs{
//				Name:         pulumi.String("tf_example_job"),
//				JobType:      pulumi.Int(1),
//				ClusterType:  pulumi.Int(2),
//				ClusterId:    pulumi.String("cluster-1kcd524h"),
//				CuMem:        pulumi.Int(4),
//				Remark:       pulumi.String("remark."),
//				FolderId:     pulumi.String("folder-7ctl246z"),
//				FlinkVersion: pulumi.String("Flink-1.16"),
//				WorkSpaceId:  pulumi.String("space-2idq8wbr"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Job struct {
	pulumi.CustomResourceState

	// When ClusterType=2, it is required to specify the ID of the exclusive cluster to which the job is submitted.
	ClusterId pulumi.StringPtrOutput `pulumi:"clusterId"`
	// The type of the cluster. 1 indicates shared cluster, and 2 indicates exclusive cluster.
	ClusterType pulumi.IntOutput `pulumi:"clusterType"`
	// Set the memory specification of each CU, in GB. It supports 2, 4, 8, and 16 (which needs to apply for the whitelist before use). The default is 4, that is, 1 CU corresponds to 4 GB of running memory.
	CuMem pulumi.IntPtrOutput `pulumi:"cuMem"`
	// The Flink version that the job runs.
	FlinkVersion pulumi.StringPtrOutput `pulumi:"flinkVersion"`
	// The folder ID to which the job name belongs. The root directory is root.
	FolderId pulumi.StringPtrOutput `pulumi:"folderId"`
	// The type of the job. 1 indicates SQL job, and 2 indicates JAR job.
	JobType pulumi.IntOutput `pulumi:"jobType"`
	// The name of the job. It can be composed of Chinese, English, numbers, hyphens (-), underscores (_), and periods (.), and the length cannot exceed 50 characters. Note that the job name cannot be the same as an existing job.
	Name pulumi.StringOutput `pulumi:"name"`
	// The remark information of the job. It can be set arbitrarily.
	Remark pulumi.StringPtrOutput `pulumi:"remark"`
	// The workspace SerialId.
	WorkSpaceId pulumi.StringPtrOutput `pulumi:"workSpaceId"`
}

// NewJob registers a new resource with the given unique name, arguments, and options.
func NewJob(ctx *pulumi.Context,
	name string, args *JobArgs, opts ...pulumi.ResourceOption) (*Job, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterType == nil {
		return nil, errors.New("invalid value for required argument 'ClusterType'")
	}
	if args.JobType == nil {
		return nil, errors.New("invalid value for required argument 'JobType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Job
	err := ctx.RegisterResource("tencentcloud:Oceanus/job:Job", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetJob gets an existing Job resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetJob(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *JobState, opts ...pulumi.ResourceOption) (*Job, error) {
	var resource Job
	err := ctx.ReadResource("tencentcloud:Oceanus/job:Job", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Job resources.
type jobState struct {
	// When ClusterType=2, it is required to specify the ID of the exclusive cluster to which the job is submitted.
	ClusterId *string `pulumi:"clusterId"`
	// The type of the cluster. 1 indicates shared cluster, and 2 indicates exclusive cluster.
	ClusterType *int `pulumi:"clusterType"`
	// Set the memory specification of each CU, in GB. It supports 2, 4, 8, and 16 (which needs to apply for the whitelist before use). The default is 4, that is, 1 CU corresponds to 4 GB of running memory.
	CuMem *int `pulumi:"cuMem"`
	// The Flink version that the job runs.
	FlinkVersion *string `pulumi:"flinkVersion"`
	// The folder ID to which the job name belongs. The root directory is root.
	FolderId *string `pulumi:"folderId"`
	// The type of the job. 1 indicates SQL job, and 2 indicates JAR job.
	JobType *int `pulumi:"jobType"`
	// The name of the job. It can be composed of Chinese, English, numbers, hyphens (-), underscores (_), and periods (.), and the length cannot exceed 50 characters. Note that the job name cannot be the same as an existing job.
	Name *string `pulumi:"name"`
	// The remark information of the job. It can be set arbitrarily.
	Remark *string `pulumi:"remark"`
	// The workspace SerialId.
	WorkSpaceId *string `pulumi:"workSpaceId"`
}

type JobState struct {
	// When ClusterType=2, it is required to specify the ID of the exclusive cluster to which the job is submitted.
	ClusterId pulumi.StringPtrInput
	// The type of the cluster. 1 indicates shared cluster, and 2 indicates exclusive cluster.
	ClusterType pulumi.IntPtrInput
	// Set the memory specification of each CU, in GB. It supports 2, 4, 8, and 16 (which needs to apply for the whitelist before use). The default is 4, that is, 1 CU corresponds to 4 GB of running memory.
	CuMem pulumi.IntPtrInput
	// The Flink version that the job runs.
	FlinkVersion pulumi.StringPtrInput
	// The folder ID to which the job name belongs. The root directory is root.
	FolderId pulumi.StringPtrInput
	// The type of the job. 1 indicates SQL job, and 2 indicates JAR job.
	JobType pulumi.IntPtrInput
	// The name of the job. It can be composed of Chinese, English, numbers, hyphens (-), underscores (_), and periods (.), and the length cannot exceed 50 characters. Note that the job name cannot be the same as an existing job.
	Name pulumi.StringPtrInput
	// The remark information of the job. It can be set arbitrarily.
	Remark pulumi.StringPtrInput
	// The workspace SerialId.
	WorkSpaceId pulumi.StringPtrInput
}

func (JobState) ElementType() reflect.Type {
	return reflect.TypeOf((*jobState)(nil)).Elem()
}

type jobArgs struct {
	// When ClusterType=2, it is required to specify the ID of the exclusive cluster to which the job is submitted.
	ClusterId *string `pulumi:"clusterId"`
	// The type of the cluster. 1 indicates shared cluster, and 2 indicates exclusive cluster.
	ClusterType int `pulumi:"clusterType"`
	// Set the memory specification of each CU, in GB. It supports 2, 4, 8, and 16 (which needs to apply for the whitelist before use). The default is 4, that is, 1 CU corresponds to 4 GB of running memory.
	CuMem *int `pulumi:"cuMem"`
	// The Flink version that the job runs.
	FlinkVersion *string `pulumi:"flinkVersion"`
	// The folder ID to which the job name belongs. The root directory is root.
	FolderId *string `pulumi:"folderId"`
	// The type of the job. 1 indicates SQL job, and 2 indicates JAR job.
	JobType int `pulumi:"jobType"`
	// The name of the job. It can be composed of Chinese, English, numbers, hyphens (-), underscores (_), and periods (.), and the length cannot exceed 50 characters. Note that the job name cannot be the same as an existing job.
	Name *string `pulumi:"name"`
	// The remark information of the job. It can be set arbitrarily.
	Remark *string `pulumi:"remark"`
	// The workspace SerialId.
	WorkSpaceId *string `pulumi:"workSpaceId"`
}

// The set of arguments for constructing a Job resource.
type JobArgs struct {
	// When ClusterType=2, it is required to specify the ID of the exclusive cluster to which the job is submitted.
	ClusterId pulumi.StringPtrInput
	// The type of the cluster. 1 indicates shared cluster, and 2 indicates exclusive cluster.
	ClusterType pulumi.IntInput
	// Set the memory specification of each CU, in GB. It supports 2, 4, 8, and 16 (which needs to apply for the whitelist before use). The default is 4, that is, 1 CU corresponds to 4 GB of running memory.
	CuMem pulumi.IntPtrInput
	// The Flink version that the job runs.
	FlinkVersion pulumi.StringPtrInput
	// The folder ID to which the job name belongs. The root directory is root.
	FolderId pulumi.StringPtrInput
	// The type of the job. 1 indicates SQL job, and 2 indicates JAR job.
	JobType pulumi.IntInput
	// The name of the job. It can be composed of Chinese, English, numbers, hyphens (-), underscores (_), and periods (.), and the length cannot exceed 50 characters. Note that the job name cannot be the same as an existing job.
	Name pulumi.StringPtrInput
	// The remark information of the job. It can be set arbitrarily.
	Remark pulumi.StringPtrInput
	// The workspace SerialId.
	WorkSpaceId pulumi.StringPtrInput
}

func (JobArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*jobArgs)(nil)).Elem()
}

type JobInput interface {
	pulumi.Input

	ToJobOutput() JobOutput
	ToJobOutputWithContext(ctx context.Context) JobOutput
}

func (*Job) ElementType() reflect.Type {
	return reflect.TypeOf((**Job)(nil)).Elem()
}

func (i *Job) ToJobOutput() JobOutput {
	return i.ToJobOutputWithContext(context.Background())
}

func (i *Job) ToJobOutputWithContext(ctx context.Context) JobOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutput)
}

// JobArrayInput is an input type that accepts JobArray and JobArrayOutput values.
// You can construct a concrete instance of `JobArrayInput` via:
//
//	JobArray{ JobArgs{...} }
type JobArrayInput interface {
	pulumi.Input

	ToJobArrayOutput() JobArrayOutput
	ToJobArrayOutputWithContext(context.Context) JobArrayOutput
}

type JobArray []JobInput

func (JobArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Job)(nil)).Elem()
}

func (i JobArray) ToJobArrayOutput() JobArrayOutput {
	return i.ToJobArrayOutputWithContext(context.Background())
}

func (i JobArray) ToJobArrayOutputWithContext(ctx context.Context) JobArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobArrayOutput)
}

// JobMapInput is an input type that accepts JobMap and JobMapOutput values.
// You can construct a concrete instance of `JobMapInput` via:
//
//	JobMap{ "key": JobArgs{...} }
type JobMapInput interface {
	pulumi.Input

	ToJobMapOutput() JobMapOutput
	ToJobMapOutputWithContext(context.Context) JobMapOutput
}

type JobMap map[string]JobInput

func (JobMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Job)(nil)).Elem()
}

func (i JobMap) ToJobMapOutput() JobMapOutput {
	return i.ToJobMapOutputWithContext(context.Background())
}

func (i JobMap) ToJobMapOutputWithContext(ctx context.Context) JobMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobMapOutput)
}

type JobOutput struct{ *pulumi.OutputState }

func (JobOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Job)(nil)).Elem()
}

func (o JobOutput) ToJobOutput() JobOutput {
	return o
}

func (o JobOutput) ToJobOutputWithContext(ctx context.Context) JobOutput {
	return o
}

// When ClusterType=2, it is required to specify the ID of the exclusive cluster to which the job is submitted.
func (o JobOutput) ClusterId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.ClusterId }).(pulumi.StringPtrOutput)
}

// The type of the cluster. 1 indicates shared cluster, and 2 indicates exclusive cluster.
func (o JobOutput) ClusterType() pulumi.IntOutput {
	return o.ApplyT(func(v *Job) pulumi.IntOutput { return v.ClusterType }).(pulumi.IntOutput)
}

// Set the memory specification of each CU, in GB. It supports 2, 4, 8, and 16 (which needs to apply for the whitelist before use). The default is 4, that is, 1 CU corresponds to 4 GB of running memory.
func (o JobOutput) CuMem() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.IntPtrOutput { return v.CuMem }).(pulumi.IntPtrOutput)
}

// The Flink version that the job runs.
func (o JobOutput) FlinkVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.FlinkVersion }).(pulumi.StringPtrOutput)
}

// The folder ID to which the job name belongs. The root directory is root.
func (o JobOutput) FolderId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.FolderId }).(pulumi.StringPtrOutput)
}

// The type of the job. 1 indicates SQL job, and 2 indicates JAR job.
func (o JobOutput) JobType() pulumi.IntOutput {
	return o.ApplyT(func(v *Job) pulumi.IntOutput { return v.JobType }).(pulumi.IntOutput)
}

// The name of the job. It can be composed of Chinese, English, numbers, hyphens (-), underscores (_), and periods (.), and the length cannot exceed 50 characters. Note that the job name cannot be the same as an existing job.
func (o JobOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Job) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The remark information of the job. It can be set arbitrarily.
func (o JobOutput) Remark() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.Remark }).(pulumi.StringPtrOutput)
}

// The workspace SerialId.
func (o JobOutput) WorkSpaceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.WorkSpaceId }).(pulumi.StringPtrOutput)
}

type JobArrayOutput struct{ *pulumi.OutputState }

func (JobArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Job)(nil)).Elem()
}

func (o JobArrayOutput) ToJobArrayOutput() JobArrayOutput {
	return o
}

func (o JobArrayOutput) ToJobArrayOutputWithContext(ctx context.Context) JobArrayOutput {
	return o
}

func (o JobArrayOutput) Index(i pulumi.IntInput) JobOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Job {
		return vs[0].([]*Job)[vs[1].(int)]
	}).(JobOutput)
}

type JobMapOutput struct{ *pulumi.OutputState }

func (JobMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Job)(nil)).Elem()
}

func (o JobMapOutput) ToJobMapOutput() JobMapOutput {
	return o
}

func (o JobMapOutput) ToJobMapOutputWithContext(ctx context.Context) JobMapOutput {
	return o
}

func (o JobMapOutput) MapIndex(k pulumi.StringInput) JobOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Job {
		return vs[0].(map[string]*Job)[vs[1].(string)]
	}).(JobOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*JobInput)(nil)).Elem(), &Job{})
	pulumi.RegisterInputType(reflect.TypeOf((*JobArrayInput)(nil)).Elem(), JobArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*JobMapInput)(nil)).Elem(), JobMap{})
	pulumi.RegisterOutputType(JobOutput{})
	pulumi.RegisterOutputType(JobArrayOutput{})
	pulumi.RegisterOutputType(JobMapOutput{})
}
