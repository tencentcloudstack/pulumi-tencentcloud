// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package elasticsearch

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create a elasticsearch diagnose instance
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Elasticsearch"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := Elasticsearch.NewDiagnoseInstance(ctx, "diagnoseInstance", &Elasticsearch.DiagnoseInstanceArgs{
//				DiagnoseIndices: pulumi.String("*"),
//				DiagnoseJobs: pulumi.StringArray{
//					pulumi.String("cluster_health"),
//				},
//				InstanceId: pulumi.String("es-xxxxxx"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type DiagnoseInstance struct {
	pulumi.CustomResourceState

	// Indexes that need to be diagnosed. Wildcards are supported.
	DiagnoseIndices pulumi.StringPtrOutput `pulumi:"diagnoseIndices"`
	// Diagnostic items that need to be triggered.
	DiagnoseJobs pulumi.StringArrayOutput `pulumi:"diagnoseJobs"`
	// Instance id.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
}

// NewDiagnoseInstance registers a new resource with the given unique name, arguments, and options.
func NewDiagnoseInstance(ctx *pulumi.Context,
	name string, args *DiagnoseInstanceArgs, opts ...pulumi.ResourceOption) (*DiagnoseInstance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource DiagnoseInstance
	err := ctx.RegisterResource("tencentcloud:Elasticsearch/diagnoseInstance:DiagnoseInstance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDiagnoseInstance gets an existing DiagnoseInstance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDiagnoseInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DiagnoseInstanceState, opts ...pulumi.ResourceOption) (*DiagnoseInstance, error) {
	var resource DiagnoseInstance
	err := ctx.ReadResource("tencentcloud:Elasticsearch/diagnoseInstance:DiagnoseInstance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DiagnoseInstance resources.
type diagnoseInstanceState struct {
	// Indexes that need to be diagnosed. Wildcards are supported.
	DiagnoseIndices *string `pulumi:"diagnoseIndices"`
	// Diagnostic items that need to be triggered.
	DiagnoseJobs []string `pulumi:"diagnoseJobs"`
	// Instance id.
	InstanceId *string `pulumi:"instanceId"`
}

type DiagnoseInstanceState struct {
	// Indexes that need to be diagnosed. Wildcards are supported.
	DiagnoseIndices pulumi.StringPtrInput
	// Diagnostic items that need to be triggered.
	DiagnoseJobs pulumi.StringArrayInput
	// Instance id.
	InstanceId pulumi.StringPtrInput
}

func (DiagnoseInstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*diagnoseInstanceState)(nil)).Elem()
}

type diagnoseInstanceArgs struct {
	// Indexes that need to be diagnosed. Wildcards are supported.
	DiagnoseIndices *string `pulumi:"diagnoseIndices"`
	// Diagnostic items that need to be triggered.
	DiagnoseJobs []string `pulumi:"diagnoseJobs"`
	// Instance id.
	InstanceId string `pulumi:"instanceId"`
}

// The set of arguments for constructing a DiagnoseInstance resource.
type DiagnoseInstanceArgs struct {
	// Indexes that need to be diagnosed. Wildcards are supported.
	DiagnoseIndices pulumi.StringPtrInput
	// Diagnostic items that need to be triggered.
	DiagnoseJobs pulumi.StringArrayInput
	// Instance id.
	InstanceId pulumi.StringInput
}

func (DiagnoseInstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*diagnoseInstanceArgs)(nil)).Elem()
}

type DiagnoseInstanceInput interface {
	pulumi.Input

	ToDiagnoseInstanceOutput() DiagnoseInstanceOutput
	ToDiagnoseInstanceOutputWithContext(ctx context.Context) DiagnoseInstanceOutput
}

func (*DiagnoseInstance) ElementType() reflect.Type {
	return reflect.TypeOf((**DiagnoseInstance)(nil)).Elem()
}

func (i *DiagnoseInstance) ToDiagnoseInstanceOutput() DiagnoseInstanceOutput {
	return i.ToDiagnoseInstanceOutputWithContext(context.Background())
}

func (i *DiagnoseInstance) ToDiagnoseInstanceOutputWithContext(ctx context.Context) DiagnoseInstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiagnoseInstanceOutput)
}

// DiagnoseInstanceArrayInput is an input type that accepts DiagnoseInstanceArray and DiagnoseInstanceArrayOutput values.
// You can construct a concrete instance of `DiagnoseInstanceArrayInput` via:
//
//	DiagnoseInstanceArray{ DiagnoseInstanceArgs{...} }
type DiagnoseInstanceArrayInput interface {
	pulumi.Input

	ToDiagnoseInstanceArrayOutput() DiagnoseInstanceArrayOutput
	ToDiagnoseInstanceArrayOutputWithContext(context.Context) DiagnoseInstanceArrayOutput
}

type DiagnoseInstanceArray []DiagnoseInstanceInput

func (DiagnoseInstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DiagnoseInstance)(nil)).Elem()
}

func (i DiagnoseInstanceArray) ToDiagnoseInstanceArrayOutput() DiagnoseInstanceArrayOutput {
	return i.ToDiagnoseInstanceArrayOutputWithContext(context.Background())
}

func (i DiagnoseInstanceArray) ToDiagnoseInstanceArrayOutputWithContext(ctx context.Context) DiagnoseInstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiagnoseInstanceArrayOutput)
}

// DiagnoseInstanceMapInput is an input type that accepts DiagnoseInstanceMap and DiagnoseInstanceMapOutput values.
// You can construct a concrete instance of `DiagnoseInstanceMapInput` via:
//
//	DiagnoseInstanceMap{ "key": DiagnoseInstanceArgs{...} }
type DiagnoseInstanceMapInput interface {
	pulumi.Input

	ToDiagnoseInstanceMapOutput() DiagnoseInstanceMapOutput
	ToDiagnoseInstanceMapOutputWithContext(context.Context) DiagnoseInstanceMapOutput
}

type DiagnoseInstanceMap map[string]DiagnoseInstanceInput

func (DiagnoseInstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DiagnoseInstance)(nil)).Elem()
}

func (i DiagnoseInstanceMap) ToDiagnoseInstanceMapOutput() DiagnoseInstanceMapOutput {
	return i.ToDiagnoseInstanceMapOutputWithContext(context.Background())
}

func (i DiagnoseInstanceMap) ToDiagnoseInstanceMapOutputWithContext(ctx context.Context) DiagnoseInstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiagnoseInstanceMapOutput)
}

type DiagnoseInstanceOutput struct{ *pulumi.OutputState }

func (DiagnoseInstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DiagnoseInstance)(nil)).Elem()
}

func (o DiagnoseInstanceOutput) ToDiagnoseInstanceOutput() DiagnoseInstanceOutput {
	return o
}

func (o DiagnoseInstanceOutput) ToDiagnoseInstanceOutputWithContext(ctx context.Context) DiagnoseInstanceOutput {
	return o
}

// Indexes that need to be diagnosed. Wildcards are supported.
func (o DiagnoseInstanceOutput) DiagnoseIndices() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DiagnoseInstance) pulumi.StringPtrOutput { return v.DiagnoseIndices }).(pulumi.StringPtrOutput)
}

// Diagnostic items that need to be triggered.
func (o DiagnoseInstanceOutput) DiagnoseJobs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DiagnoseInstance) pulumi.StringArrayOutput { return v.DiagnoseJobs }).(pulumi.StringArrayOutput)
}

// Instance id.
func (o DiagnoseInstanceOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *DiagnoseInstance) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

type DiagnoseInstanceArrayOutput struct{ *pulumi.OutputState }

func (DiagnoseInstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DiagnoseInstance)(nil)).Elem()
}

func (o DiagnoseInstanceArrayOutput) ToDiagnoseInstanceArrayOutput() DiagnoseInstanceArrayOutput {
	return o
}

func (o DiagnoseInstanceArrayOutput) ToDiagnoseInstanceArrayOutputWithContext(ctx context.Context) DiagnoseInstanceArrayOutput {
	return o
}

func (o DiagnoseInstanceArrayOutput) Index(i pulumi.IntInput) DiagnoseInstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DiagnoseInstance {
		return vs[0].([]*DiagnoseInstance)[vs[1].(int)]
	}).(DiagnoseInstanceOutput)
}

type DiagnoseInstanceMapOutput struct{ *pulumi.OutputState }

func (DiagnoseInstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DiagnoseInstance)(nil)).Elem()
}

func (o DiagnoseInstanceMapOutput) ToDiagnoseInstanceMapOutput() DiagnoseInstanceMapOutput {
	return o
}

func (o DiagnoseInstanceMapOutput) ToDiagnoseInstanceMapOutputWithContext(ctx context.Context) DiagnoseInstanceMapOutput {
	return o
}

func (o DiagnoseInstanceMapOutput) MapIndex(k pulumi.StringInput) DiagnoseInstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DiagnoseInstance {
		return vs[0].(map[string]*DiagnoseInstance)[vs[1].(string)]
	}).(DiagnoseInstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DiagnoseInstanceInput)(nil)).Elem(), &DiagnoseInstance{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiagnoseInstanceArrayInput)(nil)).Elem(), DiagnoseInstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiagnoseInstanceMapInput)(nil)).Elem(), DiagnoseInstanceMap{})
	pulumi.RegisterOutputType(DiagnoseInstanceOutput{})
	pulumi.RegisterOutputType(DiagnoseInstanceArrayOutput{})
	pulumi.RegisterOutputType(DiagnoseInstanceMapOutput{})
}
