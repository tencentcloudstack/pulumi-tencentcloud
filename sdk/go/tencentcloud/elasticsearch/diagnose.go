// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package elasticsearch

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create a elasticsearch diagnose
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Elasticsearch"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := Elasticsearch.NewDiagnose(ctx, "diagnose", &Elasticsearch.DiagnoseArgs{
// 			CronTime:   pulumi.String("15:00:00"),
// 			InstanceId: pulumi.String("es-xxxxxx"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// es diagnose can be imported using the id, e.g.
//
// ```sh
//  $ pulumi import tencentcloud:Elasticsearch/diagnose:Diagnose diagnose diagnose_id
// ```
type Diagnose struct {
	pulumi.CustomResourceState

	// Intelligent operation and maintenance staff regularly patrol the inspection time every day, the time format is HH:00:00, such as 15:00:00.
	CronTime pulumi.StringPtrOutput `pulumi:"cronTime"`
	// Diagnostic items and meta-information of intelligent operation and maintenance.
	DiagnoseJobMetas DiagnoseDiagnoseJobMetaArrayOutput `pulumi:"diagnoseJobMetas"`
	// Instance id.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// The maximum number of manual triggers per day for intelligent operation and maintenance staff.
	MaxCount pulumi.IntOutput `pulumi:"maxCount"`
}

// NewDiagnose registers a new resource with the given unique name, arguments, and options.
func NewDiagnose(ctx *pulumi.Context,
	name string, args *DiagnoseArgs, opts ...pulumi.ResourceOption) (*Diagnose, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource Diagnose
	err := ctx.RegisterResource("tencentcloud:Elasticsearch/diagnose:Diagnose", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDiagnose gets an existing Diagnose resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDiagnose(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DiagnoseState, opts ...pulumi.ResourceOption) (*Diagnose, error) {
	var resource Diagnose
	err := ctx.ReadResource("tencentcloud:Elasticsearch/diagnose:Diagnose", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Diagnose resources.
type diagnoseState struct {
	// Intelligent operation and maintenance staff regularly patrol the inspection time every day, the time format is HH:00:00, such as 15:00:00.
	CronTime *string `pulumi:"cronTime"`
	// Diagnostic items and meta-information of intelligent operation and maintenance.
	DiagnoseJobMetas []DiagnoseDiagnoseJobMeta `pulumi:"diagnoseJobMetas"`
	// Instance id.
	InstanceId *string `pulumi:"instanceId"`
	// The maximum number of manual triggers per day for intelligent operation and maintenance staff.
	MaxCount *int `pulumi:"maxCount"`
}

type DiagnoseState struct {
	// Intelligent operation and maintenance staff regularly patrol the inspection time every day, the time format is HH:00:00, such as 15:00:00.
	CronTime pulumi.StringPtrInput
	// Diagnostic items and meta-information of intelligent operation and maintenance.
	DiagnoseJobMetas DiagnoseDiagnoseJobMetaArrayInput
	// Instance id.
	InstanceId pulumi.StringPtrInput
	// The maximum number of manual triggers per day for intelligent operation and maintenance staff.
	MaxCount pulumi.IntPtrInput
}

func (DiagnoseState) ElementType() reflect.Type {
	return reflect.TypeOf((*diagnoseState)(nil)).Elem()
}

type diagnoseArgs struct {
	// Intelligent operation and maintenance staff regularly patrol the inspection time every day, the time format is HH:00:00, such as 15:00:00.
	CronTime *string `pulumi:"cronTime"`
	// Instance id.
	InstanceId string `pulumi:"instanceId"`
}

// The set of arguments for constructing a Diagnose resource.
type DiagnoseArgs struct {
	// Intelligent operation and maintenance staff regularly patrol the inspection time every day, the time format is HH:00:00, such as 15:00:00.
	CronTime pulumi.StringPtrInput
	// Instance id.
	InstanceId pulumi.StringInput
}

func (DiagnoseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*diagnoseArgs)(nil)).Elem()
}

type DiagnoseInput interface {
	pulumi.Input

	ToDiagnoseOutput() DiagnoseOutput
	ToDiagnoseOutputWithContext(ctx context.Context) DiagnoseOutput
}

func (*Diagnose) ElementType() reflect.Type {
	return reflect.TypeOf((**Diagnose)(nil)).Elem()
}

func (i *Diagnose) ToDiagnoseOutput() DiagnoseOutput {
	return i.ToDiagnoseOutputWithContext(context.Background())
}

func (i *Diagnose) ToDiagnoseOutputWithContext(ctx context.Context) DiagnoseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiagnoseOutput)
}

// DiagnoseArrayInput is an input type that accepts DiagnoseArray and DiagnoseArrayOutput values.
// You can construct a concrete instance of `DiagnoseArrayInput` via:
//
//          DiagnoseArray{ DiagnoseArgs{...} }
type DiagnoseArrayInput interface {
	pulumi.Input

	ToDiagnoseArrayOutput() DiagnoseArrayOutput
	ToDiagnoseArrayOutputWithContext(context.Context) DiagnoseArrayOutput
}

type DiagnoseArray []DiagnoseInput

func (DiagnoseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Diagnose)(nil)).Elem()
}

func (i DiagnoseArray) ToDiagnoseArrayOutput() DiagnoseArrayOutput {
	return i.ToDiagnoseArrayOutputWithContext(context.Background())
}

func (i DiagnoseArray) ToDiagnoseArrayOutputWithContext(ctx context.Context) DiagnoseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiagnoseArrayOutput)
}

// DiagnoseMapInput is an input type that accepts DiagnoseMap and DiagnoseMapOutput values.
// You can construct a concrete instance of `DiagnoseMapInput` via:
//
//          DiagnoseMap{ "key": DiagnoseArgs{...} }
type DiagnoseMapInput interface {
	pulumi.Input

	ToDiagnoseMapOutput() DiagnoseMapOutput
	ToDiagnoseMapOutputWithContext(context.Context) DiagnoseMapOutput
}

type DiagnoseMap map[string]DiagnoseInput

func (DiagnoseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Diagnose)(nil)).Elem()
}

func (i DiagnoseMap) ToDiagnoseMapOutput() DiagnoseMapOutput {
	return i.ToDiagnoseMapOutputWithContext(context.Background())
}

func (i DiagnoseMap) ToDiagnoseMapOutputWithContext(ctx context.Context) DiagnoseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiagnoseMapOutput)
}

type DiagnoseOutput struct{ *pulumi.OutputState }

func (DiagnoseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Diagnose)(nil)).Elem()
}

func (o DiagnoseOutput) ToDiagnoseOutput() DiagnoseOutput {
	return o
}

func (o DiagnoseOutput) ToDiagnoseOutputWithContext(ctx context.Context) DiagnoseOutput {
	return o
}

// Intelligent operation and maintenance staff regularly patrol the inspection time every day, the time format is HH:00:00, such as 15:00:00.
func (o DiagnoseOutput) CronTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Diagnose) pulumi.StringPtrOutput { return v.CronTime }).(pulumi.StringPtrOutput)
}

// Diagnostic items and meta-information of intelligent operation and maintenance.
func (o DiagnoseOutput) DiagnoseJobMetas() DiagnoseDiagnoseJobMetaArrayOutput {
	return o.ApplyT(func(v *Diagnose) DiagnoseDiagnoseJobMetaArrayOutput { return v.DiagnoseJobMetas }).(DiagnoseDiagnoseJobMetaArrayOutput)
}

// Instance id.
func (o DiagnoseOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *Diagnose) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// The maximum number of manual triggers per day for intelligent operation and maintenance staff.
func (o DiagnoseOutput) MaxCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Diagnose) pulumi.IntOutput { return v.MaxCount }).(pulumi.IntOutput)
}

type DiagnoseArrayOutput struct{ *pulumi.OutputState }

func (DiagnoseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Diagnose)(nil)).Elem()
}

func (o DiagnoseArrayOutput) ToDiagnoseArrayOutput() DiagnoseArrayOutput {
	return o
}

func (o DiagnoseArrayOutput) ToDiagnoseArrayOutputWithContext(ctx context.Context) DiagnoseArrayOutput {
	return o
}

func (o DiagnoseArrayOutput) Index(i pulumi.IntInput) DiagnoseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Diagnose {
		return vs[0].([]*Diagnose)[vs[1].(int)]
	}).(DiagnoseOutput)
}

type DiagnoseMapOutput struct{ *pulumi.OutputState }

func (DiagnoseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Diagnose)(nil)).Elem()
}

func (o DiagnoseMapOutput) ToDiagnoseMapOutput() DiagnoseMapOutput {
	return o
}

func (o DiagnoseMapOutput) ToDiagnoseMapOutputWithContext(ctx context.Context) DiagnoseMapOutput {
	return o
}

func (o DiagnoseMapOutput) MapIndex(k pulumi.StringInput) DiagnoseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Diagnose {
		return vs[0].(map[string]*Diagnose)[vs[1].(string)]
	}).(DiagnoseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DiagnoseInput)(nil)).Elem(), &Diagnose{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiagnoseArrayInput)(nil)).Elem(), DiagnoseArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiagnoseMapInput)(nil)).Elem(), DiagnoseMap{})
	pulumi.RegisterOutputType(DiagnoseOutput{})
	pulumi.RegisterOutputType(DiagnoseArrayOutput{})
	pulumi.RegisterOutputType(DiagnoseMapOutput{})
}
