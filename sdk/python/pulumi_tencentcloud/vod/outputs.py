# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AdaptiveDynamicStreamingTemplateStreamInfo',
    'AdaptiveDynamicStreamingTemplateStreamInfoAudio',
    'AdaptiveDynamicStreamingTemplateStreamInfoVideo',
    'AdaptiveDynamicStreamingTemplatesTemplateListResult',
    'AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult',
    'AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult',
    'AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult',
    'ImageSpriteTemplatesTemplateListResult',
    'ProcedureTemplateMediaProcessTask',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskImageSpriteTaskList',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskList',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList',
    'ProcedureTemplatesTemplateListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult',
    'ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult',
    'SnapshotByTimeOffsetTemplatesTemplateListResult',
    'SuperPlayerConfigDrmStreamingInfo',
    'SuperPlayerConfigResolutionName',
    'SuperPlayerConfigsConfigListResult',
    'SuperPlayerConfigsConfigListDrmStreamingInfoResult',
    'SuperPlayerConfigsConfigListResolutionNameResult',
]

@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeAudio":
            suggest = "remove_audio"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio: 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoAudio',
                 video: 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoVideo',
                 remove_audio: Optional[bool] = None):
        pulumi.set(__self__, "audio", audio)
        pulumi.set(__self__, "video", video)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)

    @property
    @pulumi.getter
    def audio(self) -> 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoAudio':
        return pulumi.get(self, "audio")

    @property
    @pulumi.getter
    def video(self) -> 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoVideo':
        return pulumi.get(self, "video")

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[bool]:
        return pulumi.get(self, "remove_audio")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfoAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"
        elif key == "audioChannel":
            suggest = "audio_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfoAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 sample_rate: int,
                 audio_channel: Optional[str] = None):
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[str]:
        return pulumi.get(self, "audio_channel")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfoVideo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillType":
            suggest = "fill_type"
        elif key == "resolutionAdaptive":
            suggest = "resolution_adaptive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfoVideo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoVideo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoVideo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fps: int,
                 fill_type: Optional[str] = None,
                 height: Optional[int] = None,
                 resolution_adaptive: Optional[bool] = None,
                 width: Optional[int] = None):
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def fps(self) -> int:
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[str]:
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[bool]:
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        return pulumi.get(self, "width")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 create_time: str,
                 definition: str,
                 disable_higher_video_bitrate: bool,
                 disable_higher_video_resolution: bool,
                 drm_type: str,
                 format: str,
                 name: str,
                 stream_infos: Sequence['outputs.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult'],
                 type: str,
                 update_time: str):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "disable_higher_video_bitrate", disable_higher_video_bitrate)
        pulumi.set(__self__, "disable_higher_video_resolution", disable_higher_video_resolution)
        pulumi.set(__self__, "drm_type", drm_type)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stream_infos", stream_infos)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def comment(self) -> str:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="disableHigherVideoBitrate")
    def disable_higher_video_bitrate(self) -> bool:
        return pulumi.get(self, "disable_higher_video_bitrate")

    @property
    @pulumi.getter(name="disableHigherVideoResolution")
    def disable_higher_video_resolution(self) -> bool:
        return pulumi.get(self, "disable_higher_video_resolution")

    @property
    @pulumi.getter(name="drmType")
    def drm_type(self) -> str:
        return pulumi.get(self, "drm_type")

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="streamInfos")
    def stream_infos(self) -> Sequence['outputs.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult']:
        return pulumi.get(self, "stream_infos")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult(dict):
    def __init__(__self__, *,
                 audios: Sequence['outputs.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult'],
                 remove_audio: bool,
                 videos: Sequence['outputs.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult']):
        pulumi.set(__self__, "audios", audios)
        pulumi.set(__self__, "remove_audio", remove_audio)
        pulumi.set(__self__, "videos", videos)

    @property
    @pulumi.getter
    def audios(self) -> Sequence['outputs.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult']:
        return pulumi.get(self, "audios")

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> bool:
        return pulumi.get(self, "remove_audio")

    @property
    @pulumi.getter
    def videos(self) -> Sequence['outputs.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult']:
        return pulumi.get(self, "videos")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult(dict):
    def __init__(__self__, *,
                 audio_channel: str,
                 bitrate: int,
                 codec: str,
                 sample_rate: int):
        pulumi.set(__self__, "audio_channel", audio_channel)
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> str:
        return pulumi.get(self, "audio_channel")

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult(dict):
    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fill_type: str,
                 fps: int,
                 height: int,
                 resolution_adaptive: bool,
                 width: int):
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fill_type", fill_type)
        pulumi.set(__self__, "fps", fps)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> str:
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def fps(self) -> int:
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> bool:
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")


@pulumi.output_type
class ImageSpriteTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 column_count: int,
                 comment: str,
                 create_time: str,
                 definition: str,
                 fill_type: str,
                 height: int,
                 name: str,
                 resolution_adaptive: bool,
                 row_count: int,
                 sample_interval: int,
                 sample_type: str,
                 type: str,
                 update_time: str,
                 width: int):
        pulumi.set(__self__, "column_count", column_count)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "fill_type", fill_type)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        pulumi.set(__self__, "row_count", row_count)
        pulumi.set(__self__, "sample_interval", sample_interval)
        pulumi.set(__self__, "sample_type", sample_type)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="columnCount")
    def column_count(self) -> int:
        return pulumi.get(self, "column_count")

    @property
    @pulumi.getter
    def comment(self) -> str:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> str:
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> bool:
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter(name="rowCount")
    def row_count(self) -> int:
        return pulumi.get(self, "row_count")

    @property
    @pulumi.getter(name="sampleInterval")
    def sample_interval(self) -> int:
        return pulumi.get(self, "sample_interval")

    @property
    @pulumi.getter(name="sampleType")
    def sample_type(self) -> str:
        return pulumi.get(self, "sample_type")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        return pulumi.get(self, "update_time")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")


@pulumi.output_type
class ProcedureTemplateMediaProcessTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveDynamicStreamingTaskLists":
            suggest = "adaptive_dynamic_streaming_task_lists"
        elif key == "animatedGraphicTaskLists":
            suggest = "animated_graphic_task_lists"
        elif key == "coverBySnapshotTaskLists":
            suggest = "cover_by_snapshot_task_lists"
        elif key == "imageSpriteTaskLists":
            suggest = "image_sprite_task_lists"
        elif key == "sampleSnapshotTaskLists":
            suggest = "sample_snapshot_task_lists"
        elif key == "snapshotByTimeOffsetTaskLists":
            suggest = "snapshot_by_time_offset_task_lists"
        elif key == "transcodeTaskLists":
            suggest = "transcode_task_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList']] = None,
                 animated_graphic_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList']] = None,
                 cover_by_snapshot_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList']] = None,
                 image_sprite_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskImageSpriteTaskList']] = None,
                 sample_snapshot_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList']] = None,
                 snapshot_by_time_offset_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList']] = None,
                 transcode_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskList']] = None):
        if adaptive_dynamic_streaming_task_lists is not None:
            pulumi.set(__self__, "adaptive_dynamic_streaming_task_lists", adaptive_dynamic_streaming_task_lists)
        if animated_graphic_task_lists is not None:
            pulumi.set(__self__, "animated_graphic_task_lists", animated_graphic_task_lists)
        if cover_by_snapshot_task_lists is not None:
            pulumi.set(__self__, "cover_by_snapshot_task_lists", cover_by_snapshot_task_lists)
        if image_sprite_task_lists is not None:
            pulumi.set(__self__, "image_sprite_task_lists", image_sprite_task_lists)
        if sample_snapshot_task_lists is not None:
            pulumi.set(__self__, "sample_snapshot_task_lists", sample_snapshot_task_lists)
        if snapshot_by_time_offset_task_lists is not None:
            pulumi.set(__self__, "snapshot_by_time_offset_task_lists", snapshot_by_time_offset_task_lists)
        if transcode_task_lists is not None:
            pulumi.set(__self__, "transcode_task_lists", transcode_task_lists)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskLists")
    def adaptive_dynamic_streaming_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList']]:
        return pulumi.get(self, "adaptive_dynamic_streaming_task_lists")

    @property
    @pulumi.getter(name="animatedGraphicTaskLists")
    def animated_graphic_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList']]:
        return pulumi.get(self, "animated_graphic_task_lists")

    @property
    @pulumi.getter(name="coverBySnapshotTaskLists")
    def cover_by_snapshot_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList']]:
        return pulumi.get(self, "cover_by_snapshot_task_lists")

    @property
    @pulumi.getter(name="imageSpriteTaskLists")
    def image_sprite_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskImageSpriteTaskList']]:
        return pulumi.get(self, "image_sprite_task_lists")

    @property
    @pulumi.getter(name="sampleSnapshotTaskLists")
    def sample_snapshot_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList']]:
        return pulumi.get(self, "sample_snapshot_task_lists")

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskLists")
    def snapshot_by_time_offset_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList']]:
        return pulumi.get(self, "snapshot_by_time_offset_task_lists")

    @property
    @pulumi.getter(name="transcodeTaskLists")
    def transcode_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskList']]:
        return pulumi.get(self, "transcode_task_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList']] = None):
        pulumi.set(__self__, "definition", definition)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList']]:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: float,
                 start_time_offset: float):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> float:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> float:
        return pulumi.get(self, "start_time_offset")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionType":
            suggest = "position_type"
        elif key == "positionValue":
            suggest = "position_value"
        elif key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 position_type: str,
                 position_value: float,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList']] = None):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "position_type", position_type)
        pulumi.set(__self__, "position_value", position_value)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="positionType")
    def position_type(self) -> str:
        return pulumi.get(self, "position_type")

    @property
    @pulumi.getter(name="positionValue")
    def position_value(self) -> float:
        return pulumi.get(self, "position_value")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList']]:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskImageSpriteTaskList(dict):
    def __init__(__self__, *,
                 definition: str):
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList']] = None):
        pulumi.set(__self__, "definition", definition)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList']]:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extTimeOffsetLists":
            suggest = "ext_time_offset_lists"
        elif key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 ext_time_offset_lists: Optional[Sequence[str]] = None,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList']] = None):
        pulumi.set(__self__, "definition", definition)
        if ext_time_offset_lists is not None:
            pulumi.set(__self__, "ext_time_offset_lists", ext_time_offset_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="extTimeOffsetLists")
    def ext_time_offset_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ext_time_offset_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList']]:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mosaicLists":
            suggest = "mosaic_lists"
        elif key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskTranscodeTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 mosaic_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList']] = None,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList']] = None):
        pulumi.set(__self__, "definition", definition)
        if mosaic_lists is not None:
            pulumi.set(__self__, "mosaic_lists", mosaic_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="mosaicLists")
    def mosaic_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList']]:
        return pulumi.get(self, "mosaic_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList']]:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coordinateOrigin":
            suggest = "coordinate_origin"
        elif key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "xPos":
            suggest = "x_pos"
        elif key == "yPos":
            suggest = "y_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coordinate_origin: Optional[str] = None,
                 end_time_offset: Optional[float] = None,
                 height: Optional[str] = None,
                 start_time_offset: Optional[float] = None,
                 width: Optional[str] = None,
                 x_pos: Optional[str] = None,
                 y_pos: Optional[str] = None):
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[str]:
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[str]:
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[str]:
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 create_time: str,
                 media_process_tasks: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskResult'],
                 name: str,
                 type: str,
                 update_time: str):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "media_process_tasks", media_process_tasks)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def comment(self) -> str:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="mediaProcessTasks")
    def media_process_tasks(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskResult']:
        return pulumi.get(self, "media_process_tasks")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        return pulumi.get(self, "update_time")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskResult(dict):
    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult'],
                 animated_graphic_task_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult'],
                 cover_by_snapshot_task_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult'],
                 image_sprite_task_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult'],
                 sample_snapshot_task_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult'],
                 snapshot_by_time_offset_task_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult'],
                 transcode_task_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult']):
        pulumi.set(__self__, "adaptive_dynamic_streaming_task_lists", adaptive_dynamic_streaming_task_lists)
        pulumi.set(__self__, "animated_graphic_task_lists", animated_graphic_task_lists)
        pulumi.set(__self__, "cover_by_snapshot_task_lists", cover_by_snapshot_task_lists)
        pulumi.set(__self__, "image_sprite_task_lists", image_sprite_task_lists)
        pulumi.set(__self__, "sample_snapshot_task_lists", sample_snapshot_task_lists)
        pulumi.set(__self__, "snapshot_by_time_offset_task_lists", snapshot_by_time_offset_task_lists)
        pulumi.set(__self__, "transcode_task_lists", transcode_task_lists)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskLists")
    def adaptive_dynamic_streaming_task_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult']:
        return pulumi.get(self, "adaptive_dynamic_streaming_task_lists")

    @property
    @pulumi.getter(name="animatedGraphicTaskLists")
    def animated_graphic_task_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult']:
        return pulumi.get(self, "animated_graphic_task_lists")

    @property
    @pulumi.getter(name="coverBySnapshotTaskLists")
    def cover_by_snapshot_task_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult']:
        return pulumi.get(self, "cover_by_snapshot_task_lists")

    @property
    @pulumi.getter(name="imageSpriteTaskLists")
    def image_sprite_task_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult']:
        return pulumi.get(self, "image_sprite_task_lists")

    @property
    @pulumi.getter(name="sampleSnapshotTaskLists")
    def sample_snapshot_task_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult']:
        return pulumi.get(self, "sample_snapshot_task_lists")

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskLists")
    def snapshot_by_time_offset_task_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult']:
        return pulumi.get(self, "snapshot_by_time_offset_task_lists")

    @property
    @pulumi.getter(name="transcodeTaskLists")
    def transcode_task_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult']:
        return pulumi.get(self, "transcode_task_lists")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 watermark_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult']):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult']:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: float,
                 start_time_offset: float):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> float:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> float:
        return pulumi.get(self, "start_time_offset")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 position_type: str,
                 position_value: float,
                 watermark_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult']):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "position_type", position_type)
        pulumi.set(__self__, "position_value", position_value)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="positionType")
    def position_type(self) -> str:
        return pulumi.get(self, "position_type")

    @property
    @pulumi.getter(name="positionValue")
    def position_value(self) -> float:
        return pulumi.get(self, "position_value")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult']:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str):
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 watermark_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult']):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult']:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 ext_time_offset_lists: Sequence[str],
                 watermark_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult']):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "ext_time_offset_lists", ext_time_offset_lists)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="extTimeOffsetLists")
    def ext_time_offset_lists(self) -> Sequence[str]:
        return pulumi.get(self, "ext_time_offset_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult']:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 mosaic_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult'],
                 watermark_lists: Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult']):
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "mosaic_lists", mosaic_lists)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="mosaicLists")
    def mosaic_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult']:
        return pulumi.get(self, "mosaic_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult']:
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult(dict):
    def __init__(__self__, *,
                 coordinate_origin: str,
                 end_time_offset: float,
                 height: str,
                 start_time_offset: float,
                 width: str,
                 x_pos: str,
                 y_pos: str):
        pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x_pos", x_pos)
        pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> str:
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> float:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter
    def height(self) -> str:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> float:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter
    def width(self) -> str:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> str:
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> str:
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")


@pulumi.output_type
class SnapshotByTimeOffsetTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 create_time: str,
                 definition: str,
                 fill_type: str,
                 format: str,
                 height: int,
                 name: str,
                 resolution_adaptive: bool,
                 type: str,
                 update_time: str,
                 width: int):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "fill_type", fill_type)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def comment(self) -> str:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def definition(self) -> str:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> str:
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> bool:
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        return pulumi.get(self, "update_time")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")


@pulumi.output_type
class SuperPlayerConfigDrmStreamingInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleAesDefinition":
            suggest = "simple_aes_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuperPlayerConfigDrmStreamingInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuperPlayerConfigDrmStreamingInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuperPlayerConfigDrmStreamingInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_aes_definition: Optional[str] = None):
        if simple_aes_definition is not None:
            pulumi.set(__self__, "simple_aes_definition", simple_aes_definition)

    @property
    @pulumi.getter(name="simpleAesDefinition")
    def simple_aes_definition(self) -> Optional[str]:
        return pulumi.get(self, "simple_aes_definition")


@pulumi.output_type
class SuperPlayerConfigResolutionName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minEdgeLength":
            suggest = "min_edge_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuperPlayerConfigResolutionName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuperPlayerConfigResolutionName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuperPlayerConfigResolutionName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_edge_length: int,
                 name: str):
        pulumi.set(__self__, "min_edge_length", min_edge_length)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="minEdgeLength")
    def min_edge_length(self) -> int:
        return pulumi.get(self, "min_edge_length")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class SuperPlayerConfigsConfigListResult(dict):
    def __init__(__self__, *,
                 adaptive_dynamic_streaming_definition: str,
                 comment: str,
                 create_time: str,
                 domain: str,
                 drm_streaming_infos: Sequence['outputs.SuperPlayerConfigsConfigListDrmStreamingInfoResult'],
                 drm_switch: bool,
                 image_sprite_definition: str,
                 name: str,
                 resolution_names: Sequence['outputs.SuperPlayerConfigsConfigListResolutionNameResult'],
                 scheme: str,
                 type: str,
                 update_time: str):
        pulumi.set(__self__, "adaptive_dynamic_streaming_definition", adaptive_dynamic_streaming_definition)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "drm_streaming_infos", drm_streaming_infos)
        pulumi.set(__self__, "drm_switch", drm_switch)
        pulumi.set(__self__, "image_sprite_definition", image_sprite_definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolution_names", resolution_names)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingDefinition")
    def adaptive_dynamic_streaming_definition(self) -> str:
        return pulumi.get(self, "adaptive_dynamic_streaming_definition")

    @property
    @pulumi.getter
    def comment(self) -> str:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="drmStreamingInfos")
    def drm_streaming_infos(self) -> Sequence['outputs.SuperPlayerConfigsConfigListDrmStreamingInfoResult']:
        return pulumi.get(self, "drm_streaming_infos")

    @property
    @pulumi.getter(name="drmSwitch")
    def drm_switch(self) -> bool:
        return pulumi.get(self, "drm_switch")

    @property
    @pulumi.getter(name="imageSpriteDefinition")
    def image_sprite_definition(self) -> str:
        return pulumi.get(self, "image_sprite_definition")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolutionNames")
    def resolution_names(self) -> Sequence['outputs.SuperPlayerConfigsConfigListResolutionNameResult']:
        return pulumi.get(self, "resolution_names")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        return pulumi.get(self, "update_time")


@pulumi.output_type
class SuperPlayerConfigsConfigListDrmStreamingInfoResult(dict):
    def __init__(__self__, *,
                 simple_aes_definition: str):
        pulumi.set(__self__, "simple_aes_definition", simple_aes_definition)

    @property
    @pulumi.getter(name="simpleAesDefinition")
    def simple_aes_definition(self) -> str:
        return pulumi.get(self, "simple_aes_definition")


@pulumi.output_type
class SuperPlayerConfigsConfigListResolutionNameResult(dict):
    def __init__(__self__, *,
                 min_edge_length: int,
                 name: str):
        pulumi.set(__self__, "min_edge_length", min_edge_length)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="minEdgeLength")
    def min_edge_length(self) -> int:
        return pulumi.get(self, "min_edge_length")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


