# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ActionTimerActionTimer',
    'ChcConfigBmcVirtualPrivateCloud',
    'ChcConfigDeployVirtualPrivateCloud',
    'ImportImageTagSpecification',
    'ImportImageTagSpecificationTag',
    'LaunchTemplateActionTimer',
    'LaunchTemplateActionTimerExternals',
    'LaunchTemplateActionTimerExternalsStorageBlockAttr',
    'LaunchTemplateDataDisk',
    'LaunchTemplateEnhancedService',
    'LaunchTemplateEnhancedServiceAutomationService',
    'LaunchTemplateEnhancedServiceMonitorService',
    'LaunchTemplateEnhancedServiceSecurityService',
    'LaunchTemplateInstanceChargePrepaid',
    'LaunchTemplateInstanceMarketOptions',
    'LaunchTemplateInstanceMarketOptionsSpotOptions',
    'LaunchTemplateInternetAccessible',
    'LaunchTemplateLoginSettings',
    'LaunchTemplatePlacement',
    'LaunchTemplateSystemDisk',
    'LaunchTemplateTagSpecification',
    'LaunchTemplateTagSpecificationTag',
    'LaunchTemplateVersionActionTimer',
    'LaunchTemplateVersionActionTimerExternals',
    'LaunchTemplateVersionActionTimerExternalsStorageBlockAttr',
    'LaunchTemplateVersionDataDisk',
    'LaunchTemplateVersionEnhancedService',
    'LaunchTemplateVersionEnhancedServiceAutomationService',
    'LaunchTemplateVersionEnhancedServiceMonitorService',
    'LaunchTemplateVersionEnhancedServiceSecurityService',
    'LaunchTemplateVersionInstanceChargePrepaid',
    'LaunchTemplateVersionInstanceMarketOptions',
    'LaunchTemplateVersionInstanceMarketOptionsSpotOptions',
    'LaunchTemplateVersionInternetAccessible',
    'LaunchTemplateVersionLoginSettings',
    'LaunchTemplateVersionPlacement',
    'LaunchTemplateVersionSystemDisk',
    'LaunchTemplateVersionTagSpecification',
    'LaunchTemplateVersionTagSpecificationTag',
    'LaunchTemplateVersionVirtualPrivateCloud',
    'LaunchTemplateVirtualPrivateCloud',
    'ModifyInstanceDiskTypeDataDisk',
    'ModifyInstanceDiskTypeSystemDisk',
    'RenewHostHostChargePrepaid',
    'RenewInstanceInstanceChargePrepaid',
    'GetChcDeniedActionsChcHostDeniedActionSetResult',
    'GetChcHostsChcHostSetResult',
    'GetChcHostsChcHostSetBmcVirtualPrivateCloudResult',
    'GetChcHostsChcHostSetDeployVirtualPrivateCloudResult',
    'GetChcHostsChcHostSetPlacementResult',
    'GetChcHostsFilterResult',
    'GetImageSharePermissionSharePermissionSetResult',
    'GetImportImageOsImportImageOsListSupportedResult',
    'GetImportImageOsImportImageOsVersionSetResult',
    'GetInstancesModificationFilterResult',
    'GetInstancesModificationInstanceTypeConfigStatusListResult',
    'GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfigResult',
]

@pulumi.output_type
class ActionTimerActionTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionTime":
            suggest = "action_time"
        elif key == "timerAction":
            suggest = "timer_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionTimerActionTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionTimerActionTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionTimerActionTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_time: Optional[_builtins.str] = None,
                 timer_action: Optional[_builtins.str] = None):
        """
        :param _builtins.str action_time: Execution time, expressed according to ISO8601 standard and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution time must be 5 minutes longer than the current time.
        :param _builtins.str timer_action: Timer action, currently only supports destroying one value: TerminateInstances.
        """
        if action_time is not None:
            pulumi.set(__self__, "action_time", action_time)
        if timer_action is not None:
            pulumi.set(__self__, "timer_action", timer_action)

    @_builtins.property
    @pulumi.getter(name="actionTime")
    def action_time(self) -> Optional[_builtins.str]:
        """
        Execution time, expressed according to ISO8601 standard and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution time must be 5 minutes longer than the current time.
        """
        return pulumi.get(self, "action_time")

    @_builtins.property
    @pulumi.getter(name="timerAction")
    def timer_action(self) -> Optional[_builtins.str]:
        """
        Timer action, currently only supports destroying one value: TerminateInstances.
        """
        return pulumi.get(self, "timer_action")


@pulumi.output_type
class ChcConfigBmcVirtualPrivateCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "asVpcGateway":
            suggest = "as_vpc_gateway"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChcConfigBmcVirtualPrivateCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChcConfigBmcVirtualPrivateCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChcConfigBmcVirtualPrivateCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str,
                 as_vpc_gateway: Optional[_builtins.bool] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 private_ip_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str subnet_id: VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        :param _builtins.str vpc_id: VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param _builtins.bool as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        :param _builtins.int ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param Sequence[_builtins.str] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[_builtins.bool]:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")


@pulumi.output_type
class ChcConfigDeployVirtualPrivateCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "asVpcGateway":
            suggest = "as_vpc_gateway"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChcConfigDeployVirtualPrivateCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChcConfigDeployVirtualPrivateCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChcConfigDeployVirtualPrivateCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str,
                 as_vpc_gateway: Optional[_builtins.bool] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 private_ip_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str subnet_id: VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        :param _builtins.str vpc_id: VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param _builtins.bool as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        :param _builtins.int ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param Sequence[_builtins.str] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[_builtins.bool]:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")


@pulumi.output_type
class ImportImageTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImportImageTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImportImageTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImportImageTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: _builtins.str,
                 tags: Sequence['outputs.ImportImageTagSpecificationTag']):
        """
        :param _builtins.str resource_type: Resource type. Valid values: instance (CVM), host (CDH), image (for image), and keypair (for key). Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['ImportImageTagSpecificationTagArgs'] tags: Tag pairs Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type. Valid values: instance (CVM), host (CDH), image (for image), and keypair (for key). Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.ImportImageTagSpecificationTag']:
        """
        Tag pairs Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ImportImageTagSpecificationTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Tag key.
        :param _builtins.str value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LaunchTemplateActionTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionTime":
            suggest = "action_time"
        elif key == "timerAction":
            suggest = "timer_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateActionTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateActionTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateActionTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_time: Optional[_builtins.str] = None,
                 externals: Optional['outputs.LaunchTemplateActionTimerExternals'] = None,
                 timer_action: Optional[_builtins.str] = None):
        """
        :param _builtins.str action_time: Execution time.
        :param 'LaunchTemplateActionTimerExternalsArgs' externals: Extended data.
        :param _builtins.str timer_action: Timer name.
        """
        if action_time is not None:
            pulumi.set(__self__, "action_time", action_time)
        if externals is not None:
            pulumi.set(__self__, "externals", externals)
        if timer_action is not None:
            pulumi.set(__self__, "timer_action", timer_action)

    @_builtins.property
    @pulumi.getter(name="actionTime")
    def action_time(self) -> Optional[_builtins.str]:
        """
        Execution time.
        """
        return pulumi.get(self, "action_time")

    @_builtins.property
    @pulumi.getter
    def externals(self) -> Optional['outputs.LaunchTemplateActionTimerExternals']:
        """
        Extended data.
        """
        return pulumi.get(self, "externals")

    @_builtins.property
    @pulumi.getter(name="timerAction")
    def timer_action(self) -> Optional[_builtins.str]:
        """
        Timer name.
        """
        return pulumi.get(self, "timer_action")


@pulumi.output_type
class LaunchTemplateActionTimerExternals(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseAddress":
            suggest = "release_address"
        elif key == "storageBlockAttr":
            suggest = "storage_block_attr"
        elif key == "unsupportNetworks":
            suggest = "unsupport_networks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateActionTimerExternals. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateActionTimerExternals.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateActionTimerExternals.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 release_address: Optional[_builtins.bool] = None,
                 storage_block_attr: Optional['outputs.LaunchTemplateActionTimerExternalsStorageBlockAttr'] = None,
                 unsupport_networks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool release_address: Release address.
        :param 'LaunchTemplateActionTimerExternalsStorageBlockAttrArgs' storage_block_attr: HDD local storage attributes.
        :param Sequence[_builtins.str] unsupport_networks: Unsupported network type.
        """
        if release_address is not None:
            pulumi.set(__self__, "release_address", release_address)
        if storage_block_attr is not None:
            pulumi.set(__self__, "storage_block_attr", storage_block_attr)
        if unsupport_networks is not None:
            pulumi.set(__self__, "unsupport_networks", unsupport_networks)

    @_builtins.property
    @pulumi.getter(name="releaseAddress")
    def release_address(self) -> Optional[_builtins.bool]:
        """
        Release address.
        """
        return pulumi.get(self, "release_address")

    @_builtins.property
    @pulumi.getter(name="storageBlockAttr")
    def storage_block_attr(self) -> Optional['outputs.LaunchTemplateActionTimerExternalsStorageBlockAttr']:
        """
        HDD local storage attributes.
        """
        return pulumi.get(self, "storage_block_attr")

    @_builtins.property
    @pulumi.getter(name="unsupportNetworks")
    def unsupport_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Unsupported network type.
        """
        return pulumi.get(self, "unsupport_networks")


@pulumi.output_type
class LaunchTemplateActionTimerExternalsStorageBlockAttr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateActionTimerExternalsStorageBlockAttr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateActionTimerExternalsStorageBlockAttr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateActionTimerExternalsStorageBlockAttr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: _builtins.int,
                 min_size: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int max_size: The maximum capacity of HDD local storage.
        :param _builtins.int min_size: The minimum capacity of HDD local storage.
        :param _builtins.str type: The type of HDD local storage.
        """
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.int:
        """
        The maximum capacity of HDD local storage.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> _builtins.int:
        """
        The minimum capacity of HDD local storage.
        """
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of HDD local storage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "cdcId":
            suggest = "cdc_id"
        elif key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputPerformance":
            suggest = "throughput_performance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 cdc_id: Optional[_builtins.str] = None,
                 delete_with_instance: Optional[_builtins.bool] = None,
                 disk_id: Optional[_builtins.str] = None,
                 disk_type: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.bool] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput_performance: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size: The size of the data disk.
        :param _builtins.str cdc_id: Cloud Dedicated Cluster(CDC) ID.
        :param _builtins.bool delete_with_instance: Whether the data disk is destroyed along with the instance, true or false.
        :param _builtins.str disk_id: Data disk ID.
        :param _builtins.str disk_type: The type of data disk.
        :param _builtins.bool encrypt: Whether the data disk is encrypted, TRUE or FALSE.
        :param _builtins.str kms_key_id: The id of custom CMK.
        :param _builtins.str snapshot_id: Data disk snapshot ID.
        :param _builtins.int throughput_performance: Cloud disk performance, MB/s.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        The size of the data disk.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        Cloud Dedicated Cluster(CDC) ID.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[_builtins.bool]:
        """
        Whether the data disk is destroyed along with the instance, true or false.
        """
        return pulumi.get(self, "delete_with_instance")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        Data disk ID.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The type of data disk.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.bool]:
        """
        Whether the data disk is encrypted, TRUE or FALSE.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The id of custom CMK.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Data disk snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[_builtins.int]:
        """
        Cloud disk performance, MB/s.
        """
        return pulumi.get(self, "throughput_performance")


@pulumi.output_type
class LaunchTemplateEnhancedService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationService":
            suggest = "automation_service"
        elif key == "monitorService":
            suggest = "monitor_service"
        elif key == "securityService":
            suggest = "security_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEnhancedService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEnhancedService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEnhancedService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automation_service: Optional['outputs.LaunchTemplateEnhancedServiceAutomationService'] = None,
                 monitor_service: Optional['outputs.LaunchTemplateEnhancedServiceMonitorService'] = None,
                 security_service: Optional['outputs.LaunchTemplateEnhancedServiceSecurityService'] = None):
        """
        :param 'LaunchTemplateEnhancedServiceAutomationServiceArgs' automation_service: Enable TencentCloud Automation Tools(TAT).
        :param 'LaunchTemplateEnhancedServiceMonitorServiceArgs' monitor_service: Enable cloud monitor service.
        :param 'LaunchTemplateEnhancedServiceSecurityServiceArgs' security_service: Enable cloud security service.
        """
        if automation_service is not None:
            pulumi.set(__self__, "automation_service", automation_service)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if security_service is not None:
            pulumi.set(__self__, "security_service", security_service)

    @_builtins.property
    @pulumi.getter(name="automationService")
    def automation_service(self) -> Optional['outputs.LaunchTemplateEnhancedServiceAutomationService']:
        """
        Enable TencentCloud Automation Tools(TAT).
        """
        return pulumi.get(self, "automation_service")

    @_builtins.property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional['outputs.LaunchTemplateEnhancedServiceMonitorService']:
        """
        Enable cloud monitor service.
        """
        return pulumi.get(self, "monitor_service")

    @_builtins.property
    @pulumi.getter(name="securityService")
    def security_service(self) -> Optional['outputs.LaunchTemplateEnhancedServiceSecurityService']:
        """
        Enable cloud security service.
        """
        return pulumi.get(self, "security_service")


@pulumi.output_type
class LaunchTemplateEnhancedServiceAutomationService(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable TencentCloud Automation Tools(TAT), TRUE or FALSE.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable TencentCloud Automation Tools(TAT), TRUE or FALSE.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateEnhancedServiceMonitorService(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable cloud monitor service, TRUE or FALSE.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable cloud monitor service, TRUE or FALSE.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateEnhancedServiceSecurityService(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable cloud security service, TRUE or FALSE.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable cloud security service, TRUE or FALSE.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateInstanceChargePrepaid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewFlag":
            suggest = "renew_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceChargePrepaid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceChargePrepaid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceChargePrepaid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 period: _builtins.int,
                 renew_flag: Optional[_builtins.str] = None):
        """
        :param _builtins.int period: The period of purchasing instances.
        :param _builtins.str renew_flag: Automatic renew flag.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        The period of purchasing instances.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[_builtins.str]:
        """
        Automatic renew flag.
        """
        return pulumi.get(self, "renew_flag")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotOptions":
            suggest = "spot_options"
        elif key == "marketType":
            suggest = "market_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spot_options: 'outputs.LaunchTemplateInstanceMarketOptionsSpotOptions',
                 market_type: Optional[_builtins.str] = None):
        """
        :param 'LaunchTemplateInstanceMarketOptionsSpotOptionsArgs' spot_options: Bidding related options.
        :param _builtins.str market_type: Market option type, currently only supports value: spot.
        """
        pulumi.set(__self__, "spot_options", spot_options)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> 'outputs.LaunchTemplateInstanceMarketOptionsSpotOptions':
        """
        Bidding related options.
        """
        return pulumi.get(self, "spot_options")

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        """
        Market option type, currently only supports value: spot.
        """
        return pulumi.get(self, "market_type")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_price: _builtins.str,
                 spot_instance_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_price: Bidding.
        :param _builtins.str spot_instance_type: Bidding request type, currently only supported type: one-time.
        """
        pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> _builtins.str:
        """
        Bidding.
        """
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        """
        Bidding request type, currently only supported type: one-time.
        """
        return pulumi.get(self, "spot_instance_type")


@pulumi.output_type
class LaunchTemplateInternetAccessible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthPackageId":
            suggest = "bandwidth_package_id"
        elif key == "internetChargeType":
            suggest = "internet_charge_type"
        elif key == "internetMaxBandwidthOut":
            suggest = "internet_max_bandwidth_out"
        elif key == "publicIpAssigned":
            suggest = "public_ip_assigned"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInternetAccessible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInternetAccessible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInternetAccessible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_package_id: Optional[_builtins.str] = None,
                 internet_charge_type: Optional[_builtins.str] = None,
                 internet_max_bandwidth_out: Optional[_builtins.int] = None,
                 public_ip_assigned: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bandwidth_package_id: The ID of bandwidth package.
        :param _builtins.str internet_charge_type: The type of internet charge.
        :param _builtins.int internet_max_bandwidth_out: Internet outbound bandwidth upper limit, Mbps.
        :param _builtins.bool public_ip_assigned: Whether to allocate public network IP, TRUE or FALSE.
        """
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[_builtins.str]:
        """
        The ID of bandwidth package.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[_builtins.str]:
        """
        The type of internet charge.
        """
        return pulumi.get(self, "internet_charge_type")

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[_builtins.int]:
        """
        Internet outbound bandwidth upper limit, Mbps.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[_builtins.bool]:
        """
        Whether to allocate public network IP, TRUE or FALSE.
        """
        return pulumi.get(self, "public_ip_assigned")


@pulumi.output_type
class LaunchTemplateLoginSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepImageLogin":
            suggest = "keep_image_login"
        elif key == "keyIds":
            suggest = "key_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateLoginSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateLoginSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateLoginSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_image_login: Optional[_builtins.str] = None,
                 key_ids: Optional[Sequence[_builtins.str]] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str keep_image_login: Keep the original settings of the mirror.
        :param Sequence[_builtins.str] key_ids: List of key ID.
        :param _builtins.str password: The login password of instance.
        """
        if keep_image_login is not None:
            pulumi.set(__self__, "keep_image_login", keep_image_login)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="keepImageLogin")
    def keep_image_login(self) -> Optional[_builtins.str]:
        """
        Keep the original settings of the mirror.
        """
        return pulumi.get(self, "keep_image_login")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of key ID.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The login password of instance.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LaunchTemplatePlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostIds":
            suggest = "host_ids"
        elif key == "hostIps":
            suggest = "host_ips"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: _builtins.str,
                 host_ids: Optional[Sequence[_builtins.str]] = None,
                 host_ips: Optional[Sequence[_builtins.str]] = None,
                 project_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str zone: The available zone ID of the instance.
        :param Sequence[_builtins.str] host_ids: The CDH ID list of the instance(input).
        :param Sequence[_builtins.str] host_ips: It has been deprecated from version 1.81.108. Specify the host machine ip.
        :param _builtins.int project_id: The project ID of the instance.
        """
        pulumi.set(__self__, "zone", zone)
        if host_ids is not None:
            pulumi.set(__self__, "host_ids", host_ids)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The available zone ID of the instance.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="hostIds")
    def host_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CDH ID list of the instance(input).
        """
        return pulumi.get(self, "host_ids")

    @_builtins.property
    @pulumi.getter(name="hostIps")
    @_utilities.deprecated("""It has been deprecated from version 1.81.108.""")
    def host_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        It has been deprecated from version 1.81.108. Specify the host machine ip.
        """
        return pulumi.get(self, "host_ips")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.int]:
        """
        The project ID of the instance.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class LaunchTemplateSystemDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdcId":
            suggest = "cdc_id"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateSystemDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateSystemDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateSystemDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdc_id: Optional[_builtins.str] = None,
                 disk_id: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cdc_id: Cloud Dedicated Cluster(CDC) ID.
        :param _builtins.str disk_id: System disk ID.
        :param _builtins.int disk_size: The size of system disk.
        :param _builtins.str disk_type: The type of system disk.
        """
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        Cloud Dedicated Cluster(CDC) ID.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        System disk ID.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        The size of system disk.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The type of system disk.
        """
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class LaunchTemplateTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: _builtins.str,
                 tags: Sequence['outputs.LaunchTemplateTagSpecificationTag']):
        """
        :param _builtins.str resource_type: The type of resource.
        :param Sequence['LaunchTemplateTagSpecificationTagArgs'] tags: Tag list.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The type of resource.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.LaunchTemplateTagSpecificationTag']:
        """
        Tag list.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LaunchTemplateTagSpecificationTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key of tag.
        :param _builtins.str value: The value of tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LaunchTemplateVersionActionTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionTime":
            suggest = "action_time"
        elif key == "timerAction":
            suggest = "timer_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionActionTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionActionTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionActionTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_time: Optional[_builtins.str] = None,
                 externals: Optional['outputs.LaunchTemplateVersionActionTimerExternals'] = None,
                 timer_action: Optional[_builtins.str] = None):
        """
        :param _builtins.str action_time: Execution time, displayed according to ISO8601 standard, and UTC time is used. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution must be at least 5 minutes later than the current time.
        :param 'LaunchTemplateVersionActionTimerExternalsArgs' externals: Additional data.
        :param _builtins.str timer_action: Timer name. Currently TerminateInstances is the only supported value.
        """
        if action_time is not None:
            pulumi.set(__self__, "action_time", action_time)
        if externals is not None:
            pulumi.set(__self__, "externals", externals)
        if timer_action is not None:
            pulumi.set(__self__, "timer_action", timer_action)

    @_builtins.property
    @pulumi.getter(name="actionTime")
    def action_time(self) -> Optional[_builtins.str]:
        """
        Execution time, displayed according to ISO8601 standard, and UTC time is used. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution must be at least 5 minutes later than the current time.
        """
        return pulumi.get(self, "action_time")

    @_builtins.property
    @pulumi.getter
    def externals(self) -> Optional['outputs.LaunchTemplateVersionActionTimerExternals']:
        """
        Additional data.
        """
        return pulumi.get(self, "externals")

    @_builtins.property
    @pulumi.getter(name="timerAction")
    def timer_action(self) -> Optional[_builtins.str]:
        """
        Timer name. Currently TerminateInstances is the only supported value.
        """
        return pulumi.get(self, "timer_action")


@pulumi.output_type
class LaunchTemplateVersionActionTimerExternals(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseAddress":
            suggest = "release_address"
        elif key == "storageBlockAttr":
            suggest = "storage_block_attr"
        elif key == "unsupportNetworks":
            suggest = "unsupport_networks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionActionTimerExternals. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionActionTimerExternals.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionActionTimerExternals.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 release_address: Optional[_builtins.bool] = None,
                 storage_block_attr: Optional['outputs.LaunchTemplateVersionActionTimerExternalsStorageBlockAttr'] = None,
                 unsupport_networks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool release_address: Release address.
        :param 'LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgs' storage_block_attr: Information on local HDD storage.
        :param Sequence[_builtins.str] unsupport_networks: Not supported network.
        """
        if release_address is not None:
            pulumi.set(__self__, "release_address", release_address)
        if storage_block_attr is not None:
            pulumi.set(__self__, "storage_block_attr", storage_block_attr)
        if unsupport_networks is not None:
            pulumi.set(__self__, "unsupport_networks", unsupport_networks)

    @_builtins.property
    @pulumi.getter(name="releaseAddress")
    def release_address(self) -> Optional[_builtins.bool]:
        """
        Release address.
        """
        return pulumi.get(self, "release_address")

    @_builtins.property
    @pulumi.getter(name="storageBlockAttr")
    def storage_block_attr(self) -> Optional['outputs.LaunchTemplateVersionActionTimerExternalsStorageBlockAttr']:
        """
        Information on local HDD storage.
        """
        return pulumi.get(self, "storage_block_attr")

    @_builtins.property
    @pulumi.getter(name="unsupportNetworks")
    def unsupport_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Not supported network.
        """
        return pulumi.get(self, "unsupport_networks")


@pulumi.output_type
class LaunchTemplateVersionActionTimerExternalsStorageBlockAttr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionActionTimerExternalsStorageBlockAttr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionActionTimerExternalsStorageBlockAttr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionActionTimerExternalsStorageBlockAttr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: _builtins.int,
                 min_size: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int max_size: Maximum capacity of local HDD storage.
        :param _builtins.int min_size: Minimum capacity of local HDD storage.
        :param _builtins.str type: Local HDD storage type. Value: LOCAL_PRO.
        """
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.int:
        """
        Maximum capacity of local HDD storage.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> _builtins.int:
        """
        Minimum capacity of local HDD storage.
        """
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Local HDD storage type. Value: LOCAL_PRO.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateVersionDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "cdcId":
            suggest = "cdc_id"
        elif key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputPerformance":
            suggest = "throughput_performance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 cdc_id: Optional[_builtins.str] = None,
                 delete_with_instance: Optional[_builtins.bool] = None,
                 disk_id: Optional[_builtins.str] = None,
                 disk_type: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.bool] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput_performance: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size: Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type.
        :param _builtins.str cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param _builtins.bool delete_with_instance: Whether to terminate the data disk when its CVM is terminated. Default value: `true`.
        :param _builtins.str disk_id: System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        :param _builtins.str disk_type: The type of data disk.
        :param _builtins.bool encrypt: Specifies whether the data disk is encrypted.
        :param _builtins.str kms_key_id: ID of the custom CMK in the format of UUID or `kms-abcd1234`.
        :param _builtins.str snapshot_id: Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk. Note: This field may return null, indicating that no valid value is found.
        :param _builtins.int throughput_performance: Cloud disk performance in MB/s.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[_builtins.bool]:
        """
        Whether to terminate the data disk when its CVM is terminated. Default value: `true`.
        """
        return pulumi.get(self, "delete_with_instance")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The type of data disk.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the data disk is encrypted.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        ID of the custom CMK in the format of UUID or `kms-abcd1234`.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk. Note: This field may return null, indicating that no valid value is found.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[_builtins.int]:
        """
        Cloud disk performance in MB/s.
        """
        return pulumi.get(self, "throughput_performance")


@pulumi.output_type
class LaunchTemplateVersionEnhancedService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationService":
            suggest = "automation_service"
        elif key == "monitorService":
            suggest = "monitor_service"
        elif key == "securityService":
            suggest = "security_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionEnhancedService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionEnhancedService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionEnhancedService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automation_service: Optional['outputs.LaunchTemplateVersionEnhancedServiceAutomationService'] = None,
                 monitor_service: Optional['outputs.LaunchTemplateVersionEnhancedServiceMonitorService'] = None,
                 security_service: Optional['outputs.LaunchTemplateVersionEnhancedServiceSecurityService'] = None):
        """
        :param 'LaunchTemplateVersionEnhancedServiceAutomationServiceArgs' automation_service: Whether to enable the TAT service. If this parameter is not specified, the TAT service is enabled for public images and disabled for other images by default.
        :param 'LaunchTemplateVersionEnhancedServiceMonitorServiceArgs' monitor_service: Enables cloud monitor service. If this parameter is not specified, the cloud monitor service will be enabled by default.
        :param 'LaunchTemplateVersionEnhancedServiceSecurityServiceArgs' security_service: Enables cloud security service. If this parameter is not specified, the cloud security service will be enabled by default.
        """
        if automation_service is not None:
            pulumi.set(__self__, "automation_service", automation_service)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if security_service is not None:
            pulumi.set(__self__, "security_service", security_service)

    @_builtins.property
    @pulumi.getter(name="automationService")
    def automation_service(self) -> Optional['outputs.LaunchTemplateVersionEnhancedServiceAutomationService']:
        """
        Whether to enable the TAT service. If this parameter is not specified, the TAT service is enabled for public images and disabled for other images by default.
        """
        return pulumi.get(self, "automation_service")

    @_builtins.property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional['outputs.LaunchTemplateVersionEnhancedServiceMonitorService']:
        """
        Enables cloud monitor service. If this parameter is not specified, the cloud monitor service will be enabled by default.
        """
        return pulumi.get(self, "monitor_service")

    @_builtins.property
    @pulumi.getter(name="securityService")
    def security_service(self) -> Optional['outputs.LaunchTemplateVersionEnhancedServiceSecurityService']:
        """
        Enables cloud security service. If this parameter is not specified, the cloud security service will be enabled by default.
        """
        return pulumi.get(self, "security_service")


@pulumi.output_type
class LaunchTemplateVersionEnhancedServiceAutomationService(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable the TAT service.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable the TAT service.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateVersionEnhancedServiceMonitorService(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable Cloud Monitor.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Cloud Monitor.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateVersionEnhancedServiceSecurityService(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable Cloud Security.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Cloud Security.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateVersionInstanceChargePrepaid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewFlag":
            suggest = "renew_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionInstanceChargePrepaid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionInstanceChargePrepaid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionInstanceChargePrepaid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 period: _builtins.int,
                 renew_flag: Optional[_builtins.str] = None):
        """
        :param _builtins.int period: Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        :param _builtins.str renew_flag: Auto renewal flag. Valid values: NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically &lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[_builtins.str]:
        """
        Auto renewal flag. Valid values: NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically &lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        return pulumi.get(self, "renew_flag")


@pulumi.output_type
class LaunchTemplateVersionInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotOptions":
            suggest = "spot_options"
        elif key == "marketType":
            suggest = "market_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spot_options: 'outputs.LaunchTemplateVersionInstanceMarketOptionsSpotOptions',
                 market_type: Optional[_builtins.str] = None):
        """
        :param 'LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgs' spot_options: Options related to bidding.
        :param _builtins.str market_type: Market option type. Currently spot is the only supported value.
        """
        pulumi.set(__self__, "spot_options", spot_options)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> 'outputs.LaunchTemplateVersionInstanceMarketOptionsSpotOptions':
        """
        Options related to bidding.
        """
        return pulumi.get(self, "spot_options")

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        """
        Market option type. Currently spot is the only supported value.
        """
        return pulumi.get(self, "market_type")


@pulumi.output_type
class LaunchTemplateVersionInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_price: _builtins.str,
                 spot_instance_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_price: Bidding price.
        :param _builtins.str spot_instance_type: Bidding request type. Currently only one-time is supported.
        """
        pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> _builtins.str:
        """
        Bidding price.
        """
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        """
        Bidding request type. Currently only one-time is supported.
        """
        return pulumi.get(self, "spot_instance_type")


@pulumi.output_type
class LaunchTemplateVersionInternetAccessible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthPackageId":
            suggest = "bandwidth_package_id"
        elif key == "internetChargeType":
            suggest = "internet_charge_type"
        elif key == "internetMaxBandwidthOut":
            suggest = "internet_max_bandwidth_out"
        elif key == "publicIpAssigned":
            suggest = "public_ip_assigned"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionInternetAccessible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionInternetAccessible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionInternetAccessible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_package_id: Optional[_builtins.str] = None,
                 internet_charge_type: Optional[_builtins.str] = None,
                 internet_max_bandwidth_out: Optional[_builtins.int] = None,
                 public_ip_assigned: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bandwidth_package_id: Bandwidth package ID.
        :param _builtins.str internet_charge_type: Network connection billing plan.
        :param _builtins.int internet_max_bandwidth_out: The maximum outbound bandwidth of the public network, in Mbps. The default value is 0 Mbps.
        :param _builtins.bool public_ip_assigned: Whether to assign a public IP.
        """
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[_builtins.str]:
        """
        Bandwidth package ID.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[_builtins.str]:
        """
        Network connection billing plan.
        """
        return pulumi.get(self, "internet_charge_type")

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[_builtins.int]:
        """
        The maximum outbound bandwidth of the public network, in Mbps. The default value is 0 Mbps.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[_builtins.bool]:
        """
        Whether to assign a public IP.
        """
        return pulumi.get(self, "public_ip_assigned")


@pulumi.output_type
class LaunchTemplateVersionLoginSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepImageLogin":
            suggest = "keep_image_login"
        elif key == "keyIds":
            suggest = "key_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionLoginSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionLoginSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionLoginSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_image_login: Optional[_builtins.str] = None,
                 key_ids: Optional[Sequence[_builtins.str]] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str keep_image_login: Whether to keep the original settings of an image.
        :param Sequence[_builtins.str] key_ids: List of key IDs. After an instance is associated with a key, you can access the instance with the private key in the key pair.
        :param _builtins.str password: Login password of the instance.
        """
        if keep_image_login is not None:
            pulumi.set(__self__, "keep_image_login", keep_image_login)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="keepImageLogin")
    def keep_image_login(self) -> Optional[_builtins.str]:
        """
        Whether to keep the original settings of an image.
        """
        return pulumi.get(self, "keep_image_login")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of key IDs. After an instance is associated with a key, you can access the instance with the private key in the key pair.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Login password of the instance.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LaunchTemplateVersionPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostIds":
            suggest = "host_ids"
        elif key == "hostIps":
            suggest = "host_ips"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: _builtins.str,
                 host_ids: Optional[Sequence[_builtins.str]] = None,
                 host_ips: Optional[Sequence[_builtins.str]] = None,
                 project_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str zone: ID of the availability zone where the instance resides. You can call the DescribeZones API and obtain the ID in the returned Zone field.
        :param Sequence[_builtins.str] host_ids: ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
        :param Sequence[_builtins.str] host_ips: IPs of the hosts to create CVMs.
        :param _builtins.int project_id: ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
        """
        pulumi.set(__self__, "zone", zone)
        if host_ids is not None:
            pulumi.set(__self__, "host_ids", host_ids)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        ID of the availability zone where the instance resides. You can call the DescribeZones API and obtain the ID in the returned Zone field.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="hostIds")
    def host_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
        """
        return pulumi.get(self, "host_ids")

    @_builtins.property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPs of the hosts to create CVMs.
        """
        return pulumi.get(self, "host_ips")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.int]:
        """
        ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class LaunchTemplateVersionSystemDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdcId":
            suggest = "cdc_id"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionSystemDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionSystemDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionSystemDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdc_id: Optional[_builtins.str] = None,
                 disk_id: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param _builtins.str disk_id: System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        :param _builtins.int disk_size: System disk size; unit: GB; default value: 50 GB.
        :param _builtins.str disk_type: The type of system disk. Default value: the type of hard disk currently in stock.
        """
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        System disk size; unit: GB; default value: 50 GB.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The type of system disk. Default value: the type of hard disk currently in stock.
        """
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class LaunchTemplateVersionTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: _builtins.str,
                 tags: Sequence['outputs.LaunchTemplateVersionTagSpecificationTag']):
        """
        :param _builtins.str resource_type: The type of resource that the tag is bound to.
        :param Sequence['LaunchTemplateVersionTagSpecificationTagArgs'] tags: List of tags.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The type of resource that the tag is bound to.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.LaunchTemplateVersionTagSpecificationTag']:
        """
        List of tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LaunchTemplateVersionTagSpecificationTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Tag key.
        :param _builtins.str value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LaunchTemplateVersionVirtualPrivateCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "asVpcGateway":
            suggest = "as_vpc_gateway"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVersionVirtualPrivateCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVersionVirtualPrivateCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVersionVirtualPrivateCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str,
                 as_vpc_gateway: Optional[_builtins.bool] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 private_ip_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str subnet_id: VPC subnet ID in the format subnet-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param _builtins.str vpc_id: VPC ID in the format of vpc-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param _builtins.bool as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC.
        :param _builtins.int ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param Sequence[_builtins.str] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        VPC subnet ID in the format subnet-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        VPC ID in the format of vpc-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[_builtins.bool]:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")


@pulumi.output_type
class LaunchTemplateVirtualPrivateCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "asVpcGateway":
            suggest = "as_vpc_gateway"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateVirtualPrivateCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateVirtualPrivateCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateVirtualPrivateCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str,
                 as_vpc_gateway: Optional[_builtins.bool] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 private_ip_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str subnet_id: The id of subnet.
        :param _builtins.str vpc_id: The id of VPC.
        :param _builtins.bool as_vpc_gateway: Is it used as a Public network gateway, TRUE or FALSE.
        :param _builtins.int ipv6_address_count: The number of ipv6 addresses for Elastic Network Interface.
        :param Sequence[_builtins.str] private_ip_addresses: The address of private ip.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The id of subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The id of VPC.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[_builtins.bool]:
        """
        Is it used as a Public network gateway, TRUE or FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        The number of ipv6 addresses for Elastic Network Interface.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The address of private ip.
        """
        return pulumi.get(self, "private_ip_addresses")


@pulumi.output_type
class ModifyInstanceDiskTypeDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "cdcId":
            suggest = "cdc_id"
        elif key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputPerformance":
            suggest = "throughput_performance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModifyInstanceDiskTypeDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModifyInstanceDiskTypeDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModifyInstanceDiskTypeDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 cdc_id: Optional[_builtins.str] = None,
                 delete_with_instance: Optional[_builtins.bool] = None,
                 disk_id: Optional[_builtins.str] = None,
                 disk_type: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.bool] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput_performance: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size: Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type. The default value is 0, indicating that no data disk is purchased. For more information, see the product documentation.
        :param _builtins.str cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param _builtins.bool delete_with_instance: Whether to terminate the data disk when its CVM is terminated. Valid values:
               - TRUE: terminate the data disk when its CVM is terminated. This value only supports pay-as-you-go cloud disks billed on an hourly basis.
               - FALSE: retain the data disk when its CVM is terminated.
               Default value: TRUE.
        :param _builtins.str disk_id: Data disk ID. Note that it's not available for LOCAL_BASIC and LOCAL_SSD disks.
        :param _builtins.str disk_type: Data disk type. Valid values:
               - LOCAL_BASIC: local hard disk;
               - LOCAL_SSD: local SSD hard disk;
               - LOCAL_NVME: local NVME hard disk, which is strongly related to InstanceType and cannot be specified;
               - LOCAL_PRO: local HDD hard disk, which is strongly related to InstanceType and cannot be specified;
               - CLOUD_BASIC: ordinary cloud disk;
               - CLOUD_PREMIUM: high-performance cloud disk;
               - CLOUD_SSD:SSD cloud disk;
               - CLOUD_HSSD: enhanced SSD cloud disk;
               - CLOUD_TSSD: extremely fast SSD cloud disk;
               - CLOUD_BSSD: general-purpose SSD cloud disk;
               Default value: LOCAL_BASIC.
        :param _builtins.bool encrypt: Specifies whether the data disk is encrypted. Valid values:
               - TRUE: encrypted
               - FALSE: not encrypted
               Default value: FALSE.
        :param _builtins.str kms_key_id: ID of the custom CMK in the format of UUID or kms-abcd1234. This parameter is used to encrypt cloud disks.
        :param _builtins.str snapshot_id: Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk.
        :param _builtins.int throughput_performance: Cloud disk performance, in MB/s.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type. The default value is 0, indicating that no data disk is purchased. For more information, see the product documentation.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[_builtins.bool]:
        """
        Whether to terminate the data disk when its CVM is terminated. Valid values:
        - TRUE: terminate the data disk when its CVM is terminated. This value only supports pay-as-you-go cloud disks billed on an hourly basis.
        - FALSE: retain the data disk when its CVM is terminated.
        Default value: TRUE.
        """
        return pulumi.get(self, "delete_with_instance")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        Data disk ID. Note that it's not available for LOCAL_BASIC and LOCAL_SSD disks.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Data disk type. Valid values:
        - LOCAL_BASIC: local hard disk;
        - LOCAL_SSD: local SSD hard disk;
        - LOCAL_NVME: local NVME hard disk, which is strongly related to InstanceType and cannot be specified;
        - LOCAL_PRO: local HDD hard disk, which is strongly related to InstanceType and cannot be specified;
        - CLOUD_BASIC: ordinary cloud disk;
        - CLOUD_PREMIUM: high-performance cloud disk;
        - CLOUD_SSD:SSD cloud disk;
        - CLOUD_HSSD: enhanced SSD cloud disk;
        - CLOUD_TSSD: extremely fast SSD cloud disk;
        - CLOUD_BSSD: general-purpose SSD cloud disk;
        Default value: LOCAL_BASIC.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the data disk is encrypted. Valid values:
        - TRUE: encrypted
        - FALSE: not encrypted
        Default value: FALSE.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        ID of the custom CMK in the format of UUID or kms-abcd1234. This parameter is used to encrypt cloud disks.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[_builtins.int]:
        """
        Cloud disk performance, in MB/s.
        """
        return pulumi.get(self, "throughput_performance")


@pulumi.output_type
class ModifyInstanceDiskTypeSystemDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdcId":
            suggest = "cdc_id"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModifyInstanceDiskTypeSystemDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModifyInstanceDiskTypeSystemDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModifyInstanceDiskTypeSystemDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdc_id: Optional[_builtins.str] = None,
                 disk_id: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param _builtins.str disk_id: System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter.
        :param _builtins.int disk_size: System disk size; unit: GB; default value: 50 GB.
        :param _builtins.str disk_type: System disk type. Valid values:- LOCAL_BASIC: local disk
               - LOCAL_SSD: local SSD disk
               - CLOUD_BASIC: ordinary cloud disk
               - CLOUD_SSD: SSD cloud disk
               - CLOUD_PREMIUM: Premium cloud storage
               - CLOUD_BSSD: Balanced SSD
               The disk currently in stock will be used by default.
        """
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        System disk size; unit: GB; default value: 50 GB.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        System disk type. Valid values:- LOCAL_BASIC: local disk
        - LOCAL_SSD: local SSD disk
        - CLOUD_BASIC: ordinary cloud disk
        - CLOUD_SSD: SSD cloud disk
        - CLOUD_PREMIUM: Premium cloud storage
        - CLOUD_BSSD: Balanced SSD
        The disk currently in stock will be used by default.
        """
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class RenewHostHostChargePrepaid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewFlag":
            suggest = "renew_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RenewHostHostChargePrepaid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RenewHostHostChargePrepaid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RenewHostHostChargePrepaid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 period: _builtins.int,
                 renew_flag: Optional[_builtins.str] = None):
        """
        :param _builtins.int period: The duration of purchasing an instance, unit: month. Value range: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36.
        :param _builtins.str renew_flag: Auto renewal flag. Valid values:&lt;br&gt;&lt;li&gt;NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically&lt;br&gt;&lt;li&gt;NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically&lt;br&gt;&lt;li&gt;DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically&lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_AUTO_RENEWIf this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        The duration of purchasing an instance, unit: month. Value range: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[_builtins.str]:
        """
        Auto renewal flag. Valid values:&lt;br&gt;&lt;li&gt;NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically&lt;br&gt;&lt;li&gt;NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically&lt;br&gt;&lt;li&gt;DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically&lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_AUTO_RENEWIf this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        return pulumi.get(self, "renew_flag")


@pulumi.output_type
class RenewInstanceInstanceChargePrepaid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewFlag":
            suggest = "renew_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RenewInstanceInstanceChargePrepaid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RenewInstanceInstanceChargePrepaid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RenewInstanceInstanceChargePrepaid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 period: _builtins.int,
                 renew_flag: Optional[_builtins.str] = None):
        """
        :param _builtins.int period: Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60. Note: This field may return null, indicating that no valid value is found.
        :param _builtins.str renew_flag: Auto renewal flag. Valid values:
               - `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically;
               - `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically;
               - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically;
               Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. Note: This field may return null, indicating that no valid value is found.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60. Note: This field may return null, indicating that no valid value is found.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[_builtins.str]:
        """
        Auto renewal flag. Valid values:
        - `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically;
        - `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically;
        - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically;
        Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. Note: This field may return null, indicating that no valid value is found.
        """
        return pulumi.get(self, "renew_flag")


@pulumi.output_type
class GetChcDeniedActionsChcHostDeniedActionSetResult(dict):
    def __init__(__self__, *,
                 chc_id: _builtins.str,
                 deny_actions: Sequence[_builtins.str],
                 state: _builtins.str):
        """
        :param _builtins.str chc_id: CHC instance ID.
        :param Sequence[_builtins.str] deny_actions: Actions not allowed for the current CHC instance.
        :param _builtins.str state: CHC instance status.
        """
        pulumi.set(__self__, "chc_id", chc_id)
        pulumi.set(__self__, "deny_actions", deny_actions)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="chcId")
    def chc_id(self) -> _builtins.str:
        """
        CHC instance ID.
        """
        return pulumi.get(self, "chc_id")

    @_builtins.property
    @pulumi.getter(name="denyActions")
    def deny_actions(self) -> Sequence[_builtins.str]:
        """
        Actions not allowed for the current CHC instance.
        """
        return pulumi.get(self, "deny_actions")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        CHC instance status.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetChcHostsChcHostSetResult(dict):
    def __init__(__self__, *,
                 bmc_ip: _builtins.str,
                 bmc_mac: _builtins.str,
                 bmc_security_group_ids: Sequence[_builtins.str],
                 bmc_virtual_private_clouds: Sequence['outputs.GetChcHostsChcHostSetBmcVirtualPrivateCloudResult'],
                 chc_id: _builtins.str,
                 cpu: _builtins.int,
                 created_time: _builtins.str,
                 cvm_instance_id: _builtins.str,
                 deploy_ip: _builtins.str,
                 deploy_mac: _builtins.str,
                 deploy_security_group_ids: Sequence[_builtins.str],
                 deploy_virtual_private_clouds: Sequence['outputs.GetChcHostsChcHostSetDeployVirtualPrivateCloudResult'],
                 device_type: _builtins.str,
                 disk: _builtins.str,
                 hardware_description: _builtins.str,
                 instance_name: _builtins.str,
                 instance_state: _builtins.str,
                 memory: _builtins.int,
                 placements: Sequence['outputs.GetChcHostsChcHostSetPlacementResult'],
                 serial_number: _builtins.str,
                 tenant_type: _builtins.str):
        """
        :param _builtins.str bmc_ip: Out-of-band network IPNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str bmc_mac: MAC address assigned under the out-of-band networkNote: This field may return null, indicating that no valid values can be obtained.
        :param Sequence[_builtins.str] bmc_security_group_ids: Out-of-band network security group IDNote: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetChcHostsChcHostSetBmcVirtualPrivateCloudArgs'] bmc_virtual_private_clouds: Out-of-band networkNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str chc_id: CHC host ID.
        :param _builtins.int cpu: CPU cores of the CHC hostNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str created_time: Server creation time.
        :param _builtins.str cvm_instance_id: ID of the associated CVMNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str deploy_ip: Deployment network IPNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str deploy_mac: MAC address assigned under the deployment networkNote: This field may return null, indicating that no valid values can be obtained.
        :param Sequence[_builtins.str] deploy_security_group_ids: Deployment network security group IDNote: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetChcHostsChcHostSetDeployVirtualPrivateCloudArgs'] deploy_virtual_private_clouds: Deployment networkNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str device_type: Device typeNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str disk: Disk capacity of the CHC hostNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str hardware_description: Instance hardware description, including CPU cores, memory capacity and disk capacity.Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str instance_name: Instance name.
        :param _builtins.str instance_state: CHC host status&lt;br/&gt;&lt;ul&gt;&lt;li&gt;REGISTERED: The CHC host is registered, but the out-of-band network and deployment network are not configured.&lt;/li&gt;&lt;li&gt;VPC_READY: The out-of-band network and deployment network are configured.&lt;/li&gt;&lt;li&gt;PREPARED: It&#39;s ready and can be associated with a CVM.&lt;/li&gt;&lt;li&gt;ONLINE: It&#39;s already associated with a CVM.&lt;/li&gt;&lt;/ul&gt;.
        :param _builtins.int memory: Memory capacity of the CHC host (unit: GB)Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetChcHostsChcHostSetPlacementArgs'] placements: Availability zone.
        :param _builtins.str serial_number: Server serial number.
        :param _builtins.str tenant_type: Management typeHOSTING: HostingTENANT: LeasingNote: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "bmc_ip", bmc_ip)
        pulumi.set(__self__, "bmc_mac", bmc_mac)
        pulumi.set(__self__, "bmc_security_group_ids", bmc_security_group_ids)
        pulumi.set(__self__, "bmc_virtual_private_clouds", bmc_virtual_private_clouds)
        pulumi.set(__self__, "chc_id", chc_id)
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "cvm_instance_id", cvm_instance_id)
        pulumi.set(__self__, "deploy_ip", deploy_ip)
        pulumi.set(__self__, "deploy_mac", deploy_mac)
        pulumi.set(__self__, "deploy_security_group_ids", deploy_security_group_ids)
        pulumi.set(__self__, "deploy_virtual_private_clouds", deploy_virtual_private_clouds)
        pulumi.set(__self__, "device_type", device_type)
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "hardware_description", hardware_description)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "placements", placements)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "tenant_type", tenant_type)

    @_builtins.property
    @pulumi.getter(name="bmcIp")
    def bmc_ip(self) -> _builtins.str:
        """
        Out-of-band network IPNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "bmc_ip")

    @_builtins.property
    @pulumi.getter(name="bmcMac")
    def bmc_mac(self) -> _builtins.str:
        """
        MAC address assigned under the out-of-band networkNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "bmc_mac")

    @_builtins.property
    @pulumi.getter(name="bmcSecurityGroupIds")
    def bmc_security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Out-of-band network security group IDNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "bmc_security_group_ids")

    @_builtins.property
    @pulumi.getter(name="bmcVirtualPrivateClouds")
    def bmc_virtual_private_clouds(self) -> Sequence['outputs.GetChcHostsChcHostSetBmcVirtualPrivateCloudResult']:
        """
        Out-of-band networkNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "bmc_virtual_private_clouds")

    @_builtins.property
    @pulumi.getter(name="chcId")
    def chc_id(self) -> _builtins.str:
        """
        CHC host ID.
        """
        return pulumi.get(self, "chc_id")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.int:
        """
        CPU cores of the CHC hostNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.str:
        """
        Server creation time.
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="cvmInstanceId")
    def cvm_instance_id(self) -> _builtins.str:
        """
        ID of the associated CVMNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "cvm_instance_id")

    @_builtins.property
    @pulumi.getter(name="deployIp")
    def deploy_ip(self) -> _builtins.str:
        """
        Deployment network IPNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "deploy_ip")

    @_builtins.property
    @pulumi.getter(name="deployMac")
    def deploy_mac(self) -> _builtins.str:
        """
        MAC address assigned under the deployment networkNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "deploy_mac")

    @_builtins.property
    @pulumi.getter(name="deploySecurityGroupIds")
    def deploy_security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Deployment network security group IDNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "deploy_security_group_ids")

    @_builtins.property
    @pulumi.getter(name="deployVirtualPrivateClouds")
    def deploy_virtual_private_clouds(self) -> Sequence['outputs.GetChcHostsChcHostSetDeployVirtualPrivateCloudResult']:
        """
        Deployment networkNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "deploy_virtual_private_clouds")

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> _builtins.str:
        """
        Device typeNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "device_type")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.str:
        """
        Disk capacity of the CHC hostNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="hardwareDescription")
    def hardware_description(self) -> _builtins.str:
        """
        Instance hardware description, including CPU cores, memory capacity and disk capacity.Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "hardware_description")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        Instance name.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        CHC host status&lt;br/&gt;&lt;ul&gt;&lt;li&gt;REGISTERED: The CHC host is registered, but the out-of-band network and deployment network are not configured.&lt;/li&gt;&lt;li&gt;VPC_READY: The out-of-band network and deployment network are configured.&lt;/li&gt;&lt;li&gt;PREPARED: It&#39;s ready and can be associated with a CVM.&lt;/li&gt;&lt;li&gt;ONLINE: It&#39;s already associated with a CVM.&lt;/li&gt;&lt;/ul&gt;.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        Memory capacity of the CHC host (unit: GB)Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def placements(self) -> Sequence['outputs.GetChcHostsChcHostSetPlacementResult']:
        """
        Availability zone.
        """
        return pulumi.get(self, "placements")

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> _builtins.str:
        """
        Server serial number.
        """
        return pulumi.get(self, "serial_number")

    @_builtins.property
    @pulumi.getter(name="tenantType")
    def tenant_type(self) -> _builtins.str:
        """
        Management typeHOSTING: HostingTENANT: LeasingNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "tenant_type")


@pulumi.output_type
class GetChcHostsChcHostSetBmcVirtualPrivateCloudResult(dict):
    def __init__(__self__, *,
                 as_vpc_gateway: _builtins.bool,
                 ipv6_address_count: _builtins.int,
                 private_ip_addresses: Sequence[_builtins.str],
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.bool as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        :param _builtins.int ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param Sequence[_builtins.str] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        :param _builtins.str subnet_id: VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        :param _builtins.str vpc_id: VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> _builtins.bool:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> _builtins.int:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Sequence[_builtins.str]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetChcHostsChcHostSetDeployVirtualPrivateCloudResult(dict):
    def __init__(__self__, *,
                 as_vpc_gateway: _builtins.bool,
                 ipv6_address_count: _builtins.int,
                 private_ip_addresses: Sequence[_builtins.str],
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.bool as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        :param _builtins.int ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param Sequence[_builtins.str] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        :param _builtins.str subnet_id: VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        :param _builtins.str vpc_id: VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> _builtins.bool:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> _builtins.int:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Sequence[_builtins.str]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetChcHostsChcHostSetPlacementResult(dict):
    def __init__(__self__, *,
                 host_id: _builtins.str,
                 host_ids: Sequence[_builtins.str],
                 host_ips: Sequence[_builtins.str],
                 project_id: _builtins.int,
                 zone: _builtins.str):
        """
        :param _builtins.str host_id: The ID of the CDH to which the instance belongs, only used as an output parameter.
        :param Sequence[_builtins.str] host_ids: ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
        :param Sequence[_builtins.str] host_ips: (**Deprecated**) It has been deprecated from version 1.81.108. IPs of the hosts to create CVMs.
        :param _builtins.int project_id: ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
        :param _builtins.str zone: ID of the availability zone where the instance resides. You can call the [DescribeZones](https://www.tencentcloud.com/document/product/213/35071) API and obtain the ID in the returned Zone field.
        """
        pulumi.set(__self__, "host_id", host_id)
        pulumi.set(__self__, "host_ids", host_ids)
        pulumi.set(__self__, "host_ips", host_ips)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> _builtins.str:
        """
        The ID of the CDH to which the instance belongs, only used as an output parameter.
        """
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostIds")
    def host_ids(self) -> Sequence[_builtins.str]:
        """
        ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
        """
        return pulumi.get(self, "host_ids")

    @_builtins.property
    @pulumi.getter(name="hostIps")
    @_utilities.deprecated("""It has been deprecated from version 1.81.108.""")
    def host_ips(self) -> Sequence[_builtins.str]:
        """
        (**Deprecated**) It has been deprecated from version 1.81.108. IPs of the hosts to create CVMs.
        """
        return pulumi.get(self, "host_ips")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.int:
        """
        ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        ID of the availability zone where the instance resides. You can call the [DescribeZones](https://www.tencentcloud.com/document/product/213/35071) API and obtain the ID in the returned Zone field.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetChcHostsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Filter name.
        :param Sequence[_builtins.str] values: Filter values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetImageSharePermissionSharePermissionSetResult(dict):
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 created_time: _builtins.str):
        """
        :param _builtins.str account_id: ID of the account with which the image is shared.
        :param _builtins.str created_time: Time when an image was shared.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "created_time", created_time)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        """
        ID of the account with which the image is shared.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.str:
        """
        Time when an image was shared.
        """
        return pulumi.get(self, "created_time")


@pulumi.output_type
class GetImportImageOsImportImageOsListSupportedResult(dict):
    def __init__(__self__, *,
                 linuxes: Sequence[_builtins.str],
                 windows: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] linuxes: Supported Linux OS Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence[_builtins.str] windows: Supported Windows OS Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "linuxes", linuxes)
        pulumi.set(__self__, "windows", windows)

    @_builtins.property
    @pulumi.getter
    def linuxes(self) -> Sequence[_builtins.str]:
        """
        Supported Linux OS Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "linuxes")

    @_builtins.property
    @pulumi.getter
    def windows(self) -> Sequence[_builtins.str]:
        """
        Supported Windows OS Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "windows")


@pulumi.output_type
class GetImportImageOsImportImageOsVersionSetResult(dict):
    def __init__(__self__, *,
                 architectures: Sequence[_builtins.str],
                 os_name: _builtins.str,
                 os_versions: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] architectures: Supported operating system architecture.
        :param _builtins.str os_name: Operating system type.
        :param Sequence[_builtins.str] os_versions: Supported operating system versions.
        """
        pulumi.set(__self__, "architectures", architectures)
        pulumi.set(__self__, "os_name", os_name)
        pulumi.set(__self__, "os_versions", os_versions)

    @_builtins.property
    @pulumi.getter
    def architectures(self) -> Sequence[_builtins.str]:
        """
        Supported operating system architecture.
        """
        return pulumi.get(self, "architectures")

    @_builtins.property
    @pulumi.getter(name="osName")
    def os_name(self) -> _builtins.str:
        """
        Operating system type.
        """
        return pulumi.get(self, "os_name")

    @_builtins.property
    @pulumi.getter(name="osVersions")
    def os_versions(self) -> Sequence[_builtins.str]:
        """
        Supported operating system versions.
        """
        return pulumi.get(self, "os_versions")


@pulumi.output_type
class GetInstancesModificationFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Fields to be filtered.
        :param Sequence[_builtins.str] values: Value of the field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Fields to be filtered.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Value of the field.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstancesModificationInstanceTypeConfigStatusListResult(dict):
    def __init__(__self__, *,
                 instance_type_configs: Sequence['outputs.GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfigResult'],
                 message: _builtins.str,
                 status: _builtins.str):
        """
        :param Sequence['GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfigArgs'] instance_type_configs: Configuration information.
        :param _builtins.str message: Status description information.
        :param _builtins.str status: State description.
        """
        pulumi.set(__self__, "instance_type_configs", instance_type_configs)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="instanceTypeConfigs")
    def instance_type_configs(self) -> Sequence['outputs.GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfigResult']:
        """
        Configuration information.
        """
        return pulumi.get(self, "instance_type_configs")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Status description information.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        State description.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfigResult(dict):
    def __init__(__self__, *,
                 cpu: _builtins.int,
                 fpga: _builtins.int,
                 gpu: _builtins.int,
                 instance_family: _builtins.str,
                 instance_type: _builtins.str,
                 memory: _builtins.int,
                 zone: _builtins.str):
        """
        :param _builtins.int cpu: The number of CPU kernels, in cores.
        :param _builtins.int fpga: The number of FPGA kernels, in cores.
        :param _builtins.int gpu: The number of GPU kernels, in cores.
        :param _builtins.str instance_family: Instance family.
        :param _builtins.str instance_type: Instance type.
        :param _builtins.int memory: Memory capacity (in GB).
        :param _builtins.str zone: Availability zone.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "fpga", fpga)
        pulumi.set(__self__, "gpu", gpu)
        pulumi.set(__self__, "instance_family", instance_family)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.int:
        """
        The number of CPU kernels, in cores.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def fpga(self) -> _builtins.int:
        """
        The number of FPGA kernels, in cores.
        """
        return pulumi.get(self, "fpga")

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> _builtins.int:
        """
        The number of GPU kernels, in cores.
        """
        return pulumi.get(self, "gpu")

    @_builtins.property
    @pulumi.getter(name="instanceFamily")
    def instance_family(self) -> _builtins.str:
        """
        Instance family.
        """
        return pulumi.get(self, "instance_family")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        Memory capacity (in GB).
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        Availability zone.
        """
        return pulumi.get(self, "zone")


