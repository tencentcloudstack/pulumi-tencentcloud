# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ActionTimerActionTimerArgs',
    'ActionTimerActionTimerArgsDict',
    'ChcConfigBmcVirtualPrivateCloudArgs',
    'ChcConfigBmcVirtualPrivateCloudArgsDict',
    'ChcConfigDeployVirtualPrivateCloudArgs',
    'ChcConfigDeployVirtualPrivateCloudArgsDict',
    'ImportImageTagSpecificationArgs',
    'ImportImageTagSpecificationArgsDict',
    'ImportImageTagSpecificationTagArgs',
    'ImportImageTagSpecificationTagArgsDict',
    'LaunchTemplateActionTimerArgs',
    'LaunchTemplateActionTimerArgsDict',
    'LaunchTemplateActionTimerExternalsArgs',
    'LaunchTemplateActionTimerExternalsArgsDict',
    'LaunchTemplateActionTimerExternalsStorageBlockAttrArgs',
    'LaunchTemplateActionTimerExternalsStorageBlockAttrArgsDict',
    'LaunchTemplateDataDiskArgs',
    'LaunchTemplateDataDiskArgsDict',
    'LaunchTemplateEnhancedServiceArgs',
    'LaunchTemplateEnhancedServiceArgsDict',
    'LaunchTemplateEnhancedServiceAutomationServiceArgs',
    'LaunchTemplateEnhancedServiceAutomationServiceArgsDict',
    'LaunchTemplateEnhancedServiceMonitorServiceArgs',
    'LaunchTemplateEnhancedServiceMonitorServiceArgsDict',
    'LaunchTemplateEnhancedServiceSecurityServiceArgs',
    'LaunchTemplateEnhancedServiceSecurityServiceArgsDict',
    'LaunchTemplateInstanceChargePrepaidArgs',
    'LaunchTemplateInstanceChargePrepaidArgsDict',
    'LaunchTemplateInstanceMarketOptionsArgs',
    'LaunchTemplateInstanceMarketOptionsArgsDict',
    'LaunchTemplateInstanceMarketOptionsSpotOptionsArgs',
    'LaunchTemplateInstanceMarketOptionsSpotOptionsArgsDict',
    'LaunchTemplateInternetAccessibleArgs',
    'LaunchTemplateInternetAccessibleArgsDict',
    'LaunchTemplateLoginSettingsArgs',
    'LaunchTemplateLoginSettingsArgsDict',
    'LaunchTemplatePlacementArgs',
    'LaunchTemplatePlacementArgsDict',
    'LaunchTemplateSystemDiskArgs',
    'LaunchTemplateSystemDiskArgsDict',
    'LaunchTemplateTagSpecificationArgs',
    'LaunchTemplateTagSpecificationArgsDict',
    'LaunchTemplateTagSpecificationTagArgs',
    'LaunchTemplateTagSpecificationTagArgsDict',
    'LaunchTemplateVersionActionTimerArgs',
    'LaunchTemplateVersionActionTimerArgsDict',
    'LaunchTemplateVersionActionTimerExternalsArgs',
    'LaunchTemplateVersionActionTimerExternalsArgsDict',
    'LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgs',
    'LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgsDict',
    'LaunchTemplateVersionDataDiskArgs',
    'LaunchTemplateVersionDataDiskArgsDict',
    'LaunchTemplateVersionEnhancedServiceArgs',
    'LaunchTemplateVersionEnhancedServiceArgsDict',
    'LaunchTemplateVersionEnhancedServiceAutomationServiceArgs',
    'LaunchTemplateVersionEnhancedServiceAutomationServiceArgsDict',
    'LaunchTemplateVersionEnhancedServiceMonitorServiceArgs',
    'LaunchTemplateVersionEnhancedServiceMonitorServiceArgsDict',
    'LaunchTemplateVersionEnhancedServiceSecurityServiceArgs',
    'LaunchTemplateVersionEnhancedServiceSecurityServiceArgsDict',
    'LaunchTemplateVersionInstanceChargePrepaidArgs',
    'LaunchTemplateVersionInstanceChargePrepaidArgsDict',
    'LaunchTemplateVersionInstanceMarketOptionsArgs',
    'LaunchTemplateVersionInstanceMarketOptionsArgsDict',
    'LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgs',
    'LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgsDict',
    'LaunchTemplateVersionInternetAccessibleArgs',
    'LaunchTemplateVersionInternetAccessibleArgsDict',
    'LaunchTemplateVersionLoginSettingsArgs',
    'LaunchTemplateVersionLoginSettingsArgsDict',
    'LaunchTemplateVersionPlacementArgs',
    'LaunchTemplateVersionPlacementArgsDict',
    'LaunchTemplateVersionSystemDiskArgs',
    'LaunchTemplateVersionSystemDiskArgsDict',
    'LaunchTemplateVersionTagSpecificationArgs',
    'LaunchTemplateVersionTagSpecificationArgsDict',
    'LaunchTemplateVersionTagSpecificationTagArgs',
    'LaunchTemplateVersionTagSpecificationTagArgsDict',
    'LaunchTemplateVersionVirtualPrivateCloudArgs',
    'LaunchTemplateVersionVirtualPrivateCloudArgsDict',
    'LaunchTemplateVirtualPrivateCloudArgs',
    'LaunchTemplateVirtualPrivateCloudArgsDict',
    'ModifyInstanceDiskTypeDataDiskArgs',
    'ModifyInstanceDiskTypeDataDiskArgsDict',
    'ModifyInstanceDiskTypeSystemDiskArgs',
    'ModifyInstanceDiskTypeSystemDiskArgsDict',
    'RenewHostHostChargePrepaidArgs',
    'RenewHostHostChargePrepaidArgsDict',
    'RenewInstanceInstanceChargePrepaidArgs',
    'RenewInstanceInstanceChargePrepaidArgsDict',
    'GetChcHostsFilterArgs',
    'GetChcHostsFilterArgsDict',
    'GetInstancesModificationFilterArgs',
    'GetInstancesModificationFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ActionTimerActionTimerArgsDict(TypedDict):
        action_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution time, expressed according to ISO8601 standard and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution time must be 5 minutes longer than the current time.
        """
        timer_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timer action, currently only supports destroying one value: TerminateInstances.
        """
elif False:
    ActionTimerActionTimerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionTimerActionTimerArgs:
    def __init__(__self__, *,
                 action_time: Optional[pulumi.Input[_builtins.str]] = None,
                 timer_action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_time: Execution time, expressed according to ISO8601 standard and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution time must be 5 minutes longer than the current time.
        :param pulumi.Input[_builtins.str] timer_action: Timer action, currently only supports destroying one value: TerminateInstances.
        """
        if action_time is not None:
            pulumi.set(__self__, "action_time", action_time)
        if timer_action is not None:
            pulumi.set(__self__, "timer_action", timer_action)

    @_builtins.property
    @pulumi.getter(name="actionTime")
    def action_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution time, expressed according to ISO8601 standard and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution time must be 5 minutes longer than the current time.
        """
        return pulumi.get(self, "action_time")

    @action_time.setter
    def action_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_time", value)

    @_builtins.property
    @pulumi.getter(name="timerAction")
    def timer_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timer action, currently only supports destroying one value: TerminateInstances.
        """
        return pulumi.get(self, "timer_action")

    @timer_action.setter
    def timer_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timer_action", value)


if not MYPY:
    class ChcConfigBmcVirtualPrivateCloudArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        as_vpc_gateway: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        ipv6_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
elif False:
    ChcConfigBmcVirtualPrivateCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChcConfigBmcVirtualPrivateCloudArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 as_vpc_gateway: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        :param pulumi.Input[_builtins.str] vpc_id: VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param pulumi.Input[_builtins.bool] as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        :param pulumi.Input[_builtins.int] ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @as_vpc_gateway.setter
    def as_vpc_gateway(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_vpc_gateway", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_ip_addresses", value)


if not MYPY:
    class ChcConfigDeployVirtualPrivateCloudArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        as_vpc_gateway: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        ipv6_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
elif False:
    ChcConfigDeployVirtualPrivateCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChcConfigDeployVirtualPrivateCloudArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 as_vpc_gateway: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        :param pulumi.Input[_builtins.str] vpc_id: VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param pulumi.Input[_builtins.bool] as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        :param pulumi.Input[_builtins.int] ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @as_vpc_gateway.setter
    def as_vpc_gateway(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_vpc_gateway", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_ip_addresses", value)


if not MYPY:
    class ImportImageTagSpecificationArgsDict(TypedDict):
        resource_type: pulumi.Input[_builtins.str]
        """
        Resource type. Valid values: instance (CVM), host (CDH), image (for image), and keypair (for key). Note: This field may return null, indicating that no valid values can be obtained.
        """
        tags: pulumi.Input[Sequence[pulumi.Input['ImportImageTagSpecificationTagArgsDict']]]
        """
        Tag pairs Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    ImportImageTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImportImageTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[_builtins.str],
                 tags: pulumi.Input[Sequence[pulumi.Input['ImportImageTagSpecificationTagArgs']]]):
        """
        :param pulumi.Input[_builtins.str] resource_type: Resource type. Valid values: instance (CVM), host (CDH), image (for image), and keypair (for key). Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ImportImageTagSpecificationTagArgs']]] tags: Tag pairs Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        Resource type. Valid values: instance (CVM), host (CDH), image (for image), and keypair (for key). Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input['ImportImageTagSpecificationTagArgs']]]:
        """
        Tag pairs Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input['ImportImageTagSpecificationTagArgs']]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ImportImageTagSpecificationTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Tag value.
        """
elif False:
    ImportImageTagSpecificationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImportImageTagSpecificationTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Tag key.
        :param pulumi.Input[_builtins.str] value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LaunchTemplateActionTimerArgsDict(TypedDict):
        action_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution time.
        """
        externals: NotRequired[pulumi.Input['LaunchTemplateActionTimerExternalsArgsDict']]
        """
        Extended data.
        """
        timer_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timer name.
        """
elif False:
    LaunchTemplateActionTimerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateActionTimerArgs:
    def __init__(__self__, *,
                 action_time: Optional[pulumi.Input[_builtins.str]] = None,
                 externals: Optional[pulumi.Input['LaunchTemplateActionTimerExternalsArgs']] = None,
                 timer_action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_time: Execution time.
        :param pulumi.Input['LaunchTemplateActionTimerExternalsArgs'] externals: Extended data.
        :param pulumi.Input[_builtins.str] timer_action: Timer name.
        """
        if action_time is not None:
            pulumi.set(__self__, "action_time", action_time)
        if externals is not None:
            pulumi.set(__self__, "externals", externals)
        if timer_action is not None:
            pulumi.set(__self__, "timer_action", timer_action)

    @_builtins.property
    @pulumi.getter(name="actionTime")
    def action_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution time.
        """
        return pulumi.get(self, "action_time")

    @action_time.setter
    def action_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_time", value)

    @_builtins.property
    @pulumi.getter
    def externals(self) -> Optional[pulumi.Input['LaunchTemplateActionTimerExternalsArgs']]:
        """
        Extended data.
        """
        return pulumi.get(self, "externals")

    @externals.setter
    def externals(self, value: Optional[pulumi.Input['LaunchTemplateActionTimerExternalsArgs']]):
        pulumi.set(self, "externals", value)

    @_builtins.property
    @pulumi.getter(name="timerAction")
    def timer_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timer name.
        """
        return pulumi.get(self, "timer_action")

    @timer_action.setter
    def timer_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timer_action", value)


if not MYPY:
    class LaunchTemplateActionTimerExternalsArgsDict(TypedDict):
        release_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Release address.
        """
        storage_block_attr: NotRequired[pulumi.Input['LaunchTemplateActionTimerExternalsStorageBlockAttrArgsDict']]
        """
        HDD local storage attributes.
        """
        unsupport_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Unsupported network type.
        """
elif False:
    LaunchTemplateActionTimerExternalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateActionTimerExternalsArgs:
    def __init__(__self__, *,
                 release_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 storage_block_attr: Optional[pulumi.Input['LaunchTemplateActionTimerExternalsStorageBlockAttrArgs']] = None,
                 unsupport_networks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] release_address: Release address.
        :param pulumi.Input['LaunchTemplateActionTimerExternalsStorageBlockAttrArgs'] storage_block_attr: HDD local storage attributes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] unsupport_networks: Unsupported network type.
        """
        if release_address is not None:
            pulumi.set(__self__, "release_address", release_address)
        if storage_block_attr is not None:
            pulumi.set(__self__, "storage_block_attr", storage_block_attr)
        if unsupport_networks is not None:
            pulumi.set(__self__, "unsupport_networks", unsupport_networks)

    @_builtins.property
    @pulumi.getter(name="releaseAddress")
    def release_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Release address.
        """
        return pulumi.get(self, "release_address")

    @release_address.setter
    def release_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "release_address", value)

    @_builtins.property
    @pulumi.getter(name="storageBlockAttr")
    def storage_block_attr(self) -> Optional[pulumi.Input['LaunchTemplateActionTimerExternalsStorageBlockAttrArgs']]:
        """
        HDD local storage attributes.
        """
        return pulumi.get(self, "storage_block_attr")

    @storage_block_attr.setter
    def storage_block_attr(self, value: Optional[pulumi.Input['LaunchTemplateActionTimerExternalsStorageBlockAttrArgs']]):
        pulumi.set(self, "storage_block_attr", value)

    @_builtins.property
    @pulumi.getter(name="unsupportNetworks")
    def unsupport_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Unsupported network type.
        """
        return pulumi.get(self, "unsupport_networks")

    @unsupport_networks.setter
    def unsupport_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "unsupport_networks", value)


if not MYPY:
    class LaunchTemplateActionTimerExternalsStorageBlockAttrArgsDict(TypedDict):
        max_size: pulumi.Input[_builtins.int]
        """
        The maximum capacity of HDD local storage.
        """
        min_size: pulumi.Input[_builtins.int]
        """
        The minimum capacity of HDD local storage.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of HDD local storage.
        """
elif False:
    LaunchTemplateActionTimerExternalsStorageBlockAttrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateActionTimerExternalsStorageBlockAttrArgs:
    def __init__(__self__, *,
                 max_size: pulumi.Input[_builtins.int],
                 min_size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] max_size: The maximum capacity of HDD local storage.
        :param pulumi.Input[_builtins.int] min_size: The minimum capacity of HDD local storage.
        :param pulumi.Input[_builtins.str] type: The type of HDD local storage.
        """
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum capacity of HDD local storage.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum capacity of HDD local storage.
        """
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of HDD local storage.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LaunchTemplateDataDiskArgsDict(TypedDict):
        disk_size: pulumi.Input[_builtins.int]
        """
        The size of the data disk.
        """
        cdc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud Dedicated Cluster(CDC) ID.
        """
        delete_with_instance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the data disk is destroyed along with the instance, true or false.
        """
        disk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data disk ID.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of data disk.
        """
        encrypt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the data disk is encrypted, TRUE or FALSE.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of custom CMK.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data disk snapshot ID.
        """
        throughput_performance: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk performance, MB/s.
        """
elif False:
    LaunchTemplateDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateDataDiskArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[_builtins.int],
                 cdc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_with_instance: Optional[pulumi.Input[_builtins.bool]] = None,
                 disk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypt: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput_performance: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] disk_size: The size of the data disk.
        :param pulumi.Input[_builtins.str] cdc_id: Cloud Dedicated Cluster(CDC) ID.
        :param pulumi.Input[_builtins.bool] delete_with_instance: Whether the data disk is destroyed along with the instance, true or false.
        :param pulumi.Input[_builtins.str] disk_id: Data disk ID.
        :param pulumi.Input[_builtins.str] disk_type: The type of data disk.
        :param pulumi.Input[_builtins.bool] encrypt: Whether the data disk is encrypted, TRUE or FALSE.
        :param pulumi.Input[_builtins.str] kms_key_id: The id of custom CMK.
        :param pulumi.Input[_builtins.str] snapshot_id: Data disk snapshot ID.
        :param pulumi.Input[_builtins.int] throughput_performance: Cloud disk performance, MB/s.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[_builtins.int]:
        """
        The size of the data disk.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud Dedicated Cluster(CDC) ID.
        """
        return pulumi.get(self, "cdc_id")

    @cdc_id.setter
    def cdc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cdc_id", value)

    @_builtins.property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the data disk is destroyed along with the instance, true or false.
        """
        return pulumi.get(self, "delete_with_instance")

    @delete_with_instance.setter
    def delete_with_instance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_with_instance", value)

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data disk ID.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_id", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of data disk.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the data disk is encrypted, TRUE or FALSE.
        """
        return pulumi.get(self, "encrypt")

    @encrypt.setter
    def encrypt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypt", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of custom CMK.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data disk snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk performance, MB/s.
        """
        return pulumi.get(self, "throughput_performance")

    @throughput_performance.setter
    def throughput_performance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput_performance", value)


if not MYPY:
    class LaunchTemplateEnhancedServiceArgsDict(TypedDict):
        automation_service: NotRequired[pulumi.Input['LaunchTemplateEnhancedServiceAutomationServiceArgsDict']]
        """
        Enable TencentCloud Automation Tools(TAT).
        """
        monitor_service: NotRequired[pulumi.Input['LaunchTemplateEnhancedServiceMonitorServiceArgsDict']]
        """
        Enable cloud monitor service.
        """
        security_service: NotRequired[pulumi.Input['LaunchTemplateEnhancedServiceSecurityServiceArgsDict']]
        """
        Enable cloud security service.
        """
elif False:
    LaunchTemplateEnhancedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEnhancedServiceArgs:
    def __init__(__self__, *,
                 automation_service: Optional[pulumi.Input['LaunchTemplateEnhancedServiceAutomationServiceArgs']] = None,
                 monitor_service: Optional[pulumi.Input['LaunchTemplateEnhancedServiceMonitorServiceArgs']] = None,
                 security_service: Optional[pulumi.Input['LaunchTemplateEnhancedServiceSecurityServiceArgs']] = None):
        """
        :param pulumi.Input['LaunchTemplateEnhancedServiceAutomationServiceArgs'] automation_service: Enable TencentCloud Automation Tools(TAT).
        :param pulumi.Input['LaunchTemplateEnhancedServiceMonitorServiceArgs'] monitor_service: Enable cloud monitor service.
        :param pulumi.Input['LaunchTemplateEnhancedServiceSecurityServiceArgs'] security_service: Enable cloud security service.
        """
        if automation_service is not None:
            pulumi.set(__self__, "automation_service", automation_service)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if security_service is not None:
            pulumi.set(__self__, "security_service", security_service)

    @_builtins.property
    @pulumi.getter(name="automationService")
    def automation_service(self) -> Optional[pulumi.Input['LaunchTemplateEnhancedServiceAutomationServiceArgs']]:
        """
        Enable TencentCloud Automation Tools(TAT).
        """
        return pulumi.get(self, "automation_service")

    @automation_service.setter
    def automation_service(self, value: Optional[pulumi.Input['LaunchTemplateEnhancedServiceAutomationServiceArgs']]):
        pulumi.set(self, "automation_service", value)

    @_builtins.property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional[pulumi.Input['LaunchTemplateEnhancedServiceMonitorServiceArgs']]:
        """
        Enable cloud monitor service.
        """
        return pulumi.get(self, "monitor_service")

    @monitor_service.setter
    def monitor_service(self, value: Optional[pulumi.Input['LaunchTemplateEnhancedServiceMonitorServiceArgs']]):
        pulumi.set(self, "monitor_service", value)

    @_builtins.property
    @pulumi.getter(name="securityService")
    def security_service(self) -> Optional[pulumi.Input['LaunchTemplateEnhancedServiceSecurityServiceArgs']]:
        """
        Enable cloud security service.
        """
        return pulumi.get(self, "security_service")

    @security_service.setter
    def security_service(self, value: Optional[pulumi.Input['LaunchTemplateEnhancedServiceSecurityServiceArgs']]):
        pulumi.set(self, "security_service", value)


if not MYPY:
    class LaunchTemplateEnhancedServiceAutomationServiceArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable TencentCloud Automation Tools(TAT), TRUE or FALSE.
        """
elif False:
    LaunchTemplateEnhancedServiceAutomationServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEnhancedServiceAutomationServiceArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable TencentCloud Automation Tools(TAT), TRUE or FALSE.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable TencentCloud Automation Tools(TAT), TRUE or FALSE.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateEnhancedServiceMonitorServiceArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable cloud monitor service, TRUE or FALSE.
        """
elif False:
    LaunchTemplateEnhancedServiceMonitorServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEnhancedServiceMonitorServiceArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable cloud monitor service, TRUE or FALSE.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable cloud monitor service, TRUE or FALSE.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateEnhancedServiceSecurityServiceArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable cloud security service, TRUE or FALSE.
        """
elif False:
    LaunchTemplateEnhancedServiceSecurityServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEnhancedServiceSecurityServiceArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable cloud security service, TRUE or FALSE.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable cloud security service, TRUE or FALSE.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateInstanceChargePrepaidArgsDict(TypedDict):
        period: pulumi.Input[_builtins.int]
        """
        The period of purchasing instances.
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Automatic renew flag.
        """
elif False:
    LaunchTemplateInstanceChargePrepaidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateInstanceChargePrepaidArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[_builtins.int],
                 renew_flag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] period: The period of purchasing instances.
        :param pulumi.Input[_builtins.str] renew_flag: Automatic renew flag.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        The period of purchasing instances.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Automatic renew flag.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_flag", value)


if not MYPY:
    class LaunchTemplateInstanceMarketOptionsArgsDict(TypedDict):
        spot_options: pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgsDict']
        """
        Bidding related options.
        """
        market_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Market option type, currently only supports value: spot.
        """
elif False:
    LaunchTemplateInstanceMarketOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateInstanceMarketOptionsArgs:
    def __init__(__self__, *,
                 spot_options: pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs'],
                 market_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs'] spot_options: Bidding related options.
        :param pulumi.Input[_builtins.str] market_type: Market option type, currently only supports value: spot.
        """
        pulumi.set(__self__, "spot_options", spot_options)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']:
        """
        Bidding related options.
        """
        return pulumi.get(self, "spot_options")

    @spot_options.setter
    def spot_options(self, value: pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']):
        pulumi.set(self, "spot_options", value)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Market option type, currently only supports value: spot.
        """
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "market_type", value)


if not MYPY:
    class LaunchTemplateInstanceMarketOptionsSpotOptionsArgsDict(TypedDict):
        max_price: pulumi.Input[_builtins.str]
        """
        Bidding.
        """
        spot_instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bidding request type, currently only supported type: one-time.
        """
elif False:
    LaunchTemplateInstanceMarketOptionsSpotOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateInstanceMarketOptionsSpotOptionsArgs:
    def __init__(__self__, *,
                 max_price: pulumi.Input[_builtins.str],
                 spot_instance_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] max_price: Bidding.
        :param pulumi.Input[_builtins.str] spot_instance_type: Bidding request type, currently only supported type: one-time.
        """
        pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> pulumi.Input[_builtins.str]:
        """
        Bidding.
        """
        return pulumi.get(self, "max_price")

    @max_price.setter
    def max_price(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "max_price", value)

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bidding request type, currently only supported type: one-time.
        """
        return pulumi.get(self, "spot_instance_type")

    @spot_instance_type.setter
    def spot_instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_instance_type", value)


if not MYPY:
    class LaunchTemplateInternetAccessibleArgsDict(TypedDict):
        bandwidth_package_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of bandwidth package.
        """
        internet_charge_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of internet charge.
        """
        internet_max_bandwidth_out: NotRequired[pulumi.Input[_builtins.int]]
        """
        Internet outbound bandwidth upper limit, Mbps.
        """
        public_ip_assigned: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allocate public network IP, TRUE or FALSE.
        """
elif False:
    LaunchTemplateInternetAccessibleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateInternetAccessibleArgs:
    def __init__(__self__, *,
                 bandwidth_package_id: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_charge_type: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_max_bandwidth_out: Optional[pulumi.Input[_builtins.int]] = None,
                 public_ip_assigned: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] bandwidth_package_id: The ID of bandwidth package.
        :param pulumi.Input[_builtins.str] internet_charge_type: The type of internet charge.
        :param pulumi.Input[_builtins.int] internet_max_bandwidth_out: Internet outbound bandwidth upper limit, Mbps.
        :param pulumi.Input[_builtins.bool] public_ip_assigned: Whether to allocate public network IP, TRUE or FALSE.
        """
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of bandwidth package.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @bandwidth_package_id.setter
    def bandwidth_package_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_package_id", value)

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of internet charge.
        """
        return pulumi.get(self, "internet_charge_type")

    @internet_charge_type.setter
    def internet_charge_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "internet_charge_type", value)

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Internet outbound bandwidth upper limit, Mbps.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @internet_max_bandwidth_out.setter
    def internet_max_bandwidth_out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "internet_max_bandwidth_out", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allocate public network IP, TRUE or FALSE.
        """
        return pulumi.get(self, "public_ip_assigned")

    @public_ip_assigned.setter
    def public_ip_assigned(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "public_ip_assigned", value)


if not MYPY:
    class LaunchTemplateLoginSettingsArgsDict(TypedDict):
        keep_image_login: NotRequired[pulumi.Input[_builtins.str]]
        """
        Keep the original settings of the mirror.
        """
        key_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of key ID.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The login password of instance.
        """
elif False:
    LaunchTemplateLoginSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateLoginSettingsArgs:
    def __init__(__self__, *,
                 keep_image_login: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] keep_image_login: Keep the original settings of the mirror.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_ids: List of key ID.
        :param pulumi.Input[_builtins.str] password: The login password of instance.
        """
        if keep_image_login is not None:
            pulumi.set(__self__, "keep_image_login", keep_image_login)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="keepImageLogin")
    def keep_image_login(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Keep the original settings of the mirror.
        """
        return pulumi.get(self, "keep_image_login")

    @keep_image_login.setter
    def keep_image_login(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keep_image_login", value)

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of key ID.
        """
        return pulumi.get(self, "key_ids")

    @key_ids.setter
    def key_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_ids", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The login password of instance.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class LaunchTemplatePlacementArgsDict(TypedDict):
        zone: pulumi.Input[_builtins.str]
        """
        The available zone ID of the instance.
        """
        host_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The CDH ID list of the instance(input).
        """
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        It has been deprecated from version 1.81.108. Specify the host machine ip.
        """
        project_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The project ID of the instance.
        """
elif False:
    LaunchTemplatePlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplatePlacementArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[_builtins.str],
                 host_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 project_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] zone: The available zone ID of the instance.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] host_ids: The CDH ID list of the instance(input).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] host_ips: It has been deprecated from version 1.81.108. Specify the host machine ip.
        :param pulumi.Input[_builtins.int] project_id: The project ID of the instance.
        """
        pulumi.set(__self__, "zone", zone)
        if host_ids is not None:
            pulumi.set(__self__, "host_ids", host_ids)
        if host_ips is not None:
            warnings.warn("""It has been deprecated from version 1.81.108.""", DeprecationWarning)
            pulumi.log.warn("""host_ips is deprecated: It has been deprecated from version 1.81.108.""")
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        The available zone ID of the instance.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)

    @_builtins.property
    @pulumi.getter(name="hostIds")
    def host_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The CDH ID list of the instance(input).
        """
        return pulumi.get(self, "host_ids")

    @host_ids.setter
    def host_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "host_ids", value)

    @_builtins.property
    @pulumi.getter(name="hostIps")
    @_utilities.deprecated("""It has been deprecated from version 1.81.108.""")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        It has been deprecated from version 1.81.108. Specify the host machine ip.
        """
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "host_ips", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The project ID of the instance.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class LaunchTemplateSystemDiskArgsDict(TypedDict):
        cdc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud Dedicated Cluster(CDC) ID.
        """
        disk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        System disk ID.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of system disk.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of system disk.
        """
elif False:
    LaunchTemplateSystemDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateSystemDiskArgs:
    def __init__(__self__, *,
                 cdc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cdc_id: Cloud Dedicated Cluster(CDC) ID.
        :param pulumi.Input[_builtins.str] disk_id: System disk ID.
        :param pulumi.Input[_builtins.int] disk_size: The size of system disk.
        :param pulumi.Input[_builtins.str] disk_type: The type of system disk.
        """
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud Dedicated Cluster(CDC) ID.
        """
        return pulumi.get(self, "cdc_id")

    @cdc_id.setter
    def cdc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cdc_id", value)

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        System disk ID.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_id", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of system disk.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of system disk.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)


if not MYPY:
    class LaunchTemplateTagSpecificationArgsDict(TypedDict):
        resource_type: pulumi.Input[_builtins.str]
        """
        The type of resource.
        """
        tags: pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagSpecificationTagArgsDict']]]
        """
        Tag list.
        """
elif False:
    LaunchTemplateTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[_builtins.str],
                 tags: pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagSpecificationTagArgs']]]):
        """
        :param pulumi.Input[_builtins.str] resource_type: The type of resource.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagSpecificationTagArgs']]] tags: Tag list.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of resource.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagSpecificationTagArgs']]]:
        """
        Tag list.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagSpecificationTagArgs']]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class LaunchTemplateTagSpecificationTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of tag.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of tag.
        """
elif False:
    LaunchTemplateTagSpecificationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateTagSpecificationTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The key of tag.
        :param pulumi.Input[_builtins.str] value: The value of tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LaunchTemplateVersionActionTimerArgsDict(TypedDict):
        action_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution time, displayed according to ISO8601 standard, and UTC time is used. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution must be at least 5 minutes later than the current time.
        """
        externals: NotRequired[pulumi.Input['LaunchTemplateVersionActionTimerExternalsArgsDict']]
        """
        Additional data.
        """
        timer_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timer name. Currently TerminateInstances is the only supported value.
        """
elif False:
    LaunchTemplateVersionActionTimerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionActionTimerArgs:
    def __init__(__self__, *,
                 action_time: Optional[pulumi.Input[_builtins.str]] = None,
                 externals: Optional[pulumi.Input['LaunchTemplateVersionActionTimerExternalsArgs']] = None,
                 timer_action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_time: Execution time, displayed according to ISO8601 standard, and UTC time is used. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution must be at least 5 minutes later than the current time.
        :param pulumi.Input['LaunchTemplateVersionActionTimerExternalsArgs'] externals: Additional data.
        :param pulumi.Input[_builtins.str] timer_action: Timer name. Currently TerminateInstances is the only supported value.
        """
        if action_time is not None:
            pulumi.set(__self__, "action_time", action_time)
        if externals is not None:
            pulumi.set(__self__, "externals", externals)
        if timer_action is not None:
            pulumi.set(__self__, "timer_action", timer_action)

    @_builtins.property
    @pulumi.getter(name="actionTime")
    def action_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution time, displayed according to ISO8601 standard, and UTC time is used. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution must be at least 5 minutes later than the current time.
        """
        return pulumi.get(self, "action_time")

    @action_time.setter
    def action_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_time", value)

    @_builtins.property
    @pulumi.getter
    def externals(self) -> Optional[pulumi.Input['LaunchTemplateVersionActionTimerExternalsArgs']]:
        """
        Additional data.
        """
        return pulumi.get(self, "externals")

    @externals.setter
    def externals(self, value: Optional[pulumi.Input['LaunchTemplateVersionActionTimerExternalsArgs']]):
        pulumi.set(self, "externals", value)

    @_builtins.property
    @pulumi.getter(name="timerAction")
    def timer_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timer name. Currently TerminateInstances is the only supported value.
        """
        return pulumi.get(self, "timer_action")

    @timer_action.setter
    def timer_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timer_action", value)


if not MYPY:
    class LaunchTemplateVersionActionTimerExternalsArgsDict(TypedDict):
        release_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Release address.
        """
        storage_block_attr: NotRequired[pulumi.Input['LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgsDict']]
        """
        Information on local HDD storage.
        """
        unsupport_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Not supported network.
        """
elif False:
    LaunchTemplateVersionActionTimerExternalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionActionTimerExternalsArgs:
    def __init__(__self__, *,
                 release_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 storage_block_attr: Optional[pulumi.Input['LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgs']] = None,
                 unsupport_networks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] release_address: Release address.
        :param pulumi.Input['LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgs'] storage_block_attr: Information on local HDD storage.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] unsupport_networks: Not supported network.
        """
        if release_address is not None:
            pulumi.set(__self__, "release_address", release_address)
        if storage_block_attr is not None:
            pulumi.set(__self__, "storage_block_attr", storage_block_attr)
        if unsupport_networks is not None:
            pulumi.set(__self__, "unsupport_networks", unsupport_networks)

    @_builtins.property
    @pulumi.getter(name="releaseAddress")
    def release_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Release address.
        """
        return pulumi.get(self, "release_address")

    @release_address.setter
    def release_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "release_address", value)

    @_builtins.property
    @pulumi.getter(name="storageBlockAttr")
    def storage_block_attr(self) -> Optional[pulumi.Input['LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgs']]:
        """
        Information on local HDD storage.
        """
        return pulumi.get(self, "storage_block_attr")

    @storage_block_attr.setter
    def storage_block_attr(self, value: Optional[pulumi.Input['LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgs']]):
        pulumi.set(self, "storage_block_attr", value)

    @_builtins.property
    @pulumi.getter(name="unsupportNetworks")
    def unsupport_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Not supported network.
        """
        return pulumi.get(self, "unsupport_networks")

    @unsupport_networks.setter
    def unsupport_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "unsupport_networks", value)


if not MYPY:
    class LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgsDict(TypedDict):
        max_size: pulumi.Input[_builtins.int]
        """
        Maximum capacity of local HDD storage.
        """
        min_size: pulumi.Input[_builtins.int]
        """
        Minimum capacity of local HDD storage.
        """
        type: pulumi.Input[_builtins.str]
        """
        Local HDD storage type. Value: LOCAL_PRO.
        """
elif False:
    LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionActionTimerExternalsStorageBlockAttrArgs:
    def __init__(__self__, *,
                 max_size: pulumi.Input[_builtins.int],
                 min_size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] max_size: Maximum capacity of local HDD storage.
        :param pulumi.Input[_builtins.int] min_size: Minimum capacity of local HDD storage.
        :param pulumi.Input[_builtins.str] type: Local HDD storage type. Value: LOCAL_PRO.
        """
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum capacity of local HDD storage.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum capacity of local HDD storage.
        """
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Local HDD storage type. Value: LOCAL_PRO.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LaunchTemplateVersionDataDiskArgsDict(TypedDict):
        disk_size: pulumi.Input[_builtins.int]
        """
        Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type.
        """
        cdc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        delete_with_instance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to terminate the data disk when its CVM is terminated. Default value: `true`.
        """
        disk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of data disk.
        """
        encrypt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the data disk is encrypted.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the custom CMK in the format of UUID or `kms-abcd1234`.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk. Note: This field may return null, indicating that no valid value is found.
        """
        throughput_performance: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk performance in MB/s.
        """
elif False:
    LaunchTemplateVersionDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionDataDiskArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[_builtins.int],
                 cdc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_with_instance: Optional[pulumi.Input[_builtins.bool]] = None,
                 disk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypt: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput_performance: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] disk_size: Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type.
        :param pulumi.Input[_builtins.str] cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param pulumi.Input[_builtins.bool] delete_with_instance: Whether to terminate the data disk when its CVM is terminated. Default value: `true`.
        :param pulumi.Input[_builtins.str] disk_id: System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        :param pulumi.Input[_builtins.str] disk_type: The type of data disk.
        :param pulumi.Input[_builtins.bool] encrypt: Specifies whether the data disk is encrypted.
        :param pulumi.Input[_builtins.str] kms_key_id: ID of the custom CMK in the format of UUID or `kms-abcd1234`.
        :param pulumi.Input[_builtins.str] snapshot_id: Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk. Note: This field may return null, indicating that no valid value is found.
        :param pulumi.Input[_builtins.int] throughput_performance: Cloud disk performance in MB/s.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[_builtins.int]:
        """
        Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @cdc_id.setter
    def cdc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cdc_id", value)

    @_builtins.property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to terminate the data disk when its CVM is terminated. Default value: `true`.
        """
        return pulumi.get(self, "delete_with_instance")

    @delete_with_instance.setter
    def delete_with_instance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_with_instance", value)

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_id", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of data disk.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the data disk is encrypted.
        """
        return pulumi.get(self, "encrypt")

    @encrypt.setter
    def encrypt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypt", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the custom CMK in the format of UUID or `kms-abcd1234`.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk. Note: This field may return null, indicating that no valid value is found.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk performance in MB/s.
        """
        return pulumi.get(self, "throughput_performance")

    @throughput_performance.setter
    def throughput_performance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput_performance", value)


if not MYPY:
    class LaunchTemplateVersionEnhancedServiceArgsDict(TypedDict):
        automation_service: NotRequired[pulumi.Input['LaunchTemplateVersionEnhancedServiceAutomationServiceArgsDict']]
        """
        Whether to enable the TAT service. If this parameter is not specified, the TAT service is enabled for public images and disabled for other images by default.
        """
        monitor_service: NotRequired[pulumi.Input['LaunchTemplateVersionEnhancedServiceMonitorServiceArgsDict']]
        """
        Enables cloud monitor service. If this parameter is not specified, the cloud monitor service will be enabled by default.
        """
        security_service: NotRequired[pulumi.Input['LaunchTemplateVersionEnhancedServiceSecurityServiceArgsDict']]
        """
        Enables cloud security service. If this parameter is not specified, the cloud security service will be enabled by default.
        """
elif False:
    LaunchTemplateVersionEnhancedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionEnhancedServiceArgs:
    def __init__(__self__, *,
                 automation_service: Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceAutomationServiceArgs']] = None,
                 monitor_service: Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceMonitorServiceArgs']] = None,
                 security_service: Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceSecurityServiceArgs']] = None):
        """
        :param pulumi.Input['LaunchTemplateVersionEnhancedServiceAutomationServiceArgs'] automation_service: Whether to enable the TAT service. If this parameter is not specified, the TAT service is enabled for public images and disabled for other images by default.
        :param pulumi.Input['LaunchTemplateVersionEnhancedServiceMonitorServiceArgs'] monitor_service: Enables cloud monitor service. If this parameter is not specified, the cloud monitor service will be enabled by default.
        :param pulumi.Input['LaunchTemplateVersionEnhancedServiceSecurityServiceArgs'] security_service: Enables cloud security service. If this parameter is not specified, the cloud security service will be enabled by default.
        """
        if automation_service is not None:
            pulumi.set(__self__, "automation_service", automation_service)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if security_service is not None:
            pulumi.set(__self__, "security_service", security_service)

    @_builtins.property
    @pulumi.getter(name="automationService")
    def automation_service(self) -> Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceAutomationServiceArgs']]:
        """
        Whether to enable the TAT service. If this parameter is not specified, the TAT service is enabled for public images and disabled for other images by default.
        """
        return pulumi.get(self, "automation_service")

    @automation_service.setter
    def automation_service(self, value: Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceAutomationServiceArgs']]):
        pulumi.set(self, "automation_service", value)

    @_builtins.property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceMonitorServiceArgs']]:
        """
        Enables cloud monitor service. If this parameter is not specified, the cloud monitor service will be enabled by default.
        """
        return pulumi.get(self, "monitor_service")

    @monitor_service.setter
    def monitor_service(self, value: Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceMonitorServiceArgs']]):
        pulumi.set(self, "monitor_service", value)

    @_builtins.property
    @pulumi.getter(name="securityService")
    def security_service(self) -> Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceSecurityServiceArgs']]:
        """
        Enables cloud security service. If this parameter is not specified, the cloud security service will be enabled by default.
        """
        return pulumi.get(self, "security_service")

    @security_service.setter
    def security_service(self, value: Optional[pulumi.Input['LaunchTemplateVersionEnhancedServiceSecurityServiceArgs']]):
        pulumi.set(self, "security_service", value)


if not MYPY:
    class LaunchTemplateVersionEnhancedServiceAutomationServiceArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable the TAT service.
        """
elif False:
    LaunchTemplateVersionEnhancedServiceAutomationServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionEnhancedServiceAutomationServiceArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable the TAT service.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable the TAT service.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateVersionEnhancedServiceMonitorServiceArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Cloud Monitor.
        """
elif False:
    LaunchTemplateVersionEnhancedServiceMonitorServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionEnhancedServiceMonitorServiceArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable Cloud Monitor.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Cloud Monitor.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateVersionEnhancedServiceSecurityServiceArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Cloud Security.
        """
elif False:
    LaunchTemplateVersionEnhancedServiceSecurityServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionEnhancedServiceSecurityServiceArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable Cloud Security.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Cloud Security.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateVersionInstanceChargePrepaidArgsDict(TypedDict):
        period: pulumi.Input[_builtins.int]
        """
        Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Auto renewal flag. Valid values: NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically &lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
elif False:
    LaunchTemplateVersionInstanceChargePrepaidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionInstanceChargePrepaidArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[_builtins.int],
                 renew_flag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] period: Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        :param pulumi.Input[_builtins.str] renew_flag: Auto renewal flag. Valid values: NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically &lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Auto renewal flag. Valid values: NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically &lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_flag", value)


if not MYPY:
    class LaunchTemplateVersionInstanceMarketOptionsArgsDict(TypedDict):
        spot_options: pulumi.Input['LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgsDict']
        """
        Options related to bidding.
        """
        market_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Market option type. Currently spot is the only supported value.
        """
elif False:
    LaunchTemplateVersionInstanceMarketOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionInstanceMarketOptionsArgs:
    def __init__(__self__, *,
                 spot_options: pulumi.Input['LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgs'],
                 market_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgs'] spot_options: Options related to bidding.
        :param pulumi.Input[_builtins.str] market_type: Market option type. Currently spot is the only supported value.
        """
        pulumi.set(__self__, "spot_options", spot_options)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> pulumi.Input['LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgs']:
        """
        Options related to bidding.
        """
        return pulumi.get(self, "spot_options")

    @spot_options.setter
    def spot_options(self, value: pulumi.Input['LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgs']):
        pulumi.set(self, "spot_options", value)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Market option type. Currently spot is the only supported value.
        """
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "market_type", value)


if not MYPY:
    class LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgsDict(TypedDict):
        max_price: pulumi.Input[_builtins.str]
        """
        Bidding price.
        """
        spot_instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bidding request type. Currently only one-time is supported.
        """
elif False:
    LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionInstanceMarketOptionsSpotOptionsArgs:
    def __init__(__self__, *,
                 max_price: pulumi.Input[_builtins.str],
                 spot_instance_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] max_price: Bidding price.
        :param pulumi.Input[_builtins.str] spot_instance_type: Bidding request type. Currently only one-time is supported.
        """
        pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> pulumi.Input[_builtins.str]:
        """
        Bidding price.
        """
        return pulumi.get(self, "max_price")

    @max_price.setter
    def max_price(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "max_price", value)

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bidding request type. Currently only one-time is supported.
        """
        return pulumi.get(self, "spot_instance_type")

    @spot_instance_type.setter
    def spot_instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_instance_type", value)


if not MYPY:
    class LaunchTemplateVersionInternetAccessibleArgsDict(TypedDict):
        bandwidth_package_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bandwidth package ID.
        """
        internet_charge_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network connection billing plan.
        """
        internet_max_bandwidth_out: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum outbound bandwidth of the public network, in Mbps. The default value is 0 Mbps.
        """
        public_ip_assigned: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to assign a public IP.
        """
elif False:
    LaunchTemplateVersionInternetAccessibleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionInternetAccessibleArgs:
    def __init__(__self__, *,
                 bandwidth_package_id: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_charge_type: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_max_bandwidth_out: Optional[pulumi.Input[_builtins.int]] = None,
                 public_ip_assigned: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] bandwidth_package_id: Bandwidth package ID.
        :param pulumi.Input[_builtins.str] internet_charge_type: Network connection billing plan.
        :param pulumi.Input[_builtins.int] internet_max_bandwidth_out: The maximum outbound bandwidth of the public network, in Mbps. The default value is 0 Mbps.
        :param pulumi.Input[_builtins.bool] public_ip_assigned: Whether to assign a public IP.
        """
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bandwidth package ID.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @bandwidth_package_id.setter
    def bandwidth_package_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_package_id", value)

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network connection billing plan.
        """
        return pulumi.get(self, "internet_charge_type")

    @internet_charge_type.setter
    def internet_charge_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "internet_charge_type", value)

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum outbound bandwidth of the public network, in Mbps. The default value is 0 Mbps.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @internet_max_bandwidth_out.setter
    def internet_max_bandwidth_out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "internet_max_bandwidth_out", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to assign a public IP.
        """
        return pulumi.get(self, "public_ip_assigned")

    @public_ip_assigned.setter
    def public_ip_assigned(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "public_ip_assigned", value)


if not MYPY:
    class LaunchTemplateVersionLoginSettingsArgsDict(TypedDict):
        keep_image_login: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to keep the original settings of an image.
        """
        key_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of key IDs. After an instance is associated with a key, you can access the instance with the private key in the key pair.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Login password of the instance.
        """
elif False:
    LaunchTemplateVersionLoginSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionLoginSettingsArgs:
    def __init__(__self__, *,
                 keep_image_login: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] keep_image_login: Whether to keep the original settings of an image.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_ids: List of key IDs. After an instance is associated with a key, you can access the instance with the private key in the key pair.
        :param pulumi.Input[_builtins.str] password: Login password of the instance.
        """
        if keep_image_login is not None:
            pulumi.set(__self__, "keep_image_login", keep_image_login)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="keepImageLogin")
    def keep_image_login(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to keep the original settings of an image.
        """
        return pulumi.get(self, "keep_image_login")

    @keep_image_login.setter
    def keep_image_login(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keep_image_login", value)

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of key IDs. After an instance is associated with a key, you can access the instance with the private key in the key pair.
        """
        return pulumi.get(self, "key_ids")

    @key_ids.setter
    def key_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_ids", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Login password of the instance.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class LaunchTemplateVersionPlacementArgsDict(TypedDict):
        zone: pulumi.Input[_builtins.str]
        """
        ID of the availability zone where the instance resides. You can call the DescribeZones API and obtain the ID in the returned Zone field.
        """
        host_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
        """
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IPs of the hosts to create CVMs.
        """
        project_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
        """
elif False:
    LaunchTemplateVersionPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionPlacementArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[_builtins.str],
                 host_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 project_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] zone: ID of the availability zone where the instance resides. You can call the DescribeZones API and obtain the ID in the returned Zone field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] host_ids: ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] host_ips: IPs of the hosts to create CVMs.
        :param pulumi.Input[_builtins.int] project_id: ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
        """
        pulumi.set(__self__, "zone", zone)
        if host_ids is not None:
            pulumi.set(__self__, "host_ids", host_ids)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the availability zone where the instance resides. You can call the DescribeZones API and obtain the ID in the returned Zone field.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)

    @_builtins.property
    @pulumi.getter(name="hostIds")
    def host_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
        """
        return pulumi.get(self, "host_ids")

    @host_ids.setter
    def host_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "host_ids", value)

    @_builtins.property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IPs of the hosts to create CVMs.
        """
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "host_ips", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class LaunchTemplateVersionSystemDiskArgsDict(TypedDict):
        cdc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        disk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        System disk size; unit: GB; default value: 50 GB.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of system disk. Default value: the type of hard disk currently in stock.
        """
elif False:
    LaunchTemplateVersionSystemDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionSystemDiskArgs:
    def __init__(__self__, *,
                 cdc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param pulumi.Input[_builtins.str] disk_id: System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        :param pulumi.Input[_builtins.int] disk_size: System disk size; unit: GB; default value: 50 GB.
        :param pulumi.Input[_builtins.str] disk_type: The type of system disk. Default value: the type of hard disk currently in stock.
        """
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @cdc_id.setter
    def cdc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cdc_id", value)

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_id", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        System disk size; unit: GB; default value: 50 GB.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of system disk. Default value: the type of hard disk currently in stock.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)


if not MYPY:
    class LaunchTemplateVersionTagSpecificationArgsDict(TypedDict):
        resource_type: pulumi.Input[_builtins.str]
        """
        The type of resource that the tag is bound to.
        """
        tags: pulumi.Input[Sequence[pulumi.Input['LaunchTemplateVersionTagSpecificationTagArgsDict']]]
        """
        List of tags.
        """
elif False:
    LaunchTemplateVersionTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[_builtins.str],
                 tags: pulumi.Input[Sequence[pulumi.Input['LaunchTemplateVersionTagSpecificationTagArgs']]]):
        """
        :param pulumi.Input[_builtins.str] resource_type: The type of resource that the tag is bound to.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateVersionTagSpecificationTagArgs']]] tags: List of tags.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of resource that the tag is bound to.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input['LaunchTemplateVersionTagSpecificationTagArgs']]]:
        """
        List of tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input['LaunchTemplateVersionTagSpecificationTagArgs']]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class LaunchTemplateVersionTagSpecificationTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Tag value.
        """
elif False:
    LaunchTemplateVersionTagSpecificationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionTagSpecificationTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Tag key.
        :param pulumi.Input[_builtins.str] value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LaunchTemplateVersionVirtualPrivateCloudArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        VPC subnet ID in the format subnet-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        VPC ID in the format of vpc-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        as_vpc_gateway: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC.
        """
        ipv6_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
elif False:
    LaunchTemplateVersionVirtualPrivateCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVersionVirtualPrivateCloudArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 as_vpc_gateway: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: VPC subnet ID in the format subnet-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param pulumi.Input[_builtins.str] vpc_id: VPC ID in the format of vpc-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        :param pulumi.Input[_builtins.bool] as_vpc_gateway: Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC.
        :param pulumi.Input[_builtins.int] ipv6_address_count: Number of IPv6 addresses randomly generated for the ENI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_ip_addresses: Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        VPC subnet ID in the format subnet-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        VPC ID in the format of vpc-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @as_vpc_gateway.setter
    def as_vpc_gateway(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_vpc_gateway", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of IPv6 addresses randomly generated for the ENI.
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
        """
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_ip_addresses", value)


if not MYPY:
    class LaunchTemplateVirtualPrivateCloudArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        The id of subnet.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        The id of VPC.
        """
        as_vpc_gateway: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is it used as a Public network gateway, TRUE or FALSE.
        """
        ipv6_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of ipv6 addresses for Elastic Network Interface.
        """
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The address of private ip.
        """
elif False:
    LaunchTemplateVirtualPrivateCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVirtualPrivateCloudArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 as_vpc_gateway: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: The id of subnet.
        :param pulumi.Input[_builtins.str] vpc_id: The id of VPC.
        :param pulumi.Input[_builtins.bool] as_vpc_gateway: Is it used as a Public network gateway, TRUE or FALSE.
        :param pulumi.Input[_builtins.int] ipv6_address_count: The number of ipv6 addresses for Elastic Network Interface.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_ip_addresses: The address of private ip.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if as_vpc_gateway is not None:
            pulumi.set(__self__, "as_vpc_gateway", as_vpc_gateway)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        The id of subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        The id of VPC.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="asVpcGateway")
    def as_vpc_gateway(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is it used as a Public network gateway, TRUE or FALSE.
        """
        return pulumi.get(self, "as_vpc_gateway")

    @as_vpc_gateway.setter
    def as_vpc_gateway(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_vpc_gateway", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of ipv6 addresses for Elastic Network Interface.
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The address of private ip.
        """
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_ip_addresses", value)


if not MYPY:
    class ModifyInstanceDiskTypeDataDiskArgsDict(TypedDict):
        disk_size: pulumi.Input[_builtins.int]
        """
        Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type. The default value is 0, indicating that no data disk is purchased. For more information, see the product documentation.
        """
        cdc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        delete_with_instance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to terminate the data disk when its CVM is terminated. Valid values:
        - TRUE: terminate the data disk when its CVM is terminated. This value only supports pay-as-you-go cloud disks billed on an hourly basis.
        - FALSE: retain the data disk when its CVM is terminated.
        Default value: TRUE.
        """
        disk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data disk ID. Note that it's not available for LOCAL_BASIC and LOCAL_SSD disks.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data disk type. Valid values:
        - LOCAL_BASIC: local hard disk;
        - LOCAL_SSD: local SSD hard disk;
        - LOCAL_NVME: local NVME hard disk, which is strongly related to InstanceType and cannot be specified;
        - LOCAL_PRO: local HDD hard disk, which is strongly related to InstanceType and cannot be specified;
        - CLOUD_BASIC: ordinary cloud disk;
        - CLOUD_PREMIUM: high-performance cloud disk;
        - CLOUD_SSD:SSD cloud disk;
        - CLOUD_HSSD: enhanced SSD cloud disk;
        - CLOUD_TSSD: extremely fast SSD cloud disk;
        - CLOUD_BSSD: general-purpose SSD cloud disk;
        Default value: LOCAL_BASIC.
        """
        encrypt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the data disk is encrypted. Valid values:
        - TRUE: encrypted
        - FALSE: not encrypted
        Default value: FALSE.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the custom CMK in the format of UUID or kms-abcd1234. This parameter is used to encrypt cloud disks.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk.
        """
        throughput_performance: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk performance, in MB/s.
        """
elif False:
    ModifyInstanceDiskTypeDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModifyInstanceDiskTypeDataDiskArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[_builtins.int],
                 cdc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_with_instance: Optional[pulumi.Input[_builtins.bool]] = None,
                 disk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypt: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput_performance: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] disk_size: Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type. The default value is 0, indicating that no data disk is purchased. For more information, see the product documentation.
        :param pulumi.Input[_builtins.str] cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param pulumi.Input[_builtins.bool] delete_with_instance: Whether to terminate the data disk when its CVM is terminated. Valid values:
               - TRUE: terminate the data disk when its CVM is terminated. This value only supports pay-as-you-go cloud disks billed on an hourly basis.
               - FALSE: retain the data disk when its CVM is terminated.
               Default value: TRUE.
        :param pulumi.Input[_builtins.str] disk_id: Data disk ID. Note that it's not available for LOCAL_BASIC and LOCAL_SSD disks.
        :param pulumi.Input[_builtins.str] disk_type: Data disk type. Valid values:
               - LOCAL_BASIC: local hard disk;
               - LOCAL_SSD: local SSD hard disk;
               - LOCAL_NVME: local NVME hard disk, which is strongly related to InstanceType and cannot be specified;
               - LOCAL_PRO: local HDD hard disk, which is strongly related to InstanceType and cannot be specified;
               - CLOUD_BASIC: ordinary cloud disk;
               - CLOUD_PREMIUM: high-performance cloud disk;
               - CLOUD_SSD:SSD cloud disk;
               - CLOUD_HSSD: enhanced SSD cloud disk;
               - CLOUD_TSSD: extremely fast SSD cloud disk;
               - CLOUD_BSSD: general-purpose SSD cloud disk;
               Default value: LOCAL_BASIC.
        :param pulumi.Input[_builtins.bool] encrypt: Specifies whether the data disk is encrypted. Valid values:
               - TRUE: encrypted
               - FALSE: not encrypted
               Default value: FALSE.
        :param pulumi.Input[_builtins.str] kms_key_id: ID of the custom CMK in the format of UUID or kms-abcd1234. This parameter is used to encrypt cloud disks.
        :param pulumi.Input[_builtins.str] snapshot_id: Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk.
        :param pulumi.Input[_builtins.int] throughput_performance: Cloud disk performance, in MB/s.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[_builtins.int]:
        """
        Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type. The default value is 0, indicating that no data disk is purchased. For more information, see the product documentation.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @cdc_id.setter
    def cdc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cdc_id", value)

    @_builtins.property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to terminate the data disk when its CVM is terminated. Valid values:
        - TRUE: terminate the data disk when its CVM is terminated. This value only supports pay-as-you-go cloud disks billed on an hourly basis.
        - FALSE: retain the data disk when its CVM is terminated.
        Default value: TRUE.
        """
        return pulumi.get(self, "delete_with_instance")

    @delete_with_instance.setter
    def delete_with_instance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_with_instance", value)

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data disk ID. Note that it's not available for LOCAL_BASIC and LOCAL_SSD disks.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_id", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data disk type. Valid values:
        - LOCAL_BASIC: local hard disk;
        - LOCAL_SSD: local SSD hard disk;
        - LOCAL_NVME: local NVME hard disk, which is strongly related to InstanceType and cannot be specified;
        - LOCAL_PRO: local HDD hard disk, which is strongly related to InstanceType and cannot be specified;
        - CLOUD_BASIC: ordinary cloud disk;
        - CLOUD_PREMIUM: high-performance cloud disk;
        - CLOUD_SSD:SSD cloud disk;
        - CLOUD_HSSD: enhanced SSD cloud disk;
        - CLOUD_TSSD: extremely fast SSD cloud disk;
        - CLOUD_BSSD: general-purpose SSD cloud disk;
        Default value: LOCAL_BASIC.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the data disk is encrypted. Valid values:
        - TRUE: encrypted
        - FALSE: not encrypted
        Default value: FALSE.
        """
        return pulumi.get(self, "encrypt")

    @encrypt.setter
    def encrypt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypt", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the custom CMK in the format of UUID or kms-abcd1234. This parameter is used to encrypt cloud disks.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk performance, in MB/s.
        """
        return pulumi.get(self, "throughput_performance")

    @throughput_performance.setter
    def throughput_performance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput_performance", value)


if not MYPY:
    class ModifyInstanceDiskTypeSystemDiskArgsDict(TypedDict):
        cdc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        disk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        System disk size; unit: GB; default value: 50 GB.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        System disk type. Valid values:- LOCAL_BASIC: local disk
        - LOCAL_SSD: local SSD disk
        - CLOUD_BASIC: ordinary cloud disk
        - CLOUD_SSD: SSD cloud disk
        - CLOUD_PREMIUM: Premium cloud storage
        - CLOUD_BSSD: Balanced SSD
        The disk currently in stock will be used by default.
        """
elif False:
    ModifyInstanceDiskTypeSystemDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModifyInstanceDiskTypeSystemDiskArgs:
    def __init__(__self__, *,
                 cdc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cdc_id: ID of the dedicated cluster to which the instance belongs.
        :param pulumi.Input[_builtins.str] disk_id: System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter.
        :param pulumi.Input[_builtins.int] disk_size: System disk size; unit: GB; default value: 50 GB.
        :param pulumi.Input[_builtins.str] disk_type: System disk type. Valid values:- LOCAL_BASIC: local disk
               - LOCAL_SSD: local SSD disk
               - CLOUD_BASIC: ordinary cloud disk
               - CLOUD_SSD: SSD cloud disk
               - CLOUD_PREMIUM: Premium cloud storage
               - CLOUD_BSSD: Balanced SSD
               The disk currently in stock will be used by default.
        """
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the dedicated cluster to which the instance belongs.
        """
        return pulumi.get(self, "cdc_id")

    @cdc_id.setter
    def cdc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cdc_id", value)

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_id", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        System disk size; unit: GB; default value: 50 GB.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        System disk type. Valid values:- LOCAL_BASIC: local disk
        - LOCAL_SSD: local SSD disk
        - CLOUD_BASIC: ordinary cloud disk
        - CLOUD_SSD: SSD cloud disk
        - CLOUD_PREMIUM: Premium cloud storage
        - CLOUD_BSSD: Balanced SSD
        The disk currently in stock will be used by default.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)


if not MYPY:
    class RenewHostHostChargePrepaidArgsDict(TypedDict):
        period: pulumi.Input[_builtins.int]
        """
        The duration of purchasing an instance, unit: month. Value range: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36.
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Auto renewal flag. Valid values:&lt;br&gt;&lt;li&gt;NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically&lt;br&gt;&lt;li&gt;NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically&lt;br&gt;&lt;li&gt;DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically&lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_AUTO_RENEWIf this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
elif False:
    RenewHostHostChargePrepaidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RenewHostHostChargePrepaidArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[_builtins.int],
                 renew_flag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] period: The duration of purchasing an instance, unit: month. Value range: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36.
        :param pulumi.Input[_builtins.str] renew_flag: Auto renewal flag. Valid values:&lt;br&gt;&lt;li&gt;NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically&lt;br&gt;&lt;li&gt;NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically&lt;br&gt;&lt;li&gt;DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically&lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_AUTO_RENEWIf this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        The duration of purchasing an instance, unit: month. Value range: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Auto renewal flag. Valid values:&lt;br&gt;&lt;li&gt;NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically&lt;br&gt;&lt;li&gt;NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically&lt;br&gt;&lt;li&gt;DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically&lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_AUTO_RENEWIf this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_flag", value)


if not MYPY:
    class RenewInstanceInstanceChargePrepaidArgsDict(TypedDict):
        period: pulumi.Input[_builtins.int]
        """
        Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60. Note: This field may return null, indicating that no valid value is found.
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Auto renewal flag. Valid values:
        - `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically;
        - `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically;
        - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically;
        Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. Note: This field may return null, indicating that no valid value is found.
        """
elif False:
    RenewInstanceInstanceChargePrepaidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RenewInstanceInstanceChargePrepaidArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[_builtins.int],
                 renew_flag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] period: Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60. Note: This field may return null, indicating that no valid value is found.
        :param pulumi.Input[_builtins.str] renew_flag: Auto renewal flag. Valid values:
               - `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically;
               - `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically;
               - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically;
               Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. Note: This field may return null, indicating that no valid value is found.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60. Note: This field may return null, indicating that no valid value is found.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Auto renewal flag. Valid values:
        - `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically;
        - `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically;
        - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically;
        Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. Note: This field may return null, indicating that no valid value is found.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_flag", value)


if not MYPY:
    class GetChcHostsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter name.
        """
        values: Sequence[_builtins.str]
        """
        Filter values.
        """
elif False:
    GetChcHostsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetChcHostsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Filter name.
        :param Sequence[_builtins.str] values: Filter values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetInstancesModificationFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Fields to be filtered.
        """
        values: Sequence[_builtins.str]
        """
        Value of the field.
        """
elif False:
    GetInstancesModificationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancesModificationFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Fields to be filtered.
        :param Sequence[_builtins.str] values: Value of the field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Fields to be filtered.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Value of the field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


