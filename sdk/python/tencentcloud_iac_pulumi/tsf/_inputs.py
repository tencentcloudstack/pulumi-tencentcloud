# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApiGroupBindedGatewayDeployGroupArgs',
    'ApiGroupBindedGatewayDeployGroupArgsDict',
    'ApplicationServiceConfigListArgs',
    'ApplicationServiceConfigListArgsDict',
    'ApplicationServiceConfigListHealthCheckArgs',
    'ApplicationServiceConfigListHealthCheckArgsDict',
    'ApplicationServiceConfigListPortArgs',
    'ApplicationServiceConfigListPortArgsDict',
    'ClusterOperationInfoArgs',
    'ClusterOperationInfoArgsDict',
    'ClusterOperationInfoAddInstanceArgs',
    'ClusterOperationInfoAddInstanceArgsDict',
    'ClusterOperationInfoDestroyArgs',
    'ClusterOperationInfoDestroyArgsDict',
    'ClusterOperationInfoInitArgs',
    'ClusterOperationInfoInitArgsDict',
    'DeployContainerGroupAgentProfileListArgs',
    'DeployContainerGroupAgentProfileListArgsDict',
    'DeployContainerGroupEnvArgs',
    'DeployContainerGroupEnvArgsDict',
    'DeployContainerGroupEnvValueFromArgs',
    'DeployContainerGroupEnvValueFromArgsDict',
    'DeployContainerGroupEnvValueFromFieldRefArgs',
    'DeployContainerGroupEnvValueFromFieldRefArgsDict',
    'DeployContainerGroupEnvValueFromResourceFieldRefArgs',
    'DeployContainerGroupEnvValueFromResourceFieldRefArgsDict',
    'DeployContainerGroupHealthCheckSettingsArgs',
    'DeployContainerGroupHealthCheckSettingsArgsDict',
    'DeployContainerGroupHealthCheckSettingsLivenessProbeArgs',
    'DeployContainerGroupHealthCheckSettingsLivenessProbeArgsDict',
    'DeployContainerGroupHealthCheckSettingsReadinessProbeArgs',
    'DeployContainerGroupHealthCheckSettingsReadinessProbeArgsDict',
    'DeployContainerGroupSchedulingStrategyArgs',
    'DeployContainerGroupSchedulingStrategyArgsDict',
    'DeployContainerGroupServiceSettingArgs',
    'DeployContainerGroupServiceSettingArgsDict',
    'DeployContainerGroupServiceSettingProtocolPortArgs',
    'DeployContainerGroupServiceSettingProtocolPortArgsDict',
    'DeployContainerGroupVolumeInfoListArgs',
    'DeployContainerGroupVolumeInfoListArgsDict',
    'DeployContainerGroupVolumeMountInfoListArgs',
    'DeployContainerGroupVolumeMountInfoListArgsDict',
    'DeployContainerGroupWarmupSettingArgs',
    'DeployContainerGroupWarmupSettingArgsDict',
    'DeployVmGroupAgentProfileListArgs',
    'DeployVmGroupAgentProfileListArgsDict',
    'DeployVmGroupHealthCheckSettingsArgs',
    'DeployVmGroupHealthCheckSettingsArgsDict',
    'DeployVmGroupHealthCheckSettingsLivenessProbeArgs',
    'DeployVmGroupHealthCheckSettingsLivenessProbeArgsDict',
    'DeployVmGroupHealthCheckSettingsReadinessProbeArgs',
    'DeployVmGroupHealthCheckSettingsReadinessProbeArgsDict',
    'DeployVmGroupWarmupSettingArgs',
    'DeployVmGroupWarmupSettingArgsDict',
    'InstancesAttachmentInstanceAdvancedSettingsArgs',
    'InstancesAttachmentInstanceAdvancedSettingsArgsDict',
    'LaneLaneGroupListArgs',
    'LaneLaneGroupListArgsDict',
    'LaneRuleRuleTagListArgs',
    'LaneRuleRuleTagListArgsDict',
    'TaskAdvanceSettingsArgs',
    'TaskAdvanceSettingsArgsDict',
    'TaskShardArgumentArgs',
    'TaskShardArgumentArgsDict',
    'TaskTaskRuleArgs',
    'TaskTaskRuleArgsDict',
    'UnitRuleUnitRuleItemListArgs',
    'UnitRuleUnitRuleItemListArgsDict',
    'UnitRuleUnitRuleItemListUnitRuleTagListArgs',
    'UnitRuleUnitRuleItemListUnitRuleTagListArgsDict',
]

MYPY = False

if not MYPY:
    class ApiGroupBindedGatewayDeployGroupArgsDict(TypedDict):
        application_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        application ID.
        """
        application_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Application Name.
        """
        application_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Application classification: V: virtual machine application, C: container application.
        """
        cluster_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster type, C: container, V: virtual machine.
        """
        deploy_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway deployment group ID.
        """
        deploy_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway deployment group name.
        """
        group_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deployment group application status, values: Running, Waiting, Paused, Updating, RollingBack, Abnormal, Unknown.
        """
elif False:
    ApiGroupBindedGatewayDeployGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGroupBindedGatewayDeployGroupArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[_builtins.str]] = None,
                 application_name: Optional[pulumi.Input[_builtins.str]] = None,
                 application_type: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 group_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] application_id: application ID.
        :param pulumi.Input[_builtins.str] application_name: Application Name.
        :param pulumi.Input[_builtins.str] application_type: Application classification: V: virtual machine application, C: container application.
        :param pulumi.Input[_builtins.str] cluster_type: Cluster type, C: container, V: virtual machine.
        :param pulumi.Input[_builtins.str] deploy_group_id: Gateway deployment group ID.
        :param pulumi.Input[_builtins.str] deploy_group_name: Gateway deployment group name.
        :param pulumi.Input[_builtins.str] group_status: Deployment group application status, values: Running, Waiting, Paused, Updating, RollingBack, Abnormal, Unknown.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if deploy_group_id is not None:
            pulumi.set(__self__, "deploy_group_id", deploy_group_id)
        if deploy_group_name is not None:
            pulumi.set(__self__, "deploy_group_name", deploy_group_name)
        if group_status is not None:
            pulumi.set(__self__, "group_status", group_status)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application ID.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_id", value)

    @_builtins.property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Application Name.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_name", value)

    @_builtins.property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Application classification: V: virtual machine application, C: container application.
        """
        return pulumi.get(self, "application_type")

    @application_type.setter
    def application_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_type", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster type, C: container, V: virtual machine.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter(name="deployGroupId")
    def deploy_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway deployment group ID.
        """
        return pulumi.get(self, "deploy_group_id")

    @deploy_group_id.setter
    def deploy_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deploy_group_id", value)

    @_builtins.property
    @pulumi.getter(name="deployGroupName")
    def deploy_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway deployment group name.
        """
        return pulumi.get(self, "deploy_group_name")

    @deploy_group_name.setter
    def deploy_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deploy_group_name", value)

    @_builtins.property
    @pulumi.getter(name="groupStatus")
    def group_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deployment group application status, values: Running, Waiting, Paused, Updating, RollingBack, Abnormal, Unknown.
        """
        return pulumi.get(self, "group_status")

    @group_status.setter
    def group_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_status", value)


if not MYPY:
    class ApplicationServiceConfigListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Service name.
        """
        ports: pulumi.Input[Sequence[pulumi.Input['ApplicationServiceConfigListPortArgsDict']]]
        """
        List of port information.
        """
        health_check: NotRequired[pulumi.Input['ApplicationServiceConfigListHealthCheckArgsDict']]
        """
        Health check configuration.
        """
elif False:
    ApplicationServiceConfigListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationServiceConfigListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 ports: pulumi.Input[Sequence[pulumi.Input['ApplicationServiceConfigListPortArgs']]],
                 health_check: Optional[pulumi.Input['ApplicationServiceConfigListHealthCheckArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Service name.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationServiceConfigListPortArgs']]] ports: List of port information.
        :param pulumi.Input['ApplicationServiceConfigListHealthCheckArgs'] health_check: Health check configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input['ApplicationServiceConfigListPortArgs']]]:
        """
        List of port information.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input['ApplicationServiceConfigListPortArgs']]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['ApplicationServiceConfigListHealthCheckArgs']]:
        """
        Health check configuration.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['ApplicationServiceConfigListHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)


if not MYPY:
    class ApplicationServiceConfigListHealthCheckArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Health check path.
        """
elif False:
    ApplicationServiceConfigListHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationServiceConfigListHealthCheckArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] path: Health check path.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Health check path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ApplicationServiceConfigListPortArgsDict(TypedDict):
        protocol: pulumi.Input[_builtins.str]
        """
        Port protocol.
        """
        target_port: pulumi.Input[_builtins.int]
        """
        Service port.
        """
elif False:
    ApplicationServiceConfigListPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationServiceConfigListPortArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[_builtins.str],
                 target_port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] protocol: Port protocol.
        :param pulumi.Input[_builtins.int] target_port: Service port.
        """
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Port protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[_builtins.int]:
        """
        Service port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class ClusterOperationInfoArgsDict(TypedDict):
        add_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoAddInstanceArgsDict']]]]
        """
        Add the control information of the instance button.
        """
        destroys: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoDestroyArgsDict']]]]
        """
        Destroy the control information of the machine.
        """
        inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoInitArgsDict']]]]
        """
        Initialize the control information of the button.
        """
elif False:
    ClusterOperationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOperationInfoArgs:
    def __init__(__self__, *,
                 add_instances: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoAddInstanceArgs']]]] = None,
                 destroys: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoDestroyArgs']]]] = None,
                 inits: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoInitArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoAddInstanceArgs']]] add_instances: Add the control information of the instance button.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoDestroyArgs']]] destroys: Destroy the control information of the machine.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoInitArgs']]] inits: Initialize the control information of the button.
        """
        if add_instances is not None:
            pulumi.set(__self__, "add_instances", add_instances)
        if destroys is not None:
            pulumi.set(__self__, "destroys", destroys)
        if inits is not None:
            pulumi.set(__self__, "inits", inits)

    @_builtins.property
    @pulumi.getter(name="addInstances")
    def add_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoAddInstanceArgs']]]]:
        """
        Add the control information of the instance button.
        """
        return pulumi.get(self, "add_instances")

    @add_instances.setter
    def add_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoAddInstanceArgs']]]]):
        pulumi.set(self, "add_instances", value)

    @_builtins.property
    @pulumi.getter
    def destroys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoDestroyArgs']]]]:
        """
        Destroy the control information of the machine.
        """
        return pulumi.get(self, "destroys")

    @destroys.setter
    def destroys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoDestroyArgs']]]]):
        pulumi.set(self, "destroys", value)

    @_builtins.property
    @pulumi.getter
    def inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoInitArgs']]]]:
        """
        Initialize the control information of the button.
        """
        return pulumi.get(self, "inits")

    @inits.setter
    def inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterOperationInfoInitArgs']]]]):
        pulumi.set(self, "inits", value)


if not MYPY:
    class ClusterOperationInfoAddInstanceArgsDict(TypedDict):
        disabled_reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for not showing.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is the button clickable.
        """
        supported: NotRequired[pulumi.Input[_builtins.bool]]
        """
        whether to show the button.
        """
elif False:
    ClusterOperationInfoAddInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOperationInfoAddInstanceArgs:
    def __init__(__self__, *,
                 disabled_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 supported: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] disabled_reason: Reason for not showing.
        :param pulumi.Input[_builtins.bool] enabled: Is the button clickable.
        :param pulumi.Input[_builtins.bool] supported: whether to show the button.
        """
        if disabled_reason is not None:
            pulumi.set(__self__, "disabled_reason", disabled_reason)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if supported is not None:
            pulumi.set(__self__, "supported", supported)

    @_builtins.property
    @pulumi.getter(name="disabledReason")
    def disabled_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for not showing.
        """
        return pulumi.get(self, "disabled_reason")

    @disabled_reason.setter
    def disabled_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disabled_reason", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is the button clickable.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def supported(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        whether to show the button.
        """
        return pulumi.get(self, "supported")

    @supported.setter
    def supported(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "supported", value)


if not MYPY:
    class ClusterOperationInfoDestroyArgsDict(TypedDict):
        disabled_reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for not showing.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is the button clickable.
        """
        supported: NotRequired[pulumi.Input[_builtins.bool]]
        """
        whether to show the button.
        """
elif False:
    ClusterOperationInfoDestroyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOperationInfoDestroyArgs:
    def __init__(__self__, *,
                 disabled_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 supported: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] disabled_reason: Reason for not showing.
        :param pulumi.Input[_builtins.bool] enabled: Is the button clickable.
        :param pulumi.Input[_builtins.bool] supported: whether to show the button.
        """
        if disabled_reason is not None:
            pulumi.set(__self__, "disabled_reason", disabled_reason)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if supported is not None:
            pulumi.set(__self__, "supported", supported)

    @_builtins.property
    @pulumi.getter(name="disabledReason")
    def disabled_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for not showing.
        """
        return pulumi.get(self, "disabled_reason")

    @disabled_reason.setter
    def disabled_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disabled_reason", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is the button clickable.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def supported(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        whether to show the button.
        """
        return pulumi.get(self, "supported")

    @supported.setter
    def supported(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "supported", value)


if not MYPY:
    class ClusterOperationInfoInitArgsDict(TypedDict):
        disabled_reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for not showing.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is the button clickable.
        """
        supported: NotRequired[pulumi.Input[_builtins.bool]]
        """
        whether to show the button.
        """
elif False:
    ClusterOperationInfoInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOperationInfoInitArgs:
    def __init__(__self__, *,
                 disabled_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 supported: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] disabled_reason: Reason for not showing.
        :param pulumi.Input[_builtins.bool] enabled: Is the button clickable.
        :param pulumi.Input[_builtins.bool] supported: whether to show the button.
        """
        if disabled_reason is not None:
            pulumi.set(__self__, "disabled_reason", disabled_reason)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if supported is not None:
            pulumi.set(__self__, "supported", supported)

    @_builtins.property
    @pulumi.getter(name="disabledReason")
    def disabled_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for not showing.
        """
        return pulumi.get(self, "disabled_reason")

    @disabled_reason.setter
    def disabled_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disabled_reason", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is the button clickable.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def supported(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        whether to show the button.
        """
        return pulumi.get(self, "supported")

    @supported.setter
    def supported(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "supported", value)


if not MYPY:
    class DeployContainerGroupAgentProfileListArgsDict(TypedDict):
        agent_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent type.
        """
        agent_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent version.
        """
elif False:
    DeployContainerGroupAgentProfileListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupAgentProfileListArgs:
    def __init__(__self__, *,
                 agent_type: Optional[pulumi.Input[_builtins.str]] = None,
                 agent_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent_type: Agent type.
        :param pulumi.Input[_builtins.str] agent_version: Agent version.
        """
        if agent_type is not None:
            pulumi.set(__self__, "agent_type", agent_type)
        if agent_version is not None:
            pulumi.set(__self__, "agent_version", agent_version)

    @_builtins.property
    @pulumi.getter(name="agentType")
    def agent_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent type.
        """
        return pulumi.get(self, "agent_type")

    @agent_type.setter
    def agent_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_type", value)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent version.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_version", value)


if not MYPY:
    class DeployContainerGroupEnvArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        env param name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        value of env.
        """
        value_from: NotRequired[pulumi.Input['DeployContainerGroupEnvValueFromArgsDict']]
        """
        Kubernetes ValueFrom configuration. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupEnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_from: Optional[pulumi.Input['DeployContainerGroupEnvValueFromArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: env param name.
        :param pulumi.Input[_builtins.str] value: value of env.
        :param pulumi.Input['DeployContainerGroupEnvValueFromArgs'] value_from: Kubernetes ValueFrom configuration. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        env param name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        value of env.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[pulumi.Input['DeployContainerGroupEnvValueFromArgs']]:
        """
        Kubernetes ValueFrom configuration. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: Optional[pulumi.Input['DeployContainerGroupEnvValueFromArgs']]):
        pulumi.set(self, "value_from", value)


if not MYPY:
    class DeployContainerGroupEnvValueFromArgsDict(TypedDict):
        field_ref: NotRequired[pulumi.Input['DeployContainerGroupEnvValueFromFieldRefArgsDict']]
        """
        The FieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
        """
        resource_field_ref: NotRequired[pulumi.Input['DeployContainerGroupEnvValueFromResourceFieldRefArgsDict']]
        """
        The ResourceFieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupEnvValueFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupEnvValueFromArgs:
    def __init__(__self__, *,
                 field_ref: Optional[pulumi.Input['DeployContainerGroupEnvValueFromFieldRefArgs']] = None,
                 resource_field_ref: Optional[pulumi.Input['DeployContainerGroupEnvValueFromResourceFieldRefArgs']] = None):
        """
        :param pulumi.Input['DeployContainerGroupEnvValueFromFieldRefArgs'] field_ref: The FieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input['DeployContainerGroupEnvValueFromResourceFieldRefArgs'] resource_field_ref: The ResourceFieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @_builtins.property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional[pulumi.Input['DeployContainerGroupEnvValueFromFieldRefArgs']]:
        """
        The FieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "field_ref")

    @field_ref.setter
    def field_ref(self, value: Optional[pulumi.Input['DeployContainerGroupEnvValueFromFieldRefArgs']]):
        pulumi.set(self, "field_ref", value)

    @_builtins.property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional[pulumi.Input['DeployContainerGroupEnvValueFromResourceFieldRefArgs']]:
        """
        The ResourceFieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resource_field_ref")

    @resource_field_ref.setter
    def resource_field_ref(self, value: Optional[pulumi.Input['DeployContainerGroupEnvValueFromResourceFieldRefArgs']]):
        pulumi.set(self, "resource_field_ref", value)


if not MYPY:
    class DeployContainerGroupEnvValueFromFieldRefArgsDict(TypedDict):
        field_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The FieldPath configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupEnvValueFromFieldRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupEnvValueFromFieldRefArgs:
    def __init__(__self__, *,
                 field_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] field_path: The FieldPath configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @_builtins.property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The FieldPath configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_path", value)


if not MYPY:
    class DeployContainerGroupEnvValueFromResourceFieldRefArgsDict(TypedDict):
        resource: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Resource configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupEnvValueFromResourceFieldRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupEnvValueFromResourceFieldRefArgs:
    def __init__(__self__, *,
                 resource: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] resource: The Resource configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Resource configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource", value)


if not MYPY:
    class DeployContainerGroupHealthCheckSettingsArgsDict(TypedDict):
        liveness_probe: NotRequired[pulumi.Input['DeployContainerGroupHealthCheckSettingsLivenessProbeArgsDict']]
        """
        Liveness probe. Note: This field may return null, indicating that no valid values can be obtained.
        """
        readiness_probe: NotRequired[pulumi.Input['DeployContainerGroupHealthCheckSettingsReadinessProbeArgsDict']]
        """
        Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupHealthCheckSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupHealthCheckSettingsArgs:
    def __init__(__self__, *,
                 liveness_probe: Optional[pulumi.Input['DeployContainerGroupHealthCheckSettingsLivenessProbeArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['DeployContainerGroupHealthCheckSettingsReadinessProbeArgs']] = None):
        """
        :param pulumi.Input['DeployContainerGroupHealthCheckSettingsLivenessProbeArgs'] liveness_probe: Liveness probe. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input['DeployContainerGroupHealthCheckSettingsReadinessProbeArgs'] readiness_probe: Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['DeployContainerGroupHealthCheckSettingsLivenessProbeArgs']]:
        """
        Liveness probe. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['DeployContainerGroupHealthCheckSettingsLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['DeployContainerGroupHealthCheckSettingsReadinessProbeArgs']]:
        """
        Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['DeployContainerGroupHealthCheckSettingsReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)


if not MYPY:
    class DeployContainerGroupHealthCheckSettingsLivenessProbeArgsDict(TypedDict):
        action_type: pulumi.Input[_builtins.str]
        """
        The health check method. HTTP: checks through an HTTP interface; CMD: checks by executing a command; TCP: checks by establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupHealthCheckSettingsLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupHealthCheckSettingsLivenessProbeArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[_builtins.str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_type: The health check method. HTTP: checks through an HTTP interface; CMD: checks by executing a command; TCP: checks by establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] failure_threshold: The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] path: The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] period_seconds: The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] port: The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] scheme: The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] success_threshold: The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] timeout_seconds: The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] type: The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "action_type", action_type)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[_builtins.str]:
        """
        The health check method. HTTP: checks through an HTTP interface; CMD: checks by executing a command; TCP: checks by establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_type", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeployContainerGroupHealthCheckSettingsReadinessProbeArgsDict(TypedDict):
        action_type: pulumi.Input[_builtins.str]
        """
        The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupHealthCheckSettingsReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupHealthCheckSettingsReadinessProbeArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[_builtins.str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_type: The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] failure_threshold: The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] path: The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] period_seconds: The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] port: The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] scheme: The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] success_threshold: The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] timeout_seconds: The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] type: The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "action_type", action_type)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[_builtins.str]:
        """
        The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_type", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeployContainerGroupSchedulingStrategyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        NONE: Do not use scheduling strategy; CROSS_AZ: Deploy across availability zones. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupSchedulingStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupSchedulingStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: NONE: Do not use scheduling strategy; CROSS_AZ: Deploy across availability zones. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        NONE: Do not use scheduling strategy; CROSS_AZ: Deploy across availability zones. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeployContainerGroupServiceSettingArgsDict(TypedDict):
        access_type: pulumi.Input[_builtins.int]
        """
        0: Public network, 1: Access within the cluster, 2: NodePort, 3: Access within VPC. Note: This field may return null, indicating that no valid values can be obtained.
        """
        protocol_ports: pulumi.Input[Sequence[pulumi.Input['DeployContainerGroupServiceSettingProtocolPortArgsDict']]]
        """
        Container port mapping. Note: This field may return null, indicating that no valid values can be obtained.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        subnet Id.
        """
        allow_delete_service: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to true and DisableService is also true, the previously created service will be deleted. Please use with caution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        disable_service: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to create a Kubernetes service. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
        """
        headless_service: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the service is of headless type. Note: This field may return null, indicating that no valid values can be obtained.
        """
        open_session_affinity: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable session affinity. true means enabled, false means disabled. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
        """
        session_affinity_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Session affinity session time. The default value is 10800. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployContainerGroupServiceSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupServiceSettingArgs:
    def __init__(__self__, *,
                 access_type: pulumi.Input[_builtins.int],
                 protocol_ports: pulumi.Input[Sequence[pulumi.Input['DeployContainerGroupServiceSettingProtocolPortArgs']]],
                 subnet_id: pulumi.Input[_builtins.str],
                 allow_delete_service: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_service: Optional[pulumi.Input[_builtins.bool]] = None,
                 headless_service: Optional[pulumi.Input[_builtins.bool]] = None,
                 open_session_affinity: Optional[pulumi.Input[_builtins.bool]] = None,
                 session_affinity_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] access_type: 0: Public network, 1: Access within the cluster, 2: NodePort, 3: Access within VPC. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['DeployContainerGroupServiceSettingProtocolPortArgs']]] protocol_ports: Container port mapping. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] subnet_id: subnet Id.
        :param pulumi.Input[_builtins.bool] allow_delete_service: When set to true and DisableService is also true, the previously created service will be deleted. Please use with caution. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.bool] disable_service: Whether to create a Kubernetes service. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.bool] headless_service: Whether the service is of headless type. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.bool] open_session_affinity: Enable session affinity. true means enabled, false means disabled. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] session_affinity_timeout_seconds: Session affinity session time. The default value is 10800. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "access_type", access_type)
        pulumi.set(__self__, "protocol_ports", protocol_ports)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if allow_delete_service is not None:
            pulumi.set(__self__, "allow_delete_service", allow_delete_service)
        if disable_service is not None:
            pulumi.set(__self__, "disable_service", disable_service)
        if headless_service is not None:
            pulumi.set(__self__, "headless_service", headless_service)
        if open_session_affinity is not None:
            pulumi.set(__self__, "open_session_affinity", open_session_affinity)
        if session_affinity_timeout_seconds is not None:
            pulumi.set(__self__, "session_affinity_timeout_seconds", session_affinity_timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> pulumi.Input[_builtins.int]:
        """
        0: Public network, 1: Access within the cluster, 2: NodePort, 3: Access within VPC. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "access_type", value)

    @_builtins.property
    @pulumi.getter(name="protocolPorts")
    def protocol_ports(self) -> pulumi.Input[Sequence[pulumi.Input['DeployContainerGroupServiceSettingProtocolPortArgs']]]:
        """
        Container port mapping. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "protocol_ports")

    @protocol_ports.setter
    def protocol_ports(self, value: pulumi.Input[Sequence[pulumi.Input['DeployContainerGroupServiceSettingProtocolPortArgs']]]):
        pulumi.set(self, "protocol_ports", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        subnet Id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="allowDeleteService")
    def allow_delete_service(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to true and DisableService is also true, the previously created service will be deleted. Please use with caution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "allow_delete_service")

    @allow_delete_service.setter
    def allow_delete_service(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_delete_service", value)

    @_builtins.property
    @pulumi.getter(name="disableService")
    def disable_service(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to create a Kubernetes service. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "disable_service")

    @disable_service.setter
    def disable_service(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_service", value)

    @_builtins.property
    @pulumi.getter(name="headlessService")
    def headless_service(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the service is of headless type. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "headless_service")

    @headless_service.setter
    def headless_service(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "headless_service", value)

    @_builtins.property
    @pulumi.getter(name="openSessionAffinity")
    def open_session_affinity(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable session affinity. true means enabled, false means disabled. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "open_session_affinity")

    @open_session_affinity.setter
    def open_session_affinity(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "open_session_affinity", value)

    @_builtins.property
    @pulumi.getter(name="sessionAffinityTimeoutSeconds")
    def session_affinity_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Session affinity session time. The default value is 10800. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "session_affinity_timeout_seconds")

    @session_affinity_timeout_seconds.setter
    def session_affinity_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_affinity_timeout_seconds", value)


if not MYPY:
    class DeployContainerGroupServiceSettingProtocolPortArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        port.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        TCP or UDP.
        """
        target_port: pulumi.Input[_builtins.int]
        """
        container port.
        """
        node_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        node port.
        """
elif False:
    DeployContainerGroupServiceSettingProtocolPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupServiceSettingProtocolPortArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 target_port: pulumi.Input[_builtins.int],
                 node_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: port.
        :param pulumi.Input[_builtins.str] protocol: TCP or UDP.
        :param pulumi.Input[_builtins.int] target_port: container port.
        :param pulumi.Input[_builtins.int] node_port: node port.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_port", target_port)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        TCP or UDP.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[_builtins.int]:
        """
        container port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_port", value)

    @_builtins.property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        node port.
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "node_port", value)


if not MYPY:
    class DeployContainerGroupVolumeInfoListArgsDict(TypedDict):
        volume_name: pulumi.Input[_builtins.str]
        """
        volume name.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        volume type.
        """
        volume_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        volume config.
        """
elif False:
    DeployContainerGroupVolumeInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupVolumeInfoListArgs:
    def __init__(__self__, *,
                 volume_name: pulumi.Input[_builtins.str],
                 volume_type: pulumi.Input[_builtins.str],
                 volume_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] volume_name: volume name.
        :param pulumi.Input[_builtins.str] volume_type: volume type.
        :param pulumi.Input[_builtins.str] volume_config: volume config.
        """
        pulumi.set(__self__, "volume_name", volume_name)
        pulumi.set(__self__, "volume_type", volume_type)
        if volume_config is not None:
            pulumi.set(__self__, "volume_config", volume_config)

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> pulumi.Input[_builtins.str]:
        """
        volume name.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_name", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        volume type.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)

    @_builtins.property
    @pulumi.getter(name="volumeConfig")
    def volume_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        volume config.
        """
        return pulumi.get(self, "volume_config")

    @volume_config.setter
    def volume_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_config", value)


if not MYPY:
    class DeployContainerGroupVolumeMountInfoListArgsDict(TypedDict):
        volume_mount_name: pulumi.Input[_builtins.str]
        """
        mount volume name.
        """
        volume_mount_path: pulumi.Input[_builtins.str]
        """
        mount path.
        """
        read_or_write: NotRequired[pulumi.Input[_builtins.str]]
        """
        Read and write access mode. 1: Read-only. 2: Read-write.
        """
        volume_mount_sub_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        mount subPath.
        """
elif False:
    DeployContainerGroupVolumeMountInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupVolumeMountInfoListArgs:
    def __init__(__self__, *,
                 volume_mount_name: pulumi.Input[_builtins.str],
                 volume_mount_path: pulumi.Input[_builtins.str],
                 read_or_write: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_mount_sub_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] volume_mount_name: mount volume name.
        :param pulumi.Input[_builtins.str] volume_mount_path: mount path.
        :param pulumi.Input[_builtins.str] read_or_write: Read and write access mode. 1: Read-only. 2: Read-write.
        :param pulumi.Input[_builtins.str] volume_mount_sub_path: mount subPath.
        """
        pulumi.set(__self__, "volume_mount_name", volume_mount_name)
        pulumi.set(__self__, "volume_mount_path", volume_mount_path)
        if read_or_write is not None:
            pulumi.set(__self__, "read_or_write", read_or_write)
        if volume_mount_sub_path is not None:
            pulumi.set(__self__, "volume_mount_sub_path", volume_mount_sub_path)

    @_builtins.property
    @pulumi.getter(name="volumeMountName")
    def volume_mount_name(self) -> pulumi.Input[_builtins.str]:
        """
        mount volume name.
        """
        return pulumi.get(self, "volume_mount_name")

    @volume_mount_name.setter
    def volume_mount_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_mount_name", value)

    @_builtins.property
    @pulumi.getter(name="volumeMountPath")
    def volume_mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        mount path.
        """
        return pulumi.get(self, "volume_mount_path")

    @volume_mount_path.setter
    def volume_mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_mount_path", value)

    @_builtins.property
    @pulumi.getter(name="readOrWrite")
    def read_or_write(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Read and write access mode. 1: Read-only. 2: Read-write.
        """
        return pulumi.get(self, "read_or_write")

    @read_or_write.setter
    def read_or_write(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read_or_write", value)

    @_builtins.property
    @pulumi.getter(name="volumeMountSubPath")
    def volume_mount_sub_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        mount subPath.
        """
        return pulumi.get(self, "volume_mount_sub_path")

    @volume_mount_sub_path.setter
    def volume_mount_sub_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_mount_sub_path", value)


if not MYPY:
    class DeployContainerGroupWarmupSettingArgsDict(TypedDict):
        curvature: NotRequired[pulumi.Input[_builtins.int]]
        """
        Preheating curvature, with a value between 1 and 5.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable preheating.
        """
        enabled_protection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
        """
        warmup_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        warmup time.
        """
elif False:
    DeployContainerGroupWarmupSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployContainerGroupWarmupSettingArgs:
    def __init__(__self__, *,
                 curvature: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled_protection: Optional[pulumi.Input[_builtins.bool]] = None,
                 warmup_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] curvature: Preheating curvature, with a value between 1 and 5.
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable preheating.
        :param pulumi.Input[_builtins.bool] enabled_protection: Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
        :param pulumi.Input[_builtins.int] warmup_time: warmup time.
        """
        if curvature is not None:
            pulumi.set(__self__, "curvature", curvature)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enabled_protection is not None:
            pulumi.set(__self__, "enabled_protection", enabled_protection)
        if warmup_time is not None:
            pulumi.set(__self__, "warmup_time", warmup_time)

    @_builtins.property
    @pulumi.getter
    def curvature(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Preheating curvature, with a value between 1 and 5.
        """
        return pulumi.get(self, "curvature")

    @curvature.setter
    def curvature(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "curvature", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable preheating.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="enabledProtection")
    def enabled_protection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
        """
        return pulumi.get(self, "enabled_protection")

    @enabled_protection.setter
    def enabled_protection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled_protection", value)

    @_builtins.property
    @pulumi.getter(name="warmupTime")
    def warmup_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        warmup time.
        """
        return pulumi.get(self, "warmup_time")

    @warmup_time.setter
    def warmup_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "warmup_time", value)


if not MYPY:
    class DeployVmGroupAgentProfileListArgsDict(TypedDict):
        agent_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent type.
        """
        agent_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent version.
        """
elif False:
    DeployVmGroupAgentProfileListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployVmGroupAgentProfileListArgs:
    def __init__(__self__, *,
                 agent_type: Optional[pulumi.Input[_builtins.str]] = None,
                 agent_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent_type: Agent type.
        :param pulumi.Input[_builtins.str] agent_version: Agent version.
        """
        if agent_type is not None:
            pulumi.set(__self__, "agent_type", agent_type)
        if agent_version is not None:
            pulumi.set(__self__, "agent_version", agent_version)

    @_builtins.property
    @pulumi.getter(name="agentType")
    def agent_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent type.
        """
        return pulumi.get(self, "agent_type")

    @agent_type.setter
    def agent_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_type", value)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent version.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_version", value)


if not MYPY:
    class DeployVmGroupHealthCheckSettingsArgsDict(TypedDict):
        liveness_probe: NotRequired[pulumi.Input['DeployVmGroupHealthCheckSettingsLivenessProbeArgsDict']]
        """
        Survival health check. Note: This field may return null, indicating that no valid value was found.
        """
        readiness_probe: NotRequired[pulumi.Input['DeployVmGroupHealthCheckSettingsReadinessProbeArgsDict']]
        """
        Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployVmGroupHealthCheckSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployVmGroupHealthCheckSettingsArgs:
    def __init__(__self__, *,
                 liveness_probe: Optional[pulumi.Input['DeployVmGroupHealthCheckSettingsLivenessProbeArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['DeployVmGroupHealthCheckSettingsReadinessProbeArgs']] = None):
        """
        :param pulumi.Input['DeployVmGroupHealthCheckSettingsLivenessProbeArgs'] liveness_probe: Survival health check. Note: This field may return null, indicating that no valid value was found.
        :param pulumi.Input['DeployVmGroupHealthCheckSettingsReadinessProbeArgs'] readiness_probe: Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['DeployVmGroupHealthCheckSettingsLivenessProbeArgs']]:
        """
        Survival health check. Note: This field may return null, indicating that no valid value was found.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['DeployVmGroupHealthCheckSettingsLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['DeployVmGroupHealthCheckSettingsReadinessProbeArgs']]:
        """
        Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['DeployVmGroupHealthCheckSettingsReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)


if not MYPY:
    class DeployVmGroupHealthCheckSettingsLivenessProbeArgsDict(TypedDict):
        action_type: pulumi.Input[_builtins.str]
        """
        Health check method. HTTP: check through HTTP interface; CMD: check through executing command; TCP: check through establishing TCP connection. Note: This field may return null, indicating that no valid value was found.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployVmGroupHealthCheckSettingsLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployVmGroupHealthCheckSettingsLivenessProbeArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[_builtins.str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_type: Health check method. HTTP: check through HTTP interface; CMD: check through executing command; TCP: check through establishing TCP connection. Note: This field may return null, indicating that no valid value was found.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] failure_threshold: The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] path: The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] period_seconds: The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] port: The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] scheme: The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] success_threshold: The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] timeout_seconds: The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] type: The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "action_type", action_type)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[_builtins.str]:
        """
        Health check method. HTTP: check through HTTP interface; CMD: check through executing command; TCP: check through establishing TCP connection. Note: This field may return null, indicating that no valid value was found.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_type", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeployVmGroupHealthCheckSettingsReadinessProbeArgsDict(TypedDict):
        action_type: pulumi.Input[_builtins.str]
        """
        The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    DeployVmGroupHealthCheckSettingsReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployVmGroupHealthCheckSettingsReadinessProbeArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[_builtins.str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_type: The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] failure_threshold: The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] path: The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] period_seconds: The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] port: The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] scheme: The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] success_threshold: The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] timeout_seconds: The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] type: The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "action_type", action_type)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[_builtins.str]:
        """
        The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_type", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeployVmGroupWarmupSettingArgsDict(TypedDict):
        curvature: NotRequired[pulumi.Input[_builtins.int]]
        """
        Preheating curvature, with a value between 1 and 5.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable preheating.
        """
        enabled_protection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
        """
        warmup_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        warmup time.
        """
elif False:
    DeployVmGroupWarmupSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployVmGroupWarmupSettingArgs:
    def __init__(__self__, *,
                 curvature: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled_protection: Optional[pulumi.Input[_builtins.bool]] = None,
                 warmup_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] curvature: Preheating curvature, with a value between 1 and 5.
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable preheating.
        :param pulumi.Input[_builtins.bool] enabled_protection: Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
        :param pulumi.Input[_builtins.int] warmup_time: warmup time.
        """
        if curvature is not None:
            pulumi.set(__self__, "curvature", curvature)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enabled_protection is not None:
            pulumi.set(__self__, "enabled_protection", enabled_protection)
        if warmup_time is not None:
            pulumi.set(__self__, "warmup_time", warmup_time)

    @_builtins.property
    @pulumi.getter
    def curvature(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Preheating curvature, with a value between 1 and 5.
        """
        return pulumi.get(self, "curvature")

    @curvature.setter
    def curvature(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "curvature", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable preheating.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="enabledProtection")
    def enabled_protection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
        """
        return pulumi.get(self, "enabled_protection")

    @enabled_protection.setter
    def enabled_protection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled_protection", value)

    @_builtins.property
    @pulumi.getter(name="warmupTime")
    def warmup_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        warmup time.
        """
        return pulumi.get(self, "warmup_time")

    @warmup_time.setter
    def warmup_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "warmup_time", value)


if not MYPY:
    class InstancesAttachmentInstanceAdvancedSettingsArgsDict(TypedDict):
        docker_graph_path: pulumi.Input[_builtins.str]
        """
        Dockerd --graph specifies the value, default is /var/lib/docker Note: This field may return null, indicating that no valid values can be obtained.
        """
        mount_target: pulumi.Input[_builtins.str]
        """
        Data disk mount point, data disks are not mounted by default. Data disks with formatted ext3, ext4, xfs file systems will be mounted directly, other file systems or unformatted data disks will be automatically formatted as ext4 and mounted. Please back up your data! This setting does not take effect for cloud servers with no data disks or multiple data disks. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    InstancesAttachmentInstanceAdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancesAttachmentInstanceAdvancedSettingsArgs:
    def __init__(__self__, *,
                 docker_graph_path: pulumi.Input[_builtins.str],
                 mount_target: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] docker_graph_path: Dockerd --graph specifies the value, default is /var/lib/docker Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] mount_target: Data disk mount point, data disks are not mounted by default. Data disks with formatted ext3, ext4, xfs file systems will be mounted directly, other file systems or unformatted data disks will be automatically formatted as ext4 and mounted. Please back up your data! This setting does not take effect for cloud servers with no data disks or multiple data disks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    def docker_graph_path(self) -> pulumi.Input[_builtins.str]:
        """
        Dockerd --graph specifies the value, default is /var/lib/docker Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "docker_graph_path")

    @docker_graph_path.setter
    def docker_graph_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "docker_graph_path", value)

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> pulumi.Input[_builtins.str]:
        """
        Data disk mount point, data disks are not mounted by default. Data disks with formatted ext3, ext4, xfs file systems will be mounted directly, other file systems or unformatted data disks will be automatically formatted as ext4 and mounted. Please back up your data! This setting does not take effect for cloud servers with no data disks or multiple data disks. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "mount_target")

    @mount_target.setter
    def mount_target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_target", value)


if not MYPY:
    class LaneLaneGroupListArgsDict(TypedDict):
        entrance: pulumi.Input[_builtins.bool]
        """
        Whether to enter the application.
        """
        group_id: pulumi.Input[_builtins.str]
        """
        Deployment group ID.
        """
        application_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        application ID.
        """
        application_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        application name.
        """
        cluster_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        cluster type.
        """
        create_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        creation time.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        deployment group name.
        """
        lane_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Swimlane deployment group ID.
        """
        lane_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Lane ID.
        """
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace ID.
        """
        namespace_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        namespace name.
        """
        update_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        update time.
        """
elif False:
    LaneLaneGroupListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaneLaneGroupListArgs:
    def __init__(__self__, *,
                 entrance: pulumi.Input[_builtins.bool],
                 group_id: pulumi.Input[_builtins.str],
                 application_id: Optional[pulumi.Input[_builtins.str]] = None,
                 application_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
                 create_time: Optional[pulumi.Input[_builtins.int]] = None,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 lane_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 lane_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_name: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] entrance: Whether to enter the application.
        :param pulumi.Input[_builtins.str] group_id: Deployment group ID.
        :param pulumi.Input[_builtins.str] application_id: application ID.
        :param pulumi.Input[_builtins.str] application_name: application name.
        :param pulumi.Input[_builtins.str] cluster_type: cluster type.
        :param pulumi.Input[_builtins.int] create_time: creation time.
        :param pulumi.Input[_builtins.str] group_name: deployment group name.
        :param pulumi.Input[_builtins.str] lane_group_id: Swimlane deployment group ID.
        :param pulumi.Input[_builtins.str] lane_id: Lane ID.
        :param pulumi.Input[_builtins.str] namespace_id: Namespace ID.
        :param pulumi.Input[_builtins.str] namespace_name: namespace name.
        :param pulumi.Input[_builtins.int] update_time: update time.
        """
        pulumi.set(__self__, "entrance", entrance)
        pulumi.set(__self__, "group_id", group_id)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if lane_group_id is not None:
            pulumi.set(__self__, "lane_group_id", lane_group_id)
        if lane_id is not None:
            pulumi.set(__self__, "lane_id", lane_id)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if namespace_name is not None:
            pulumi.set(__self__, "namespace_name", namespace_name)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def entrance(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether to enter the application.
        """
        return pulumi.get(self, "entrance")

    @entrance.setter
    def entrance(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "entrance", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Deployment group ID.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application ID.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_id", value)

    @_builtins.property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application name.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_name", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        cluster type.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        creation time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        deployment group name.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="laneGroupId")
    def lane_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Swimlane deployment group ID.
        """
        return pulumi.get(self, "lane_group_id")

    @lane_group_id.setter
    def lane_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lane_group_id", value)

    @_builtins.property
    @pulumi.getter(name="laneId")
    def lane_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Lane ID.
        """
        return pulumi.get(self, "lane_id")

    @lane_id.setter
    def lane_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lane_id", value)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace ID.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        namespace name.
        """
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_name", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class LaneRuleRuleTagListArgsDict(TypedDict):
        tag_name: pulumi.Input[_builtins.str]
        """
        label name.
        """
        tag_operator: pulumi.Input[_builtins.str]
        """
        label operator.
        """
        tag_value: pulumi.Input[_builtins.str]
        """
        tag value.
        """
        create_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        creation time.
        """
        lane_rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        lane rule ID.
        """
        tag_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        label ID.
        """
        update_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        update time.
        """
elif False:
    LaneRuleRuleTagListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaneRuleRuleTagListArgs:
    def __init__(__self__, *,
                 tag_name: pulumi.Input[_builtins.str],
                 tag_operator: pulumi.Input[_builtins.str],
                 tag_value: pulumi.Input[_builtins.str],
                 create_time: Optional[pulumi.Input[_builtins.int]] = None,
                 lane_rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_id: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] tag_name: label name.
        :param pulumi.Input[_builtins.str] tag_operator: label operator.
        :param pulumi.Input[_builtins.str] tag_value: tag value.
        :param pulumi.Input[_builtins.int] create_time: creation time.
        :param pulumi.Input[_builtins.str] lane_rule_id: lane rule ID.
        :param pulumi.Input[_builtins.str] tag_id: label ID.
        :param pulumi.Input[_builtins.int] update_time: update time.
        """
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "tag_operator", tag_operator)
        pulumi.set(__self__, "tag_value", tag_value)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if lane_rule_id is not None:
            pulumi.set(__self__, "lane_rule_id", lane_rule_id)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> pulumi.Input[_builtins.str]:
        """
        label name.
        """
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_name", value)

    @_builtins.property
    @pulumi.getter(name="tagOperator")
    def tag_operator(self) -> pulumi.Input[_builtins.str]:
        """
        label operator.
        """
        return pulumi.get(self, "tag_operator")

    @tag_operator.setter
    def tag_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_operator", value)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> pulumi.Input[_builtins.str]:
        """
        tag value.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_value", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        creation time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="laneRuleId")
    def lane_rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        lane rule ID.
        """
        return pulumi.get(self, "lane_rule_id")

    @lane_rule_id.setter
    def lane_rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lane_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        label ID.
        """
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_id", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class TaskAdvanceSettingsArgsDict(TypedDict):
        sub_task_concurrency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Subtask single-machine concurrency limit, the default value is 2.
        """
elif False:
    TaskAdvanceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskAdvanceSettingsArgs:
    def __init__(__self__, *,
                 sub_task_concurrency: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] sub_task_concurrency: Subtask single-machine concurrency limit, the default value is 2.
        """
        if sub_task_concurrency is not None:
            pulumi.set(__self__, "sub_task_concurrency", sub_task_concurrency)

    @_builtins.property
    @pulumi.getter(name="subTaskConcurrency")
    def sub_task_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Subtask single-machine concurrency limit, the default value is 2.
        """
        return pulumi.get(self, "sub_task_concurrency")

    @sub_task_concurrency.setter
    def sub_task_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sub_task_concurrency", value)


if not MYPY:
    class TaskShardArgumentArgsDict(TypedDict):
        shard_key: pulumi.Input[_builtins.int]
        """
        Sharding parameter KEY, integer, range [1,1000].
        """
        shard_value: pulumi.Input[_builtins.str]
        """
        Shard parameter VALUE.
        """
elif False:
    TaskShardArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskShardArgumentArgs:
    def __init__(__self__, *,
                 shard_key: pulumi.Input[_builtins.int],
                 shard_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] shard_key: Sharding parameter KEY, integer, range [1,1000].
        :param pulumi.Input[_builtins.str] shard_value: Shard parameter VALUE.
        """
        pulumi.set(__self__, "shard_key", shard_key)
        pulumi.set(__self__, "shard_value", shard_value)

    @_builtins.property
    @pulumi.getter(name="shardKey")
    def shard_key(self) -> pulumi.Input[_builtins.int]:
        """
        Sharding parameter KEY, integer, range [1,1000].
        """
        return pulumi.get(self, "shard_key")

    @shard_key.setter
    def shard_key(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "shard_key", value)

    @_builtins.property
    @pulumi.getter(name="shardValue")
    def shard_value(self) -> pulumi.Input[_builtins.str]:
        """
        Shard parameter VALUE.
        """
        return pulumi.get(self, "shard_value")

    @shard_value.setter
    def shard_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shard_value", value)


if not MYPY:
    class TaskTaskRuleArgsDict(TypedDict):
        rule_type: pulumi.Input[_builtins.str]
        """
        trigger rule type, Cron/Repeat.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cron type rule, cron expression.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        time interval, in milliseconds.
        """
elif False:
    TaskTaskRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] rule_type: trigger rule type, Cron/Repeat.
        :param pulumi.Input[_builtins.str] expression: Cron type rule, cron expression.
        :param pulumi.Input[_builtins.int] repeat_interval: time interval, in milliseconds.
        """
        pulumi.set(__self__, "rule_type", rule_type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[_builtins.str]:
        """
        trigger rule type, Cron/Repeat.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cron type rule, cron expression.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        time interval, in milliseconds.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class UnitRuleUnitRuleItemListArgsDict(TypedDict):
        dest_namespace_id: pulumi.Input[_builtins.str]
        """
        destination namespace ID.
        """
        dest_namespace_name: pulumi.Input[_builtins.str]
        """
        destination namespace name.
        """
        name: pulumi.Input[_builtins.str]
        """
        rule item name.
        """
        relationship: pulumi.Input[_builtins.str]
        """
        logical relationship: AND/OR.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        rule description.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        rule order, the smaller the higher the priority: the default is 0.
        """
        rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        rule ID.
        """
        unit_rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unitization rule ID.
        """
        unit_rule_tag_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['UnitRuleUnitRuleItemListUnitRuleTagListArgsDict']]]]
        """
        list of rule labels.
        """
elif False:
    UnitRuleUnitRuleItemListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitRuleUnitRuleItemListArgs:
    def __init__(__self__, *,
                 dest_namespace_id: pulumi.Input[_builtins.str],
                 dest_namespace_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 relationship: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 unit_rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 unit_rule_tag_lists: Optional[pulumi.Input[Sequence[pulumi.Input['UnitRuleUnitRuleItemListUnitRuleTagListArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] dest_namespace_id: destination namespace ID.
        :param pulumi.Input[_builtins.str] dest_namespace_name: destination namespace name.
        :param pulumi.Input[_builtins.str] name: rule item name.
        :param pulumi.Input[_builtins.str] relationship: logical relationship: AND/OR.
        :param pulumi.Input[_builtins.str] description: rule description.
        :param pulumi.Input[_builtins.int] priority: rule order, the smaller the higher the priority: the default is 0.
        :param pulumi.Input[_builtins.str] rule_id: rule ID.
        :param pulumi.Input[_builtins.str] unit_rule_id: Unitization rule ID.
        :param pulumi.Input[Sequence[pulumi.Input['UnitRuleUnitRuleItemListUnitRuleTagListArgs']]] unit_rule_tag_lists: list of rule labels.
        """
        pulumi.set(__self__, "dest_namespace_id", dest_namespace_id)
        pulumi.set(__self__, "dest_namespace_name", dest_namespace_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "relationship", relationship)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if unit_rule_id is not None:
            pulumi.set(__self__, "unit_rule_id", unit_rule_id)
        if unit_rule_tag_lists is not None:
            pulumi.set(__self__, "unit_rule_tag_lists", unit_rule_tag_lists)

    @_builtins.property
    @pulumi.getter(name="destNamespaceId")
    def dest_namespace_id(self) -> pulumi.Input[_builtins.str]:
        """
        destination namespace ID.
        """
        return pulumi.get(self, "dest_namespace_id")

    @dest_namespace_id.setter
    def dest_namespace_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dest_namespace_id", value)

    @_builtins.property
    @pulumi.getter(name="destNamespaceName")
    def dest_namespace_name(self) -> pulumi.Input[_builtins.str]:
        """
        destination namespace name.
        """
        return pulumi.get(self, "dest_namespace_name")

    @dest_namespace_name.setter
    def dest_namespace_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dest_namespace_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        rule item name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def relationship(self) -> pulumi.Input[_builtins.str]:
        """
        logical relationship: AND/OR.
        """
        return pulumi.get(self, "relationship")

    @relationship.setter
    def relationship(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "relationship", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        rule order, the smaller the higher the priority: the default is 0.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        rule ID.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="unitRuleId")
    def unit_rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unitization rule ID.
        """
        return pulumi.get(self, "unit_rule_id")

    @unit_rule_id.setter
    def unit_rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="unitRuleTagLists")
    def unit_rule_tag_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UnitRuleUnitRuleItemListUnitRuleTagListArgs']]]]:
        """
        list of rule labels.
        """
        return pulumi.get(self, "unit_rule_tag_lists")

    @unit_rule_tag_lists.setter
    def unit_rule_tag_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UnitRuleUnitRuleItemListUnitRuleTagListArgs']]]]):
        pulumi.set(self, "unit_rule_tag_lists", value)


if not MYPY:
    class UnitRuleUnitRuleItemListUnitRuleTagListArgsDict(TypedDict):
        tag_field: pulumi.Input[_builtins.str]
        """
        label name.
        """
        tag_operator: pulumi.Input[_builtins.str]
        """
        Operator: IN/NOT_IN/EQUAL/NOT_EQUAL/REGEX.
        """
        tag_type: pulumi.Input[_builtins.str]
        """
        Tag Type: U(User Tag).
        """
        tag_value: pulumi.Input[_builtins.str]
        """
        tag value.
        """
        rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        rule ID.
        """
        unit_rule_item_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unitization rule item ID.
        """
elif False:
    UnitRuleUnitRuleItemListUnitRuleTagListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitRuleUnitRuleItemListUnitRuleTagListArgs:
    def __init__(__self__, *,
                 tag_field: pulumi.Input[_builtins.str],
                 tag_operator: pulumi.Input[_builtins.str],
                 tag_type: pulumi.Input[_builtins.str],
                 tag_value: pulumi.Input[_builtins.str],
                 rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 unit_rule_item_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tag_field: label name.
        :param pulumi.Input[_builtins.str] tag_operator: Operator: IN/NOT_IN/EQUAL/NOT_EQUAL/REGEX.
        :param pulumi.Input[_builtins.str] tag_type: Tag Type: U(User Tag).
        :param pulumi.Input[_builtins.str] tag_value: tag value.
        :param pulumi.Input[_builtins.str] rule_id: rule ID.
        :param pulumi.Input[_builtins.str] unit_rule_item_id: Unitization rule item ID.
        """
        pulumi.set(__self__, "tag_field", tag_field)
        pulumi.set(__self__, "tag_operator", tag_operator)
        pulumi.set(__self__, "tag_type", tag_type)
        pulumi.set(__self__, "tag_value", tag_value)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if unit_rule_item_id is not None:
            pulumi.set(__self__, "unit_rule_item_id", unit_rule_item_id)

    @_builtins.property
    @pulumi.getter(name="tagField")
    def tag_field(self) -> pulumi.Input[_builtins.str]:
        """
        label name.
        """
        return pulumi.get(self, "tag_field")

    @tag_field.setter
    def tag_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_field", value)

    @_builtins.property
    @pulumi.getter(name="tagOperator")
    def tag_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator: IN/NOT_IN/EQUAL/NOT_EQUAL/REGEX.
        """
        return pulumi.get(self, "tag_operator")

    @tag_operator.setter
    def tag_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_operator", value)

    @_builtins.property
    @pulumi.getter(name="tagType")
    def tag_type(self) -> pulumi.Input[_builtins.str]:
        """
        Tag Type: U(User Tag).
        """
        return pulumi.get(self, "tag_type")

    @tag_type.setter
    def tag_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_type", value)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> pulumi.Input[_builtins.str]:
        """
        tag value.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_value", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        rule ID.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="unitRuleItemId")
    def unit_rule_item_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unitization rule item ID.
        """
        return pulumi.get(self, "unit_rule_item_id")

    @unit_rule_item_id.setter
    def unit_rule_item_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit_rule_item_id", value)


