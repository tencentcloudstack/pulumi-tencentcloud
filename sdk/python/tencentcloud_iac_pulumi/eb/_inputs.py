# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'EventConnectorConnectionDescriptionArgs',
    'EventConnectorConnectionDescriptionArgsDict',
    'EventConnectorConnectionDescriptionApiGwParamsArgs',
    'EventConnectorConnectionDescriptionApiGwParamsArgsDict',
    'EventConnectorConnectionDescriptionCkafkaParamsArgs',
    'EventConnectorConnectionDescriptionCkafkaParamsArgsDict',
    'EventTargetTargetDescriptionArgs',
    'EventTargetTargetDescriptionArgsDict',
    'EventTargetTargetDescriptionCkafkaTargetParamsArgs',
    'EventTargetTargetDescriptionCkafkaTargetParamsArgsDict',
    'EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgs',
    'EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgsDict',
    'EventTargetTargetDescriptionEsTargetParamsArgs',
    'EventTargetTargetDescriptionEsTargetParamsArgsDict',
    'EventTargetTargetDescriptionScfParamsArgs',
    'EventTargetTargetDescriptionScfParamsArgsDict',
    'EventTransformTransformationArgs',
    'EventTransformTransformationArgsDict',
    'EventTransformTransformationEtlFilterArgs',
    'EventTransformTransformationEtlFilterArgsDict',
    'EventTransformTransformationExtractionArgs',
    'EventTransformTransformationExtractionArgsDict',
    'EventTransformTransformationExtractionTextParamsArgs',
    'EventTransformTransformationExtractionTextParamsArgsDict',
    'EventTransformTransformationTransformArgs',
    'EventTransformTransformationTransformArgsDict',
    'EventTransformTransformationTransformOutputStructArgs',
    'EventTransformTransformationTransformOutputStructArgsDict',
    'PutEventsEventListArgs',
    'PutEventsEventListArgsDict',
    'GetBusFilterArgs',
    'GetBusFilterArgsDict',
    'GetSearchFilterArgs',
    'GetSearchFilterArgsDict',
    'GetSearchFilterFilterArgs',
    'GetSearchFilterFilterArgsDict',
]

MYPY = False

if not MYPY:
    class EventConnectorConnectionDescriptionArgsDict(TypedDict):
        resource_description: pulumi.Input[_builtins.str]
        """
        Resource qcs six-segment style, more reference [resource six-segment style](https://cloud.tencent.com/document/product/598/10606).
        """
        api_gw_params: NotRequired[pulumi.Input['EventConnectorConnectionDescriptionApiGwParamsArgsDict']]
        """
        apigw parameter,Note: This field may return null, indicating that no valid value can be obtained.
        """
        ckafka_params: NotRequired[pulumi.Input['EventConnectorConnectionDescriptionCkafkaParamsArgsDict']]
        """
        ckafka parameter, note: this field may return null, indicating that no valid value can be obtained.
        """
elif False:
    EventConnectorConnectionDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectorConnectionDescriptionArgs:
    def __init__(__self__, *,
                 resource_description: pulumi.Input[_builtins.str],
                 api_gw_params: Optional[pulumi.Input['EventConnectorConnectionDescriptionApiGwParamsArgs']] = None,
                 ckafka_params: Optional[pulumi.Input['EventConnectorConnectionDescriptionCkafkaParamsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] resource_description: Resource qcs six-segment style, more reference [resource six-segment style](https://cloud.tencent.com/document/product/598/10606).
        :param pulumi.Input['EventConnectorConnectionDescriptionApiGwParamsArgs'] api_gw_params: apigw parameter,Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['EventConnectorConnectionDescriptionCkafkaParamsArgs'] ckafka_params: ckafka parameter, note: this field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "resource_description", resource_description)
        if api_gw_params is not None:
            pulumi.set(__self__, "api_gw_params", api_gw_params)
        if ckafka_params is not None:
            pulumi.set(__self__, "ckafka_params", ckafka_params)

    @_builtins.property
    @pulumi.getter(name="resourceDescription")
    def resource_description(self) -> pulumi.Input[_builtins.str]:
        """
        Resource qcs six-segment style, more reference [resource six-segment style](https://cloud.tencent.com/document/product/598/10606).
        """
        return pulumi.get(self, "resource_description")

    @resource_description.setter
    def resource_description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_description", value)

    @_builtins.property
    @pulumi.getter(name="apiGwParams")
    def api_gw_params(self) -> Optional[pulumi.Input['EventConnectorConnectionDescriptionApiGwParamsArgs']]:
        """
        apigw parameter,Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "api_gw_params")

    @api_gw_params.setter
    def api_gw_params(self, value: Optional[pulumi.Input['EventConnectorConnectionDescriptionApiGwParamsArgs']]):
        pulumi.set(self, "api_gw_params", value)

    @_builtins.property
    @pulumi.getter(name="ckafkaParams")
    def ckafka_params(self) -> Optional[pulumi.Input['EventConnectorConnectionDescriptionCkafkaParamsArgs']]:
        """
        ckafka parameter, note: this field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "ckafka_params")

    @ckafka_params.setter
    def ckafka_params(self, value: Optional[pulumi.Input['EventConnectorConnectionDescriptionCkafkaParamsArgs']]):
        pulumi.set(self, "ckafka_params", value)


if not MYPY:
    class EventConnectorConnectionDescriptionApiGwParamsArgsDict(TypedDict):
        method: pulumi.Input[_builtins.str]
        """
        POST.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        HTTPS.
        """
elif False:
    EventConnectorConnectionDescriptionApiGwParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectorConnectionDescriptionApiGwParamsArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] method: POST.
        :param pulumi.Input[_builtins.str] protocol: HTTPS.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        POST.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        HTTPS.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class EventConnectorConnectionDescriptionCkafkaParamsArgsDict(TypedDict):
        offset: pulumi.Input[_builtins.str]
        """
        kafka offset.
        """
        topic_name: pulumi.Input[_builtins.str]
        """
        ckafka  topic.
        """
elif False:
    EventConnectorConnectionDescriptionCkafkaParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectorConnectionDescriptionCkafkaParamsArgs:
    def __init__(__self__, *,
                 offset: pulumi.Input[_builtins.str],
                 topic_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] offset: kafka offset.
        :param pulumi.Input[_builtins.str] topic_name: ckafka  topic.
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "topic_name", topic_name)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> pulumi.Input[_builtins.str]:
        """
        kafka offset.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[_builtins.str]:
        """
        ckafka  topic.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_name", value)


if not MYPY:
    class EventTargetTargetDescriptionArgsDict(TypedDict):
        resource_description: pulumi.Input[_builtins.str]
        """
        QCS resource six-stage format, more references [resource six-stage format](https://cloud.tencent.com/document/product/598/10606).
        """
        ckafka_target_params: NotRequired[pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsArgsDict']]
        """
        Ckafka parameters.
        """
        es_target_params: NotRequired[pulumi.Input['EventTargetTargetDescriptionEsTargetParamsArgsDict']]
        """
        ElasticSearch parameters.
        """
        scf_params: NotRequired[pulumi.Input['EventTargetTargetDescriptionScfParamsArgsDict']]
        """
        cloud function parameters.
        """
elif False:
    EventTargetTargetDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetTargetDescriptionArgs:
    def __init__(__self__, *,
                 resource_description: pulumi.Input[_builtins.str],
                 ckafka_target_params: Optional[pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsArgs']] = None,
                 es_target_params: Optional[pulumi.Input['EventTargetTargetDescriptionEsTargetParamsArgs']] = None,
                 scf_params: Optional[pulumi.Input['EventTargetTargetDescriptionScfParamsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] resource_description: QCS resource six-stage format, more references [resource six-stage format](https://cloud.tencent.com/document/product/598/10606).
        :param pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsArgs'] ckafka_target_params: Ckafka parameters.
        :param pulumi.Input['EventTargetTargetDescriptionEsTargetParamsArgs'] es_target_params: ElasticSearch parameters.
        :param pulumi.Input['EventTargetTargetDescriptionScfParamsArgs'] scf_params: cloud function parameters.
        """
        pulumi.set(__self__, "resource_description", resource_description)
        if ckafka_target_params is not None:
            pulumi.set(__self__, "ckafka_target_params", ckafka_target_params)
        if es_target_params is not None:
            pulumi.set(__self__, "es_target_params", es_target_params)
        if scf_params is not None:
            pulumi.set(__self__, "scf_params", scf_params)

    @_builtins.property
    @pulumi.getter(name="resourceDescription")
    def resource_description(self) -> pulumi.Input[_builtins.str]:
        """
        QCS resource six-stage format, more references [resource six-stage format](https://cloud.tencent.com/document/product/598/10606).
        """
        return pulumi.get(self, "resource_description")

    @resource_description.setter
    def resource_description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_description", value)

    @_builtins.property
    @pulumi.getter(name="ckafkaTargetParams")
    def ckafka_target_params(self) -> Optional[pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsArgs']]:
        """
        Ckafka parameters.
        """
        return pulumi.get(self, "ckafka_target_params")

    @ckafka_target_params.setter
    def ckafka_target_params(self, value: Optional[pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsArgs']]):
        pulumi.set(self, "ckafka_target_params", value)

    @_builtins.property
    @pulumi.getter(name="esTargetParams")
    def es_target_params(self) -> Optional[pulumi.Input['EventTargetTargetDescriptionEsTargetParamsArgs']]:
        """
        ElasticSearch parameters.
        """
        return pulumi.get(self, "es_target_params")

    @es_target_params.setter
    def es_target_params(self, value: Optional[pulumi.Input['EventTargetTargetDescriptionEsTargetParamsArgs']]):
        pulumi.set(self, "es_target_params", value)

    @_builtins.property
    @pulumi.getter(name="scfParams")
    def scf_params(self) -> Optional[pulumi.Input['EventTargetTargetDescriptionScfParamsArgs']]:
        """
        cloud function parameters.
        """
        return pulumi.get(self, "scf_params")

    @scf_params.setter
    def scf_params(self, value: Optional[pulumi.Input['EventTargetTargetDescriptionScfParamsArgs']]):
        pulumi.set(self, "scf_params", value)


if not MYPY:
    class EventTargetTargetDescriptionCkafkaTargetParamsArgsDict(TypedDict):
        retry_policy: pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgsDict']
        """
        retry strategy.
        """
        topic_name: pulumi.Input[_builtins.str]
        """
        The ckafka topic to deliver to.
        """
elif False:
    EventTargetTargetDescriptionCkafkaTargetParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetTargetDescriptionCkafkaTargetParamsArgs:
    def __init__(__self__, *,
                 retry_policy: pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgs'],
                 topic_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgs'] retry_policy: retry strategy.
        :param pulumi.Input[_builtins.str] topic_name: The ckafka topic to deliver to.
        """
        pulumi.set(__self__, "retry_policy", retry_policy)
        pulumi.set(__self__, "topic_name", topic_name)

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgs']:
        """
        retry strategy.
        """
        return pulumi.get(self, "retry_policy")

    @retry_policy.setter
    def retry_policy(self, value: pulumi.Input['EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgs']):
        pulumi.set(self, "retry_policy", value)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[_builtins.str]:
        """
        The ckafka topic to deliver to.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_name", value)


if not MYPY:
    class EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgsDict(TypedDict):
        max_retry_attempts: pulumi.Input[_builtins.int]
        """
        Maximum number of retries.
        """
        retry_interval: pulumi.Input[_builtins.int]
        """
        Retry Interval Unit: Seconds.
        """
elif False:
    EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicyArgs:
    def __init__(__self__, *,
                 max_retry_attempts: pulumi.Input[_builtins.int],
                 retry_interval: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_retry_attempts: Maximum number of retries.
        :param pulumi.Input[_builtins.int] retry_interval: Retry Interval Unit: Seconds.
        """
        pulumi.set(__self__, "max_retry_attempts", max_retry_attempts)
        pulumi.set(__self__, "retry_interval", retry_interval)

    @_builtins.property
    @pulumi.getter(name="maxRetryAttempts")
    def max_retry_attempts(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retry_attempts")

    @max_retry_attempts.setter
    def max_retry_attempts(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_retry_attempts", value)

    @_builtins.property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> pulumi.Input[_builtins.int]:
        """
        Retry Interval Unit: Seconds.
        """
        return pulumi.get(self, "retry_interval")

    @retry_interval.setter
    def retry_interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "retry_interval", value)


if not MYPY:
    class EventTargetTargetDescriptionEsTargetParamsArgsDict(TypedDict):
        index_prefix: pulumi.Input[_builtins.str]
        """
        index prefix.
        """
        index_suffix_mode: pulumi.Input[_builtins.str]
        """
        DTS index configuration.
        """
        net_mode: pulumi.Input[_builtins.str]
        """
        network connection type.
        """
        output_mode: pulumi.Input[_builtins.str]
        """
        DTS event configuration.
        """
        rotation_interval: pulumi.Input[_builtins.str]
        """
        es log rotation granularity.
        """
        index_template_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        es template type.
        """
elif False:
    EventTargetTargetDescriptionEsTargetParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetTargetDescriptionEsTargetParamsArgs:
    def __init__(__self__, *,
                 index_prefix: pulumi.Input[_builtins.str],
                 index_suffix_mode: pulumi.Input[_builtins.str],
                 net_mode: pulumi.Input[_builtins.str],
                 output_mode: pulumi.Input[_builtins.str],
                 rotation_interval: pulumi.Input[_builtins.str],
                 index_template_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] index_prefix: index prefix.
        :param pulumi.Input[_builtins.str] index_suffix_mode: DTS index configuration.
        :param pulumi.Input[_builtins.str] net_mode: network connection type.
        :param pulumi.Input[_builtins.str] output_mode: DTS event configuration.
        :param pulumi.Input[_builtins.str] rotation_interval: es log rotation granularity.
        :param pulumi.Input[_builtins.str] index_template_type: es template type.
        """
        pulumi.set(__self__, "index_prefix", index_prefix)
        pulumi.set(__self__, "index_suffix_mode", index_suffix_mode)
        pulumi.set(__self__, "net_mode", net_mode)
        pulumi.set(__self__, "output_mode", output_mode)
        pulumi.set(__self__, "rotation_interval", rotation_interval)
        if index_template_type is not None:
            pulumi.set(__self__, "index_template_type", index_template_type)

    @_builtins.property
    @pulumi.getter(name="indexPrefix")
    def index_prefix(self) -> pulumi.Input[_builtins.str]:
        """
        index prefix.
        """
        return pulumi.get(self, "index_prefix")

    @index_prefix.setter
    def index_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index_prefix", value)

    @_builtins.property
    @pulumi.getter(name="indexSuffixMode")
    def index_suffix_mode(self) -> pulumi.Input[_builtins.str]:
        """
        DTS index configuration.
        """
        return pulumi.get(self, "index_suffix_mode")

    @index_suffix_mode.setter
    def index_suffix_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index_suffix_mode", value)

    @_builtins.property
    @pulumi.getter(name="netMode")
    def net_mode(self) -> pulumi.Input[_builtins.str]:
        """
        network connection type.
        """
        return pulumi.get(self, "net_mode")

    @net_mode.setter
    def net_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_mode", value)

    @_builtins.property
    @pulumi.getter(name="outputMode")
    def output_mode(self) -> pulumi.Input[_builtins.str]:
        """
        DTS event configuration.
        """
        return pulumi.get(self, "output_mode")

    @output_mode.setter
    def output_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_mode", value)

    @_builtins.property
    @pulumi.getter(name="rotationInterval")
    def rotation_interval(self) -> pulumi.Input[_builtins.str]:
        """
        es log rotation granularity.
        """
        return pulumi.get(self, "rotation_interval")

    @rotation_interval.setter
    def rotation_interval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rotation_interval", value)

    @_builtins.property
    @pulumi.getter(name="indexTemplateType")
    def index_template_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        es template type.
        """
        return pulumi.get(self, "index_template_type")

    @index_template_type.setter
    def index_template_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_template_type", value)


if not MYPY:
    class EventTargetTargetDescriptionScfParamsArgsDict(TypedDict):
        batch_event_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of events for batch delivery. This parameter is no longer effective, please use the batch_event_count parameter at the outer level.
        """
        batch_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum waiting time for batch delivery. This parameter is no longer effective, please use the batch_timeout parameter at the outer level.
        """
        enable_batch_delivery: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable batch delivery. This parameter is no longer effective, please use the enable_batch_delivery parameter at the outer level.
        """
elif False:
    EventTargetTargetDescriptionScfParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetTargetDescriptionScfParamsArgs:
    def __init__(__self__, *,
                 batch_event_count: Optional[pulumi.Input[_builtins.int]] = None,
                 batch_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 enable_batch_delivery: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] batch_event_count: Maximum number of events for batch delivery. This parameter is no longer effective, please use the batch_event_count parameter at the outer level.
        :param pulumi.Input[_builtins.int] batch_timeout: Maximum waiting time for batch delivery. This parameter is no longer effective, please use the batch_timeout parameter at the outer level.
        :param pulumi.Input[_builtins.bool] enable_batch_delivery: Enable batch delivery. This parameter is no longer effective, please use the enable_batch_delivery parameter at the outer level.
        """
        if batch_event_count is not None:
            pulumi.set(__self__, "batch_event_count", batch_event_count)
        if batch_timeout is not None:
            pulumi.set(__self__, "batch_timeout", batch_timeout)
        if enable_batch_delivery is not None:
            pulumi.set(__self__, "enable_batch_delivery", enable_batch_delivery)

    @_builtins.property
    @pulumi.getter(name="batchEventCount")
    def batch_event_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of events for batch delivery. This parameter is no longer effective, please use the batch_event_count parameter at the outer level.
        """
        return pulumi.get(self, "batch_event_count")

    @batch_event_count.setter
    def batch_event_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_event_count", value)

    @_builtins.property
    @pulumi.getter(name="batchTimeout")
    def batch_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum waiting time for batch delivery. This parameter is no longer effective, please use the batch_timeout parameter at the outer level.
        """
        return pulumi.get(self, "batch_timeout")

    @batch_timeout.setter
    def batch_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_timeout", value)

    @_builtins.property
    @pulumi.getter(name="enableBatchDelivery")
    def enable_batch_delivery(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable batch delivery. This parameter is no longer effective, please use the enable_batch_delivery parameter at the outer level.
        """
        return pulumi.get(self, "enable_batch_delivery")

    @enable_batch_delivery.setter
    def enable_batch_delivery(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_batch_delivery", value)


if not MYPY:
    class EventTransformTransformationArgsDict(TypedDict):
        etl_filter: NotRequired[pulumi.Input['EventTransformTransformationEtlFilterArgsDict']]
        """
        Describe how to filter data.
        """
        extraction: NotRequired[pulumi.Input['EventTransformTransformationExtractionArgsDict']]
        """
        Describe how to extract data.
        """
        transform: NotRequired[pulumi.Input['EventTransformTransformationTransformArgsDict']]
        """
        Describe how to convert data.
        """
elif False:
    EventTransformTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTransformTransformationArgs:
    def __init__(__self__, *,
                 etl_filter: Optional[pulumi.Input['EventTransformTransformationEtlFilterArgs']] = None,
                 extraction: Optional[pulumi.Input['EventTransformTransformationExtractionArgs']] = None,
                 transform: Optional[pulumi.Input['EventTransformTransformationTransformArgs']] = None):
        """
        :param pulumi.Input['EventTransformTransformationEtlFilterArgs'] etl_filter: Describe how to filter data.
        :param pulumi.Input['EventTransformTransformationExtractionArgs'] extraction: Describe how to extract data.
        :param pulumi.Input['EventTransformTransformationTransformArgs'] transform: Describe how to convert data.
        """
        if etl_filter is not None:
            pulumi.set(__self__, "etl_filter", etl_filter)
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if transform is not None:
            pulumi.set(__self__, "transform", transform)

    @_builtins.property
    @pulumi.getter(name="etlFilter")
    def etl_filter(self) -> Optional[pulumi.Input['EventTransformTransformationEtlFilterArgs']]:
        """
        Describe how to filter data.
        """
        return pulumi.get(self, "etl_filter")

    @etl_filter.setter
    def etl_filter(self, value: Optional[pulumi.Input['EventTransformTransformationEtlFilterArgs']]):
        pulumi.set(self, "etl_filter", value)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional[pulumi.Input['EventTransformTransformationExtractionArgs']]:
        """
        Describe how to extract data.
        """
        return pulumi.get(self, "extraction")

    @extraction.setter
    def extraction(self, value: Optional[pulumi.Input['EventTransformTransformationExtractionArgs']]):
        pulumi.set(self, "extraction", value)

    @_builtins.property
    @pulumi.getter
    def transform(self) -> Optional[pulumi.Input['EventTransformTransformationTransformArgs']]:
        """
        Describe how to convert data.
        """
        return pulumi.get(self, "transform")

    @transform.setter
    def transform(self, value: Optional[pulumi.Input['EventTransformTransformationTransformArgs']]):
        pulumi.set(self, "transform", value)


if not MYPY:
    class EventTransformTransformationEtlFilterArgsDict(TypedDict):
        filter: pulumi.Input[_builtins.str]
        """
        Grammatical Rules are consistent.
        """
elif False:
    EventTransformTransformationEtlFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTransformTransformationEtlFilterArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] filter: Grammatical Rules are consistent.
        """
        pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> pulumi.Input[_builtins.str]:
        """
        Grammatical Rules are consistent.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class EventTransformTransformationExtractionArgsDict(TypedDict):
        extraction_input_path: pulumi.Input[_builtins.str]
        """
        JsonPath, if not specified, the default value $.
        """
        format: pulumi.Input[_builtins.str]
        """
        Value: `TEXT`, `JSON`.
        """
        text_params: NotRequired[pulumi.Input['EventTransformTransformationExtractionTextParamsArgsDict']]
        """
        Only Text needs to be passed.
        """
elif False:
    EventTransformTransformationExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTransformTransformationExtractionArgs:
    def __init__(__self__, *,
                 extraction_input_path: pulumi.Input[_builtins.str],
                 format: pulumi.Input[_builtins.str],
                 text_params: Optional[pulumi.Input['EventTransformTransformationExtractionTextParamsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] extraction_input_path: JsonPath, if not specified, the default value $.
        :param pulumi.Input[_builtins.str] format: Value: `TEXT`, `JSON`.
        :param pulumi.Input['EventTransformTransformationExtractionTextParamsArgs'] text_params: Only Text needs to be passed.
        """
        pulumi.set(__self__, "extraction_input_path", extraction_input_path)
        pulumi.set(__self__, "format", format)
        if text_params is not None:
            pulumi.set(__self__, "text_params", text_params)

    @_builtins.property
    @pulumi.getter(name="extractionInputPath")
    def extraction_input_path(self) -> pulumi.Input[_builtins.str]:
        """
        JsonPath, if not specified, the default value $.
        """
        return pulumi.get(self, "extraction_input_path")

    @extraction_input_path.setter
    def extraction_input_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "extraction_input_path", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        Value: `TEXT`, `JSON`.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="textParams")
    def text_params(self) -> Optional[pulumi.Input['EventTransformTransformationExtractionTextParamsArgs']]:
        """
        Only Text needs to be passed.
        """
        return pulumi.get(self, "text_params")

    @text_params.setter
    def text_params(self, value: Optional[pulumi.Input['EventTransformTransformationExtractionTextParamsArgs']]):
        pulumi.set(self, "text_params", value)


if not MYPY:
    class EventTransformTransformationExtractionTextParamsArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fill in the regular expression: length 128.
        """
        separator: NotRequired[pulumi.Input[_builtins.str]]
        """
        `Comma`, `|`, `tab`, `space`, `newline`, `%`, `#`, the limit length is 1.
        """
elif False:
    EventTransformTransformationExtractionTextParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTransformTransformationExtractionTextParamsArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None,
                 separator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Fill in the regular expression: length 128.
        :param pulumi.Input[_builtins.str] separator: `Comma`, `|`, `tab`, `space`, `newline`, `%`, `#`, the limit length is 1.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fill in the regular expression: length 128.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `Comma`, `|`, `tab`, `space`, `newline`, `%`, `#`, the limit length is 1.
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "separator", value)


if not MYPY:
    class EventTransformTransformationTransformArgsDict(TypedDict):
        output_structs: pulumi.Input[Sequence[pulumi.Input['EventTransformTransformationTransformOutputStructArgsDict']]]
        """
        Describe how the data is transformed.
        """
elif False:
    EventTransformTransformationTransformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTransformTransformationTransformArgs:
    def __init__(__self__, *,
                 output_structs: pulumi.Input[Sequence[pulumi.Input['EventTransformTransformationTransformOutputStructArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventTransformTransformationTransformOutputStructArgs']]] output_structs: Describe how the data is transformed.
        """
        pulumi.set(__self__, "output_structs", output_structs)

    @_builtins.property
    @pulumi.getter(name="outputStructs")
    def output_structs(self) -> pulumi.Input[Sequence[pulumi.Input['EventTransformTransformationTransformOutputStructArgs']]]:
        """
        Describe how the data is transformed.
        """
        return pulumi.get(self, "output_structs")

    @output_structs.setter
    def output_structs(self, value: pulumi.Input[Sequence[pulumi.Input['EventTransformTransformationTransformOutputStructArgs']]]):
        pulumi.set(self, "output_structs", value)


if not MYPY:
    class EventTransformTransformationTransformOutputStructArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Corresponding to the key in the output json.
        """
        value: pulumi.Input[_builtins.str]
        """
        You can fill in the json-path and also support constants or built-in keyword date types.
        """
        value_type: pulumi.Input[_builtins.str]
        """
        The data type of value, optional values: `STRING`, `NUMBER`, `BOOLEAN`, `NULL`, `SYS_VARIABLE`, `JSONPATH`.
        """
elif False:
    EventTransformTransformationTransformOutputStructArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTransformTransformationTransformOutputStructArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 value_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Corresponding to the key in the output json.
        :param pulumi.Input[_builtins.str] value: You can fill in the json-path and also support constants or built-in keyword date types.
        :param pulumi.Input[_builtins.str] value_type: The data type of value, optional values: `STRING`, `NUMBER`, `BOOLEAN`, `NULL`, `SYS_VARIABLE`, `JSONPATH`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Corresponding to the key in the output json.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        You can fill in the json-path and also support constants or built-in keyword date types.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[_builtins.str]:
        """
        The data type of value, optional values: `STRING`, `NUMBER`, `BOOLEAN`, `NULL`, `SYS_VARIABLE`, `JSONPATH`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class PutEventsEventListArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        Event data, the content is controlled by the system that created the event, the current datacontenttype only supports application/json;charset=utf-8, so this field is a json string.
        """
        source: pulumi.Input[_builtins.str]
        """
        Event source information, new product reporting must comply with EB specifications.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Detailed description of the event source, customizable, optional. The cloud service defaults to the standard qcs resource representation syntax: qcs::dts:ap-guangzhou:appid/uin:xxx.
        """
        type: pulumi.Input[_builtins.str]
        """
        Event type, customizable, optional. The cloud service writes COS:Created:PostObject by default, use: to separate the type field.
        """
        time: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timestamp in milliseconds when the event occurred,time.Now().UnixNano()/1e6.
        """
elif False:
    PutEventsEventListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PutEventsEventListArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] data: Event data, the content is controlled by the system that created the event, the current datacontenttype only supports application/json;charset=utf-8, so this field is a json string.
        :param pulumi.Input[_builtins.str] source: Event source information, new product reporting must comply with EB specifications.
        :param pulumi.Input[_builtins.str] subject: Detailed description of the event source, customizable, optional. The cloud service defaults to the standard qcs resource representation syntax: qcs::dts:ap-guangzhou:appid/uin:xxx.
        :param pulumi.Input[_builtins.str] type: Event type, customizable, optional. The cloud service writes COS:Created:PostObject by default, use: to separate the type field.
        :param pulumi.Input[_builtins.int] time: The timestamp in milliseconds when the event occurred,time.Now().UnixNano()/1e6.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "type", type)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        Event data, the content is controlled by the system that created the event, the current datacontenttype only supports application/json;charset=utf-8, so this field is a json string.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Event source information, new product reporting must comply with EB specifications.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Detailed description of the event source, customizable, optional. The cloud service defaults to the standard qcs resource representation syntax: qcs::dts:ap-guangzhou:appid/uin:xxx.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Event type, customizable, optional. The cloud service writes COS:Created:PostObject by default, use: to separate the type field.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timestamp in milliseconds when the event occurred,time.Now().UnixNano()/1e6.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class GetBusFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the filter key.
        """
        values: Sequence[_builtins.str]
        """
        One or more filter values.
        """
elif False:
    GetBusFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBusFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the filter key.
        :param Sequence[_builtins.str] values: One or more filter values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the filter key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        One or more filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSearchFilterArgsDict(TypedDict):
        filters: NotRequired[Sequence['GetSearchFilterFilterArgsDict']]
        """
        LogFilters array.
        """
        key: NotRequired[_builtins.str]
        """
        filter field name.
        """
        operator: NotRequired[_builtins.str]
        """
        operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, in range range, not in range norange.
        """
        type: NotRequired[_builtins.str]
        """
        The logical relationship of the level filters, the value AND or OR.
        """
        value: NotRequired[_builtins.str]
        """
        Filter value, range operation needs to enter two values at the same time, separated by commas.
        """
elif False:
    GetSearchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSearchFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[Sequence['GetSearchFilterFilterArgs']] = None,
                 key: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param Sequence['GetSearchFilterFilterArgs'] filters: LogFilters array.
        :param _builtins.str key: filter field name.
        :param _builtins.str operator: operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, in range range, not in range norange.
        :param _builtins.str type: The logical relationship of the level filters, the value AND or OR.
        :param _builtins.str value: Filter value, range operation needs to enter two values at the same time, separated by commas.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['GetSearchFilterFilterArgs']]:
        """
        LogFilters array.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[Sequence['GetSearchFilterFilterArgs']]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        filter field name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, in range range, not in range norange.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The logical relationship of the level filters, the value AND or OR.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Filter value, range operation needs to enter two values at the same time, separated by commas.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetSearchFilterFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        filter field name.
        """
        operator: _builtins.str
        """
        operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, within range range, not within range norange.
        """
        value: _builtins.str
        """
        Filter values, range operations need to enter two values at the same time, separated by commas.
        """
elif False:
    GetSearchFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSearchFilterFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: filter field name.
        :param _builtins.str operator: operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, within range range, not within range norange.
        :param _builtins.str value: Filter values, range operations need to enter two values at the same time, separated by commas.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        filter field name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, within range range, not within range norange.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Filter values, range operations need to enter two values at the same time, separated by commas.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


