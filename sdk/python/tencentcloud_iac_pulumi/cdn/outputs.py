# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'DomainAuthentication',
    'DomainAuthenticationTypeA',
    'DomainAuthenticationTypeB',
    'DomainAuthenticationTypeC',
    'DomainAuthenticationTypeD',
    'DomainAwsPrivateAccess',
    'DomainBandWidthAlert',
    'DomainBandWidthAlertStatisticItem',
    'DomainCacheKey',
    'DomainCacheKeyKeyRule',
    'DomainCacheKeyKeyRuleQueryString',
    'DomainCacheKeyQueryString',
    'DomainCompression',
    'DomainCompressionCompressionRule',
    'DomainDownstreamCapping',
    'DomainDownstreamCappingCappingRule',
    'DomainErrorPage',
    'DomainErrorPagePageRule',
    'DomainHttpsConfig',
    'DomainHttpsConfigClientCertificateConfig',
    'DomainHttpsConfigForceRedirect',
    'DomainHttpsConfigServerCertificateConfig',
    'DomainHwPrivateAccess',
    'DomainIpFilter',
    'DomainIpFilterFilterRule',
    'DomainIpFreqLimit',
    'DomainMaxAge',
    'DomainMaxAgeMaxAgeRule',
    'DomainOrigin',
    'DomainOriginPullOptimization',
    'DomainOriginPullTimeout',
    'DomainOssPrivateAccess',
    'DomainOthersPrivateAccess',
    'DomainPostMaxSize',
    'DomainQnPrivateAccess',
    'DomainReferer',
    'DomainRefererRefererRule',
    'DomainRequestHeader',
    'DomainRequestHeaderHeaderRule',
    'DomainResponseHeader',
    'DomainResponseHeaderHeaderRule',
    'DomainRuleCache',
    'DomainStatusCodeCache',
    'DomainStatusCodeCacheCacheRule',
    'UrlPurgePurgeHistory',
    'UrlPushPushHistory',
    'GetDomainsDomainListResult',
    'GetDomainsDomainListHttpsConfigResult',
    'GetDomainsDomainListOriginResult',
    'GetDomainsDomainListRequestHeaderResult',
    'GetDomainsDomainListRequestHeaderHeaderRuleResult',
    'GetDomainsDomainListRuleCacheResult',
]

@pulumi.output_type
class DomainAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeA":
            suggest = "type_a"
        elif key == "typeB":
            suggest = "type_b"
        elif key == "typeC":
            suggest = "type_c"
        elif key == "typeD":
            suggest = "type_d"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: Optional[_builtins.str] = None,
                 type_a: Optional['outputs.DomainAuthenticationTypeA'] = None,
                 type_b: Optional['outputs.DomainAuthenticationTypeB'] = None,
                 type_c: Optional['outputs.DomainAuthenticationTypeC'] = None,
                 type_d: Optional['outputs.DomainAuthenticationTypeD'] = None):
        """
        :param _builtins.str switch: Authentication switching, available values: `on`, `off`.
        :param 'DomainAuthenticationTypeAArgs' type_a: Timestamp hotlink protection mode A configuration.
        :param 'DomainAuthenticationTypeBArgs' type_b: Timestamp hotlink protection mode B configuration. NOTE: according to upgrading of TencentCloud Platform, TypeB is unavailable for now.
        :param 'DomainAuthenticationTypeCArgs' type_c: Timestamp hotlink protection mode C configuration.
        :param 'DomainAuthenticationTypeDArgs' type_d: Timestamp hotlink protection mode D configuration.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type_a is not None:
            pulumi.set(__self__, "type_a", type_a)
        if type_b is not None:
            pulumi.set(__self__, "type_b", type_b)
        if type_c is not None:
            pulumi.set(__self__, "type_c", type_c)
        if type_d is not None:
            pulumi.set(__self__, "type_d", type_d)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[_builtins.str]:
        """
        Authentication switching, available values: `on`, `off`.
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="typeA")
    def type_a(self) -> Optional['outputs.DomainAuthenticationTypeA']:
        """
        Timestamp hotlink protection mode A configuration.
        """
        return pulumi.get(self, "type_a")

    @_builtins.property
    @pulumi.getter(name="typeB")
    def type_b(self) -> Optional['outputs.DomainAuthenticationTypeB']:
        """
        Timestamp hotlink protection mode B configuration. NOTE: according to upgrading of TencentCloud Platform, TypeB is unavailable for now.
        """
        return pulumi.get(self, "type_b")

    @_builtins.property
    @pulumi.getter(name="typeC")
    def type_c(self) -> Optional['outputs.DomainAuthenticationTypeC']:
        """
        Timestamp hotlink protection mode C configuration.
        """
        return pulumi.get(self, "type_c")

    @_builtins.property
    @pulumi.getter(name="typeD")
    def type_d(self) -> Optional['outputs.DomainAuthenticationTypeD']:
        """
        Timestamp hotlink protection mode D configuration.
        """
        return pulumi.get(self, "type_d")


@pulumi.output_type
class DomainAuthenticationTypeA(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expireTime":
            suggest = "expire_time"
        elif key == "fileExtensions":
            suggest = "file_extensions"
        elif key == "filterType":
            suggest = "filter_type"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "signParam":
            suggest = "sign_param"
        elif key == "backupSecretKey":
            suggest = "backup_secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAuthenticationTypeA. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAuthenticationTypeA.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAuthenticationTypeA.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire_time: _builtins.int,
                 file_extensions: Sequence[_builtins.str],
                 filter_type: _builtins.str,
                 secret_key: _builtins.str,
                 sign_param: _builtins.str,
                 backup_secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.int expire_time: Signature expiration time in second. The maximum value is 630720000.
        :param Sequence[_builtins.str] file_extensions: File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        :param _builtins.str filter_type: Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        :param _builtins.str secret_key: The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        :param _builtins.str sign_param: Signature parameter name. Only upper and lower-case letters, digits, and underscores (_) are allowed. It cannot start with a digit. Length limit: 1-100 characters.
        :param _builtins.str backup_secret_key: Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        """
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "file_extensions", file_extensions)
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "sign_param", sign_param)
        if backup_secret_key is not None:
            pulumi.set(__self__, "backup_secret_key", backup_secret_key)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> _builtins.int:
        """
        Signature expiration time in second. The maximum value is 630720000.
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter(name="fileExtensions")
    def file_extensions(self) -> Sequence[_builtins.str]:
        """
        File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        """
        return pulumi.get(self, "file_extensions")

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> _builtins.str:
        """
        Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        """
        return pulumi.get(self, "filter_type")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="signParam")
    def sign_param(self) -> _builtins.str:
        """
        Signature parameter name. Only upper and lower-case letters, digits, and underscores (_) are allowed. It cannot start with a digit. Length limit: 1-100 characters.
        """
        return pulumi.get(self, "sign_param")

    @_builtins.property
    @pulumi.getter(name="backupSecretKey")
    def backup_secret_key(self) -> Optional[_builtins.str]:
        """
        Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        """
        return pulumi.get(self, "backup_secret_key")


@pulumi.output_type
class DomainAuthenticationTypeB(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expireTime":
            suggest = "expire_time"
        elif key == "fileExtensions":
            suggest = "file_extensions"
        elif key == "filterType":
            suggest = "filter_type"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "backupSecretKey":
            suggest = "backup_secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAuthenticationTypeB. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAuthenticationTypeB.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAuthenticationTypeB.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire_time: _builtins.int,
                 file_extensions: Sequence[_builtins.str],
                 filter_type: _builtins.str,
                 secret_key: _builtins.str,
                 backup_secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.int expire_time: Signature expiration time in second. The maximum value is 630720000.
        :param Sequence[_builtins.str] file_extensions: File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        :param _builtins.str filter_type: Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        :param _builtins.str secret_key: The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        :param _builtins.str backup_secret_key: Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        """
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "file_extensions", file_extensions)
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "secret_key", secret_key)
        if backup_secret_key is not None:
            pulumi.set(__self__, "backup_secret_key", backup_secret_key)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> _builtins.int:
        """
        Signature expiration time in second. The maximum value is 630720000.
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter(name="fileExtensions")
    def file_extensions(self) -> Sequence[_builtins.str]:
        """
        File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        """
        return pulumi.get(self, "file_extensions")

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> _builtins.str:
        """
        Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        """
        return pulumi.get(self, "filter_type")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="backupSecretKey")
    def backup_secret_key(self) -> Optional[_builtins.str]:
        """
        Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        """
        return pulumi.get(self, "backup_secret_key")


@pulumi.output_type
class DomainAuthenticationTypeC(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expireTime":
            suggest = "expire_time"
        elif key == "fileExtensions":
            suggest = "file_extensions"
        elif key == "filterType":
            suggest = "filter_type"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "backupSecretKey":
            suggest = "backup_secret_key"
        elif key == "timeFormat":
            suggest = "time_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAuthenticationTypeC. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAuthenticationTypeC.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAuthenticationTypeC.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire_time: _builtins.int,
                 file_extensions: Sequence[_builtins.str],
                 filter_type: _builtins.str,
                 secret_key: _builtins.str,
                 backup_secret_key: Optional[_builtins.str] = None,
                 time_format: Optional[_builtins.str] = None):
        """
        :param _builtins.int expire_time: Signature expiration time in second. The maximum value is 630720000.
        :param Sequence[_builtins.str] file_extensions: File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        :param _builtins.str filter_type: Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        :param _builtins.str secret_key: The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        :param _builtins.str backup_secret_key: Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        :param _builtins.str time_format: Timestamp formation, available values: `dec`, `hex`.
        """
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "file_extensions", file_extensions)
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "secret_key", secret_key)
        if backup_secret_key is not None:
            pulumi.set(__self__, "backup_secret_key", backup_secret_key)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> _builtins.int:
        """
        Signature expiration time in second. The maximum value is 630720000.
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter(name="fileExtensions")
    def file_extensions(self) -> Sequence[_builtins.str]:
        """
        File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        """
        return pulumi.get(self, "file_extensions")

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> _builtins.str:
        """
        Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        """
        return pulumi.get(self, "filter_type")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="backupSecretKey")
    def backup_secret_key(self) -> Optional[_builtins.str]:
        """
        Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        """
        return pulumi.get(self, "backup_secret_key")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        Timestamp formation, available values: `dec`, `hex`.
        """
        return pulumi.get(self, "time_format")


@pulumi.output_type
class DomainAuthenticationTypeD(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expireTime":
            suggest = "expire_time"
        elif key == "fileExtensions":
            suggest = "file_extensions"
        elif key == "filterType":
            suggest = "filter_type"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "backupSecretKey":
            suggest = "backup_secret_key"
        elif key == "timeFormat":
            suggest = "time_format"
        elif key == "timeParam":
            suggest = "time_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAuthenticationTypeD. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAuthenticationTypeD.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAuthenticationTypeD.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire_time: _builtins.int,
                 file_extensions: Sequence[_builtins.str],
                 filter_type: _builtins.str,
                 secret_key: _builtins.str,
                 backup_secret_key: Optional[_builtins.str] = None,
                 time_format: Optional[_builtins.str] = None,
                 time_param: Optional[_builtins.str] = None):
        """
        :param _builtins.int expire_time: Signature expiration time in second. The maximum value is 630720000.
        :param Sequence[_builtins.str] file_extensions: File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        :param _builtins.str filter_type: Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        :param _builtins.str secret_key: The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        :param _builtins.str backup_secret_key: Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        :param _builtins.str time_format: Timestamp formation, available values: `dec`, `hex`.
        :param _builtins.str time_param: Timestamp parameter name. Only upper and lower-case letters, digits, and underscores (_) are allowed. It cannot start with a digit. Length limit: 1-100 characters.
        """
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "file_extensions", file_extensions)
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "secret_key", secret_key)
        if backup_secret_key is not None:
            pulumi.set(__self__, "backup_secret_key", backup_secret_key)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_param is not None:
            pulumi.set(__self__, "time_param", time_param)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> _builtins.int:
        """
        Signature expiration time in second. The maximum value is 630720000.
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter(name="fileExtensions")
    def file_extensions(self) -> Sequence[_builtins.str]:
        """
        File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
        """
        return pulumi.get(self, "file_extensions")

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> _builtins.str:
        """
        Available values: `whitelist` - all types apart from `file_extensions` are authenticated, `blacklist`: - only the types in the `file_extensions` are authenticated.
        """
        return pulumi.get(self, "filter_type")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="backupSecretKey")
    def backup_secret_key(self) -> Optional[_builtins.str]:
        """
        Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
        """
        return pulumi.get(self, "backup_secret_key")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        Timestamp formation, available values: `dec`, `hex`.
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter(name="timeParam")
    def time_param(self) -> Optional[_builtins.str]:
        """
        Timestamp parameter name. Only upper and lower-case letters, digits, and underscores (_) are allowed. It cannot start with a digit. Length limit: 1-100 characters.
        """
        return pulumi.get(self, "time_param")


@pulumi.output_type
class DomainAwsPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAwsPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAwsPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAwsPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bucket: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.str access_key: Access ID.
        :param _builtins.str bucket: Bucket.
        :param _builtins.str region: Region.
        :param _builtins.str secret_key: Key.
        """
        pulumi.set(__self__, "switch", switch)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Access ID.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        """
        Bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class DomainBandWidthAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertPercentage":
            suggest = "alert_percentage"
        elif key == "alertSwitch":
            suggest = "alert_switch"
        elif key == "bpsThreshold":
            suggest = "bps_threshold"
        elif key == "counterMeasure":
            suggest = "counter_measure"
        elif key == "lastTriggerTime":
            suggest = "last_trigger_time"
        elif key == "lastTriggerTimeOverseas":
            suggest = "last_trigger_time_overseas"
        elif key == "statisticItem":
            suggest = "statistic_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainBandWidthAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainBandWidthAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainBandWidthAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 alert_percentage: Optional[_builtins.int] = None,
                 alert_switch: Optional[_builtins.str] = None,
                 bps_threshold: Optional[_builtins.int] = None,
                 counter_measure: Optional[_builtins.str] = None,
                 last_trigger_time: Optional[_builtins.str] = None,
                 last_trigger_time_overseas: Optional[_builtins.str] = None,
                 metric: Optional[_builtins.str] = None,
                 statistic_item: Optional['outputs.DomainBandWidthAlertStatisticItem'] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.int alert_percentage: Alert percentage.
        :param _builtins.str alert_switch: Switch alert.
        :param _builtins.int bps_threshold: threshold of bps.
        :param _builtins.str counter_measure: Counter measure, values: `RETURN_404`, `RESOLVE_DNS_TO_ORIGIN`.
        :param _builtins.str last_trigger_time: Last trigger time.
        :param _builtins.str last_trigger_time_overseas: Last trigger time of overseas.
        :param _builtins.str metric: Metric.
        :param 'DomainBandWidthAlertStatisticItemArgs' statistic_item: Specify statistic item configuration.
        """
        pulumi.set(__self__, "switch", switch)
        if alert_percentage is not None:
            pulumi.set(__self__, "alert_percentage", alert_percentage)
        if alert_switch is not None:
            pulumi.set(__self__, "alert_switch", alert_switch)
        if bps_threshold is not None:
            pulumi.set(__self__, "bps_threshold", bps_threshold)
        if counter_measure is not None:
            pulumi.set(__self__, "counter_measure", counter_measure)
        if last_trigger_time is not None:
            pulumi.set(__self__, "last_trigger_time", last_trigger_time)
        if last_trigger_time_overseas is not None:
            pulumi.set(__self__, "last_trigger_time_overseas", last_trigger_time_overseas)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if statistic_item is not None:
            pulumi.set(__self__, "statistic_item", statistic_item)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="alertPercentage")
    def alert_percentage(self) -> Optional[_builtins.int]:
        """
        Alert percentage.
        """
        return pulumi.get(self, "alert_percentage")

    @_builtins.property
    @pulumi.getter(name="alertSwitch")
    def alert_switch(self) -> Optional[_builtins.str]:
        """
        Switch alert.
        """
        return pulumi.get(self, "alert_switch")

    @_builtins.property
    @pulumi.getter(name="bpsThreshold")
    def bps_threshold(self) -> Optional[_builtins.int]:
        """
        threshold of bps.
        """
        return pulumi.get(self, "bps_threshold")

    @_builtins.property
    @pulumi.getter(name="counterMeasure")
    def counter_measure(self) -> Optional[_builtins.str]:
        """
        Counter measure, values: `RETURN_404`, `RESOLVE_DNS_TO_ORIGIN`.
        """
        return pulumi.get(self, "counter_measure")

    @_builtins.property
    @pulumi.getter(name="lastTriggerTime")
    def last_trigger_time(self) -> Optional[_builtins.str]:
        """
        Last trigger time.
        """
        return pulumi.get(self, "last_trigger_time")

    @_builtins.property
    @pulumi.getter(name="lastTriggerTimeOverseas")
    def last_trigger_time_overseas(self) -> Optional[_builtins.str]:
        """
        Last trigger time of overseas.
        """
        return pulumi.get(self, "last_trigger_time_overseas")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.str]:
        """
        Metric.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="statisticItem")
    def statistic_item(self) -> Optional['outputs.DomainBandWidthAlertStatisticItem']:
        """
        Specify statistic item configuration.
        """
        return pulumi.get(self, "statistic_item")


@pulumi.output_type
class DomainBandWidthAlertStatisticItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertPercentage":
            suggest = "alert_percentage"
        elif key == "alertSwitch":
            suggest = "alert_switch"
        elif key == "bpsThreshold":
            suggest = "bps_threshold"
        elif key == "counterMeasure":
            suggest = "counter_measure"
        elif key == "unblockTime":
            suggest = "unblock_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainBandWidthAlertStatisticItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainBandWidthAlertStatisticItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainBandWidthAlertStatisticItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 alert_percentage: Optional[_builtins.int] = None,
                 alert_switch: Optional[_builtins.str] = None,
                 bps_threshold: Optional[_builtins.int] = None,
                 counter_measure: Optional[_builtins.str] = None,
                 cycle: Optional[_builtins.int] = None,
                 metric: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 unblock_time: Optional[_builtins.int] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.int alert_percentage: Alert percentage.
        :param _builtins.str alert_switch: Switch alert.
        :param _builtins.int bps_threshold: threshold of bps.
        :param _builtins.str counter_measure: Counter measure, values: `RETURN_404`, `RESOLVE_DNS_TO_ORIGIN`.
        :param _builtins.int cycle: Cycle of checking in minutes, values `60`, `1440`.
        :param _builtins.str metric: Metric.
        :param _builtins.str type: Type of statistic item.
        :param _builtins.int unblock_time: Time of auto unblock.
        """
        pulumi.set(__self__, "switch", switch)
        if alert_percentage is not None:
            pulumi.set(__self__, "alert_percentage", alert_percentage)
        if alert_switch is not None:
            pulumi.set(__self__, "alert_switch", alert_switch)
        if bps_threshold is not None:
            pulumi.set(__self__, "bps_threshold", bps_threshold)
        if counter_measure is not None:
            pulumi.set(__self__, "counter_measure", counter_measure)
        if cycle is not None:
            pulumi.set(__self__, "cycle", cycle)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unblock_time is not None:
            pulumi.set(__self__, "unblock_time", unblock_time)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="alertPercentage")
    def alert_percentage(self) -> Optional[_builtins.int]:
        """
        Alert percentage.
        """
        return pulumi.get(self, "alert_percentage")

    @_builtins.property
    @pulumi.getter(name="alertSwitch")
    def alert_switch(self) -> Optional[_builtins.str]:
        """
        Switch alert.
        """
        return pulumi.get(self, "alert_switch")

    @_builtins.property
    @pulumi.getter(name="bpsThreshold")
    def bps_threshold(self) -> Optional[_builtins.int]:
        """
        threshold of bps.
        """
        return pulumi.get(self, "bps_threshold")

    @_builtins.property
    @pulumi.getter(name="counterMeasure")
    def counter_measure(self) -> Optional[_builtins.str]:
        """
        Counter measure, values: `RETURN_404`, `RESOLVE_DNS_TO_ORIGIN`.
        """
        return pulumi.get(self, "counter_measure")

    @_builtins.property
    @pulumi.getter
    def cycle(self) -> Optional[_builtins.int]:
        """
        Cycle of checking in minutes, values `60`, `1440`.
        """
        return pulumi.get(self, "cycle")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.str]:
        """
        Metric.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of statistic item.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unblockTime")
    def unblock_time(self) -> Optional[_builtins.int]:
        """
        Time of auto unblock.
        """
        return pulumi.get(self, "unblock_time")


@pulumi.output_type
class DomainCacheKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullUrlCache":
            suggest = "full_url_cache"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "keyRules":
            suggest = "key_rules"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCacheKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCacheKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCacheKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_url_cache: Optional[_builtins.str] = None,
                 ignore_case: Optional[_builtins.str] = None,
                 key_rules: Optional[Sequence['outputs.DomainCacheKeyKeyRule']] = None,
                 query_string: Optional['outputs.DomainCacheKeyQueryString'] = None):
        """
        :param _builtins.str full_url_cache: Whether to enable full-path cache, values `on` (DEFAULT ON), `off`.
        :param _builtins.str ignore_case: Whether caches are case insensitive.
        :param Sequence['DomainCacheKeyKeyRuleArgs'] key_rules: Path-specific cache key configuration.
        :param 'DomainCacheKeyQueryStringArgs' query_string: Request parameter contained in CacheKey.
        """
        if full_url_cache is not None:
            pulumi.set(__self__, "full_url_cache", full_url_cache)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if key_rules is not None:
            pulumi.set(__self__, "key_rules", key_rules)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)

    @_builtins.property
    @pulumi.getter(name="fullUrlCache")
    def full_url_cache(self) -> Optional[_builtins.str]:
        """
        Whether to enable full-path cache, values `on` (DEFAULT ON), `off`.
        """
        return pulumi.get(self, "full_url_cache")

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[_builtins.str]:
        """
        Whether caches are case insensitive.
        """
        return pulumi.get(self, "ignore_case")

    @_builtins.property
    @pulumi.getter(name="keyRules")
    def key_rules(self) -> Optional[Sequence['outputs.DomainCacheKeyKeyRule']]:
        """
        Path-specific cache key configuration.
        """
        return pulumi.get(self, "key_rules")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.DomainCacheKeyQueryString']:
        """
        Request parameter contained in CacheKey.
        """
        return pulumi.get(self, "query_string")


@pulumi.output_type
class DomainCacheKeyKeyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "fullUrlCache":
            suggest = "full_url_cache"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "ruleTag":
            suggest = "rule_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCacheKeyKeyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCacheKeyKeyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCacheKeyKeyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string: 'outputs.DomainCacheKeyKeyRuleQueryString',
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str,
                 full_url_cache: Optional[_builtins.str] = None,
                 ignore_case: Optional[_builtins.str] = None,
                 rule_tag: Optional[_builtins.str] = None):
        """
        :param 'DomainCacheKeyKeyRuleQueryStringArgs' query_string: Request parameter contained in CacheKey.
        :param Sequence[_builtins.str] rule_paths: List of rule paths for each `key_rules`: `/` for `index`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        :param _builtins.str rule_type: Rule type, available: `file`, `directory`, `path`, `index`.
        :param _builtins.str full_url_cache: Whether to enable full-path cache, values `on` (DEFAULT ON), `off`.
        :param _builtins.str ignore_case: Whether caches are case insensitive.
        :param _builtins.str rule_tag: Specify rule tag, default value is `user`.
        """
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)
        if full_url_cache is not None:
            pulumi.set(__self__, "full_url_cache", full_url_cache)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if rule_tag is not None:
            pulumi.set(__self__, "rule_tag", rule_tag)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> 'outputs.DomainCacheKeyKeyRuleQueryString':
        """
        Request parameter contained in CacheKey.
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        List of rule paths for each `key_rules`: `/` for `index`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Rule type, available: `file`, `directory`, `path`, `index`.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter(name="fullUrlCache")
    def full_url_cache(self) -> Optional[_builtins.str]:
        """
        Whether to enable full-path cache, values `on` (DEFAULT ON), `off`.
        """
        return pulumi.get(self, "full_url_cache")

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[_builtins.str]:
        """
        Whether caches are case insensitive.
        """
        return pulumi.get(self, "ignore_case")

    @_builtins.property
    @pulumi.getter(name="ruleTag")
    def rule_tag(self) -> Optional[_builtins.str]:
        """
        Specify rule tag, default value is `user`.
        """
        return pulumi.get(self, "rule_tag")


@pulumi.output_type
class DomainCacheKeyKeyRuleQueryString(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 switch: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Specify key rule QS action, values: `includeCustom`, `excludeCustom`.
        :param _builtins.str switch: Whether to use QueryString as part of CacheKey, values `on`, `off` (Default).
        :param _builtins.str value: Array of included/excluded query strings (separated by `;`).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Specify key rule QS action, values: `includeCustom`, `excludeCustom`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[_builtins.str]:
        """
        Whether to use QueryString as part of CacheKey, values `on`, `off` (Default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Array of included/excluded query strings (separated by `;`).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainCacheKeyQueryString(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 reorder: Optional[_builtins.str] = None,
                 switch: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Specify key rule QS action, values: `includeCustom`, `excludeCustom`.
        :param _builtins.str reorder: Whether to sort again, values `on`, `off` (Default).
        :param _builtins.str switch: Whether to use QueryString as part of CacheKey, values `on`, `off` (Default).
        :param _builtins.str value: Array of included/excluded query strings (separated by `;`).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if reorder is not None:
            pulumi.set(__self__, "reorder", reorder)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Specify key rule QS action, values: `includeCustom`, `excludeCustom`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def reorder(self) -> Optional[_builtins.str]:
        """
        Whether to sort again, values `on`, `off` (Default).
        """
        return pulumi.get(self, "reorder")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[_builtins.str]:
        """
        Whether to use QueryString as part of CacheKey, values `on`, `off` (Default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Array of included/excluded query strings (separated by `;`).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionRules":
            suggest = "compression_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 compression_rules: Optional[Sequence['outputs.DomainCompressionCompressionRule']] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainCompressionCompressionRuleArgs'] compression_rules: List of compression rules.
        """
        pulumi.set(__self__, "switch", switch)
        if compression_rules is not None:
            pulumi.set(__self__, "compression_rules", compression_rules)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="compressionRules")
    def compression_rules(self) -> Optional[Sequence['outputs.DomainCompressionCompressionRule']]:
        """
        List of compression rules.
        """
        return pulumi.get(self, "compression_rules")


@pulumi.output_type
class DomainCompressionCompressionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxLength":
            suggest = "max_length"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "fileExtensions":
            suggest = "file_extensions"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCompressionCompressionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCompressionCompressionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCompressionCompressionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithms: Sequence[_builtins.str],
                 compress: _builtins.bool,
                 max_length: _builtins.int,
                 min_length: _builtins.int,
                 file_extensions: Optional[Sequence[_builtins.str]] = None,
                 rule_paths: Optional[Sequence[_builtins.str]] = None,
                 rule_type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] algorithms: List of algorithms, available: `gzip` and `brotli`.
        :param _builtins.bool compress: Must be set as true, enables compression.
        :param _builtins.int max_length: The maximum file size to trigger compression (in bytes).
        :param _builtins.int min_length: The minimum file size to trigger compression (in bytes).
        :param Sequence[_builtins.str] file_extensions: List of file extensions like `jpg`, `txt`.
        :param Sequence[_builtins.str] rule_paths: List of rule paths for each `rule_type`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        :param _builtins.str rule_type: Rule type, available: `all`, `file`, `directory`, `path`, `contentType`.
        """
        pulumi.set(__self__, "algorithms", algorithms)
        pulumi.set(__self__, "compress", compress)
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "min_length", min_length)
        if file_extensions is not None:
            pulumi.set(__self__, "file_extensions", file_extensions)
        if rule_paths is not None:
            pulumi.set(__self__, "rule_paths", rule_paths)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter
    def algorithms(self) -> Sequence[_builtins.str]:
        """
        List of algorithms, available: `gzip` and `brotli`.
        """
        return pulumi.get(self, "algorithms")

    @_builtins.property
    @pulumi.getter
    def compress(self) -> _builtins.bool:
        """
        Must be set as true, enables compression.
        """
        return pulumi.get(self, "compress")

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> _builtins.int:
        """
        The maximum file size to trigger compression (in bytes).
        """
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> _builtins.int:
        """
        The minimum file size to trigger compression (in bytes).
        """
        return pulumi.get(self, "min_length")

    @_builtins.property
    @pulumi.getter(name="fileExtensions")
    def file_extensions(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of file extensions like `jpg`, `txt`.
        """
        return pulumi.get(self, "file_extensions")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of rule paths for each `rule_type`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.str]:
        """
        Rule type, available: `all`, `file`, `directory`, `path`, `contentType`.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class DomainDownstreamCapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cappingRules":
            suggest = "capping_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDownstreamCapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDownstreamCapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDownstreamCapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 capping_rules: Optional[Sequence['outputs.DomainDownstreamCappingCappingRule']] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainDownstreamCappingCappingRuleArgs'] capping_rules: List of capping rule.
        """
        pulumi.set(__self__, "switch", switch)
        if capping_rules is not None:
            pulumi.set(__self__, "capping_rules", capping_rules)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="cappingRules")
    def capping_rules(self) -> Optional[Sequence['outputs.DomainDownstreamCappingCappingRule']]:
        """
        List of capping rule.
        """
        return pulumi.get(self, "capping_rules")


@pulumi.output_type
class DomainDownstreamCappingCappingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kbpsThreshold":
            suggest = "kbps_threshold"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDownstreamCappingCappingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDownstreamCappingCappingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDownstreamCappingCappingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kbps_threshold: _builtins.int,
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str):
        """
        :param _builtins.int kbps_threshold: Capping rule kbps threshold.
        :param Sequence[_builtins.str] rule_paths: List of capping rule path.
        :param _builtins.str rule_type: Capping rule type.
        """
        pulumi.set(__self__, "kbps_threshold", kbps_threshold)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter(name="kbpsThreshold")
    def kbps_threshold(self) -> _builtins.int:
        """
        Capping rule kbps threshold.
        """
        return pulumi.get(self, "kbps_threshold")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        List of capping rule path.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Capping rule type.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class DomainErrorPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageRules":
            suggest = "page_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainErrorPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainErrorPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainErrorPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 page_rules: Optional[Sequence['outputs.DomainErrorPagePageRule']] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainErrorPagePageRuleArgs'] page_rules: List of error page rule.
        """
        pulumi.set(__self__, "switch", switch)
        if page_rules is not None:
            pulumi.set(__self__, "page_rules", page_rules)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="pageRules")
    def page_rules(self) -> Optional[Sequence['outputs.DomainErrorPagePageRule']]:
        """
        List of error page rule.
        """
        return pulumi.get(self, "page_rules")


@pulumi.output_type
class DomainErrorPagePageRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectCode":
            suggest = "redirect_code"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainErrorPagePageRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainErrorPagePageRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainErrorPagePageRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_code: _builtins.int,
                 redirect_url: _builtins.str,
                 status_code: _builtins.int):
        """
        :param _builtins.int redirect_code: Redirect code of error page rules.
        :param _builtins.str redirect_url: Redirect url of error page rules.
        :param _builtins.int status_code: Status code of error page rules.
        """
        pulumi.set(__self__, "redirect_code", redirect_code)
        pulumi.set(__self__, "redirect_url", redirect_url)
        pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> _builtins.int:
        """
        Redirect code of error page rules.
        """
        return pulumi.get(self, "redirect_code")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> _builtins.str:
        """
        Redirect url of error page rules.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> _builtins.int:
        """
        Status code of error page rules.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class DomainHttpsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsSwitch":
            suggest = "https_switch"
        elif key == "clientCertificateConfig":
            suggest = "client_certificate_config"
        elif key == "forceRedirect":
            suggest = "force_redirect"
        elif key == "http2Switch":
            suggest = "http2_switch"
        elif key == "ocspStaplingSwitch":
            suggest = "ocsp_stapling_switch"
        elif key == "serverCertificateConfig":
            suggest = "server_certificate_config"
        elif key == "spdySwitch":
            suggest = "spdy_switch"
        elif key == "tlsVersions":
            suggest = "tls_versions"
        elif key == "verifyClient":
            suggest = "verify_client"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainHttpsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainHttpsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainHttpsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_switch: _builtins.str,
                 client_certificate_config: Optional['outputs.DomainHttpsConfigClientCertificateConfig'] = None,
                 force_redirect: Optional['outputs.DomainHttpsConfigForceRedirect'] = None,
                 http2_switch: Optional[_builtins.str] = None,
                 ocsp_stapling_switch: Optional[_builtins.str] = None,
                 server_certificate_config: Optional['outputs.DomainHttpsConfigServerCertificateConfig'] = None,
                 spdy_switch: Optional[_builtins.str] = None,
                 tls_versions: Optional[Sequence[_builtins.str]] = None,
                 verify_client: Optional[_builtins.str] = None):
        """
        :param _builtins.str https_switch: HTTPS configuration switch. Valid values are `on` and `off`.
        :param 'DomainHttpsConfigClientCertificateConfigArgs' client_certificate_config: Client certificate configuration information.
        :param 'DomainHttpsConfigForceRedirectArgs' force_redirect: Configuration of forced HTTP or HTTPS redirects.
        :param _builtins.str http2_switch: HTTP2 configuration switch. Valid values are `on` and `off`. and default value is `off`.
        :param _builtins.str ocsp_stapling_switch: OCSP configuration switch. Valid values are `on` and `off`. and default value is `off`.
        :param 'DomainHttpsConfigServerCertificateConfigArgs' server_certificate_config: Server certificate configuration information.
        :param _builtins.str spdy_switch: Spdy configuration switch. Valid values are `on` and `off`. and default value is `off`. This parameter is for white-list customer.
        :param Sequence[_builtins.str] tls_versions: Tls version settings, only support some Advanced domain names, support settings TLSv1, TLSV1.1, TLSV1.2, TLSv1.3, when modifying must open consecutive versions.
        :param _builtins.str verify_client: Client certificate authentication feature. Valid values are `on` and `off`. and default value is `off`.
        """
        pulumi.set(__self__, "https_switch", https_switch)
        if client_certificate_config is not None:
            pulumi.set(__self__, "client_certificate_config", client_certificate_config)
        if force_redirect is not None:
            pulumi.set(__self__, "force_redirect", force_redirect)
        if http2_switch is not None:
            pulumi.set(__self__, "http2_switch", http2_switch)
        if ocsp_stapling_switch is not None:
            pulumi.set(__self__, "ocsp_stapling_switch", ocsp_stapling_switch)
        if server_certificate_config is not None:
            pulumi.set(__self__, "server_certificate_config", server_certificate_config)
        if spdy_switch is not None:
            pulumi.set(__self__, "spdy_switch", spdy_switch)
        if tls_versions is not None:
            pulumi.set(__self__, "tls_versions", tls_versions)
        if verify_client is not None:
            pulumi.set(__self__, "verify_client", verify_client)

    @_builtins.property
    @pulumi.getter(name="httpsSwitch")
    def https_switch(self) -> _builtins.str:
        """
        HTTPS configuration switch. Valid values are `on` and `off`.
        """
        return pulumi.get(self, "https_switch")

    @_builtins.property
    @pulumi.getter(name="clientCertificateConfig")
    def client_certificate_config(self) -> Optional['outputs.DomainHttpsConfigClientCertificateConfig']:
        """
        Client certificate configuration information.
        """
        return pulumi.get(self, "client_certificate_config")

    @_builtins.property
    @pulumi.getter(name="forceRedirect")
    def force_redirect(self) -> Optional['outputs.DomainHttpsConfigForceRedirect']:
        """
        Configuration of forced HTTP or HTTPS redirects.
        """
        return pulumi.get(self, "force_redirect")

    @_builtins.property
    @pulumi.getter(name="http2Switch")
    def http2_switch(self) -> Optional[_builtins.str]:
        """
        HTTP2 configuration switch. Valid values are `on` and `off`. and default value is `off`.
        """
        return pulumi.get(self, "http2_switch")

    @_builtins.property
    @pulumi.getter(name="ocspStaplingSwitch")
    def ocsp_stapling_switch(self) -> Optional[_builtins.str]:
        """
        OCSP configuration switch. Valid values are `on` and `off`. and default value is `off`.
        """
        return pulumi.get(self, "ocsp_stapling_switch")

    @_builtins.property
    @pulumi.getter(name="serverCertificateConfig")
    def server_certificate_config(self) -> Optional['outputs.DomainHttpsConfigServerCertificateConfig']:
        """
        Server certificate configuration information.
        """
        return pulumi.get(self, "server_certificate_config")

    @_builtins.property
    @pulumi.getter(name="spdySwitch")
    def spdy_switch(self) -> Optional[_builtins.str]:
        """
        Spdy configuration switch. Valid values are `on` and `off`. and default value is `off`. This parameter is for white-list customer.
        """
        return pulumi.get(self, "spdy_switch")

    @_builtins.property
    @pulumi.getter(name="tlsVersions")
    def tls_versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Tls version settings, only support some Advanced domain names, support settings TLSv1, TLSV1.1, TLSV1.2, TLSv1.3, when modifying must open consecutive versions.
        """
        return pulumi.get(self, "tls_versions")

    @_builtins.property
    @pulumi.getter(name="verifyClient")
    def verify_client(self) -> Optional[_builtins.str]:
        """
        Client certificate authentication feature. Valid values are `on` and `off`. and default value is `off`.
        """
        return pulumi.get(self, "verify_client")


@pulumi.output_type
class DomainHttpsConfigClientCertificateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateContent":
            suggest = "certificate_content"
        elif key == "certificateName":
            suggest = "certificate_name"
        elif key == "deployTime":
            suggest = "deploy_time"
        elif key == "expireTime":
            suggest = "expire_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainHttpsConfigClientCertificateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainHttpsConfigClientCertificateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainHttpsConfigClientCertificateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_content: _builtins.str,
                 certificate_name: Optional[_builtins.str] = None,
                 deploy_time: Optional[_builtins.str] = None,
                 expire_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_content: Client Certificate PEM format, requires Base64 encoding.
        :param _builtins.str certificate_name: Client certificate name.
        :param _builtins.str deploy_time: Deploy time of client certificate.
        :param _builtins.str expire_time: Expire time of client certificate.
        """
        pulumi.set(__self__, "certificate_content", certificate_content)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if deploy_time is not None:
            pulumi.set(__self__, "deploy_time", deploy_time)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)

    @_builtins.property
    @pulumi.getter(name="certificateContent")
    def certificate_content(self) -> _builtins.str:
        """
        Client Certificate PEM format, requires Base64 encoding.
        """
        return pulumi.get(self, "certificate_content")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[_builtins.str]:
        """
        Client certificate name.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="deployTime")
    def deploy_time(self) -> Optional[_builtins.str]:
        """
        Deploy time of client certificate.
        """
        return pulumi.get(self, "deploy_time")

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[_builtins.str]:
        """
        Expire time of client certificate.
        """
        return pulumi.get(self, "expire_time")


@pulumi.output_type
class DomainHttpsConfigForceRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "carryHeaders":
            suggest = "carry_headers"
        elif key == "redirectStatusCode":
            suggest = "redirect_status_code"
        elif key == "redirectType":
            suggest = "redirect_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainHttpsConfigForceRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainHttpsConfigForceRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainHttpsConfigForceRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 carry_headers: Optional[_builtins.str] = None,
                 redirect_status_code: Optional[_builtins.int] = None,
                 redirect_type: Optional[_builtins.str] = None,
                 switch: Optional[_builtins.str] = None):
        """
        :param _builtins.str carry_headers: Whether to return the newly added header during force redirection. Values: `on`, `off`.
        :param _builtins.int redirect_status_code: Forced redirect status code. Valid values are `301` and `302`. When `switch` setting `off`, this property does not need to be set or set to `302`. Default value is `302`.
        :param _builtins.str redirect_type: Forced redirect type. Valid values are `http` and `https`. `http` means a forced redirect from HTTPS to HTTP, `https` means a forced redirect from HTTP to HTTPS. When `switch` setting `off`, this property does not need to be set or set to `http`. Default value is `http`.
        :param _builtins.str switch: Forced redirect configuration switch. Valid values are `on` and `off`. Default value is `off`.
        """
        if carry_headers is not None:
            pulumi.set(__self__, "carry_headers", carry_headers)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)
        if redirect_type is not None:
            pulumi.set(__self__, "redirect_type", redirect_type)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter(name="carryHeaders")
    def carry_headers(self) -> Optional[_builtins.str]:
        """
        Whether to return the newly added header during force redirection. Values: `on`, `off`.
        """
        return pulumi.get(self, "carry_headers")

    @_builtins.property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[_builtins.int]:
        """
        Forced redirect status code. Valid values are `301` and `302`. When `switch` setting `off`, this property does not need to be set or set to `302`. Default value is `302`.
        """
        return pulumi.get(self, "redirect_status_code")

    @_builtins.property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> Optional[_builtins.str]:
        """
        Forced redirect type. Valid values are `http` and `https`. `http` means a forced redirect from HTTPS to HTTP, `https` means a forced redirect from HTTP to HTTPS. When `switch` setting `off`, this property does not need to be set or set to `http`. Default value is `http`.
        """
        return pulumi.get(self, "redirect_type")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[_builtins.str]:
        """
        Forced redirect configuration switch. Valid values are `on` and `off`. Default value is `off`.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class DomainHttpsConfigServerCertificateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateContent":
            suggest = "certificate_content"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "certificateName":
            suggest = "certificate_name"
        elif key == "deployTime":
            suggest = "deploy_time"
        elif key == "expireTime":
            suggest = "expire_time"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainHttpsConfigServerCertificateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainHttpsConfigServerCertificateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainHttpsConfigServerCertificateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_content: Optional[_builtins.str] = None,
                 certificate_id: Optional[_builtins.str] = None,
                 certificate_name: Optional[_builtins.str] = None,
                 deploy_time: Optional[_builtins.str] = None,
                 expire_time: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_content: Server certificate information. This is required when uploading an external certificate, which should contain the complete certificate chain.
        :param _builtins.str certificate_id: Server certificate ID.
        :param _builtins.str certificate_name: Server certificate name.
        :param _builtins.str deploy_time: Deploy time of server certificate.
        :param _builtins.str expire_time: Expire time of server certificate.
        :param _builtins.str message: Certificate remarks.
        :param _builtins.str private_key: Server key information. This is required when uploading an external certificate.
        """
        if certificate_content is not None:
            pulumi.set(__self__, "certificate_content", certificate_content)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if deploy_time is not None:
            pulumi.set(__self__, "deploy_time", deploy_time)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)

    @_builtins.property
    @pulumi.getter(name="certificateContent")
    def certificate_content(self) -> Optional[_builtins.str]:
        """
        Server certificate information. This is required when uploading an external certificate, which should contain the complete certificate chain.
        """
        return pulumi.get(self, "certificate_content")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        Server certificate ID.
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[_builtins.str]:
        """
        Server certificate name.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="deployTime")
    def deploy_time(self) -> Optional[_builtins.str]:
        """
        Deploy time of server certificate.
        """
        return pulumi.get(self, "deploy_time")

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[_builtins.str]:
        """
        Expire time of server certificate.
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Certificate remarks.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        Server key information. This is required when uploading an external certificate.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class DomainHwPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainHwPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainHwPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainHwPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bucket: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.str access_key: Access ID.
        :param _builtins.str bucket: Bucket.
        :param _builtins.str secret_key: Key.
        """
        pulumi.set(__self__, "switch", switch)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Access ID.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        """
        Bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class DomainIpFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterRules":
            suggest = "filter_rules"
        elif key == "filterType":
            suggest = "filter_type"
        elif key == "returnCode":
            suggest = "return_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainIpFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainIpFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainIpFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 filter_rules: Optional[Sequence['outputs.DomainIpFilterFilterRule']] = None,
                 filter_type: Optional[_builtins.str] = None,
                 filters: Optional[Sequence[_builtins.str]] = None,
                 return_code: Optional[_builtins.int] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainIpFilterFilterRuleArgs'] filter_rules: Ip filter rules, This feature is only available to selected beta customers.
        :param _builtins.str filter_type: IP `blacklist`/`whitelist` type.
        :param Sequence[_builtins.str] filters: Ip filter list, Supports IPs in X.X.X.X format, or /8, /16, /24 format IP ranges. Up to 50 allowlists or blocklists can be entered.
        :param _builtins.int return_code: Return code, available values: 400-499.
        """
        pulumi.set(__self__, "switch", switch)
        if filter_rules is not None:
            pulumi.set(__self__, "filter_rules", filter_rules)
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if return_code is not None:
            pulumi.set(__self__, "return_code", return_code)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="filterRules")
    def filter_rules(self) -> Optional[Sequence['outputs.DomainIpFilterFilterRule']]:
        """
        Ip filter rules, This feature is only available to selected beta customers.
        """
        return pulumi.get(self, "filter_rules")

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[_builtins.str]:
        """
        IP `blacklist`/`whitelist` type.
        """
        return pulumi.get(self, "filter_type")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Ip filter list, Supports IPs in X.X.X.X format, or /8, /16, /24 format IP ranges. Up to 50 allowlists or blocklists can be entered.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter(name="returnCode")
    def return_code(self) -> Optional[_builtins.int]:
        """
        Return code, available values: 400-499.
        """
        return pulumi.get(self, "return_code")


@pulumi.output_type
class DomainIpFilterFilterRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainIpFilterFilterRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainIpFilterFilterRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainIpFilterFilterRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: _builtins.str,
                 filters: Sequence[_builtins.str],
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str):
        """
        :param _builtins.str filter_type: Ip filter `blacklist`/`whitelist` type of filter rules.
        :param Sequence[_builtins.str] filters: Ip filter rule list, supports IPs in X.X.X.X format, or /8, /16, /24 format IP ranges. Up to 50 allowlists or blocklists can be entered.
        :param Sequence[_builtins.str] rule_paths: Content list for each `rule_type`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        :param _builtins.str rule_type: Ip filter rule type of filter rules, available: `all`, `file`, `directory`, `path`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> _builtins.str:
        """
        Ip filter `blacklist`/`whitelist` type of filter rules.
        """
        return pulumi.get(self, "filter_type")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Sequence[_builtins.str]:
        """
        Ip filter rule list, supports IPs in X.X.X.X format, or /8, /16, /24 format IP ranges. Up to 50 allowlists or blocklists can be entered.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        Content list for each `rule_type`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Ip filter rule type of filter rules, available: `all`, `file`, `directory`, `path`.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class DomainIpFreqLimit(dict):
    def __init__(__self__, *,
                 switch: _builtins.str,
                 qps: Optional[_builtins.int] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.int qps: Sets the limited number of requests per second, 514 will be returned for requests that exceed the limit.
        """
        pulumi.set(__self__, "switch", switch)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[_builtins.int]:
        """
        Sets the limited number of requests per second, 514 will be returned for requests that exceed the limit.
        """
        return pulumi.get(self, "qps")


@pulumi.output_type
class DomainMaxAge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAgeRules":
            suggest = "max_age_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainMaxAge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainMaxAge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainMaxAge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 max_age_rules: Optional[Sequence['outputs.DomainMaxAgeMaxAgeRule']] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainMaxAgeMaxAgeRuleArgs'] max_age_rules: List of Max Age rule configuration.
        """
        pulumi.set(__self__, "switch", switch)
        if max_age_rules is not None:
            pulumi.set(__self__, "max_age_rules", max_age_rules)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="maxAgeRules")
    def max_age_rules(self) -> Optional[Sequence['outputs.DomainMaxAgeMaxAgeRule']]:
        """
        List of Max Age rule configuration.
        """
        return pulumi.get(self, "max_age_rules")


@pulumi.output_type
class DomainMaxAgeMaxAgeRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAgeContents":
            suggest = "max_age_contents"
        elif key == "maxAgeTime":
            suggest = "max_age_time"
        elif key == "maxAgeType":
            suggest = "max_age_type"
        elif key == "followOrigin":
            suggest = "follow_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainMaxAgeMaxAgeRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainMaxAgeMaxAgeRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainMaxAgeMaxAgeRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_age_contents: Sequence[_builtins.str],
                 max_age_time: _builtins.int,
                 max_age_type: _builtins.str,
                 follow_origin: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] max_age_contents: List of rule paths for each `max_age_type`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        :param _builtins.int max_age_time: Max Age time in seconds, this can set to `0` that stands for no cache.
        :param _builtins.str max_age_type: The following types are supported: `all`: all documents take effect, `file`: the specified file suffix takes effect, `directory`: the specified path takes effect, `path`: specify the absolute path to take effect, `index`: home page.
        :param _builtins.str follow_origin: Whether to follow origin, values: `on`/`off`, if set to `on`, the `max_age_time` will be ignored.
        """
        pulumi.set(__self__, "max_age_contents", max_age_contents)
        pulumi.set(__self__, "max_age_time", max_age_time)
        pulumi.set(__self__, "max_age_type", max_age_type)
        if follow_origin is not None:
            pulumi.set(__self__, "follow_origin", follow_origin)

    @_builtins.property
    @pulumi.getter(name="maxAgeContents")
    def max_age_contents(self) -> Sequence[_builtins.str]:
        """
        List of rule paths for each `max_age_type`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
        """
        return pulumi.get(self, "max_age_contents")

    @_builtins.property
    @pulumi.getter(name="maxAgeTime")
    def max_age_time(self) -> _builtins.int:
        """
        Max Age time in seconds, this can set to `0` that stands for no cache.
        """
        return pulumi.get(self, "max_age_time")

    @_builtins.property
    @pulumi.getter(name="maxAgeType")
    def max_age_type(self) -> _builtins.str:
        """
        The following types are supported: `all`: all documents take effect, `file`: the specified file suffix takes effect, `directory`: the specified path takes effect, `path`: specify the absolute path to take effect, `index`: home page.
        """
        return pulumi.get(self, "max_age_type")

    @_builtins.property
    @pulumi.getter(name="followOrigin")
    def follow_origin(self) -> Optional[_builtins.str]:
        """
        Whether to follow origin, values: `on`/`off`, if set to `on`, the `max_age_time` will be ignored.
        """
        return pulumi.get(self, "follow_origin")


@pulumi.output_type
class DomainOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originLists":
            suggest = "origin_lists"
        elif key == "originType":
            suggest = "origin_type"
        elif key == "backupOriginLists":
            suggest = "backup_origin_lists"
        elif key == "backupOriginType":
            suggest = "backup_origin_type"
        elif key == "backupServerName":
            suggest = "backup_server_name"
        elif key == "cosPrivateAccess":
            suggest = "cos_private_access"
        elif key == "originCompany":
            suggest = "origin_company"
        elif key == "originPullProtocol":
            suggest = "origin_pull_protocol"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_lists: Sequence[_builtins.str],
                 origin_type: _builtins.str,
                 backup_origin_lists: Optional[Sequence[_builtins.str]] = None,
                 backup_origin_type: Optional[_builtins.str] = None,
                 backup_server_name: Optional[_builtins.str] = None,
                 cos_private_access: Optional[_builtins.str] = None,
                 origin_company: Optional[_builtins.str] = None,
                 origin_pull_protocol: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] origin_lists: Master origin server list. Valid values can be ip or domain name. When modifying the origin server, you need to enter the corresponding `origin_type`.
        :param _builtins.str origin_type: Master origin server type. The following types are supported: `domain`: Domain name, `domainv6`: IPv6 domain name, `cos`: COS bucket address, `third_party`: Third-party object storage origin, `igtm`: IGTM origin, `ip`: IP address, `ipv6`: One IPv6 address, `ip_ipv6`: Multiple IPv4 addresses and one IPv6 address, `ip_domain`: IP addresses and domain names (only available to beta users), `ip_domainv6`: Multiple IPv4 addresses and one IPv6 domain name, `ipv6_domain`: Multiple IPv6 addresses and one domain name, `ipv6_domainv6`: Multiple IPv6 addresses and one IPv6 domain name, `domain_domainv6`: Multiple IPv4 domain names and one IPv6 domain name, `ip_ipv6_domain`: Multiple IPv4 and IPv6 addresses and one domain name, `ip_ipv6_domainv6`: Multiple IPv4 and IPv6 addresses and one IPv6 domain name, `ip_domain_domainv6`: Multiple IPv4 addresses and IPv4 domain names and one IPv6 domain name, `ipv6_domain_domainv6`: Multiple IPv4 domain names and IPv6 addresses and one IPv6 domain name, `ip_ipv6_domain_domainv6`: Multiple IPv4 and IPv6 addresses and IPv4 domain names and one IPv6 domain name.
        :param Sequence[_builtins.str] backup_origin_lists: Backup origin server list. Valid values can be ip or domain name. When modifying the backup origin server, you need to enter the corresponding `backup_origin_type`.
        :param _builtins.str backup_origin_type: Backup origin server type, which supports the following types: `domain`: domain name type, `ip`: IP list used as origin server, `ipv6_domain`: Multiple IPv6 addresses and one domain name, `ip_ipv6`: Multiple IPv4 addresses and one IPv6 address, `ip_ipv6_domain`: Multiple IPv4 and IPv6 addresses and one domain name.
        :param _builtins.str backup_server_name: Host header used when accessing the backup origin server. If left empty, the ServerName of master origin server will be used by default.
        :param _builtins.str cos_private_access: When OriginType is COS, you can specify if access to private buckets is allowed. Valid values are `on` and `off`. and default value is `off`.
        :param _builtins.str origin_company: Object storage back to the source vendor. Required when the source station type is a third-party storage source station (third_party). Optional values include the following: `aws_s3`: AWS S3; `ali_oss`: Alibaba Cloud OSS; `hw_obs`: Huawei OBS; `qiniu_kodo`: Qiniu Cloud kodo; `others`: other vendors' object storage, only supports object storage compatible with AWS signature algorithm, such as Tencent Cloud Financial Zone COS. Example value: `hw_obs`.
        :param _builtins.str origin_pull_protocol: Origin-pull protocol configuration. `http`: forced HTTP origin-pull, `follow`: protocol follow origin-pull, `https`: forced HTTPS origin-pull. This only supports origin server port 443 for origin-pull.
        :param _builtins.str server_name: Host header used when accessing the master origin server. If left empty, the acceleration domain name will be used by default.
        """
        pulumi.set(__self__, "origin_lists", origin_lists)
        pulumi.set(__self__, "origin_type", origin_type)
        if backup_origin_lists is not None:
            pulumi.set(__self__, "backup_origin_lists", backup_origin_lists)
        if backup_origin_type is not None:
            pulumi.set(__self__, "backup_origin_type", backup_origin_type)
        if backup_server_name is not None:
            pulumi.set(__self__, "backup_server_name", backup_server_name)
        if cos_private_access is not None:
            pulumi.set(__self__, "cos_private_access", cos_private_access)
        if origin_company is not None:
            pulumi.set(__self__, "origin_company", origin_company)
        if origin_pull_protocol is not None:
            pulumi.set(__self__, "origin_pull_protocol", origin_pull_protocol)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @_builtins.property
    @pulumi.getter(name="originLists")
    def origin_lists(self) -> Sequence[_builtins.str]:
        """
        Master origin server list. Valid values can be ip or domain name. When modifying the origin server, you need to enter the corresponding `origin_type`.
        """
        return pulumi.get(self, "origin_lists")

    @_builtins.property
    @pulumi.getter(name="originType")
    def origin_type(self) -> _builtins.str:
        """
        Master origin server type. The following types are supported: `domain`: Domain name, `domainv6`: IPv6 domain name, `cos`: COS bucket address, `third_party`: Third-party object storage origin, `igtm`: IGTM origin, `ip`: IP address, `ipv6`: One IPv6 address, `ip_ipv6`: Multiple IPv4 addresses and one IPv6 address, `ip_domain`: IP addresses and domain names (only available to beta users), `ip_domainv6`: Multiple IPv4 addresses and one IPv6 domain name, `ipv6_domain`: Multiple IPv6 addresses and one domain name, `ipv6_domainv6`: Multiple IPv6 addresses and one IPv6 domain name, `domain_domainv6`: Multiple IPv4 domain names and one IPv6 domain name, `ip_ipv6_domain`: Multiple IPv4 and IPv6 addresses and one domain name, `ip_ipv6_domainv6`: Multiple IPv4 and IPv6 addresses and one IPv6 domain name, `ip_domain_domainv6`: Multiple IPv4 addresses and IPv4 domain names and one IPv6 domain name, `ipv6_domain_domainv6`: Multiple IPv4 domain names and IPv6 addresses and one IPv6 domain name, `ip_ipv6_domain_domainv6`: Multiple IPv4 and IPv6 addresses and IPv4 domain names and one IPv6 domain name.
        """
        return pulumi.get(self, "origin_type")

    @_builtins.property
    @pulumi.getter(name="backupOriginLists")
    def backup_origin_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Backup origin server list. Valid values can be ip or domain name. When modifying the backup origin server, you need to enter the corresponding `backup_origin_type`.
        """
        return pulumi.get(self, "backup_origin_lists")

    @_builtins.property
    @pulumi.getter(name="backupOriginType")
    def backup_origin_type(self) -> Optional[_builtins.str]:
        """
        Backup origin server type, which supports the following types: `domain`: domain name type, `ip`: IP list used as origin server, `ipv6_domain`: Multiple IPv6 addresses and one domain name, `ip_ipv6`: Multiple IPv4 addresses and one IPv6 address, `ip_ipv6_domain`: Multiple IPv4 and IPv6 addresses and one domain name.
        """
        return pulumi.get(self, "backup_origin_type")

    @_builtins.property
    @pulumi.getter(name="backupServerName")
    def backup_server_name(self) -> Optional[_builtins.str]:
        """
        Host header used when accessing the backup origin server. If left empty, the ServerName of master origin server will be used by default.
        """
        return pulumi.get(self, "backup_server_name")

    @_builtins.property
    @pulumi.getter(name="cosPrivateAccess")
    def cos_private_access(self) -> Optional[_builtins.str]:
        """
        When OriginType is COS, you can specify if access to private buckets is allowed. Valid values are `on` and `off`. and default value is `off`.
        """
        return pulumi.get(self, "cos_private_access")

    @_builtins.property
    @pulumi.getter(name="originCompany")
    def origin_company(self) -> Optional[_builtins.str]:
        """
        Object storage back to the source vendor. Required when the source station type is a third-party storage source station (third_party). Optional values include the following: `aws_s3`: AWS S3; `ali_oss`: Alibaba Cloud OSS; `hw_obs`: Huawei OBS; `qiniu_kodo`: Qiniu Cloud kodo; `others`: other vendors' object storage, only supports object storage compatible with AWS signature algorithm, such as Tencent Cloud Financial Zone COS. Example value: `hw_obs`.
        """
        return pulumi.get(self, "origin_company")

    @_builtins.property
    @pulumi.getter(name="originPullProtocol")
    def origin_pull_protocol(self) -> Optional[_builtins.str]:
        """
        Origin-pull protocol configuration. `http`: forced HTTP origin-pull, `follow`: protocol follow origin-pull, `https`: forced HTTPS origin-pull. This only supports origin server port 443 for origin-pull.
        """
        return pulumi.get(self, "origin_pull_protocol")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Host header used when accessing the master origin server. If left empty, the acceleration domain name will be used by default.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class DomainOriginPullOptimization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optimizationType":
            suggest = "optimization_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOriginPullOptimization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOriginPullOptimization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOriginPullOptimization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 optimization_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.str optimization_type: Optimization type, values: `OVToCN` - Overseas to CN, `CNToOV` CN to Overseas.
        """
        pulumi.set(__self__, "switch", switch)
        if optimization_type is not None:
            pulumi.set(__self__, "optimization_type", optimization_type)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="optimizationType")
    def optimization_type(self) -> Optional[_builtins.str]:
        """
        Optimization type, values: `OVToCN` - Overseas to CN, `CNToOV` CN to Overseas.
        """
        return pulumi.get(self, "optimization_type")


@pulumi.output_type
class DomainOriginPullTimeout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "receiveTimeout":
            suggest = "receive_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOriginPullTimeout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOriginPullTimeout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOriginPullTimeout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: _builtins.int,
                 receive_timeout: _builtins.int):
        """
        :param _builtins.int connect_timeout: The origin-pull connection timeout (in seconds). Valid range: 5-60.
        :param _builtins.int receive_timeout: The origin-pull receipt timeout (in seconds). Valid range: 10-60.
        """
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "receive_timeout", receive_timeout)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> _builtins.int:
        """
        The origin-pull connection timeout (in seconds). Valid range: 5-60.
        """
        return pulumi.get(self, "connect_timeout")

    @_builtins.property
    @pulumi.getter(name="receiveTimeout")
    def receive_timeout(self) -> _builtins.int:
        """
        The origin-pull receipt timeout (in seconds). Valid range: 10-60.
        """
        return pulumi.get(self, "receive_timeout")


@pulumi.output_type
class DomainOssPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOssPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOssPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOssPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bucket: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.str access_key: Access ID.
        :param _builtins.str bucket: Bucket.
        :param _builtins.str region: Region.
        :param _builtins.str secret_key: Key.
        """
        pulumi.set(__self__, "switch", switch)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Access ID.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        """
        Bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class DomainOthersPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOthersPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOthersPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOthersPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bucket: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.str access_key: Access ID.
        :param _builtins.str bucket: Bucket.
        :param _builtins.str region: Region.
        :param _builtins.str secret_key: Key.
        """
        pulumi.set(__self__, "switch", switch)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Access ID.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        """
        Bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class DomainPostMaxSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainPostMaxSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainPostMaxSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainPostMaxSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 max_size: Optional[_builtins.int] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.int max_size: Maximum size in MB, value range is `[1, 200]`.
        """
        pulumi.set(__self__, "switch", switch)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        Maximum size in MB, value range is `[1, 200]`.
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainQnPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainQnPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainQnPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainQnPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param _builtins.str access_key: Access ID.
        :param _builtins.str secret_key: Key.
        """
        pulumi.set(__self__, "switch", switch)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Access ID.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class DomainReferer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refererRules":
            suggest = "referer_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainReferer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainReferer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainReferer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 referer_rules: Optional[Sequence['outputs.DomainRefererRefererRule']] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainRefererRefererRuleArgs'] referer_rules: List of referer rules.
        """
        pulumi.set(__self__, "switch", switch)
        if referer_rules is not None:
            pulumi.set(__self__, "referer_rules", referer_rules)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="refererRules")
    def referer_rules(self) -> Optional[Sequence['outputs.DomainRefererRefererRule']]:
        """
        List of referer rules.
        """
        return pulumi.get(self, "referer_rules")


@pulumi.output_type
class DomainRefererRefererRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowEmpty":
            suggest = "allow_empty"
        elif key == "refererType":
            suggest = "referer_type"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRefererRefererRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRefererRefererRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRefererRefererRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_empty: _builtins.bool,
                 referer_type: _builtins.str,
                 referers: Sequence[_builtins.str],
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str):
        """
        :param _builtins.bool allow_empty: Whether to allow emptpy.
        :param _builtins.str referer_type: Referer type.
        :param Sequence[_builtins.str] referers: Referer list.
        :param Sequence[_builtins.str] rule_paths: Referer rule path list.
        :param _builtins.str rule_type: Referer rule type.
        """
        pulumi.set(__self__, "allow_empty", allow_empty)
        pulumi.set(__self__, "referer_type", referer_type)
        pulumi.set(__self__, "referers", referers)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter(name="allowEmpty")
    def allow_empty(self) -> _builtins.bool:
        """
        Whether to allow emptpy.
        """
        return pulumi.get(self, "allow_empty")

    @_builtins.property
    @pulumi.getter(name="refererType")
    def referer_type(self) -> _builtins.str:
        """
        Referer type.
        """
        return pulumi.get(self, "referer_type")

    @_builtins.property
    @pulumi.getter
    def referers(self) -> Sequence[_builtins.str]:
        """
        Referer list.
        """
        return pulumi.get(self, "referers")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        Referer rule path list.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Referer rule type.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class DomainRequestHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerRules":
            suggest = "header_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRequestHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRequestHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRequestHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_rules: Optional[Sequence['outputs.DomainRequestHeaderHeaderRule']] = None,
                 switch: Optional[_builtins.str] = None):
        """
        :param Sequence['DomainRequestHeaderHeaderRuleArgs'] header_rules: Custom request header configuration rules.
        :param _builtins.str switch: Custom request header configuration switch. Valid values are `on` and `off`. and default value is `off`.
        """
        if header_rules is not None:
            pulumi.set(__self__, "header_rules", header_rules)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter(name="headerRules")
    def header_rules(self) -> Optional[Sequence['outputs.DomainRequestHeaderHeaderRule']]:
        """
        Custom request header configuration rules.
        """
        return pulumi.get(self, "header_rules")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[_builtins.str]:
        """
        Custom request header configuration switch. Valid values are `on` and `off`. and default value is `off`.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class DomainRequestHeaderHeaderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerMode":
            suggest = "header_mode"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRequestHeaderHeaderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRequestHeaderHeaderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRequestHeaderHeaderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_mode: _builtins.str,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str):
        """
        :param _builtins.str header_mode: Response header mode.
        :param _builtins.str header_name: response header name of rule.
        :param _builtins.str header_value: response header value of rule.
        :param Sequence[_builtins.str] rule_paths: response rule paths of rule.
        :param _builtins.str rule_type: response rule type of rule.
        """
        pulumi.set(__self__, "header_mode", header_mode)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter(name="headerMode")
    def header_mode(self) -> _builtins.str:
        """
        Response header mode.
        """
        return pulumi.get(self, "header_mode")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        response header name of rule.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        response header value of rule.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        response rule paths of rule.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        response rule type of rule.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class DomainResponseHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerRules":
            suggest = "header_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainResponseHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainResponseHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainResponseHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 header_rules: Optional[Sequence['outputs.DomainResponseHeaderHeaderRule']] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainResponseHeaderHeaderRuleArgs'] header_rules: List of response header rule.
        """
        pulumi.set(__self__, "switch", switch)
        if header_rules is not None:
            pulumi.set(__self__, "header_rules", header_rules)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="headerRules")
    def header_rules(self) -> Optional[Sequence['outputs.DomainResponseHeaderHeaderRule']]:
        """
        List of response header rule.
        """
        return pulumi.get(self, "header_rules")


@pulumi.output_type
class DomainResponseHeaderHeaderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerMode":
            suggest = "header_mode"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainResponseHeaderHeaderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainResponseHeaderHeaderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainResponseHeaderHeaderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_mode: _builtins.str,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str):
        """
        :param _builtins.str header_mode: Response header mode.
        :param _builtins.str header_name: response header name of rule.
        :param _builtins.str header_value: response header value of rule.
        :param Sequence[_builtins.str] rule_paths: response rule paths of rule.
        :param _builtins.str rule_type: response rule type of rule.
        """
        pulumi.set(__self__, "header_mode", header_mode)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter(name="headerMode")
    def header_mode(self) -> _builtins.str:
        """
        Response header mode.
        """
        return pulumi.get(self, "header_mode")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        response header name of rule.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        response header value of rule.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        response rule paths of rule.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        response rule type of rule.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class DomainRuleCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheTime":
            suggest = "cache_time"
        elif key == "compareMaxAge":
            suggest = "compare_max_age"
        elif key == "followOriginSwitch":
            suggest = "follow_origin_switch"
        elif key == "heuristicCacheSwitch":
            suggest = "heuristic_cache_switch"
        elif key == "heuristicCacheTime":
            suggest = "heuristic_cache_time"
        elif key == "ignoreCacheControl":
            suggest = "ignore_cache_control"
        elif key == "ignoreSetCookie":
            suggest = "ignore_set_cookie"
        elif key == "noCacheSwitch":
            suggest = "no_cache_switch"
        elif key == "reValidate":
            suggest = "re_validate"
        elif key == "rulePaths":
            suggest = "rule_paths"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_time: _builtins.int,
                 compare_max_age: Optional[_builtins.str] = None,
                 follow_origin_switch: Optional[_builtins.str] = None,
                 heuristic_cache_switch: Optional[_builtins.str] = None,
                 heuristic_cache_time: Optional[_builtins.int] = None,
                 ignore_cache_control: Optional[_builtins.str] = None,
                 ignore_set_cookie: Optional[_builtins.str] = None,
                 no_cache_switch: Optional[_builtins.str] = None,
                 re_validate: Optional[_builtins.str] = None,
                 rule_paths: Optional[Sequence[_builtins.str]] = None,
                 rule_type: Optional[_builtins.str] = None,
                 switch: Optional[_builtins.str] = None):
        """
        :param _builtins.int cache_time: Cache expiration time setting, the unit is second, the maximum can be set to 365 days.
        :param _builtins.str compare_max_age: Advanced cache expiration configuration. When it is turned on, it will compare the max-age value returned by the origin site with the cache expiration time set in CacheRules, and take the minimum value to cache at the node. Valid values are `on` and `off`. Default value is `off`.
        :param _builtins.str follow_origin_switch: Follow the source station configuration switch. Valid values are `on` and `off`.
        :param _builtins.str heuristic_cache_switch: Specify whether to enable heuristic cache, only available while `follow_origin_switch` enabled, values: `on`, `off` (Default).
        :param _builtins.int heuristic_cache_time: Specify heuristic cache time in second, only available while `follow_origin_switch` and `heuristic_cache_switch` enabled.
        :param _builtins.str ignore_cache_control: Force caching. After opening, the no-store and no-cache resources returned by the origin site will also be cached in accordance with the CacheRules rules. Valid values are `on` and `off`. Default value is `off`.
        :param _builtins.str ignore_set_cookie: Ignore the Set-Cookie header of the origin site. Valid values are `on` and `off`. Default value is `off`. This parameter is for white-list customer.
        :param _builtins.str no_cache_switch: Cache configuration switch. Valid values are `on` and `off`.
        :param _builtins.str re_validate: Always check back to origin. Valid values are `on` and `off`. Default value is `off`.
        :param Sequence[_builtins.str] rule_paths: Matching content under the corresponding type of CacheType: `all`: fill *, `file`: fill in the suffix name, such as jpg, txt, `directory`: fill in the path, such as /xxx/test, `path`: fill in the absolute path, such as /xxx/test.html, `index`: fill /.
        :param _builtins.str rule_type: Rule type. The following types are supported: `all`: all documents take effect, `file`: the specified file suffix takes effect, `directory`: the specified path takes effect, `path`: specify the absolute path to take effect, `index`: home page.
        :param _builtins.str switch: Cache configuration switch. Valid values are `on` and `off`.
        """
        pulumi.set(__self__, "cache_time", cache_time)
        if compare_max_age is not None:
            pulumi.set(__self__, "compare_max_age", compare_max_age)
        if follow_origin_switch is not None:
            pulumi.set(__self__, "follow_origin_switch", follow_origin_switch)
        if heuristic_cache_switch is not None:
            pulumi.set(__self__, "heuristic_cache_switch", heuristic_cache_switch)
        if heuristic_cache_time is not None:
            pulumi.set(__self__, "heuristic_cache_time", heuristic_cache_time)
        if ignore_cache_control is not None:
            pulumi.set(__self__, "ignore_cache_control", ignore_cache_control)
        if ignore_set_cookie is not None:
            pulumi.set(__self__, "ignore_set_cookie", ignore_set_cookie)
        if no_cache_switch is not None:
            pulumi.set(__self__, "no_cache_switch", no_cache_switch)
        if re_validate is not None:
            pulumi.set(__self__, "re_validate", re_validate)
        if rule_paths is not None:
            pulumi.set(__self__, "rule_paths", rule_paths)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter(name="cacheTime")
    def cache_time(self) -> _builtins.int:
        """
        Cache expiration time setting, the unit is second, the maximum can be set to 365 days.
        """
        return pulumi.get(self, "cache_time")

    @_builtins.property
    @pulumi.getter(name="compareMaxAge")
    def compare_max_age(self) -> Optional[_builtins.str]:
        """
        Advanced cache expiration configuration. When it is turned on, it will compare the max-age value returned by the origin site with the cache expiration time set in CacheRules, and take the minimum value to cache at the node. Valid values are `on` and `off`. Default value is `off`.
        """
        return pulumi.get(self, "compare_max_age")

    @_builtins.property
    @pulumi.getter(name="followOriginSwitch")
    def follow_origin_switch(self) -> Optional[_builtins.str]:
        """
        Follow the source station configuration switch. Valid values are `on` and `off`.
        """
        return pulumi.get(self, "follow_origin_switch")

    @_builtins.property
    @pulumi.getter(name="heuristicCacheSwitch")
    def heuristic_cache_switch(self) -> Optional[_builtins.str]:
        """
        Specify whether to enable heuristic cache, only available while `follow_origin_switch` enabled, values: `on`, `off` (Default).
        """
        return pulumi.get(self, "heuristic_cache_switch")

    @_builtins.property
    @pulumi.getter(name="heuristicCacheTime")
    def heuristic_cache_time(self) -> Optional[_builtins.int]:
        """
        Specify heuristic cache time in second, only available while `follow_origin_switch` and `heuristic_cache_switch` enabled.
        """
        return pulumi.get(self, "heuristic_cache_time")

    @_builtins.property
    @pulumi.getter(name="ignoreCacheControl")
    def ignore_cache_control(self) -> Optional[_builtins.str]:
        """
        Force caching. After opening, the no-store and no-cache resources returned by the origin site will also be cached in accordance with the CacheRules rules. Valid values are `on` and `off`. Default value is `off`.
        """
        return pulumi.get(self, "ignore_cache_control")

    @_builtins.property
    @pulumi.getter(name="ignoreSetCookie")
    def ignore_set_cookie(self) -> Optional[_builtins.str]:
        """
        Ignore the Set-Cookie header of the origin site. Valid values are `on` and `off`. Default value is `off`. This parameter is for white-list customer.
        """
        return pulumi.get(self, "ignore_set_cookie")

    @_builtins.property
    @pulumi.getter(name="noCacheSwitch")
    def no_cache_switch(self) -> Optional[_builtins.str]:
        """
        Cache configuration switch. Valid values are `on` and `off`.
        """
        return pulumi.get(self, "no_cache_switch")

    @_builtins.property
    @pulumi.getter(name="reValidate")
    def re_validate(self) -> Optional[_builtins.str]:
        """
        Always check back to origin. Valid values are `on` and `off`. Default value is `off`.
        """
        return pulumi.get(self, "re_validate")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        Matching content under the corresponding type of CacheType: `all`: fill *, `file`: fill in the suffix name, such as jpg, txt, `directory`: fill in the path, such as /xxx/test, `path`: fill in the absolute path, such as /xxx/test.html, `index`: fill /.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.str]:
        """
        Rule type. The following types are supported: `all`: all documents take effect, `file`: the specified file suffix takes effect, `directory`: the specified path takes effect, `path`: specify the absolute path to take effect, `index`: home page.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> Optional[_builtins.str]:
        """
        Cache configuration switch. Valid values are `on` and `off`.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class DomainStatusCodeCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheRules":
            suggest = "cache_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusCodeCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusCodeCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusCodeCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: _builtins.str,
                 cache_rules: Optional[Sequence['outputs.DomainStatusCodeCacheCacheRule']] = None):
        """
        :param _builtins.str switch: Configuration switch, available values: `on`, `off` (default).
        :param Sequence['DomainStatusCodeCacheCacheRuleArgs'] cache_rules: List of cache rule.
        """
        pulumi.set(__self__, "switch", switch)
        if cache_rules is not None:
            pulumi.set(__self__, "cache_rules", cache_rules)

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Configuration switch, available values: `on`, `off` (default).
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="cacheRules")
    def cache_rules(self) -> Optional[Sequence['outputs.DomainStatusCodeCacheCacheRule']]:
        """
        List of cache rule.
        """
        return pulumi.get(self, "cache_rules")


@pulumi.output_type
class DomainStatusCodeCacheCacheRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheTime":
            suggest = "cache_time"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusCodeCacheCacheRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusCodeCacheCacheRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusCodeCacheCacheRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_time: _builtins.int,
                 status_code: _builtins.str):
        """
        :param _builtins.int cache_time: Status code cache expiration time (in seconds).
        :param _builtins.str status_code: Code of status cache. available values: `403`, `404`.
        """
        pulumi.set(__self__, "cache_time", cache_time)
        pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="cacheTime")
    def cache_time(self) -> _builtins.int:
        """
        Status code cache expiration time (in seconds).
        """
        return pulumi.get(self, "cache_time")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> _builtins.str:
        """
        Code of status cache. available values: `403`, `404`.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class UrlPurgePurgeHistory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "flushType":
            suggest = "flush_type"
        elif key == "purgeType":
            suggest = "purge_type"
        elif key == "taskId":
            suggest = "task_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlPurgePurgeHistory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlPurgePurgeHistory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlPurgePurgeHistory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_time: Optional[_builtins.str] = None,
                 flush_type: Optional[_builtins.str] = None,
                 purge_type: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 task_id: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: Purge task create time.
        :param _builtins.str flush_type: Purge flush type of `flush` or `delete`.
        :param _builtins.str purge_type: Purge category in of `url` or `path`.
        :param _builtins.str status: Purge status of `fail`, `done`, `process`.
        :param _builtins.str task_id: Task id of last operation.
        :param _builtins.str url: Purge url.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if flush_type is not None:
            pulumi.set(__self__, "flush_type", flush_type)
        if purge_type is not None:
            pulumi.set(__self__, "purge_type", purge_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_id is not None:
            pulumi.set(__self__, "task_id", task_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Purge task create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="flushType")
    def flush_type(self) -> Optional[_builtins.str]:
        """
        Purge flush type of `flush` or `delete`.
        """
        return pulumi.get(self, "flush_type")

    @_builtins.property
    @pulumi.getter(name="purgeType")
    def purge_type(self) -> Optional[_builtins.str]:
        """
        Purge category in of `url` or `path`.
        """
        return pulumi.get(self, "purge_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Purge status of `fail`, `done`, `process`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[_builtins.str]:
        """
        Task id of last operation.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Purge url.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class UrlPushPushHistory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "taskId":
            suggest = "task_id"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlPushPushHistory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlPushPushHistory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlPushPushHistory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area: Optional[_builtins.str] = None,
                 create_time: Optional[_builtins.str] = None,
                 percent: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None,
                 task_id: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str area: Specify push area. NOTE: only push same area cache contents.
        :param _builtins.str create_time: Push task create time.
        :param _builtins.int percent: Push progress in percent.
        :param _builtins.str status: Push status of `fail`, `done`, `process` or `invalid` (4xx, 5xx response).
        :param _builtins.str task_id: Push task id.
        :param _builtins.str update_time: Push task update time.
        :param _builtins.str url: Push url.
        """
        if area is not None:
            pulumi.set(__self__, "area", area)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_id is not None:
            pulumi.set(__self__, "task_id", task_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def area(self) -> Optional[_builtins.str]:
        """
        Specify push area. NOTE: only push same area cache contents.
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Push task create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[_builtins.int]:
        """
        Push progress in percent.
        """
        return pulumi.get(self, "percent")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Push status of `fail`, `done`, `process` or `invalid` (4xx, 5xx response).
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[_builtins.str]:
        """
        Push task id.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Push task update time.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Push url.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetDomainsDomainListResult(dict):
    def __init__(__self__, *,
                 area: _builtins.str,
                 cname: _builtins.str,
                 create_time: _builtins.str,
                 domain: _builtins.str,
                 full_url_cache: _builtins.bool,
                 https_configs: Sequence['outputs.GetDomainsDomainListHttpsConfigResult'],
                 id: _builtins.str,
                 origins: Sequence['outputs.GetDomainsDomainListOriginResult'],
                 project_id: _builtins.int,
                 range_origin_switch: _builtins.str,
                 request_headers: Sequence['outputs.GetDomainsDomainListRequestHeaderResult'],
                 rule_caches: Sequence['outputs.GetDomainsDomainListRuleCacheResult'],
                 service_type: _builtins.str,
                 status: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 update_time: _builtins.str):
        """
        :param _builtins.str area: Acceleration region.
        :param _builtins.str cname: CNAME address of domain name.
        :param _builtins.str create_time: Domain name creation time.
        :param _builtins.str domain: Acceleration domain name.
        :param _builtins.bool full_url_cache: Whether to enable full-path cache.
        :param Sequence['GetDomainsDomainListHttpsConfigArgs'] https_configs: HTTPS acceleration configuration. It's a list and consist of at most one item.
        :param _builtins.str id: Domain name ID.
        :param Sequence['GetDomainsDomainListOriginArgs'] origins: Origin server configuration.
        :param _builtins.int project_id: The project CDN belongs to.
        :param _builtins.str range_origin_switch: Sharding back to source configuration switch.
        :param Sequence['GetDomainsDomainListRequestHeaderArgs'] request_headers: Request header configuration.
        :param Sequence['GetDomainsDomainListRuleCacheArgs'] rule_caches: Advanced path cache configuration.
        :param _builtins.str service_type: Service type of acceleration domain name. The available value include `web`, `download` and `media`.
        :param _builtins.str status: Acceleration service status.
        :param Mapping[str, _builtins.str] tags: Tags of cdn domain.
        :param _builtins.str update_time: Last modified time of domain name.
        """
        pulumi.set(__self__, "area", area)
        pulumi.set(__self__, "cname", cname)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "full_url_cache", full_url_cache)
        pulumi.set(__self__, "https_configs", https_configs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "origins", origins)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "range_origin_switch", range_origin_switch)
        pulumi.set(__self__, "request_headers", request_headers)
        pulumi.set(__self__, "rule_caches", rule_caches)
        pulumi.set(__self__, "service_type", service_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def area(self) -> _builtins.str:
        """
        Acceleration region.
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter
    def cname(self) -> _builtins.str:
        """
        CNAME address of domain name.
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Domain name creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Acceleration domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="fullUrlCache")
    def full_url_cache(self) -> _builtins.bool:
        """
        Whether to enable full-path cache.
        """
        return pulumi.get(self, "full_url_cache")

    @_builtins.property
    @pulumi.getter(name="httpsConfigs")
    def https_configs(self) -> Sequence['outputs.GetDomainsDomainListHttpsConfigResult']:
        """
        HTTPS acceleration configuration. It's a list and consist of at most one item.
        """
        return pulumi.get(self, "https_configs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Domain name ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def origins(self) -> Sequence['outputs.GetDomainsDomainListOriginResult']:
        """
        Origin server configuration.
        """
        return pulumi.get(self, "origins")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.int:
        """
        The project CDN belongs to.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="rangeOriginSwitch")
    def range_origin_switch(self) -> _builtins.str:
        """
        Sharding back to source configuration switch.
        """
        return pulumi.get(self, "range_origin_switch")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Sequence['outputs.GetDomainsDomainListRequestHeaderResult']:
        """
        Request header configuration.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter(name="ruleCaches")
    def rule_caches(self) -> Sequence['outputs.GetDomainsDomainListRuleCacheResult']:
        """
        Advanced path cache configuration.
        """
        return pulumi.get(self, "rule_caches")

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> _builtins.str:
        """
        Service type of acceleration domain name. The available value include `web`, `download` and `media`.
        """
        return pulumi.get(self, "service_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Acceleration service status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Tags of cdn domain.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Last modified time of domain name.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetDomainsDomainListHttpsConfigResult(dict):
    def __init__(__self__, *,
                 http2_switch: _builtins.str,
                 https_switch: _builtins.str,
                 ocsp_stapling_switch: _builtins.str,
                 spdy_switch: _builtins.str,
                 verify_client: _builtins.str):
        """
        :param _builtins.str http2_switch: HTTP2 configuration switch.
        :param _builtins.str https_switch: HTTPS configuration. Valid values: `on`, `off` and `processing`.
        :param _builtins.str ocsp_stapling_switch: OCSP configuration switch.
        :param _builtins.str spdy_switch: Spdy configuration switch.
        :param _builtins.str verify_client: Client certificate authentication feature.
        """
        pulumi.set(__self__, "http2_switch", http2_switch)
        pulumi.set(__self__, "https_switch", https_switch)
        pulumi.set(__self__, "ocsp_stapling_switch", ocsp_stapling_switch)
        pulumi.set(__self__, "spdy_switch", spdy_switch)
        pulumi.set(__self__, "verify_client", verify_client)

    @_builtins.property
    @pulumi.getter(name="http2Switch")
    def http2_switch(self) -> _builtins.str:
        """
        HTTP2 configuration switch.
        """
        return pulumi.get(self, "http2_switch")

    @_builtins.property
    @pulumi.getter(name="httpsSwitch")
    def https_switch(self) -> _builtins.str:
        """
        HTTPS configuration. Valid values: `on`, `off` and `processing`.
        """
        return pulumi.get(self, "https_switch")

    @_builtins.property
    @pulumi.getter(name="ocspStaplingSwitch")
    def ocsp_stapling_switch(self) -> _builtins.str:
        """
        OCSP configuration switch.
        """
        return pulumi.get(self, "ocsp_stapling_switch")

    @_builtins.property
    @pulumi.getter(name="spdySwitch")
    def spdy_switch(self) -> _builtins.str:
        """
        Spdy configuration switch.
        """
        return pulumi.get(self, "spdy_switch")

    @_builtins.property
    @pulumi.getter(name="verifyClient")
    def verify_client(self) -> _builtins.str:
        """
        Client certificate authentication feature.
        """
        return pulumi.get(self, "verify_client")


@pulumi.output_type
class GetDomainsDomainListOriginResult(dict):
    def __init__(__self__, *,
                 backup_origin_lists: Sequence[_builtins.str],
                 backup_origin_type: _builtins.str,
                 backup_server_name: _builtins.str,
                 cos_private_access: _builtins.str,
                 origin_lists: Sequence[_builtins.str],
                 origin_pull_protocol: _builtins.str,
                 origin_type: _builtins.str,
                 server_name: _builtins.str):
        """
        :param Sequence[_builtins.str] backup_origin_lists: Backup origin server list.
        :param _builtins.str backup_origin_type: Backup origin server type.
        :param _builtins.str backup_server_name: Host header used when accessing the backup origin server. If left empty, the ServerName of master origin server will be used by default.
        :param _builtins.str cos_private_access: When OriginType is COS, you can specify if access to private buckets is allowed.
        :param Sequence[_builtins.str] origin_lists: Master origin server list.
        :param _builtins.str origin_pull_protocol: Origin-pull protocol configuration. Valid values: `http`, `https` and `follow`.
        :param _builtins.str origin_type: Master origin server type.
        :param _builtins.str server_name: Host header used when accessing the master origin server. If left empty, the acceleration domain name will be used by default.
        """
        pulumi.set(__self__, "backup_origin_lists", backup_origin_lists)
        pulumi.set(__self__, "backup_origin_type", backup_origin_type)
        pulumi.set(__self__, "backup_server_name", backup_server_name)
        pulumi.set(__self__, "cos_private_access", cos_private_access)
        pulumi.set(__self__, "origin_lists", origin_lists)
        pulumi.set(__self__, "origin_pull_protocol", origin_pull_protocol)
        pulumi.set(__self__, "origin_type", origin_type)
        pulumi.set(__self__, "server_name", server_name)

    @_builtins.property
    @pulumi.getter(name="backupOriginLists")
    def backup_origin_lists(self) -> Sequence[_builtins.str]:
        """
        Backup origin server list.
        """
        return pulumi.get(self, "backup_origin_lists")

    @_builtins.property
    @pulumi.getter(name="backupOriginType")
    def backup_origin_type(self) -> _builtins.str:
        """
        Backup origin server type.
        """
        return pulumi.get(self, "backup_origin_type")

    @_builtins.property
    @pulumi.getter(name="backupServerName")
    def backup_server_name(self) -> _builtins.str:
        """
        Host header used when accessing the backup origin server. If left empty, the ServerName of master origin server will be used by default.
        """
        return pulumi.get(self, "backup_server_name")

    @_builtins.property
    @pulumi.getter(name="cosPrivateAccess")
    def cos_private_access(self) -> _builtins.str:
        """
        When OriginType is COS, you can specify if access to private buckets is allowed.
        """
        return pulumi.get(self, "cos_private_access")

    @_builtins.property
    @pulumi.getter(name="originLists")
    def origin_lists(self) -> Sequence[_builtins.str]:
        """
        Master origin server list.
        """
        return pulumi.get(self, "origin_lists")

    @_builtins.property
    @pulumi.getter(name="originPullProtocol")
    def origin_pull_protocol(self) -> _builtins.str:
        """
        Origin-pull protocol configuration. Valid values: `http`, `https` and `follow`.
        """
        return pulumi.get(self, "origin_pull_protocol")

    @_builtins.property
    @pulumi.getter(name="originType")
    def origin_type(self) -> _builtins.str:
        """
        Master origin server type.
        """
        return pulumi.get(self, "origin_type")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> _builtins.str:
        """
        Host header used when accessing the master origin server. If left empty, the acceleration domain name will be used by default.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class GetDomainsDomainListRequestHeaderResult(dict):
    def __init__(__self__, *,
                 header_rules: Sequence['outputs.GetDomainsDomainListRequestHeaderHeaderRuleResult'],
                 switch: _builtins.str):
        """
        :param Sequence['GetDomainsDomainListRequestHeaderHeaderRuleArgs'] header_rules: Custom request header configuration rules.
        :param _builtins.str switch: Cache configuration switch.
        """
        pulumi.set(__self__, "header_rules", header_rules)
        pulumi.set(__self__, "switch", switch)

    @_builtins.property
    @pulumi.getter(name="headerRules")
    def header_rules(self) -> Sequence['outputs.GetDomainsDomainListRequestHeaderHeaderRuleResult']:
        """
        Custom request header configuration rules.
        """
        return pulumi.get(self, "header_rules")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Cache configuration switch.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class GetDomainsDomainListRequestHeaderHeaderRuleResult(dict):
    def __init__(__self__, *,
                 header_mode: _builtins.str,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str):
        """
        :param _builtins.str header_mode: Http header setting method.
        :param _builtins.str header_name: Http header name.
        :param _builtins.str header_value: Http header value.
        :param Sequence[_builtins.str] rule_paths: Rule paths.
        :param _builtins.str rule_type: Rule type.
        """
        pulumi.set(__self__, "header_mode", header_mode)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter(name="headerMode")
    def header_mode(self) -> _builtins.str:
        """
        Http header setting method.
        """
        return pulumi.get(self, "header_mode")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        Http header name.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        Http header value.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        Rule paths.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Rule type.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class GetDomainsDomainListRuleCacheResult(dict):
    def __init__(__self__, *,
                 cache_time: _builtins.int,
                 follow_origin_switch: _builtins.str,
                 ignore_set_cookie: _builtins.str,
                 no_cache_switch: _builtins.str,
                 re_validate: _builtins.str,
                 rule_paths: Sequence[_builtins.str],
                 rule_type: _builtins.str,
                 switch: _builtins.str,
                 compare_max_age: Optional[_builtins.str] = None,
                 ignore_cache_control: Optional[_builtins.str] = None):
        """
        :param _builtins.int cache_time: Cache expiration time setting, the unit is second.
        :param _builtins.str follow_origin_switch: Follow the source station configuration switch.
        :param _builtins.str ignore_set_cookie: Ignore the Set-Cookie header of the origin site.
        :param _builtins.str no_cache_switch: Cache configuration switch.
        :param _builtins.str re_validate: Always check back to origin.
        :param Sequence[_builtins.str] rule_paths: Rule paths.
        :param _builtins.str rule_type: Rule type.
        :param _builtins.str switch: Cache configuration switch.
        :param _builtins.str compare_max_age: Advanced cache expiration configuration.
        :param _builtins.str ignore_cache_control: Force caching. After opening, the no-store and no-cache resources returned by the origin site will also be cached in accordance with the CacheRules rules.
        """
        pulumi.set(__self__, "cache_time", cache_time)
        pulumi.set(__self__, "follow_origin_switch", follow_origin_switch)
        pulumi.set(__self__, "ignore_set_cookie", ignore_set_cookie)
        pulumi.set(__self__, "no_cache_switch", no_cache_switch)
        pulumi.set(__self__, "re_validate", re_validate)
        pulumi.set(__self__, "rule_paths", rule_paths)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "switch", switch)
        if compare_max_age is not None:
            pulumi.set(__self__, "compare_max_age", compare_max_age)
        if ignore_cache_control is not None:
            pulumi.set(__self__, "ignore_cache_control", ignore_cache_control)

    @_builtins.property
    @pulumi.getter(name="cacheTime")
    def cache_time(self) -> _builtins.int:
        """
        Cache expiration time setting, the unit is second.
        """
        return pulumi.get(self, "cache_time")

    @_builtins.property
    @pulumi.getter(name="followOriginSwitch")
    def follow_origin_switch(self) -> _builtins.str:
        """
        Follow the source station configuration switch.
        """
        return pulumi.get(self, "follow_origin_switch")

    @_builtins.property
    @pulumi.getter(name="ignoreSetCookie")
    def ignore_set_cookie(self) -> _builtins.str:
        """
        Ignore the Set-Cookie header of the origin site.
        """
        return pulumi.get(self, "ignore_set_cookie")

    @_builtins.property
    @pulumi.getter(name="noCacheSwitch")
    def no_cache_switch(self) -> _builtins.str:
        """
        Cache configuration switch.
        """
        return pulumi.get(self, "no_cache_switch")

    @_builtins.property
    @pulumi.getter(name="reValidate")
    def re_validate(self) -> _builtins.str:
        """
        Always check back to origin.
        """
        return pulumi.get(self, "re_validate")

    @_builtins.property
    @pulumi.getter(name="rulePaths")
    def rule_paths(self) -> Sequence[_builtins.str]:
        """
        Rule paths.
        """
        return pulumi.get(self, "rule_paths")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Rule type.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def switch(self) -> _builtins.str:
        """
        Cache configuration switch.
        """
        return pulumi.get(self, "switch")

    @_builtins.property
    @pulumi.getter(name="compareMaxAge")
    def compare_max_age(self) -> Optional[_builtins.str]:
        """
        Advanced cache expiration configuration.
        """
        return pulumi.get(self, "compare_max_age")

    @_builtins.property
    @pulumi.getter(name="ignoreCacheControl")
    def ignore_cache_control(self) -> Optional[_builtins.str]:
        """
        Force caching. After opening, the no-store and no-cache resources returned by the origin site will also be cached in accordance with the CacheRules rules.
        """
        return pulumi.get(self, "ignore_cache_control")


