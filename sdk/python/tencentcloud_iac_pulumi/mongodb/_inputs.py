# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'InstanceAccountAuthRoleArgs',
    'InstanceAccountAuthRoleArgsDict',
    'InstanceAddNodeListArgs',
    'InstanceAddNodeListArgsDict',
    'InstanceBackupDownloadTaskBackupSetArgs',
    'InstanceBackupDownloadTaskBackupSetArgsDict',
    'InstanceParamsInstanceParamArgs',
    'InstanceParamsInstanceParamArgsDict',
    'InstanceRemoveNodeListArgs',
    'InstanceRemoveNodeListArgsDict',
    'InstanceStandbyInstanceListArgs',
    'InstanceStandbyInstanceListArgsDict',
    'InstanceTransparentDataEncryptionKeyInfoListArgs',
    'InstanceTransparentDataEncryptionKeyInfoListArgsDict',
]

MYPY = False

if not MYPY:
    class InstanceAccountAuthRoleArgsDict(TypedDict):
        mask: pulumi.Input[_builtins.int]
        """
        Permission information of the current account. 0: No permission. 1: read-only. 2: Write only. 3: Read and write.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Refers to the name of the database with the current account permissions.*: Indicates all databases. db.name: Indicates the database of a specific name.
        """
elif False:
    InstanceAccountAuthRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAccountAuthRoleArgs:
    def __init__(__self__, *,
                 mask: pulumi.Input[_builtins.int],
                 namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] mask: Permission information of the current account. 0: No permission. 1: read-only. 2: Write only. 3: Read and write.
        :param pulumi.Input[_builtins.str] namespace: Refers to the name of the database with the current account permissions.*: Indicates all databases. db.name: Indicates the database of a specific name.
        """
        pulumi.set(__self__, "mask", mask)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def mask(self) -> pulumi.Input[_builtins.int]:
        """
        Permission information of the current account. 0: No permission. 1: read-only. 2: Write only. 3: Read and write.
        """
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "mask", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Refers to the name of the database with the current account permissions.*: Indicates all databases. db.name: Indicates the database of a specific name.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class InstanceAddNodeListArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        The node role that needs to be added.
        - SECONDARY: Mongod node;
        - READONLY: read-only node;
        - MONGOS: Mongos node.
        """
        zone: pulumi.Input[_builtins.str]
        """
        The availability zone corresponding to the node.
        - single availability zone, where all nodes are in the same availability zone;
        - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
        """
elif False:
    InstanceAddNodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAddNodeListArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 zone: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] role: The node role that needs to be added.
               - SECONDARY: Mongod node;
               - READONLY: read-only node;
               - MONGOS: Mongos node.
        :param pulumi.Input[_builtins.str] zone: The availability zone corresponding to the node.
               - single availability zone, where all nodes are in the same availability zone;
               - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The node role that needs to be added.
        - SECONDARY: Mongod node;
        - READONLY: read-only node;
        - MONGOS: Mongos node.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        The availability zone corresponding to the node.
        - single availability zone, where all nodes are in the same availability zone;
        - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class InstanceBackupDownloadTaskBackupSetArgsDict(TypedDict):
        replica_set_id: pulumi.Input[_builtins.str]
        """
        Replication Id.
        """
elif False:
    InstanceBackupDownloadTaskBackupSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceBackupDownloadTaskBackupSetArgs:
    def __init__(__self__, *,
                 replica_set_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] replica_set_id: Replication Id.
        """
        pulumi.set(__self__, "replica_set_id", replica_set_id)

    @_builtins.property
    @pulumi.getter(name="replicaSetId")
    def replica_set_id(self) -> pulumi.Input[_builtins.str]:
        """
        Replication Id.
        """
        return pulumi.get(self, "replica_set_id")

    @replica_set_id.setter
    def replica_set_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "replica_set_id", value)


if not MYPY:
    class InstanceParamsInstanceParamArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Parameter names that need to be modified.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value corresponding to the parameter name to be modified.
        """
elif False:
    InstanceParamsInstanceParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceParamsInstanceParamArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Parameter names that need to be modified.
        :param pulumi.Input[_builtins.str] value: The value corresponding to the parameter name to be modified.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter names that need to be modified.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value corresponding to the parameter name to be modified.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InstanceRemoveNodeListArgsDict(TypedDict):
        node_name: pulumi.Input[_builtins.str]
        """
        The node ID to delete. The shard cluster must specify the name of the node to be deleted by a group of shards, and the rest of the shards should be grouped and aligned.
        """
        role: pulumi.Input[_builtins.str]
        """
        The node role that needs to be deleted.
        - SECONDARY: Mongod node;
        - READONLY: read-only node;
        - MONGOS: Mongos node.
        """
        zone: pulumi.Input[_builtins.str]
        """
        The availability zone corresponding to the node.
        - single availability zone, where all nodes are in the same availability zone;
        - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
        """
elif False:
    InstanceRemoveNodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceRemoveNodeListArgs:
    def __init__(__self__, *,
                 node_name: pulumi.Input[_builtins.str],
                 role: pulumi.Input[_builtins.str],
                 zone: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] node_name: The node ID to delete. The shard cluster must specify the name of the node to be deleted by a group of shards, and the rest of the shards should be grouped and aligned.
        :param pulumi.Input[_builtins.str] role: The node role that needs to be deleted.
               - SECONDARY: Mongod node;
               - READONLY: read-only node;
               - MONGOS: Mongos node.
        :param pulumi.Input[_builtins.str] zone: The availability zone corresponding to the node.
               - single availability zone, where all nodes are in the same availability zone;
               - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
        """
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> pulumi.Input[_builtins.str]:
        """
        The node ID to delete. The shard cluster must specify the name of the node to be deleted by a group of shards, and the rest of the shards should be grouped and aligned.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_name", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The node role that needs to be deleted.
        - SECONDARY: Mongod node;
        - READONLY: read-only node;
        - MONGOS: Mongos node.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        The availability zone corresponding to the node.
        - single availability zone, where all nodes are in the same availability zone;
        - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class InstanceStandbyInstanceListArgsDict(TypedDict):
        standby_instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the ID of standby instance.
        """
        standby_instance_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the region of standby instance.
        """
elif False:
    InstanceStandbyInstanceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStandbyInstanceListArgs:
    def __init__(__self__, *,
                 standby_instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 standby_instance_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] standby_instance_id: Indicates the ID of standby instance.
        :param pulumi.Input[_builtins.str] standby_instance_region: Indicates the region of standby instance.
        """
        if standby_instance_id is not None:
            pulumi.set(__self__, "standby_instance_id", standby_instance_id)
        if standby_instance_region is not None:
            pulumi.set(__self__, "standby_instance_region", standby_instance_region)

    @_builtins.property
    @pulumi.getter(name="standbyInstanceId")
    def standby_instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the ID of standby instance.
        """
        return pulumi.get(self, "standby_instance_id")

    @standby_instance_id.setter
    def standby_instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "standby_instance_id", value)

    @_builtins.property
    @pulumi.getter(name="standbyInstanceRegion")
    def standby_instance_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the region of standby instance.
        """
        return pulumi.get(self, "standby_instance_region")

    @standby_instance_region.setter
    def standby_instance_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "standby_instance_region", value)


if not MYPY:
    class InstanceTransparentDataEncryptionKeyInfoListArgsDict(TypedDict):
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance and key binding time.
        """
        key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Master Key ID.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Master key name.
        """
        key_origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key origin.
        """
        key_usage: NotRequired[pulumi.Input[_builtins.str]]
        """
        Purpose of the key.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key status.
        """
elif False:
    InstanceTransparentDataEncryptionKeyInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceTransparentDataEncryptionKeyInfoListArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 key_origin: Optional[pulumi.Input[_builtins.str]] = None,
                 key_usage: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create_time: Instance and key binding time.
        :param pulumi.Input[_builtins.str] key_id: Master Key ID.
        :param pulumi.Input[_builtins.str] key_name: Master key name.
        :param pulumi.Input[_builtins.str] key_origin: Key origin.
        :param pulumi.Input[_builtins.str] key_usage: Purpose of the key.
        :param pulumi.Input[_builtins.str] status: Key status.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_origin is not None:
            pulumi.set(__self__, "key_origin", key_origin)
        if key_usage is not None:
            pulumi.set(__self__, "key_usage", key_usage)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance and key binding time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Master Key ID.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Master key name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="keyOrigin")
    def key_origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key origin.
        """
        return pulumi.get(self, "key_origin")

    @key_origin.setter
    def key_origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_origin", value)

    @_builtins.property
    @pulumi.getter(name="keyUsage")
    def key_usage(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Purpose of the key.
        """
        return pulumi.get(self, "key_usage")

    @key_usage.setter
    def key_usage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_usage", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


