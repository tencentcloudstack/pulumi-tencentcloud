# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'MediaAnimationTemplateContainerArgs',
    'MediaAnimationTemplateTimeIntervalArgs',
    'MediaAnimationTemplateVideoArgs',
    'MediaConcatTemplateConcatTemplateArgs',
    'MediaConcatTemplateConcatTemplateAudioArgs',
    'MediaConcatTemplateConcatTemplateAudioMixArgs',
    'MediaConcatTemplateConcatTemplateAudioMixEffectConfigArgs',
    'MediaConcatTemplateConcatTemplateConcatFragmentArgs',
    'MediaConcatTemplateConcatTemplateContainerArgs',
    'MediaConcatTemplateConcatTemplateVideoArgs',
    'MediaPicProcessTemplatePicProcessArgs',
    'MediaSmartCoverTemplateSmartCoverArgs',
    'MediaSnapshotTemplateSnapshotArgs',
    'MediaSnapshotTemplateSnapshotSpriteSnapshotConfigArgs',
    'MediaSpeechRecognitionTemplateSpeechRecognitionArgs',
    'MediaTranscodeProTemplateAudioArgs',
    'MediaTranscodeProTemplateContainerArgs',
    'MediaTranscodeProTemplateContainerClipConfigArgs',
    'MediaTranscodeProTemplateTimeIntervalArgs',
    'MediaTranscodeProTemplateTransConfigArgs',
    'MediaTranscodeProTemplateVideoArgs',
    'MediaTranscodeTemplateAudioArgs',
    'MediaTranscodeTemplateAudioMixArgs',
    'MediaTranscodeTemplateAudioMixEffectConfigArgs',
    'MediaTranscodeTemplateContainerArgs',
    'MediaTranscodeTemplateContainerClipConfigArgs',
    'MediaTranscodeTemplateTimeIntervalArgs',
    'MediaTranscodeTemplateTransConfigArgs',
    'MediaTranscodeTemplateTransConfigHlsEncryptArgs',
    'MediaTranscodeTemplateVideoArgs',
    'MediaVideoMontageTemplateAudioArgs',
    'MediaVideoMontageTemplateAudioMixArgs',
    'MediaVideoMontageTemplateAudioMixEffectConfigArgs',
    'MediaVideoMontageTemplateContainerArgs',
    'MediaVideoMontageTemplateVideoArgs',
    'MediaVideoProcessTemplateColorEnhanceArgs',
    'MediaVideoProcessTemplateMsSharpenArgs',
    'MediaVoiceSeparateTemplateAudioConfigArgs',
    'MediaWatermarkTemplateWatermarkArgs',
    'MediaWatermarkTemplateWatermarkImageArgs',
    'MediaWatermarkTemplateWatermarkTextArgs',
]

@pulumi.input_type
class MediaAnimationTemplateContainerArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str]):
        """
        :param pulumi.Input[str] format: Package format.
        """
        pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Package format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)


@pulumi.input_type
class MediaAnimationTemplateTimeIntervalArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] duration: duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param pulumi.Input[str] start: Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class MediaAnimationTemplateVideoArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 animate_frames_per_second: Optional[pulumi.Input[str]] = None,
                 animate_only_keep_key_frame: Optional[pulumi.Input[str]] = None,
                 animate_time_interval_of_frame: Optional[pulumi.Input[str]] = None,
                 fps: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 quality: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: Codec format `gif`, `webp`.
        :param pulumi.Input[str] animate_frames_per_second: Animation per second frame number, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        :param pulumi.Input[str] animate_only_keep_key_frame: GIFs are kept only Keyframe, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        :param pulumi.Input[str] animate_time_interval_of_frame: Animation frame extraction every time, (0, video duration], Animation frame extraction time interval, If TimeInterval.Duration is set, it is less than this value.
        :param pulumi.Input[str] fps: Frame rate, value range: (0, 60], Unit: fps.
        :param pulumi.Input[str] height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param pulumi.Input[str] quality: Set relative quality, [1, 100), webp image quality setting takes effect, gif has no quality parameter.
        :param pulumi.Input[str] width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        pulumi.set(__self__, "codec", codec)
        if animate_frames_per_second is not None:
            pulumi.set(__self__, "animate_frames_per_second", animate_frames_per_second)
        if animate_only_keep_key_frame is not None:
            pulumi.set(__self__, "animate_only_keep_key_frame", animate_only_keep_key_frame)
        if animate_time_interval_of_frame is not None:
            pulumi.set(__self__, "animate_time_interval_of_frame", animate_time_interval_of_frame)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Codec format `gif`, `webp`.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="animateFramesPerSecond")
    def animate_frames_per_second(self) -> Optional[pulumi.Input[str]]:
        """
        Animation per second frame number, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        """
        return pulumi.get(self, "animate_frames_per_second")

    @animate_frames_per_second.setter
    def animate_frames_per_second(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "animate_frames_per_second", value)

    @property
    @pulumi.getter(name="animateOnlyKeepKeyFrame")
    def animate_only_keep_key_frame(self) -> Optional[pulumi.Input[str]]:
        """
        GIFs are kept only Keyframe, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        """
        return pulumi.get(self, "animate_only_keep_key_frame")

    @animate_only_keep_key_frame.setter
    def animate_only_keep_key_frame(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "animate_only_keep_key_frame", value)

    @property
    @pulumi.getter(name="animateTimeIntervalOfFrame")
    def animate_time_interval_of_frame(self) -> Optional[pulumi.Input[str]]:
        """
        Animation frame extraction every time, (0, video duration], Animation frame extraction time interval, If TimeInterval.Duration is set, it is less than this value.
        """
        return pulumi.get(self, "animate_time_interval_of_frame")

    @animate_time_interval_of_frame.setter
    def animate_time_interval_of_frame(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "animate_time_interval_of_frame", value)

    @property
    @pulumi.getter
    def fps(self) -> Optional[pulumi.Input[str]]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[str]]:
        """
        Set relative quality, [1, 100), webp image quality setting takes effect, gif has no quality parameter.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quality", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaConcatTemplateConcatTemplateArgs:
    def __init__(__self__, *,
                 concat_fragments: pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateConcatFragmentArgs']]],
                 container: pulumi.Input['MediaConcatTemplateConcatTemplateContainerArgs'],
                 audio: Optional[pulumi.Input['MediaConcatTemplateConcatTemplateAudioArgs']] = None,
                 audio_mixes: Optional[pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixArgs']]]] = None,
                 video: Optional[pulumi.Input['MediaConcatTemplateConcatTemplateVideoArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateConcatFragmentArgs']]] concat_fragments: Package format.
        :param pulumi.Input['MediaConcatTemplateConcatTemplateContainerArgs'] container: Only splicing without transcoding.
        :param pulumi.Input['MediaConcatTemplateConcatTemplateAudioArgs'] audio: audio parameters, the target file does not require Audio information, need to set Audio.Remove to true.
        :param pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixArgs']]] audio_mixes: mixing parameters.
        :param pulumi.Input['MediaConcatTemplateConcatTemplateVideoArgs'] video: video information, do not upload Video, which is equivalent to deleting video information.
        """
        pulumi.set(__self__, "concat_fragments", concat_fragments)
        pulumi.set(__self__, "container", container)
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if audio_mixes is not None:
            pulumi.set(__self__, "audio_mixes", audio_mixes)
        if video is not None:
            pulumi.set(__self__, "video", video)

    @property
    @pulumi.getter(name="concatFragments")
    def concat_fragments(self) -> pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateConcatFragmentArgs']]]:
        """
        Package format.
        """
        return pulumi.get(self, "concat_fragments")

    @concat_fragments.setter
    def concat_fragments(self, value: pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateConcatFragmentArgs']]]):
        pulumi.set(self, "concat_fragments", value)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input['MediaConcatTemplateConcatTemplateContainerArgs']:
        """
        Only splicing without transcoding.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input['MediaConcatTemplateConcatTemplateContainerArgs']):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter
    def audio(self) -> Optional[pulumi.Input['MediaConcatTemplateConcatTemplateAudioArgs']]:
        """
        audio parameters, the target file does not require Audio information, need to set Audio.Remove to true.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: Optional[pulumi.Input['MediaConcatTemplateConcatTemplateAudioArgs']]):
        pulumi.set(self, "audio", value)

    @property
    @pulumi.getter(name="audioMixes")
    def audio_mixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixArgs']]]]:
        """
        mixing parameters.
        """
        return pulumi.get(self, "audio_mixes")

    @audio_mixes.setter
    def audio_mixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixArgs']]]]):
        pulumi.set(self, "audio_mixes", value)

    @property
    @pulumi.getter
    def video(self) -> Optional[pulumi.Input['MediaConcatTemplateConcatTemplateVideoArgs']]:
        """
        video information, do not upload Video, which is equivalent to deleting video information.
        """
        return pulumi.get(self, "video")

    @video.setter
    def video(self, value: Optional[pulumi.Input['MediaConcatTemplateConcatTemplateVideoArgs']]):
        pulumi.set(self, "video", value)


@pulumi.input_type
class MediaConcatTemplateConcatTemplateAudioArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 bitrate: Optional[pulumi.Input[str]] = None,
                 channels: Optional[pulumi.Input[str]] = None,
                 samplerate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: Codec format, value aac, mp3.
        :param pulumi.Input[str] bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param pulumi.Input[str] channels: number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        :param pulumi.Input[str] samplerate: Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Codec format, value aac, mp3.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[str]]:
        """
        number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[pulumi.Input[str]]:
        """
        Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        return pulumi.get(self, "samplerate")

    @samplerate.setter
    def samplerate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samplerate", value)


@pulumi.input_type
class MediaConcatTemplateConcatTemplateAudioMixArgs:
    def __init__(__self__, *,
                 audio_source: pulumi.Input[str],
                 effect_config: Optional[pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixEffectConfigArgs']] = None,
                 mix_mode: Optional[pulumi.Input[str]] = None,
                 replace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] audio_source: The media address of the audio track that needs to be mixed.
        :param pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixEffectConfigArgs'] effect_config: Mix Fade Configuration.
        :param pulumi.Input[str] mix_mode: Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        :param pulumi.Input[str] replace: Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        pulumi.set(__self__, "audio_source", audio_source)
        if effect_config is not None:
            pulumi.set(__self__, "effect_config", effect_config)
        if mix_mode is not None:
            pulumi.set(__self__, "mix_mode", mix_mode)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="audioSource")
    def audio_source(self) -> pulumi.Input[str]:
        """
        The media address of the audio track that needs to be mixed.
        """
        return pulumi.get(self, "audio_source")

    @audio_source.setter
    def audio_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "audio_source", value)

    @property
    @pulumi.getter(name="effectConfig")
    def effect_config(self) -> Optional[pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixEffectConfigArgs']]:
        """
        Mix Fade Configuration.
        """
        return pulumi.get(self, "effect_config")

    @effect_config.setter
    def effect_config(self, value: Optional[pulumi.Input['MediaConcatTemplateConcatTemplateAudioMixEffectConfigArgs']]):
        pulumi.set(self, "effect_config", value)

    @property
    @pulumi.getter(name="mixMode")
    def mix_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        """
        return pulumi.get(self, "mix_mode")

    @mix_mode.setter
    def mix_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mix_mode", value)

    @property
    @pulumi.getter
    def replace(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace", value)


@pulumi.input_type
class MediaConcatTemplateConcatTemplateAudioMixEffectConfigArgs:
    def __init__(__self__, *,
                 bgm_fade_time: Optional[pulumi.Input[str]] = None,
                 enable_bgm_fade: Optional[pulumi.Input[str]] = None,
                 enable_end_fadeout: Optional[pulumi.Input[str]] = None,
                 enable_start_fadein: Optional[pulumi.Input[str]] = None,
                 end_fadeout_time: Optional[pulumi.Input[str]] = None,
                 start_fadein_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bgm_fade_time: bgm transition fade-in duration, support floating point numbers.
        :param pulumi.Input[str] enable_bgm_fade: Enable bgm conversion fade in.
        :param pulumi.Input[str] enable_end_fadeout: enable fade out.
        :param pulumi.Input[str] enable_start_fadein: enable fade in.
        :param pulumi.Input[str] end_fadeout_time: fade out time, greater than 0, support floating point numbers.
        :param pulumi.Input[str] start_fadein_time: Fade in duration, greater than 0, support floating point numbers.
        """
        if bgm_fade_time is not None:
            pulumi.set(__self__, "bgm_fade_time", bgm_fade_time)
        if enable_bgm_fade is not None:
            pulumi.set(__self__, "enable_bgm_fade", enable_bgm_fade)
        if enable_end_fadeout is not None:
            pulumi.set(__self__, "enable_end_fadeout", enable_end_fadeout)
        if enable_start_fadein is not None:
            pulumi.set(__self__, "enable_start_fadein", enable_start_fadein)
        if end_fadeout_time is not None:
            pulumi.set(__self__, "end_fadeout_time", end_fadeout_time)
        if start_fadein_time is not None:
            pulumi.set(__self__, "start_fadein_time", start_fadein_time)

    @property
    @pulumi.getter(name="bgmFadeTime")
    def bgm_fade_time(self) -> Optional[pulumi.Input[str]]:
        """
        bgm transition fade-in duration, support floating point numbers.
        """
        return pulumi.get(self, "bgm_fade_time")

    @bgm_fade_time.setter
    def bgm_fade_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgm_fade_time", value)

    @property
    @pulumi.getter(name="enableBgmFade")
    def enable_bgm_fade(self) -> Optional[pulumi.Input[str]]:
        """
        Enable bgm conversion fade in.
        """
        return pulumi.get(self, "enable_bgm_fade")

    @enable_bgm_fade.setter
    def enable_bgm_fade(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_bgm_fade", value)

    @property
    @pulumi.getter(name="enableEndFadeout")
    def enable_end_fadeout(self) -> Optional[pulumi.Input[str]]:
        """
        enable fade out.
        """
        return pulumi.get(self, "enable_end_fadeout")

    @enable_end_fadeout.setter
    def enable_end_fadeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_end_fadeout", value)

    @property
    @pulumi.getter(name="enableStartFadein")
    def enable_start_fadein(self) -> Optional[pulumi.Input[str]]:
        """
        enable fade in.
        """
        return pulumi.get(self, "enable_start_fadein")

    @enable_start_fadein.setter
    def enable_start_fadein(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_start_fadein", value)

    @property
    @pulumi.getter(name="endFadeoutTime")
    def end_fadeout_time(self) -> Optional[pulumi.Input[str]]:
        """
        fade out time, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "end_fadeout_time")

    @end_fadeout_time.setter
    def end_fadeout_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_fadeout_time", value)

    @property
    @pulumi.getter(name="startFadeinTime")
    def start_fadein_time(self) -> Optional[pulumi.Input[str]]:
        """
        Fade in duration, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "start_fadein_time")

    @start_fadein_time.setter
    def start_fadein_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_fadein_time", value)


@pulumi.input_type
class MediaConcatTemplateConcatTemplateConcatFragmentArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mode: node type, `start`, `end`.
        :param pulumi.Input[str] url: Splicing object address.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        node type, `start`, `end`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Splicing object address.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class MediaConcatTemplateConcatTemplateContainerArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str]):
        """
        :param pulumi.Input[str] format: Container format: mp4, flv, hls, ts, mp3, aac.
        """
        pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Container format: mp4, flv, hls, ts, mp3, aac.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)


@pulumi.input_type
class MediaConcatTemplateConcatTemplateVideoArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 bitrate: Optional[pulumi.Input[str]] = None,
                 crf: Optional[pulumi.Input[str]] = None,
                 fps: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[str]] = None,
                 rotate: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: Codec format `H.264`.
        :param pulumi.Input[str] bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param pulumi.Input[str] crf: Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        :param pulumi.Input[str] fps: Frame rate, value range: (0, 60], Unit: fps.
        :param pulumi.Input[str] height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param pulumi.Input[str] remove: Whether to delete the source audio stream, the value is true, false.
        :param pulumi.Input[str] rotate: Rotation angle, Value range: [0, 360), Unit: degree.
        :param pulumi.Input[str] width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if crf is not None:
            pulumi.set(__self__, "crf", crf)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rotate is not None:
            pulumi.set(__self__, "rotate", rotate)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Codec format `H.264`.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def crf(self) -> Optional[pulumi.Input[str]]:
        """
        Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        """
        return pulumi.get(self, "crf")

    @crf.setter
    def crf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "crf", value)

    @property
    @pulumi.getter
    def fps(self) -> Optional[pulumi.Input[str]]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def rotate(self) -> Optional[pulumi.Input[str]]:
        """
        Rotation angle, Value range: [0, 360), Unit: degree.
        """
        return pulumi.get(self, "rotate")

    @rotate.setter
    def rotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rotate", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaPicProcessTemplatePicProcessArgs:
    def __init__(__self__, *,
                 process_rule: pulumi.Input[str],
                 is_pic_info: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] process_rule: Image processing rules, 1: basic image processing, please refer to the basic image processing document, 2: image compression, please refer to the image compression document, 3: blind watermark, please refer to the blind watermark document.
        :param pulumi.Input[str] is_pic_info: Whether to return the original image information.
        """
        pulumi.set(__self__, "process_rule", process_rule)
        if is_pic_info is not None:
            pulumi.set(__self__, "is_pic_info", is_pic_info)

    @property
    @pulumi.getter(name="processRule")
    def process_rule(self) -> pulumi.Input[str]:
        """
        Image processing rules, 1: basic image processing, please refer to the basic image processing document, 2: image compression, please refer to the image compression document, 3: blind watermark, please refer to the blind watermark document.
        """
        return pulumi.get(self, "process_rule")

    @process_rule.setter
    def process_rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "process_rule", value)

    @property
    @pulumi.getter(name="isPicInfo")
    def is_pic_info(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to return the original image information.
        """
        return pulumi.get(self, "is_pic_info")

    @is_pic_info.setter
    def is_pic_info(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_pic_info", value)


@pulumi.input_type
class MediaSmartCoverTemplateSmartCoverArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 count: Optional[pulumi.Input[str]] = None,
                 delete_duplicates: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] format: Image Format, value jpg, png, webp.
        :param pulumi.Input[str] count: Number of screenshots, [1,10].
        :param pulumi.Input[str] delete_duplicates: cover deduplication, true/false.
        :param pulumi.Input[str] height: Height, value range: [128, 4096], unit: px, if only Height is set, Width is calculated according to the original video ratio.
        :param pulumi.Input[str] width: Width, value range: [128, 4096], unit: px, if only Width is set, Height is calculated according to the original ratio of the video.
        """
        pulumi.set(__self__, "format", format)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if delete_duplicates is not None:
            pulumi.set(__self__, "delete_duplicates", delete_duplicates)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Image Format, value jpg, png, webp.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[str]]:
        """
        Number of screenshots, [1,10].
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="deleteDuplicates")
    def delete_duplicates(self) -> Optional[pulumi.Input[str]]:
        """
        cover deduplication, true/false.
        """
        return pulumi.get(self, "delete_duplicates")

    @delete_duplicates.setter
    def delete_duplicates(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_duplicates", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        Height, value range: [128, 4096], unit: px, if only Height is set, Width is calculated according to the original video ratio.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        Width, value range: [128, 4096], unit: px, if only Width is set, Height is calculated according to the original ratio of the video.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaSnapshotTemplateSnapshotArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[str],
                 black_level: Optional[pulumi.Input[str]] = None,
                 ci_param: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 is_check_black: Optional[pulumi.Input[str]] = None,
                 is_check_count: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 pixel_black_threshold: Optional[pulumi.Input[str]] = None,
                 snapshot_out_mode: Optional[pulumi.Input[str]] = None,
                 sprite_snapshot_config: Optional[pulumi.Input['MediaSnapshotTemplateSnapshotSpriteSnapshotConfigArgs']] = None,
                 start: Optional[pulumi.Input[str]] = None,
                 time_interval: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] count: Number of screenshots, range (0 10000].
        :param pulumi.Input[str] black_level: Screenshot black screen detection parameters, Valid when IsCheckBlack=true, Value reference range [30, 100], indicating the proportion of black pixels, the smaller the value, the smaller the proportion of black pixels, Start&gt;0, the parameter setting is invalid, no filter black screen, Start =0 parameter is valid, the start time of the frame capture is the first frame non-black screen start.
        :param pulumi.Input[str] ci_param: Screenshot image processing parameters, for example: imageMogr2/format/png.
        :param pulumi.Input[str] height: high, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video.
        :param pulumi.Input[str] is_check_black: Whether to enable black screen detection true/false.
        :param pulumi.Input[str] is_check_count: Whether to check the number of screenshots forcibly, when using custom interval mode to take screenshots, the video time is not long enough to capture Count screenshots, you can switch to average screenshot mode to capture Count screenshots.
        :param pulumi.Input[str] mode: Screenshot mode, value range: {Interval, Average, KeyFrame}- Interval means interval mode Average means average mode- KeyFrame represents the key frame mode- Interval mode: Start, TimeInterval, The Count parameter takes effect. When Count is set and TimeInterval is not set, Indicates to capture all frames, a total of Count pictures- Average mode: Start, the Count parameter takes effect. express.
        :param pulumi.Input[str] pixel_black_threshold: Screenshot black screen detection parameters, Valid when IsCheckBlack=true, The threshold for judging whether a pixel is a black point, value range: [0, 255].
        :param pulumi.Input[str] snapshot_out_mode: Screenshot output mode parameters, Value range: {OnlySnapshot, OnlySprite, SnapshotAndSprite}, OnlySnapshot means output only screenshot mode OnlySprite means only output sprite mode SnapshotAndSprite means output screenshot and sprite mode.
        :param pulumi.Input['MediaSnapshotTemplateSnapshotSpriteSnapshotConfigArgs'] sprite_snapshot_config: Screenshot output configuration.
        :param pulumi.Input[str] start: Starting time, [0 video duration] in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param pulumi.Input[str] time_interval: Screenshot time interval, (0 3600], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param pulumi.Input[str] width: wide, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video.
        """
        pulumi.set(__self__, "count", count)
        if black_level is not None:
            pulumi.set(__self__, "black_level", black_level)
        if ci_param is not None:
            pulumi.set(__self__, "ci_param", ci_param)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if is_check_black is not None:
            pulumi.set(__self__, "is_check_black", is_check_black)
        if is_check_count is not None:
            pulumi.set(__self__, "is_check_count", is_check_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pixel_black_threshold is not None:
            pulumi.set(__self__, "pixel_black_threshold", pixel_black_threshold)
        if snapshot_out_mode is not None:
            pulumi.set(__self__, "snapshot_out_mode", snapshot_out_mode)
        if sprite_snapshot_config is not None:
            pulumi.set(__self__, "sprite_snapshot_config", sprite_snapshot_config)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[str]:
        """
        Number of screenshots, range (0 10000].
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[str]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="blackLevel")
    def black_level(self) -> Optional[pulumi.Input[str]]:
        """
        Screenshot black screen detection parameters, Valid when IsCheckBlack=true, Value reference range [30, 100], indicating the proportion of black pixels, the smaller the value, the smaller the proportion of black pixels, Start&gt;0, the parameter setting is invalid, no filter black screen, Start =0 parameter is valid, the start time of the frame capture is the first frame non-black screen start.
        """
        return pulumi.get(self, "black_level")

    @black_level.setter
    def black_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "black_level", value)

    @property
    @pulumi.getter(name="ciParam")
    def ci_param(self) -> Optional[pulumi.Input[str]]:
        """
        Screenshot image processing parameters, for example: imageMogr2/format/png.
        """
        return pulumi.get(self, "ci_param")

    @ci_param.setter
    def ci_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ci_param", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        high, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="isCheckBlack")
    def is_check_black(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable black screen detection true/false.
        """
        return pulumi.get(self, "is_check_black")

    @is_check_black.setter
    def is_check_black(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_black", value)

    @property
    @pulumi.getter(name="isCheckCount")
    def is_check_count(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to check the number of screenshots forcibly, when using custom interval mode to take screenshots, the video time is not long enough to capture Count screenshots, you can switch to average screenshot mode to capture Count screenshots.
        """
        return pulumi.get(self, "is_check_count")

    @is_check_count.setter
    def is_check_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_count", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Screenshot mode, value range: {Interval, Average, KeyFrame}- Interval means interval mode Average means average mode- KeyFrame represents the key frame mode- Interval mode: Start, TimeInterval, The Count parameter takes effect. When Count is set and TimeInterval is not set, Indicates to capture all frames, a total of Count pictures- Average mode: Start, the Count parameter takes effect. express.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="pixelBlackThreshold")
    def pixel_black_threshold(self) -> Optional[pulumi.Input[str]]:
        """
        Screenshot black screen detection parameters, Valid when IsCheckBlack=true, The threshold for judging whether a pixel is a black point, value range: [0, 255].
        """
        return pulumi.get(self, "pixel_black_threshold")

    @pixel_black_threshold.setter
    def pixel_black_threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pixel_black_threshold", value)

    @property
    @pulumi.getter(name="snapshotOutMode")
    def snapshot_out_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Screenshot output mode parameters, Value range: {OnlySnapshot, OnlySprite, SnapshotAndSprite}, OnlySnapshot means output only screenshot mode OnlySprite means only output sprite mode SnapshotAndSprite means output screenshot and sprite mode.
        """
        return pulumi.get(self, "snapshot_out_mode")

    @snapshot_out_mode.setter
    def snapshot_out_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_out_mode", value)

    @property
    @pulumi.getter(name="spriteSnapshotConfig")
    def sprite_snapshot_config(self) -> Optional[pulumi.Input['MediaSnapshotTemplateSnapshotSpriteSnapshotConfigArgs']]:
        """
        Screenshot output configuration.
        """
        return pulumi.get(self, "sprite_snapshot_config")

    @sprite_snapshot_config.setter
    def sprite_snapshot_config(self, value: Optional[pulumi.Input['MediaSnapshotTemplateSnapshotSpriteSnapshotConfigArgs']]):
        pulumi.set(self, "sprite_snapshot_config", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Starting time, [0 video duration] in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Screenshot time interval, (0 3600], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_interval", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        wide, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaSnapshotTemplateSnapshotSpriteSnapshotConfigArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 columns: pulumi.Input[str],
                 lines: pulumi.Input[str],
                 cell_height: Optional[pulumi.Input[str]] = None,
                 cell_width: Optional[pulumi.Input[str]] = None,
                 margin: Optional[pulumi.Input[str]] = None,
                 padding: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color: See `https://www.ffmpeg.org/ffmpeg-utils.html#color-syntax` for details on supported colors.
        :param pulumi.Input[str] columns: Number of screenshot columns, value range: [1, 10000].
        :param pulumi.Input[str] lines: Number of screenshot lines, value range: [1, 10000].
        :param pulumi.Input[str] cell_height: Single image height Value range: [8, 4096], Unit: px.
        :param pulumi.Input[str] cell_width: Single image width Value range: [8, 4096], Unit: px.
        :param pulumi.Input[str] margin: screenshot margin size, Value range: [8, 4096], Unit: px.
        :param pulumi.Input[str] padding: screenshot padding size, Value range: [8, 4096], Unit: px.
        """
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "lines", lines)
        if cell_height is not None:
            pulumi.set(__self__, "cell_height", cell_height)
        if cell_width is not None:
            pulumi.set(__self__, "cell_width", cell_width)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        See `https://www.ffmpeg.org/ffmpeg-utils.html#color-syntax` for details on supported colors.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[str]:
        """
        Number of screenshot columns, value range: [1, 10000].
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[str]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def lines(self) -> pulumi.Input[str]:
        """
        Number of screenshot lines, value range: [1, 10000].
        """
        return pulumi.get(self, "lines")

    @lines.setter
    def lines(self, value: pulumi.Input[str]):
        pulumi.set(self, "lines", value)

    @property
    @pulumi.getter(name="cellHeight")
    def cell_height(self) -> Optional[pulumi.Input[str]]:
        """
        Single image height Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "cell_height")

    @cell_height.setter
    def cell_height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_height", value)

    @property
    @pulumi.getter(name="cellWidth")
    def cell_width(self) -> Optional[pulumi.Input[str]]:
        """
        Single image width Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "cell_width")

    @cell_width.setter
    def cell_width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_width", value)

    @property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input[str]]:
        """
        screenshot margin size, Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "margin", value)

    @property
    @pulumi.getter
    def padding(self) -> Optional[pulumi.Input[str]]:
        """
        screenshot padding size, Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "padding")

    @padding.setter
    def padding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "padding", value)


@pulumi.input_type
class MediaSpeechRecognitionTemplateSpeechRecognitionArgs:
    def __init__(__self__, *,
                 channel_num: pulumi.Input[str],
                 engine_model_type: pulumi.Input[str],
                 convert_num_mode: Optional[pulumi.Input[str]] = None,
                 filter_dirty: Optional[pulumi.Input[str]] = None,
                 filter_modal: Optional[pulumi.Input[str]] = None,
                 filter_punc: Optional[pulumi.Input[str]] = None,
                 output_file_type: Optional[pulumi.Input[str]] = None,
                 res_text_format: Optional[pulumi.Input[str]] = None,
                 speaker_diarization: Optional[pulumi.Input[str]] = None,
                 speaker_number: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] channel_num: Number of voice channels: 1 means mono. EngineModelType supports only mono for non-telephone scenarios, and 2 means dual channels (only 8k_zh engine model supports dual channels, which should correspond to both sides of the call).
        :param pulumi.Input[str] engine_model_type: Engine model type, divided into phone scene and non-phone scene, phone scene: 8k_zh: phone 8k Chinese Mandarin general (can be used for dual-channel audio), 8k_zh_s: phone 8k Chinese Mandarin speaker separation (only for monophonic audio), 8k_en: Telephone 8k English; non-telephone scene: 16k_zh: 16k Mandarin Chinese, 16k_zh_video: 16k audio and video field, 16k_en: 16k English, 16k_ca: 16k Cantonese, 16k_ja: 16k Japanese, 16k_zh_edu: Chinese education, 16k_en_edu: English education, 16k_zh_medical: medical, 16k_th: Thai, 16k_zh_dialect: multi-dialect, supports 23 dialects.
        :param pulumi.Input[str] convert_num_mode: Whether to perform intelligent conversion of Arabic numerals (currently supports Mandarin Chinese engine): 0 means no conversion, directly output Chinese numbers, 1 means intelligently convert to Arabic numerals according to the scene, 3 means enable math-related digital conversion, the default value is 0.
        :param pulumi.Input[str] filter_dirty: Whether to filter dirty words (currently supports Mandarin Chinese engine): 0 means not to filter dirty words, 1 means to filter dirty words, 2 means to replace dirty words with *, the default value is 0.
        :param pulumi.Input[str] filter_modal: Whether to pass modal particles (currently supports Mandarin Chinese engine): 0 means not to filter modal particles, 1 means partial filtering, 2 means strict filtering, and the default value is 0.
        :param pulumi.Input[str] filter_punc: Whether to filter punctuation (currently supports Mandarin Chinese engine): 0 means no filtering, 1 means filtering end-of-sentence punctuation, 2 means filtering all punctuation, the default value is 0.
        :param pulumi.Input[str] output_file_type: Output file type, optional txt, srt. The default is txt.
        :param pulumi.Input[str] res_text_format: Recognition result return form: 0 means the recognition result text (including segmented time stamps), 1 is the detailed recognition result at the word level granularity, without punctuation, and includes the speech rate value (a list of word time stamps, generally used to generate subtitle scenes), 2 Detailed recognition results at word-level granularity (including punctuation and speech rate values)..
        :param pulumi.Input[str] speaker_diarization: Whether to enable speaker separation: 0 means not enabled, 1 means enabled (only supports 8k_zh, 16k_zh, 16k_zh_video, monophonic audio), the default value is 0, Note: 8K telephony scenarios suggest using dual-channel to distinguish between the two parties, set ChannelNum=2 is enough, no need to enable speaker separation.
        :param pulumi.Input[str] speaker_number: The number of speakers to be separated (need to be used in conjunction with enabling speaker separation), value range: 0-10, 0 means automatic separation (currently only supports <= 6 people), 1-10 represents the number of specified speakers to be separated. The default value is 0.
        """
        pulumi.set(__self__, "channel_num", channel_num)
        pulumi.set(__self__, "engine_model_type", engine_model_type)
        if convert_num_mode is not None:
            pulumi.set(__self__, "convert_num_mode", convert_num_mode)
        if filter_dirty is not None:
            pulumi.set(__self__, "filter_dirty", filter_dirty)
        if filter_modal is not None:
            pulumi.set(__self__, "filter_modal", filter_modal)
        if filter_punc is not None:
            pulumi.set(__self__, "filter_punc", filter_punc)
        if output_file_type is not None:
            pulumi.set(__self__, "output_file_type", output_file_type)
        if res_text_format is not None:
            pulumi.set(__self__, "res_text_format", res_text_format)
        if speaker_diarization is not None:
            pulumi.set(__self__, "speaker_diarization", speaker_diarization)
        if speaker_number is not None:
            pulumi.set(__self__, "speaker_number", speaker_number)

    @property
    @pulumi.getter(name="channelNum")
    def channel_num(self) -> pulumi.Input[str]:
        """
        Number of voice channels: 1 means mono. EngineModelType supports only mono for non-telephone scenarios, and 2 means dual channels (only 8k_zh engine model supports dual channels, which should correspond to both sides of the call).
        """
        return pulumi.get(self, "channel_num")

    @channel_num.setter
    def channel_num(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel_num", value)

    @property
    @pulumi.getter(name="engineModelType")
    def engine_model_type(self) -> pulumi.Input[str]:
        """
        Engine model type, divided into phone scene and non-phone scene, phone scene: 8k_zh: phone 8k Chinese Mandarin general (can be used for dual-channel audio), 8k_zh_s: phone 8k Chinese Mandarin speaker separation (only for monophonic audio), 8k_en: Telephone 8k English; non-telephone scene: 16k_zh: 16k Mandarin Chinese, 16k_zh_video: 16k audio and video field, 16k_en: 16k English, 16k_ca: 16k Cantonese, 16k_ja: 16k Japanese, 16k_zh_edu: Chinese education, 16k_en_edu: English education, 16k_zh_medical: medical, 16k_th: Thai, 16k_zh_dialect: multi-dialect, supports 23 dialects.
        """
        return pulumi.get(self, "engine_model_type")

    @engine_model_type.setter
    def engine_model_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "engine_model_type", value)

    @property
    @pulumi.getter(name="convertNumMode")
    def convert_num_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to perform intelligent conversion of Arabic numerals (currently supports Mandarin Chinese engine): 0 means no conversion, directly output Chinese numbers, 1 means intelligently convert to Arabic numerals according to the scene, 3 means enable math-related digital conversion, the default value is 0.
        """
        return pulumi.get(self, "convert_num_mode")

    @convert_num_mode.setter
    def convert_num_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "convert_num_mode", value)

    @property
    @pulumi.getter(name="filterDirty")
    def filter_dirty(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to filter dirty words (currently supports Mandarin Chinese engine): 0 means not to filter dirty words, 1 means to filter dirty words, 2 means to replace dirty words with *, the default value is 0.
        """
        return pulumi.get(self, "filter_dirty")

    @filter_dirty.setter
    def filter_dirty(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_dirty", value)

    @property
    @pulumi.getter(name="filterModal")
    def filter_modal(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to pass modal particles (currently supports Mandarin Chinese engine): 0 means not to filter modal particles, 1 means partial filtering, 2 means strict filtering, and the default value is 0.
        """
        return pulumi.get(self, "filter_modal")

    @filter_modal.setter
    def filter_modal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_modal", value)

    @property
    @pulumi.getter(name="filterPunc")
    def filter_punc(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to filter punctuation (currently supports Mandarin Chinese engine): 0 means no filtering, 1 means filtering end-of-sentence punctuation, 2 means filtering all punctuation, the default value is 0.
        """
        return pulumi.get(self, "filter_punc")

    @filter_punc.setter
    def filter_punc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_punc", value)

    @property
    @pulumi.getter(name="outputFileType")
    def output_file_type(self) -> Optional[pulumi.Input[str]]:
        """
        Output file type, optional txt, srt. The default is txt.
        """
        return pulumi.get(self, "output_file_type")

    @output_file_type.setter
    def output_file_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_file_type", value)

    @property
    @pulumi.getter(name="resTextFormat")
    def res_text_format(self) -> Optional[pulumi.Input[str]]:
        """
        Recognition result return form: 0 means the recognition result text (including segmented time stamps), 1 is the detailed recognition result at the word level granularity, without punctuation, and includes the speech rate value (a list of word time stamps, generally used to generate subtitle scenes), 2 Detailed recognition results at word-level granularity (including punctuation and speech rate values)..
        """
        return pulumi.get(self, "res_text_format")

    @res_text_format.setter
    def res_text_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "res_text_format", value)

    @property
    @pulumi.getter(name="speakerDiarization")
    def speaker_diarization(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable speaker separation: 0 means not enabled, 1 means enabled (only supports 8k_zh, 16k_zh, 16k_zh_video, monophonic audio), the default value is 0, Note: 8K telephony scenarios suggest using dual-channel to distinguish between the two parties, set ChannelNum=2 is enough, no need to enable speaker separation.
        """
        return pulumi.get(self, "speaker_diarization")

    @speaker_diarization.setter
    def speaker_diarization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speaker_diarization", value)

    @property
    @pulumi.getter(name="speakerNumber")
    def speaker_number(self) -> Optional[pulumi.Input[str]]:
        """
        The number of speakers to be separated (need to be used in conjunction with enabling speaker separation), value range: 0-10, 0 means automatic separation (currently only supports <= 6 people), 1-10 represents the number of specified speakers to be separated. The default value is 0.
        """
        return pulumi.get(self, "speaker_number")

    @speaker_number.setter
    def speaker_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speaker_number", value)


@pulumi.input_type
class MediaTranscodeProTemplateAudioArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 remove: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        :param pulumi.Input[str] remove: Whether to delete the source audio stream, the value is true, false.
        """
        pulumi.set(__self__, "codec", codec)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remove", value)


@pulumi.input_type
class MediaTranscodeProTemplateContainerArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 clip_config: Optional[pulumi.Input['MediaTranscodeProTemplateContainerClipConfigArgs']] = None):
        """
        :param pulumi.Input[str] format: Package format.
        :param pulumi.Input['MediaTranscodeProTemplateContainerClipConfigArgs'] clip_config: Fragment configuration, valid when format is hls and dash.
        """
        pulumi.set(__self__, "format", format)
        if clip_config is not None:
            pulumi.set(__self__, "clip_config", clip_config)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Package format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="clipConfig")
    def clip_config(self) -> Optional[pulumi.Input['MediaTranscodeProTemplateContainerClipConfigArgs']]:
        """
        Fragment configuration, valid when format is hls and dash.
        """
        return pulumi.get(self, "clip_config")

    @clip_config.setter
    def clip_config(self, value: Optional[pulumi.Input['MediaTranscodeProTemplateContainerClipConfigArgs']]):
        pulumi.set(self, "clip_config", value)


@pulumi.input_type
class MediaTranscodeProTemplateContainerClipConfigArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] duration: Fragmentation duration, default 5s.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Fragmentation duration, default 5s.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)


@pulumi.input_type
class MediaTranscodeProTemplateTimeIntervalArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] duration: duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param pulumi.Input[str] start: Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class MediaTranscodeProTemplateTransConfigArgs:
    def __init__(__self__, *,
                 adj_dar_method: Optional[pulumi.Input[str]] = None,
                 audio_bitrate_adj_method: Optional[pulumi.Input[str]] = None,
                 delete_metadata: Optional[pulumi.Input[str]] = None,
                 is_check_audio_bitrate: Optional[pulumi.Input[str]] = None,
                 is_check_reso: Optional[pulumi.Input[str]] = None,
                 is_check_video_bitrate: Optional[pulumi.Input[str]] = None,
                 is_hdr2_sdr: Optional[pulumi.Input[str]] = None,
                 reso_adj_method: Optional[pulumi.Input[str]] = None,
                 video_bitrate_adj_method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] adj_dar_method: Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        :param pulumi.Input[str] audio_bitrate_adj_method: Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        :param pulumi.Input[str] delete_metadata: Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        :param pulumi.Input[str] is_check_audio_bitrate: Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        :param pulumi.Input[str] is_check_reso: Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        :param pulumi.Input[str] is_check_video_bitrate: Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        :param pulumi.Input[str] is_hdr2_sdr: Whether to enable HDR to SDR true, false.
        :param pulumi.Input[str] reso_adj_method: Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        :param pulumi.Input[str] video_bitrate_adj_method: Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        if adj_dar_method is not None:
            pulumi.set(__self__, "adj_dar_method", adj_dar_method)
        if audio_bitrate_adj_method is not None:
            pulumi.set(__self__, "audio_bitrate_adj_method", audio_bitrate_adj_method)
        if delete_metadata is not None:
            pulumi.set(__self__, "delete_metadata", delete_metadata)
        if is_check_audio_bitrate is not None:
            pulumi.set(__self__, "is_check_audio_bitrate", is_check_audio_bitrate)
        if is_check_reso is not None:
            pulumi.set(__self__, "is_check_reso", is_check_reso)
        if is_check_video_bitrate is not None:
            pulumi.set(__self__, "is_check_video_bitrate", is_check_video_bitrate)
        if is_hdr2_sdr is not None:
            pulumi.set(__self__, "is_hdr2_sdr", is_hdr2_sdr)
        if reso_adj_method is not None:
            pulumi.set(__self__, "reso_adj_method", reso_adj_method)
        if video_bitrate_adj_method is not None:
            pulumi.set(__self__, "video_bitrate_adj_method", video_bitrate_adj_method)

    @property
    @pulumi.getter(name="adjDarMethod")
    def adj_dar_method(self) -> Optional[pulumi.Input[str]]:
        """
        Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        """
        return pulumi.get(self, "adj_dar_method")

    @adj_dar_method.setter
    def adj_dar_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adj_dar_method", value)

    @property
    @pulumi.getter(name="audioBitrateAdjMethod")
    def audio_bitrate_adj_method(self) -> Optional[pulumi.Input[str]]:
        """
        Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        """
        return pulumi.get(self, "audio_bitrate_adj_method")

    @audio_bitrate_adj_method.setter
    def audio_bitrate_adj_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_bitrate_adj_method", value)

    @property
    @pulumi.getter(name="deleteMetadata")
    def delete_metadata(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        """
        return pulumi.get(self, "delete_metadata")

    @delete_metadata.setter
    def delete_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_metadata", value)

    @property
    @pulumi.getter(name="isCheckAudioBitrate")
    def is_check_audio_bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        """
        return pulumi.get(self, "is_check_audio_bitrate")

    @is_check_audio_bitrate.setter
    def is_check_audio_bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_audio_bitrate", value)

    @property
    @pulumi.getter(name="isCheckReso")
    def is_check_reso(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_reso")

    @is_check_reso.setter
    def is_check_reso(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_reso", value)

    @property
    @pulumi.getter(name="isCheckVideoBitrate")
    def is_check_video_bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_video_bitrate")

    @is_check_video_bitrate.setter
    def is_check_video_bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_video_bitrate", value)

    @property
    @pulumi.getter(name="isHdr2Sdr")
    def is_hdr2_sdr(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable HDR to SDR true, false.
        """
        return pulumi.get(self, "is_hdr2_sdr")

    @is_hdr2_sdr.setter
    def is_hdr2_sdr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_hdr2_sdr", value)

    @property
    @pulumi.getter(name="resoAdjMethod")
    def reso_adj_method(self) -> Optional[pulumi.Input[str]]:
        """
        Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        """
        return pulumi.get(self, "reso_adj_method")

    @reso_adj_method.setter
    def reso_adj_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reso_adj_method", value)

    @property
    @pulumi.getter(name="videoBitrateAdjMethod")
    def video_bitrate_adj_method(self) -> Optional[pulumi.Input[str]]:
        """
        Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        return pulumi.get(self, "video_bitrate_adj_method")

    @video_bitrate_adj_method.setter
    def video_bitrate_adj_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "video_bitrate_adj_method", value)


@pulumi.input_type
class MediaTranscodeProTemplateVideoArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[str]] = None,
                 codec: Optional[pulumi.Input[str]] = None,
                 fps: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 interlaced: Optional[pulumi.Input[str]] = None,
                 profile: Optional[pulumi.Input[str]] = None,
                 rotate: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bitrate: Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        :param pulumi.Input[str] codec: Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        :param pulumi.Input[str] fps: Frame rate, value range: (0, 60], Unit: fps.
        :param pulumi.Input[str] height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param pulumi.Input[str] interlaced: field pattern.
        :param pulumi.Input[str] profile: encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        :param pulumi.Input[str] rotate: Rotation angle, Value range: [0, 360), Unit: degree.
        :param pulumi.Input[str] width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if interlaced is not None:
            pulumi.set(__self__, "interlaced", interlaced)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if rotate is not None:
            pulumi.set(__self__, "rotate", rotate)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def fps(self) -> Optional[pulumi.Input[str]]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def interlaced(self) -> Optional[pulumi.Input[str]]:
        """
        field pattern.
        """
        return pulumi.get(self, "interlaced")

    @interlaced.setter
    def interlaced(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interlaced", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[str]]:
        """
        encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile", value)

    @property
    @pulumi.getter
    def rotate(self) -> Optional[pulumi.Input[str]]:
        """
        Rotation angle, Value range: [0, 360), Unit: degree.
        """
        return pulumi.get(self, "rotate")

    @rotate.setter
    def rotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rotate", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaTranscodeTemplateAudioArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[str]] = None,
                 channels: Optional[pulumi.Input[str]] = None,
                 codec: Optional[pulumi.Input[str]] = None,
                 keep_two_tracks: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[str]] = None,
                 sample_format: Optional[pulumi.Input[str]] = None,
                 samplerate: Optional[pulumi.Input[str]] = None,
                 switch_track: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param pulumi.Input[str] channels: number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3/opus, support 1, 2- When Codec is set to Vorbis, only 2 is supported- When Codec is set to amr, only 1 is supported- When Codec is set to pcm_s16le, only 1 and 2 are supported- When the encapsulation format is dash, 8 is not supported.
        :param pulumi.Input[str] codec: Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        :param pulumi.Input[str] keep_two_tracks: Keep dual audio tracks, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        :param pulumi.Input[str] remove: Whether to delete the source audio stream, the value is true, false.
        :param pulumi.Input[str] sample_format: Sampling bit width- When Codec is set to aac, support fltp- When Codec is set to mp3, fltp, s16p, s32p are supported- When Codec is set to flac, s16, s32, s16p, s32p are supported- When Codec is set to amr, support s16, s16p- When Codec is set to opus, support s16- When Codec is set to pcm_s16le, support s16- When Codec is set to Vorbis, support fltp- This parameter is invalid when Video.Codec is H.265.
        :param pulumi.Input[str] samplerate: Sampling Rate- Unit: Hz- Optional 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below- When Codec is set to amr, only 8000 is supported- When Codec is set to opus, it supports 8000, 16000, 24000, 48000.
        :param pulumi.Input[str] switch_track: Convert track, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if keep_two_tracks is not None:
            pulumi.set(__self__, "keep_two_tracks", keep_two_tracks)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if sample_format is not None:
            pulumi.set(__self__, "sample_format", sample_format)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)
        if switch_track is not None:
            pulumi.set(__self__, "switch_track", switch_track)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[str]]:
        """
        number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3/opus, support 1, 2- When Codec is set to Vorbis, only 2 is supported- When Codec is set to amr, only 1 is supported- When Codec is set to pcm_s16le, only 1 and 2 are supported- When the encapsulation format is dash, 8 is not supported.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="keepTwoTracks")
    def keep_two_tracks(self) -> Optional[pulumi.Input[str]]:
        """
        Keep dual audio tracks, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        """
        return pulumi.get(self, "keep_two_tracks")

    @keep_two_tracks.setter
    def keep_two_tracks(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_two_tracks", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter(name="sampleFormat")
    def sample_format(self) -> Optional[pulumi.Input[str]]:
        """
        Sampling bit width- When Codec is set to aac, support fltp- When Codec is set to mp3, fltp, s16p, s32p are supported- When Codec is set to flac, s16, s32, s16p, s32p are supported- When Codec is set to amr, support s16, s16p- When Codec is set to opus, support s16- When Codec is set to pcm_s16le, support s16- When Codec is set to Vorbis, support fltp- This parameter is invalid when Video.Codec is H.265.
        """
        return pulumi.get(self, "sample_format")

    @sample_format.setter
    def sample_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sample_format", value)

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[pulumi.Input[str]]:
        """
        Sampling Rate- Unit: Hz- Optional 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below- When Codec is set to amr, only 8000 is supported- When Codec is set to opus, it supports 8000, 16000, 24000, 48000.
        """
        return pulumi.get(self, "samplerate")

    @samplerate.setter
    def samplerate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samplerate", value)

    @property
    @pulumi.getter(name="switchTrack")
    def switch_track(self) -> Optional[pulumi.Input[str]]:
        """
        Convert track, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        """
        return pulumi.get(self, "switch_track")

    @switch_track.setter
    def switch_track(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch_track", value)


@pulumi.input_type
class MediaTranscodeTemplateAudioMixArgs:
    def __init__(__self__, *,
                 audio_source: pulumi.Input[str],
                 effect_config: Optional[pulumi.Input['MediaTranscodeTemplateAudioMixEffectConfigArgs']] = None,
                 mix_mode: Optional[pulumi.Input[str]] = None,
                 replace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] audio_source: The media address of the audio track that needs to be mixed.
        :param pulumi.Input['MediaTranscodeTemplateAudioMixEffectConfigArgs'] effect_config: Mix Fade Configuration.
        :param pulumi.Input[str] mix_mode: Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        :param pulumi.Input[str] replace: Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        pulumi.set(__self__, "audio_source", audio_source)
        if effect_config is not None:
            pulumi.set(__self__, "effect_config", effect_config)
        if mix_mode is not None:
            pulumi.set(__self__, "mix_mode", mix_mode)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="audioSource")
    def audio_source(self) -> pulumi.Input[str]:
        """
        The media address of the audio track that needs to be mixed.
        """
        return pulumi.get(self, "audio_source")

    @audio_source.setter
    def audio_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "audio_source", value)

    @property
    @pulumi.getter(name="effectConfig")
    def effect_config(self) -> Optional[pulumi.Input['MediaTranscodeTemplateAudioMixEffectConfigArgs']]:
        """
        Mix Fade Configuration.
        """
        return pulumi.get(self, "effect_config")

    @effect_config.setter
    def effect_config(self, value: Optional[pulumi.Input['MediaTranscodeTemplateAudioMixEffectConfigArgs']]):
        pulumi.set(self, "effect_config", value)

    @property
    @pulumi.getter(name="mixMode")
    def mix_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        """
        return pulumi.get(self, "mix_mode")

    @mix_mode.setter
    def mix_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mix_mode", value)

    @property
    @pulumi.getter
    def replace(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace", value)


@pulumi.input_type
class MediaTranscodeTemplateAudioMixEffectConfigArgs:
    def __init__(__self__, *,
                 bgm_fade_time: Optional[pulumi.Input[str]] = None,
                 enable_bgm_fade: Optional[pulumi.Input[str]] = None,
                 enable_end_fadeout: Optional[pulumi.Input[str]] = None,
                 enable_start_fadein: Optional[pulumi.Input[str]] = None,
                 end_fadeout_time: Optional[pulumi.Input[str]] = None,
                 start_fadein_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bgm_fade_time: bgm transition fade-in duration, support floating point numbers.
        :param pulumi.Input[str] enable_bgm_fade: Enable bgm conversion fade in.
        :param pulumi.Input[str] enable_end_fadeout: enable fade out.
        :param pulumi.Input[str] enable_start_fadein: enable fade in.
        :param pulumi.Input[str] end_fadeout_time: fade out time, greater than 0, support floating point numbers.
        :param pulumi.Input[str] start_fadein_time: Fade in duration, greater than 0, support floating point numbers.
        """
        if bgm_fade_time is not None:
            pulumi.set(__self__, "bgm_fade_time", bgm_fade_time)
        if enable_bgm_fade is not None:
            pulumi.set(__self__, "enable_bgm_fade", enable_bgm_fade)
        if enable_end_fadeout is not None:
            pulumi.set(__self__, "enable_end_fadeout", enable_end_fadeout)
        if enable_start_fadein is not None:
            pulumi.set(__self__, "enable_start_fadein", enable_start_fadein)
        if end_fadeout_time is not None:
            pulumi.set(__self__, "end_fadeout_time", end_fadeout_time)
        if start_fadein_time is not None:
            pulumi.set(__self__, "start_fadein_time", start_fadein_time)

    @property
    @pulumi.getter(name="bgmFadeTime")
    def bgm_fade_time(self) -> Optional[pulumi.Input[str]]:
        """
        bgm transition fade-in duration, support floating point numbers.
        """
        return pulumi.get(self, "bgm_fade_time")

    @bgm_fade_time.setter
    def bgm_fade_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgm_fade_time", value)

    @property
    @pulumi.getter(name="enableBgmFade")
    def enable_bgm_fade(self) -> Optional[pulumi.Input[str]]:
        """
        Enable bgm conversion fade in.
        """
        return pulumi.get(self, "enable_bgm_fade")

    @enable_bgm_fade.setter
    def enable_bgm_fade(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_bgm_fade", value)

    @property
    @pulumi.getter(name="enableEndFadeout")
    def enable_end_fadeout(self) -> Optional[pulumi.Input[str]]:
        """
        enable fade out.
        """
        return pulumi.get(self, "enable_end_fadeout")

    @enable_end_fadeout.setter
    def enable_end_fadeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_end_fadeout", value)

    @property
    @pulumi.getter(name="enableStartFadein")
    def enable_start_fadein(self) -> Optional[pulumi.Input[str]]:
        """
        enable fade in.
        """
        return pulumi.get(self, "enable_start_fadein")

    @enable_start_fadein.setter
    def enable_start_fadein(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_start_fadein", value)

    @property
    @pulumi.getter(name="endFadeoutTime")
    def end_fadeout_time(self) -> Optional[pulumi.Input[str]]:
        """
        fade out time, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "end_fadeout_time")

    @end_fadeout_time.setter
    def end_fadeout_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_fadeout_time", value)

    @property
    @pulumi.getter(name="startFadeinTime")
    def start_fadein_time(self) -> Optional[pulumi.Input[str]]:
        """
        Fade in duration, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "start_fadein_time")

    @start_fadein_time.setter
    def start_fadein_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_fadein_time", value)


@pulumi.input_type
class MediaTranscodeTemplateContainerArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 clip_config: Optional[pulumi.Input['MediaTranscodeTemplateContainerClipConfigArgs']] = None):
        """
        :param pulumi.Input[str] format: Package format.
        :param pulumi.Input['MediaTranscodeTemplateContainerClipConfigArgs'] clip_config: Fragment configuration, valid when format is hls and dash.
        """
        pulumi.set(__self__, "format", format)
        if clip_config is not None:
            pulumi.set(__self__, "clip_config", clip_config)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Package format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="clipConfig")
    def clip_config(self) -> Optional[pulumi.Input['MediaTranscodeTemplateContainerClipConfigArgs']]:
        """
        Fragment configuration, valid when format is hls and dash.
        """
        return pulumi.get(self, "clip_config")

    @clip_config.setter
    def clip_config(self, value: Optional[pulumi.Input['MediaTranscodeTemplateContainerClipConfigArgs']]):
        pulumi.set(self, "clip_config", value)


@pulumi.input_type
class MediaTranscodeTemplateContainerClipConfigArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] duration: Fragmentation duration, default 5s.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Fragmentation duration, default 5s.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)


@pulumi.input_type
class MediaTranscodeTemplateTimeIntervalArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] duration: duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param pulumi.Input[str] start: Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class MediaTranscodeTemplateTransConfigArgs:
    def __init__(__self__, *,
                 adj_dar_method: Optional[pulumi.Input[str]] = None,
                 audio_bitrate_adj_method: Optional[pulumi.Input[str]] = None,
                 delete_metadata: Optional[pulumi.Input[str]] = None,
                 hls_encrypt: Optional[pulumi.Input['MediaTranscodeTemplateTransConfigHlsEncryptArgs']] = None,
                 is_check_audio_bitrate: Optional[pulumi.Input[str]] = None,
                 is_check_reso: Optional[pulumi.Input[str]] = None,
                 is_check_video_bitrate: Optional[pulumi.Input[str]] = None,
                 is_hdr2_sdr: Optional[pulumi.Input[str]] = None,
                 reso_adj_method: Optional[pulumi.Input[str]] = None,
                 video_bitrate_adj_method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] adj_dar_method: Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        :param pulumi.Input[str] audio_bitrate_adj_method: Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        :param pulumi.Input[str] delete_metadata: Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        :param pulumi.Input['MediaTranscodeTemplateTransConfigHlsEncryptArgs'] hls_encrypt: hls encryption configuration.
        :param pulumi.Input[str] is_check_audio_bitrate: Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        :param pulumi.Input[str] is_check_reso: Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        :param pulumi.Input[str] is_check_video_bitrate: Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        :param pulumi.Input[str] is_hdr2_sdr: Whether to enable HDR to SDR true, false.
        :param pulumi.Input[str] reso_adj_method: Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        :param pulumi.Input[str] video_bitrate_adj_method: Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        if adj_dar_method is not None:
            pulumi.set(__self__, "adj_dar_method", adj_dar_method)
        if audio_bitrate_adj_method is not None:
            pulumi.set(__self__, "audio_bitrate_adj_method", audio_bitrate_adj_method)
        if delete_metadata is not None:
            pulumi.set(__self__, "delete_metadata", delete_metadata)
        if hls_encrypt is not None:
            pulumi.set(__self__, "hls_encrypt", hls_encrypt)
        if is_check_audio_bitrate is not None:
            pulumi.set(__self__, "is_check_audio_bitrate", is_check_audio_bitrate)
        if is_check_reso is not None:
            pulumi.set(__self__, "is_check_reso", is_check_reso)
        if is_check_video_bitrate is not None:
            pulumi.set(__self__, "is_check_video_bitrate", is_check_video_bitrate)
        if is_hdr2_sdr is not None:
            pulumi.set(__self__, "is_hdr2_sdr", is_hdr2_sdr)
        if reso_adj_method is not None:
            pulumi.set(__self__, "reso_adj_method", reso_adj_method)
        if video_bitrate_adj_method is not None:
            pulumi.set(__self__, "video_bitrate_adj_method", video_bitrate_adj_method)

    @property
    @pulumi.getter(name="adjDarMethod")
    def adj_dar_method(self) -> Optional[pulumi.Input[str]]:
        """
        Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        """
        return pulumi.get(self, "adj_dar_method")

    @adj_dar_method.setter
    def adj_dar_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adj_dar_method", value)

    @property
    @pulumi.getter(name="audioBitrateAdjMethod")
    def audio_bitrate_adj_method(self) -> Optional[pulumi.Input[str]]:
        """
        Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        """
        return pulumi.get(self, "audio_bitrate_adj_method")

    @audio_bitrate_adj_method.setter
    def audio_bitrate_adj_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_bitrate_adj_method", value)

    @property
    @pulumi.getter(name="deleteMetadata")
    def delete_metadata(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        """
        return pulumi.get(self, "delete_metadata")

    @delete_metadata.setter
    def delete_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_metadata", value)

    @property
    @pulumi.getter(name="hlsEncrypt")
    def hls_encrypt(self) -> Optional[pulumi.Input['MediaTranscodeTemplateTransConfigHlsEncryptArgs']]:
        """
        hls encryption configuration.
        """
        return pulumi.get(self, "hls_encrypt")

    @hls_encrypt.setter
    def hls_encrypt(self, value: Optional[pulumi.Input['MediaTranscodeTemplateTransConfigHlsEncryptArgs']]):
        pulumi.set(self, "hls_encrypt", value)

    @property
    @pulumi.getter(name="isCheckAudioBitrate")
    def is_check_audio_bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        """
        return pulumi.get(self, "is_check_audio_bitrate")

    @is_check_audio_bitrate.setter
    def is_check_audio_bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_audio_bitrate", value)

    @property
    @pulumi.getter(name="isCheckReso")
    def is_check_reso(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_reso")

    @is_check_reso.setter
    def is_check_reso(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_reso", value)

    @property
    @pulumi.getter(name="isCheckVideoBitrate")
    def is_check_video_bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_video_bitrate")

    @is_check_video_bitrate.setter
    def is_check_video_bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_check_video_bitrate", value)

    @property
    @pulumi.getter(name="isHdr2Sdr")
    def is_hdr2_sdr(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable HDR to SDR true, false.
        """
        return pulumi.get(self, "is_hdr2_sdr")

    @is_hdr2_sdr.setter
    def is_hdr2_sdr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_hdr2_sdr", value)

    @property
    @pulumi.getter(name="resoAdjMethod")
    def reso_adj_method(self) -> Optional[pulumi.Input[str]]:
        """
        Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        """
        return pulumi.get(self, "reso_adj_method")

    @reso_adj_method.setter
    def reso_adj_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reso_adj_method", value)

    @property
    @pulumi.getter(name="videoBitrateAdjMethod")
    def video_bitrate_adj_method(self) -> Optional[pulumi.Input[str]]:
        """
        Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        return pulumi.get(self, "video_bitrate_adj_method")

    @video_bitrate_adj_method.setter
    def video_bitrate_adj_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "video_bitrate_adj_method", value)


@pulumi.input_type
class MediaTranscodeTemplateTransConfigHlsEncryptArgs:
    def __init__(__self__, *,
                 is_hls_encrypt: Optional[pulumi.Input[str]] = None,
                 uri_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] is_hls_encrypt: Whether to enable HLS encryption, support encryption when Container.Format is hls.
        :param pulumi.Input[str] uri_key: HLS encrypted key, this parameter is only meaningful when IsHlsEncrypt is true.
        """
        if is_hls_encrypt is not None:
            pulumi.set(__self__, "is_hls_encrypt", is_hls_encrypt)
        if uri_key is not None:
            pulumi.set(__self__, "uri_key", uri_key)

    @property
    @pulumi.getter(name="isHlsEncrypt")
    def is_hls_encrypt(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable HLS encryption, support encryption when Container.Format is hls.
        """
        return pulumi.get(self, "is_hls_encrypt")

    @is_hls_encrypt.setter
    def is_hls_encrypt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_hls_encrypt", value)

    @property
    @pulumi.getter(name="uriKey")
    def uri_key(self) -> Optional[pulumi.Input[str]]:
        """
        HLS encrypted key, this parameter is only meaningful when IsHlsEncrypt is true.
        """
        return pulumi.get(self, "uri_key")

    @uri_key.setter
    def uri_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri_key", value)


@pulumi.input_type
class MediaTranscodeTemplateVideoArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[str]] = None,
                 bufsize: Optional[pulumi.Input[str]] = None,
                 codec: Optional[pulumi.Input[str]] = None,
                 crf: Optional[pulumi.Input[str]] = None,
                 fps: Optional[pulumi.Input[str]] = None,
                 gop: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 long_short_mode: Optional[pulumi.Input[str]] = None,
                 maxrate: Optional[pulumi.Input[str]] = None,
                 pixfmt: Optional[pulumi.Input[str]] = None,
                 preset: Optional[pulumi.Input[str]] = None,
                 profile: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[str]] = None,
                 rotate: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bitrate: Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        :param pulumi.Input[str] bufsize: buffer size, Value range: [1000, 128000], Unit: Kb, This parameter is not supported when Codec is VP8/VP9.
        :param pulumi.Input[str] codec: Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        :param pulumi.Input[str] crf: Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        :param pulumi.Input[str] fps: Frame rate, value range: (0, 60], Unit: fps.
        :param pulumi.Input[str] gop: The maximum number of frames between key frames, value range: [1, 100000].
        :param pulumi.Input[str] height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param pulumi.Input[str] long_short_mode: Adaptive length,true, false, This parameter is not supported when Codec is VP8/VP9/AV1.
        :param pulumi.Input[str] maxrate: Peak video bit rate, Value range: [10, 50000], Unit: Kbps, This parameter is not supported when Codec is VP8/VP9.
        :param pulumi.Input[str] pixfmt: video color format, H.264 support: yuv420p, yuv422p, yuv444p, yuvj420p, yuvj422p, yuvj444p, auto, H.265 support: yuv420p, yuv420p10le, auto, This parameter is not supported when Codec is VP8/VP9/AV1.
        :param pulumi.Input[str] preset: Video Algorithm Presets- H.264 supports this parameter, the values are veryfast, fast, medium, slow, slower- VP8 supports this parameter, the value is good, realtime- AV1 supports this parameter, the value is 5 (recommended value), 4- H.265 and VP9 do not support this parameter.
        :param pulumi.Input[str] profile: encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        :param pulumi.Input[str] remove: Whether to delete the video stream, true, false.
        :param pulumi.Input[str] rotate: Rotation angle, Value range: [0, 360), Unit: degree.
        :param pulumi.Input[str] width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if bufsize is not None:
            pulumi.set(__self__, "bufsize", bufsize)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if crf is not None:
            pulumi.set(__self__, "crf", crf)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if long_short_mode is not None:
            pulumi.set(__self__, "long_short_mode", long_short_mode)
        if maxrate is not None:
            pulumi.set(__self__, "maxrate", maxrate)
        if pixfmt is not None:
            pulumi.set(__self__, "pixfmt", pixfmt)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rotate is not None:
            pulumi.set(__self__, "rotate", rotate)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def bufsize(self) -> Optional[pulumi.Input[str]]:
        """
        buffer size, Value range: [1000, 128000], Unit: Kb, This parameter is not supported when Codec is VP8/VP9.
        """
        return pulumi.get(self, "bufsize")

    @bufsize.setter
    def bufsize(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bufsize", value)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def crf(self) -> Optional[pulumi.Input[str]]:
        """
        Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        """
        return pulumi.get(self, "crf")

    @crf.setter
    def crf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "crf", value)

    @property
    @pulumi.getter
    def fps(self) -> Optional[pulumi.Input[str]]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of frames between key frames, value range: [1, 100000].
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gop", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="longShortMode")
    def long_short_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Adaptive length,true, false, This parameter is not supported when Codec is VP8/VP9/AV1.
        """
        return pulumi.get(self, "long_short_mode")

    @long_short_mode.setter
    def long_short_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_short_mode", value)

    @property
    @pulumi.getter
    def maxrate(self) -> Optional[pulumi.Input[str]]:
        """
        Peak video bit rate, Value range: [10, 50000], Unit: Kbps, This parameter is not supported when Codec is VP8/VP9.
        """
        return pulumi.get(self, "maxrate")

    @maxrate.setter
    def maxrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maxrate", value)

    @property
    @pulumi.getter
    def pixfmt(self) -> Optional[pulumi.Input[str]]:
        """
        video color format, H.264 support: yuv420p, yuv422p, yuv444p, yuvj420p, yuvj422p, yuvj444p, auto, H.265 support: yuv420p, yuv420p10le, auto, This parameter is not supported when Codec is VP8/VP9/AV1.
        """
        return pulumi.get(self, "pixfmt")

    @pixfmt.setter
    def pixfmt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pixfmt", value)

    @property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[str]]:
        """
        Video Algorithm Presets- H.264 supports this parameter, the values are veryfast, fast, medium, slow, slower- VP8 supports this parameter, the value is good, realtime- AV1 supports this parameter, the value is 5 (recommended value), 4- H.265 and VP9 do not support this parameter.
        """
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preset", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[str]]:
        """
        encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the video stream, true, false.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def rotate(self) -> Optional[pulumi.Input[str]]:
        """
        Rotation angle, Value range: [0, 360), Unit: degree.
        """
        return pulumi.get(self, "rotate")

    @rotate.setter
    def rotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rotate", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaVideoMontageTemplateAudioArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 bitrate: Optional[pulumi.Input[str]] = None,
                 channels: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[str]] = None,
                 samplerate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: Codec format, value aac, mp3.
        :param pulumi.Input[str] bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param pulumi.Input[str] channels: number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        :param pulumi.Input[str] remove: Whether to delete the source audio stream, the value is true, false.
        :param pulumi.Input[str] samplerate: Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Codec format, value aac, mp3.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[str]]:
        """
        number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[pulumi.Input[str]]:
        """
        Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        return pulumi.get(self, "samplerate")

    @samplerate.setter
    def samplerate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samplerate", value)


@pulumi.input_type
class MediaVideoMontageTemplateAudioMixArgs:
    def __init__(__self__, *,
                 audio_source: pulumi.Input[str],
                 effect_config: Optional[pulumi.Input['MediaVideoMontageTemplateAudioMixEffectConfigArgs']] = None,
                 mix_mode: Optional[pulumi.Input[str]] = None,
                 replace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] audio_source: The media address of the audio track that needs to be mixed.
        :param pulumi.Input['MediaVideoMontageTemplateAudioMixEffectConfigArgs'] effect_config: Mix Fade Configuration.
        :param pulumi.Input[str] mix_mode: Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        :param pulumi.Input[str] replace: Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        pulumi.set(__self__, "audio_source", audio_source)
        if effect_config is not None:
            pulumi.set(__self__, "effect_config", effect_config)
        if mix_mode is not None:
            pulumi.set(__self__, "mix_mode", mix_mode)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="audioSource")
    def audio_source(self) -> pulumi.Input[str]:
        """
        The media address of the audio track that needs to be mixed.
        """
        return pulumi.get(self, "audio_source")

    @audio_source.setter
    def audio_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "audio_source", value)

    @property
    @pulumi.getter(name="effectConfig")
    def effect_config(self) -> Optional[pulumi.Input['MediaVideoMontageTemplateAudioMixEffectConfigArgs']]:
        """
        Mix Fade Configuration.
        """
        return pulumi.get(self, "effect_config")

    @effect_config.setter
    def effect_config(self, value: Optional[pulumi.Input['MediaVideoMontageTemplateAudioMixEffectConfigArgs']]):
        pulumi.set(self, "effect_config", value)

    @property
    @pulumi.getter(name="mixMode")
    def mix_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        """
        return pulumi.get(self, "mix_mode")

    @mix_mode.setter
    def mix_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mix_mode", value)

    @property
    @pulumi.getter
    def replace(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace", value)


@pulumi.input_type
class MediaVideoMontageTemplateAudioMixEffectConfigArgs:
    def __init__(__self__, *,
                 bgm_fade_time: Optional[pulumi.Input[str]] = None,
                 enable_bgm_fade: Optional[pulumi.Input[str]] = None,
                 enable_end_fadeout: Optional[pulumi.Input[str]] = None,
                 enable_start_fadein: Optional[pulumi.Input[str]] = None,
                 end_fadeout_time: Optional[pulumi.Input[str]] = None,
                 start_fadein_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bgm_fade_time: bgm transition fade-in duration, support floating point numbers.
        :param pulumi.Input[str] enable_bgm_fade: Enable bgm conversion fade in.
        :param pulumi.Input[str] enable_end_fadeout: enable fade out.
        :param pulumi.Input[str] enable_start_fadein: enable fade in.
        :param pulumi.Input[str] end_fadeout_time: fade out time, greater than 0, support floating point numbers.
        :param pulumi.Input[str] start_fadein_time: Fade in duration, greater than 0, support floating point numbers.
        """
        if bgm_fade_time is not None:
            pulumi.set(__self__, "bgm_fade_time", bgm_fade_time)
        if enable_bgm_fade is not None:
            pulumi.set(__self__, "enable_bgm_fade", enable_bgm_fade)
        if enable_end_fadeout is not None:
            pulumi.set(__self__, "enable_end_fadeout", enable_end_fadeout)
        if enable_start_fadein is not None:
            pulumi.set(__self__, "enable_start_fadein", enable_start_fadein)
        if end_fadeout_time is not None:
            pulumi.set(__self__, "end_fadeout_time", end_fadeout_time)
        if start_fadein_time is not None:
            pulumi.set(__self__, "start_fadein_time", start_fadein_time)

    @property
    @pulumi.getter(name="bgmFadeTime")
    def bgm_fade_time(self) -> Optional[pulumi.Input[str]]:
        """
        bgm transition fade-in duration, support floating point numbers.
        """
        return pulumi.get(self, "bgm_fade_time")

    @bgm_fade_time.setter
    def bgm_fade_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgm_fade_time", value)

    @property
    @pulumi.getter(name="enableBgmFade")
    def enable_bgm_fade(self) -> Optional[pulumi.Input[str]]:
        """
        Enable bgm conversion fade in.
        """
        return pulumi.get(self, "enable_bgm_fade")

    @enable_bgm_fade.setter
    def enable_bgm_fade(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_bgm_fade", value)

    @property
    @pulumi.getter(name="enableEndFadeout")
    def enable_end_fadeout(self) -> Optional[pulumi.Input[str]]:
        """
        enable fade out.
        """
        return pulumi.get(self, "enable_end_fadeout")

    @enable_end_fadeout.setter
    def enable_end_fadeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_end_fadeout", value)

    @property
    @pulumi.getter(name="enableStartFadein")
    def enable_start_fadein(self) -> Optional[pulumi.Input[str]]:
        """
        enable fade in.
        """
        return pulumi.get(self, "enable_start_fadein")

    @enable_start_fadein.setter
    def enable_start_fadein(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_start_fadein", value)

    @property
    @pulumi.getter(name="endFadeoutTime")
    def end_fadeout_time(self) -> Optional[pulumi.Input[str]]:
        """
        fade out time, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "end_fadeout_time")

    @end_fadeout_time.setter
    def end_fadeout_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_fadeout_time", value)

    @property
    @pulumi.getter(name="startFadeinTime")
    def start_fadein_time(self) -> Optional[pulumi.Input[str]]:
        """
        Fade in duration, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "start_fadein_time")

    @start_fadein_time.setter
    def start_fadein_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_fadein_time", value)


@pulumi.input_type
class MediaVideoMontageTemplateContainerArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str]):
        """
        :param pulumi.Input[str] format: Container format: mp4, flv, hls, ts, mkv.
        """
        pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Container format: mp4, flv, hls, ts, mkv.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)


@pulumi.input_type
class MediaVideoMontageTemplateVideoArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 bitrate: Optional[pulumi.Input[str]] = None,
                 crf: Optional[pulumi.Input[str]] = None,
                 fps: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: Codec format `H.264`.
        :param pulumi.Input[str] bitrate: Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        :param pulumi.Input[str] crf: Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        :param pulumi.Input[str] fps: Frame rate, value range: (0, 60], Unit: fps.
        :param pulumi.Input[str] height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param pulumi.Input[str] remove: Whether to delete the source audio stream, the value is true, false.
        :param pulumi.Input[str] width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if crf is not None:
            pulumi.set(__self__, "crf", crf)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Codec format `H.264`.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def crf(self) -> Optional[pulumi.Input[str]]:
        """
        Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        """
        return pulumi.get(self, "crf")

    @crf.setter
    def crf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "crf", value)

    @property
    @pulumi.getter
    def fps(self) -> Optional[pulumi.Input[str]]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaVideoProcessTemplateColorEnhanceArgs:
    def __init__(__self__, *,
                 contrast: Optional[pulumi.Input[str]] = None,
                 correction: Optional[pulumi.Input[str]] = None,
                 enable: Optional[pulumi.Input[str]] = None,
                 saturation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contrast: Contrast, value range: [0, 100], empty string (indicates automatic analysis).
        :param pulumi.Input[str] correction: colorcorrection, value range: [0, 100], empty string (indicating automatic analysis).
        :param pulumi.Input[str] enable: Whether color enhancement is turned on.
        :param pulumi.Input[str] saturation: Saturation, value range: [0, 100], empty string (indicating automatic analysis).
        """
        if contrast is not None:
            pulumi.set(__self__, "contrast", contrast)
        if correction is not None:
            pulumi.set(__self__, "correction", correction)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)

    @property
    @pulumi.getter
    def contrast(self) -> Optional[pulumi.Input[str]]:
        """
        Contrast, value range: [0, 100], empty string (indicates automatic analysis).
        """
        return pulumi.get(self, "contrast")

    @contrast.setter
    def contrast(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contrast", value)

    @property
    @pulumi.getter
    def correction(self) -> Optional[pulumi.Input[str]]:
        """
        colorcorrection, value range: [0, 100], empty string (indicating automatic analysis).
        """
        return pulumi.get(self, "correction")

    @correction.setter
    def correction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "correction", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether color enhancement is turned on.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def saturation(self) -> Optional[pulumi.Input[str]]:
        """
        Saturation, value range: [0, 100], empty string (indicating automatic analysis).
        """
        return pulumi.get(self, "saturation")

    @saturation.setter
    def saturation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saturation", value)


@pulumi.input_type
class MediaVideoProcessTemplateMsSharpenArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[str]] = None,
                 sharpen_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] enable: Whether detail enhancement is enabled.
        :param pulumi.Input[str] sharpen_level: Enhancement level, value range: [0, 10], empty string (indicates automatic analysis).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sharpen_level is not None:
            pulumi.set(__self__, "sharpen_level", sharpen_level)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether detail enhancement is enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="sharpenLevel")
    def sharpen_level(self) -> Optional[pulumi.Input[str]]:
        """
        Enhancement level, value range: [0, 10], empty string (indicates automatic analysis).
        """
        return pulumi.get(self, "sharpen_level")

    @sharpen_level.setter
    def sharpen_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sharpen_level", value)


@pulumi.input_type
class MediaVoiceSeparateTemplateAudioConfigArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 bitrate: Optional[pulumi.Input[str]] = None,
                 channels: Optional[pulumi.Input[str]] = None,
                 samplerate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: Codec format, value aac, mp3, flac, amr.
        :param pulumi.Input[str] bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param pulumi.Input[str] channels: number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2- When Codec is set to amr, only 1 is supported.
        :param pulumi.Input[str] samplerate: Sampling Rate- 1: Unit: Hz- 2: Optional 8000, 11025, 22050, 32000, 44100, 48000, 96000- 3: When Codec is set to aac/flac, 8000 is not supported- 4: When Codec is set to mp3, 8000 and 96000 are not supported- 5: When Codec is set to amr, only 8000 is supported.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Codec format, value aac, mp3, flac, amr.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[str]]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[str]]:
        """
        number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2- When Codec is set to amr, only 1 is supported.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[pulumi.Input[str]]:
        """
        Sampling Rate- 1: Unit: Hz- 2: Optional 8000, 11025, 22050, 32000, 44100, 48000, 96000- 3: When Codec is set to aac/flac, 8000 is not supported- 4: When Codec is set to mp3, 8000 and 96000 are not supported- 5: When Codec is set to amr, only 8000 is supported.
        """
        return pulumi.get(self, "samplerate")

    @samplerate.setter
    def samplerate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samplerate", value)


@pulumi.input_type
class MediaWatermarkTemplateWatermarkArgs:
    def __init__(__self__, *,
                 dx: pulumi.Input[str],
                 dy: pulumi.Input[str],
                 loc_mode: pulumi.Input[str],
                 pos: pulumi.Input[str],
                 type: pulumi.Input[str],
                 end_time: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input['MediaWatermarkTemplateWatermarkImageArgs']] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 text: Optional[pulumi.Input['MediaWatermarkTemplateWatermarkTextArgs']] = None):
        """
        :param pulumi.Input[str] dx: Horizontal offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ], 2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Top, Bottom and Center, the parameter is invalid.
        :param pulumi.Input[str] dy: Vertical offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ],2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096],3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Left, Right and Center, the parameter is invalid.
        :param pulumi.Input[str] loc_mode: Offset method, Relativity: proportional, Absolute: fixed position.
        :param pulumi.Input[str] pos: Reference position, TopRight, TopLeft, BottomRight, BottomLeft, Left, Right, Top, Bottom, Center.
        :param pulumi.Input[str] type: Watermark type, Text: text watermark, Image: image watermark.
        :param pulumi.Input[str] end_time: Watermark end time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        :param pulumi.Input['MediaWatermarkTemplateWatermarkImageArgs'] image: Image watermark node.
        :param pulumi.Input[str] start_time: Watermark start time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        :param pulumi.Input['MediaWatermarkTemplateWatermarkTextArgs'] text: Text Watermark Node.
        """
        pulumi.set(__self__, "dx", dx)
        pulumi.set(__self__, "dy", dy)
        pulumi.set(__self__, "loc_mode", loc_mode)
        pulumi.set(__self__, "pos", pos)
        pulumi.set(__self__, "type", type)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def dx(self) -> pulumi.Input[str]:
        """
        Horizontal offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ], 2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Top, Bottom and Center, the parameter is invalid.
        """
        return pulumi.get(self, "dx")

    @dx.setter
    def dx(self, value: pulumi.Input[str]):
        pulumi.set(self, "dx", value)

    @property
    @pulumi.getter
    def dy(self) -> pulumi.Input[str]:
        """
        Vertical offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ],2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096],3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Left, Right and Center, the parameter is invalid.
        """
        return pulumi.get(self, "dy")

    @dy.setter
    def dy(self, value: pulumi.Input[str]):
        pulumi.set(self, "dy", value)

    @property
    @pulumi.getter(name="locMode")
    def loc_mode(self) -> pulumi.Input[str]:
        """
        Offset method, Relativity: proportional, Absolute: fixed position.
        """
        return pulumi.get(self, "loc_mode")

    @loc_mode.setter
    def loc_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "loc_mode", value)

    @property
    @pulumi.getter
    def pos(self) -> pulumi.Input[str]:
        """
        Reference position, TopRight, TopLeft, BottomRight, BottomLeft, Left, Right, Top, Bottom, Center.
        """
        return pulumi.get(self, "pos")

    @pos.setter
    def pos(self, value: pulumi.Input[str]):
        pulumi.set(self, "pos", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Watermark type, Text: text watermark, Image: image watermark.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark end time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['MediaWatermarkTemplateWatermarkImageArgs']]:
        """
        Image watermark node.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['MediaWatermarkTemplateWatermarkImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark start time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['MediaWatermarkTemplateWatermarkTextArgs']]:
        """
        Text Watermark Node.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['MediaWatermarkTemplateWatermarkTextArgs']]):
        pulumi.set(self, "text", value)


@pulumi.input_type
class MediaWatermarkTemplateWatermarkImageArgs:
    def __init__(__self__, *,
                 background: pulumi.Input[str],
                 mode: pulumi.Input[str],
                 transparency: pulumi.Input[str],
                 url: pulumi.Input[str],
                 height: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background: Whether the background image.
        :param pulumi.Input[str] mode: Size mode, Original: original size, Proportion: proportional, Fixed: fixed size.
        :param pulumi.Input[str] transparency: Transparency, value range: [1 100], unit %.
        :param pulumi.Input[str] url: Address of watermark map (pass in after Urlencode is required).
        :param pulumi.Input[str] height: High, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        :param pulumi.Input[str] width: Width, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        """
        pulumi.set(__self__, "background", background)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "transparency", transparency)
        pulumi.set(__self__, "url", url)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def background(self) -> pulumi.Input[str]:
        """
        Whether the background image.
        """
        return pulumi.get(self, "background")

    @background.setter
    def background(self, value: pulumi.Input[str]):
        pulumi.set(self, "background", value)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Size mode, Original: original size, Proportion: proportional, Fixed: fixed size.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def transparency(self) -> pulumi.Input[str]:
        """
        Transparency, value range: [1 100], unit %.
        """
        return pulumi.get(self, "transparency")

    @transparency.setter
    def transparency(self, value: pulumi.Input[str]):
        pulumi.set(self, "transparency", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Address of watermark map (pass in after Urlencode is required).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        High, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        Width, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class MediaWatermarkTemplateWatermarkTextArgs:
    def __init__(__self__, *,
                 font_color: pulumi.Input[str],
                 font_size: pulumi.Input[str],
                 font_type: pulumi.Input[str],
                 text: pulumi.Input[str],
                 transparency: pulumi.Input[str]):
        """
        :param pulumi.Input[str] font_color: Font color, format: 0xRRGGBB.
        :param pulumi.Input[str] font_size: Font size, value range: [5 100], unit px.
        :param pulumi.Input[str] font_type: font type.
        :param pulumi.Input[str] text: Watermark content, the length does not exceed 64 characters, only supports Chinese, English, numbers, _, - and *.
        :param pulumi.Input[str] transparency: Transparency, value range: [1 100], unit %.
        """
        pulumi.set(__self__, "font_color", font_color)
        pulumi.set(__self__, "font_size", font_size)
        pulumi.set(__self__, "font_type", font_type)
        pulumi.set(__self__, "text", text)
        pulumi.set(__self__, "transparency", transparency)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> pulumi.Input[str]:
        """
        Font color, format: 0xRRGGBB.
        """
        return pulumi.get(self, "font_color")

    @font_color.setter
    def font_color(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> pulumi.Input[str]:
        """
        Font size, value range: [5 100], unit px.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> pulumi.Input[str]:
        """
        font type.
        """
        return pulumi.get(self, "font_type")

    @font_type.setter
    def font_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_type", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        Watermark content, the length does not exceed 64 characters, only supports Chinese, English, numbers, _, - and *.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def transparency(self) -> pulumi.Input[str]:
        """
        Transparency, value range: [1 100], unit %.
        """
        return pulumi.get(self, "transparency")

    @transparency.setter
    def transparency(self, value: pulumi.Input[str]):
        pulumi.set(self, "transparency", value)


