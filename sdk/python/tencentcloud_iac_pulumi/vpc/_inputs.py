# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FlowLogFlowLogStorageArgs',
    'FlowLogFlowLogStorageArgsDict',
    'Ipv6CidrBlockIpv6CidrBlockSetArgs',
    'Ipv6CidrBlockIpv6CidrBlockSetArgsDict',
    'Ipv6SubnetCidrBlockIpv6SubnetCidrBlocksArgs',
    'Ipv6SubnetCidrBlockIpv6SubnetCidrBlocksArgsDict',
    'NetworkAclQuintupleNetworkAclQuintupleSetArgs',
    'NetworkAclQuintupleNetworkAclQuintupleSetArgsDict',
    'NetworkAclQuintupleNetworkAclQuintupleSetEgressArgs',
    'NetworkAclQuintupleNetworkAclQuintupleSetEgressArgsDict',
    'NetworkAclQuintupleNetworkAclQuintupleSetIngressArgs',
    'NetworkAclQuintupleNetworkAclQuintupleSetIngressArgsDict',
    'PrivateNatGatewayTranslationNatRuleTranslationNatRuleArgs',
    'PrivateNatGatewayTranslationNatRuleTranslationNatRuleArgsDict',
    'SnapshotPolicyAttachmentInstanceArgs',
    'SnapshotPolicyAttachmentInstanceArgsDict',
    'SnapshotPolicyBackupPolicyArgs',
    'SnapshotPolicyBackupPolicyArgsDict',
    'GetClassicLinkInstancesFilterArgs',
    'GetClassicLinkInstancesFilterArgsDict',
    'GetCvmInstancesFilterArgs',
    'GetCvmInstancesFilterArgsDict',
    'GetNetDetectStatesFilterArgs',
    'GetNetDetectStatesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class FlowLogFlowLogStorageArgsDict(TypedDict):
        storage_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Storage instance ID, required while `storage_type` is `ckafka`.
        """
        storage_topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Topic ID, required while `storage_type` is `ckafka`.
        """
elif False:
    FlowLogFlowLogStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowLogFlowLogStorageArgs:
    def __init__(__self__, *,
                 storage_id: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_topic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_id: Storage instance ID, required while `storage_type` is `ckafka`.
        :param pulumi.Input[_builtins.str] storage_topic: Topic ID, required while `storage_type` is `ckafka`.
        """
        if storage_id is not None:
            pulumi.set(__self__, "storage_id", storage_id)
        if storage_topic is not None:
            pulumi.set(__self__, "storage_topic", storage_topic)

    @_builtins.property
    @pulumi.getter(name="storageId")
    def storage_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Storage instance ID, required while `storage_type` is `ckafka`.
        """
        return pulumi.get(self, "storage_id")

    @storage_id.setter
    def storage_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_id", value)

    @_builtins.property
    @pulumi.getter(name="storageTopic")
    def storage_topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Topic ID, required while `storage_type` is `ckafka`.
        """
        return pulumi.get(self, "storage_topic")

    @storage_topic.setter
    def storage_topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_topic", value)


if not MYPY:
    class Ipv6CidrBlockIpv6CidrBlockSetArgsDict(TypedDict):
        address_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apply for the type of IPv6 Cidr, GUA (Global Unicast Address), ULA (Unique Local Address).
        """
        ipv6_cidr_block: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6 cidr block.
        """
        isp_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Range of network operator types: 'BGP' - default, 'CMCC' - China Mobile, 'CTCC' - China Telecom, 'CUCC' - China Joint Debugging.
        """
elif False:
    Ipv6CidrBlockIpv6CidrBlockSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ipv6CidrBlockIpv6CidrBlockSetArgs:
    def __init__(__self__, *,
                 address_type: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[_builtins.str]] = None,
                 isp_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address_type: Apply for the type of IPv6 Cidr, GUA (Global Unicast Address), ULA (Unique Local Address).
        :param pulumi.Input[_builtins.str] ipv6_cidr_block: Ipv6 cidr block.
        :param pulumi.Input[_builtins.str] isp_type: Range of network operator types: 'BGP' - default, 'CMCC' - China Mobile, 'CTCC' - China Telecom, 'CUCC' - China Joint Debugging.
        """
        if address_type is not None:
            pulumi.set(__self__, "address_type", address_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if isp_type is not None:
            pulumi.set(__self__, "isp_type", isp_type)

    @_builtins.property
    @pulumi.getter(name="addressType")
    def address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apply for the type of IPv6 Cidr, GUA (Global Unicast Address), ULA (Unique Local Address).
        """
        return pulumi.get(self, "address_type")

    @address_type.setter
    def address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_type", value)

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6 cidr block.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @_builtins.property
    @pulumi.getter(name="ispType")
    def isp_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Range of network operator types: 'BGP' - default, 'CMCC' - China Mobile, 'CTCC' - China Telecom, 'CUCC' - China Joint Debugging.
        """
        return pulumi.get(self, "isp_type")

    @isp_type.setter
    def isp_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "isp_type", value)


if not MYPY:
    class Ipv6SubnetCidrBlockIpv6SubnetCidrBlocksArgsDict(TypedDict):
        ipv6_cidr_block: pulumi.Input[_builtins.str]
        """
        `IPv6` subnet segment. Such as: `3402:4e00:20:1001::/64`.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        Subnet instance `ID`. Such as:`subnet-pxir56ns`.
        """
elif False:
    Ipv6SubnetCidrBlockIpv6SubnetCidrBlocksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ipv6SubnetCidrBlockIpv6SubnetCidrBlocksArgs:
    def __init__(__self__, *,
                 ipv6_cidr_block: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ipv6_cidr_block: `IPv6` subnet segment. Such as: `3402:4e00:20:1001::/64`.
        :param pulumi.Input[_builtins.str] subnet_id: Subnet instance `ID`. Such as:`subnet-pxir56ns`.
        """
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> pulumi.Input[_builtins.str]:
        """
        `IPv6` subnet segment. Such as: `3402:4e00:20:1001::/64`.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet instance `ID`. Such as:`subnet-pxir56ns`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class NetworkAclQuintupleNetworkAclQuintupleSetArgsDict(TypedDict):
        egresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetEgressArgsDict']]]]
        """
        Network ACL quintuple outbound rule.
        """
        ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetIngressArgsDict']]]]
        """
        Network ACL quintuple inbound rule.
        """
elif False:
    NetworkAclQuintupleNetworkAclQuintupleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkAclQuintupleNetworkAclQuintupleSetArgs:
    def __init__(__self__, *,
                 egresses: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetEgressArgs']]]] = None,
                 ingresses: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetIngressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetEgressArgs']]] egresses: Network ACL quintuple outbound rule.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetIngressArgs']]] ingresses: Network ACL quintuple inbound rule.
        """
        if egresses is not None:
            pulumi.set(__self__, "egresses", egresses)
        if ingresses is not None:
            pulumi.set(__self__, "ingresses", ingresses)

    @_builtins.property
    @pulumi.getter
    def egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetEgressArgs']]]]:
        """
        Network ACL quintuple outbound rule.
        """
        return pulumi.get(self, "egresses")

    @egresses.setter
    def egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetEgressArgs']]]]):
        pulumi.set(self, "egresses", value)

    @_builtins.property
    @pulumi.getter
    def ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetIngressArgs']]]]:
        """
        Network ACL quintuple inbound rule.
        """
        return pulumi.get(self, "ingresses")

    @ingresses.setter
    def ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkAclQuintupleNetworkAclQuintupleSetIngressArgs']]]]):
        pulumi.set(self, "ingresses", value)


if not MYPY:
    class NetworkAclQuintupleNetworkAclQuintupleSetEgressArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action, ACCEPT or DROP.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description.
        """
        destination_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination CIDR.
        """
        destination_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        """
        network_acl_direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        network_acl_quintuple_entry_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique ID of a network ACL entry.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority, starting from 1.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol, value: TCP,UDP, ICMP, ALL.
        """
        source_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source CIDR.
        """
        source_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        """
elif False:
    NetworkAclQuintupleNetworkAclQuintupleSetEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkAclQuintupleNetworkAclQuintupleSetEgressArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_port: Optional[pulumi.Input[_builtins.str]] = None,
                 network_acl_direction: Optional[pulumi.Input[_builtins.str]] = None,
                 network_acl_quintuple_entry_id: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 source_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 source_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action, ACCEPT or DROP.
        :param pulumi.Input[_builtins.str] create_time: Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
        :param pulumi.Input[_builtins.str] description: Description.
        :param pulumi.Input[_builtins.str] destination_cidr: Destination CIDR.
        :param pulumi.Input[_builtins.str] destination_port: Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        :param pulumi.Input[_builtins.str] network_acl_direction: Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
        :param pulumi.Input[_builtins.str] network_acl_quintuple_entry_id: Unique ID of a network ACL entry.
        :param pulumi.Input[_builtins.int] priority: Priority, starting from 1.
        :param pulumi.Input[_builtins.str] protocol: Protocol, value: TCP,UDP, ICMP, ALL.
        :param pulumi.Input[_builtins.str] source_cidr: Source CIDR.
        :param pulumi.Input[_builtins.str] source_port: Source port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if network_acl_direction is not None:
            pulumi.set(__self__, "network_acl_direction", network_acl_direction)
        if network_acl_quintuple_entry_id is not None:
            pulumi.set(__self__, "network_acl_quintuple_entry_id", network_acl_quintuple_entry_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_cidr is not None:
            pulumi.set(__self__, "source_cidr", source_cidr)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action, ACCEPT or DROP.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination CIDR.
        """
        return pulumi.get(self, "destination_cidr")

    @destination_cidr.setter
    def destination_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter(name="networkAclDirection")
    def network_acl_direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        return pulumi.get(self, "network_acl_direction")

    @network_acl_direction.setter
    def network_acl_direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_acl_direction", value)

    @_builtins.property
    @pulumi.getter(name="networkAclQuintupleEntryId")
    def network_acl_quintuple_entry_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique ID of a network ACL entry.
        """
        return pulumi.get(self, "network_acl_quintuple_entry_id")

    @network_acl_quintuple_entry_id.setter
    def network_acl_quintuple_entry_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_acl_quintuple_entry_id", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority, starting from 1.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol, value: TCP,UDP, ICMP, ALL.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="sourceCidr")
    def source_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source CIDR.
        """
        return pulumi.get(self, "source_cidr")

    @source_cidr.setter
    def source_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_cidr", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class NetworkAclQuintupleNetworkAclQuintupleSetIngressArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action, ACCEPT or DROP.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description.
        """
        destination_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination CIDR.
        """
        destination_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        """
        network_acl_direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        network_acl_quintuple_entry_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique ID of a network ACL entry.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority, starting from 1.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol, value: TCP,UDP, ICMP, ALL.
        """
        source_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        源CIDR。.
        """
        source_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        source port (all, single port, range). When the protocol is ALL or ICMP, the port cannot be specified.
        """
elif False:
    NetworkAclQuintupleNetworkAclQuintupleSetIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkAclQuintupleNetworkAclQuintupleSetIngressArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_port: Optional[pulumi.Input[_builtins.str]] = None,
                 network_acl_direction: Optional[pulumi.Input[_builtins.str]] = None,
                 network_acl_quintuple_entry_id: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 source_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 source_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action, ACCEPT or DROP.
        :param pulumi.Input[_builtins.str] create_time: Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
        :param pulumi.Input[_builtins.str] description: Description.
        :param pulumi.Input[_builtins.str] destination_cidr: Destination CIDR.
        :param pulumi.Input[_builtins.str] destination_port: Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        :param pulumi.Input[_builtins.str] network_acl_direction: Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
        :param pulumi.Input[_builtins.str] network_acl_quintuple_entry_id: Unique ID of a network ACL entry.
        :param pulumi.Input[_builtins.int] priority: Priority, starting from 1.
        :param pulumi.Input[_builtins.str] protocol: Protocol, value: TCP,UDP, ICMP, ALL.
        :param pulumi.Input[_builtins.str] source_cidr: 源CIDR。.
        :param pulumi.Input[_builtins.str] source_port: source port (all, single port, range). When the protocol is ALL or ICMP, the port cannot be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if network_acl_direction is not None:
            pulumi.set(__self__, "network_acl_direction", network_acl_direction)
        if network_acl_quintuple_entry_id is not None:
            pulumi.set(__self__, "network_acl_quintuple_entry_id", network_acl_quintuple_entry_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_cidr is not None:
            pulumi.set(__self__, "source_cidr", source_cidr)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action, ACCEPT or DROP.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination CIDR.
        """
        return pulumi.get(self, "destination_cidr")

    @destination_cidr.setter
    def destination_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_cidr", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter(name="networkAclDirection")
    def network_acl_direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
        """
        return pulumi.get(self, "network_acl_direction")

    @network_acl_direction.setter
    def network_acl_direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_acl_direction", value)

    @_builtins.property
    @pulumi.getter(name="networkAclQuintupleEntryId")
    def network_acl_quintuple_entry_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique ID of a network ACL entry.
        """
        return pulumi.get(self, "network_acl_quintuple_entry_id")

    @network_acl_quintuple_entry_id.setter
    def network_acl_quintuple_entry_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_acl_quintuple_entry_id", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority, starting from 1.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol, value: TCP,UDP, ICMP, ALL.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="sourceCidr")
    def source_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        源CIDR。.
        """
        return pulumi.get(self, "source_cidr")

    @source_cidr.setter
    def source_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_cidr", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        source port (all, single port, range). When the protocol is ALL or ICMP, the port cannot be specified.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class PrivateNatGatewayTranslationNatRuleTranslationNatRuleArgsDict(TypedDict):
        description: pulumi.Input[_builtins.str]
        """
        Translation rule description.
        """
        translation_direction: pulumi.Input[_builtins.str]
        """
        Translation rule target, optional values "LOCAL","PEER".
        """
        translation_ip: pulumi.Input[_builtins.str]
        """
        Translation IP, when translation rule type is transport layer, it is an IP pool.
        """
        translation_type: pulumi.Input[_builtins.str]
        """
        Translation rule type, optional values "NETWORK_LAYER","TRANSPORT_LAYER".
        """
        original_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source IP, valid when translation rule type is network layer.
        """
elif False:
    PrivateNatGatewayTranslationNatRuleTranslationNatRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateNatGatewayTranslationNatRuleTranslationNatRuleArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 translation_direction: pulumi.Input[_builtins.str],
                 translation_ip: pulumi.Input[_builtins.str],
                 translation_type: pulumi.Input[_builtins.str],
                 original_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Translation rule description.
        :param pulumi.Input[_builtins.str] translation_direction: Translation rule target, optional values "LOCAL","PEER".
        :param pulumi.Input[_builtins.str] translation_ip: Translation IP, when translation rule type is transport layer, it is an IP pool.
        :param pulumi.Input[_builtins.str] translation_type: Translation rule type, optional values "NETWORK_LAYER","TRANSPORT_LAYER".
        :param pulumi.Input[_builtins.str] original_ip: Source IP, valid when translation rule type is network layer.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "translation_direction", translation_direction)
        pulumi.set(__self__, "translation_ip", translation_ip)
        pulumi.set(__self__, "translation_type", translation_type)
        if original_ip is not None:
            pulumi.set(__self__, "original_ip", original_ip)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        Translation rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="translationDirection")
    def translation_direction(self) -> pulumi.Input[_builtins.str]:
        """
        Translation rule target, optional values "LOCAL","PEER".
        """
        return pulumi.get(self, "translation_direction")

    @translation_direction.setter
    def translation_direction(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "translation_direction", value)

    @_builtins.property
    @pulumi.getter(name="translationIp")
    def translation_ip(self) -> pulumi.Input[_builtins.str]:
        """
        Translation IP, when translation rule type is transport layer, it is an IP pool.
        """
        return pulumi.get(self, "translation_ip")

    @translation_ip.setter
    def translation_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "translation_ip", value)

    @_builtins.property
    @pulumi.getter(name="translationType")
    def translation_type(self) -> pulumi.Input[_builtins.str]:
        """
        Translation rule type, optional values "NETWORK_LAYER","TRANSPORT_LAYER".
        """
        return pulumi.get(self, "translation_type")

    @translation_type.setter
    def translation_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "translation_type", value)

    @_builtins.property
    @pulumi.getter(name="originalIp")
    def original_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source IP, valid when translation rule type is network layer.
        """
        return pulumi.get(self, "original_ip")

    @original_ip.setter
    def original_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "original_ip", value)


if not MYPY:
    class SnapshotPolicyAttachmentInstanceArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        InstanceId.
        """
        instance_region: pulumi.Input[_builtins.str]
        """
        The region where the instance is located.
        """
        instance_type: pulumi.Input[_builtins.str]
        """
        Instance type, currently supports set: `securitygroup`.
        """
        instance_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance name.
        """
        snapshot_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Snapshot policy Id.
        """
elif False:
    SnapshotPolicyAttachmentInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotPolicyAttachmentInstanceArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 instance_region: pulumi.Input[_builtins.str],
                 instance_type: pulumi.Input[_builtins.str],
                 instance_name: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_policy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_id: InstanceId.
        :param pulumi.Input[_builtins.str] instance_region: The region where the instance is located.
        :param pulumi.Input[_builtins.str] instance_type: Instance type, currently supports set: `securitygroup`.
        :param pulumi.Input[_builtins.str] instance_name: Instance name.
        :param pulumi.Input[_builtins.str] snapshot_policy_id: Snapshot policy Id.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_region", instance_region)
        pulumi.set(__self__, "instance_type", instance_type)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if snapshot_policy_id is not None:
            pulumi.set(__self__, "snapshot_policy_id", snapshot_policy_id)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        InstanceId.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceRegion")
    def instance_region(self) -> pulumi.Input[_builtins.str]:
        """
        The region where the instance is located.
        """
        return pulumi.get(self, "instance_region")

    @instance_region.setter
    def instance_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_region", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        """
        Instance type, currently supports set: `securitygroup`.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance name.
        """
        return pulumi.get(self, "instance_name")

    @instance_name.setter
    def instance_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_name", value)

    @_builtins.property
    @pulumi.getter(name="snapshotPolicyId")
    def snapshot_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Snapshot policy Id.
        """
        return pulumi.get(self, "snapshot_policy_id")

    @snapshot_policy_id.setter
    def snapshot_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_policy_id", value)


if not MYPY:
    class SnapshotPolicyBackupPolicyArgsDict(TypedDict):
        backup_day: pulumi.Input[_builtins.str]
        """
        Backup cycle time, the value can be monday, tuesday, wednesday, thursday, friday, saturday, sunday.
        """
        backup_time: pulumi.Input[_builtins.str]
        """
        Backup time point, format:HH:mm:ss.
        """
elif False:
    SnapshotPolicyBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotPolicyBackupPolicyArgs:
    def __init__(__self__, *,
                 backup_day: pulumi.Input[_builtins.str],
                 backup_time: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] backup_day: Backup cycle time, the value can be monday, tuesday, wednesday, thursday, friday, saturday, sunday.
        :param pulumi.Input[_builtins.str] backup_time: Backup time point, format:HH:mm:ss.
        """
        pulumi.set(__self__, "backup_day", backup_day)
        pulumi.set(__self__, "backup_time", backup_time)

    @_builtins.property
    @pulumi.getter(name="backupDay")
    def backup_day(self) -> pulumi.Input[_builtins.str]:
        """
        Backup cycle time, the value can be monday, tuesday, wednesday, thursday, friday, saturday, sunday.
        """
        return pulumi.get(self, "backup_day")

    @backup_day.setter
    def backup_day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "backup_day", value)

    @_builtins.property
    @pulumi.getter(name="backupTime")
    def backup_time(self) -> pulumi.Input[_builtins.str]:
        """
        Backup time point, format:HH:mm:ss.
        """
        return pulumi.get(self, "backup_time")

    @backup_time.setter
    def backup_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "backup_time", value)


if not MYPY:
    class GetClassicLinkInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        """
        values: Sequence[_builtins.str]
        """
        The attribute value. If there are multiple Values for one Filter, the logical relation between these Values under the same Filter is `OR`.
        """
elif False:
    GetClassicLinkInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClassicLinkInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        :param Sequence[_builtins.str] values: The attribute value. If there are multiple Values for one Filter, the logical relation between these Values under the same Filter is `OR`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The attribute value. If there are multiple Values for one Filter, the logical relation between these Values under the same Filter is `OR`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCvmInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        """
        values: Sequence[_builtins.str]
        """
        Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
        """
elif False:
    GetCvmInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCvmInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        :param Sequence[_builtins.str] values: Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetDetectStatesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        """
        values: Sequence[_builtins.str]
        """
        Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
        """
elif False:
    GetNetDetectStatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetDetectStatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        :param Sequence[_builtins.str] values: Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


