# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CustomDomainCertConfig',
    'CustomDomainEndpointsConfig',
    'CustomDomainEndpointsConfigPathRewrite',
    'CustomDomainWafConfig',
    'FunctionAliasRoutingConfig',
    'FunctionAliasRoutingConfigAdditionalVersionMatch',
    'FunctionAliasRoutingConfigAdditionalVersionWeight',
    'FunctionCfsConfig',
    'FunctionEventInvokeConfigAsyncTriggerConfig',
    'FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig',
    'FunctionImageConfig',
    'FunctionIntranetConfig',
    'FunctionLayer',
    'FunctionTrigger',
    'FunctionTriggerInfo',
    'LayerContent',
    'ProvisionedConcurrencyConfigTriggerAction',
    'GetAccountInfoAccountLimitResult',
    'GetAccountInfoAccountLimitNamespaceResult',
    'GetAccountInfoAccountLimitNamespaceTriggerResult',
    'GetAccountInfoAccountUsageResult',
    'GetAccountInfoAccountUsageNamespaceResult',
    'GetAsyncEventManagementEventListResult',
    'GetAsyncEventStatusResultResult',
    'GetFunctionAliasesAliasResult',
    'GetFunctionAliasesAliasRoutingConfigResult',
    'GetFunctionAliasesAliasRoutingConfigAdditionVersionMatchResult',
    'GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeightResult',
    'GetFunctionVersionsVersionResult',
    'GetFunctionsFunctionResult',
    'GetFunctionsFunctionImageConfigResult',
    'GetFunctionsFunctionIntranetConfigResult',
    'GetFunctionsFunctionTriggerInfoResult',
    'GetLayerVersionsLayerVersionResult',
    'GetLayersLayerResult',
    'GetLogsLogResult',
    'GetNamespacesNamespaceResult',
    'GetRequestStatusDataResult',
    'GetTriggersFilterResult',
    'GetTriggersTriggerResult',
]

@pulumi.output_type
class CustomDomainCertConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainCertConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainCertConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainCertConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_id: SSL Certificates ID.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        SSL Certificates ID.
        """
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class CustomDomainEndpointsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionName":
            suggest = "function_name"
        elif key == "pathMatch":
            suggest = "path_match"
        elif key == "pathRewrites":
            suggest = "path_rewrites"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainEndpointsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainEndpointsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainEndpointsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_name: _builtins.str,
                 namespace: _builtins.str,
                 path_match: _builtins.str,
                 qualifier: _builtins.str,
                 path_rewrites: Optional[Sequence['outputs.CustomDomainEndpointsConfigPathRewrite']] = None):
        """
        :param _builtins.str function_name: Function name.
        :param _builtins.str namespace: Function namespace.
        :param _builtins.str path_match: Path, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        :param _builtins.str qualifier: Function alias or version.
        :param Sequence['CustomDomainEndpointsConfigPathRewriteArgs'] path_rewrites: Path rewriting policy.
        """
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "path_match", path_match)
        pulumi.set(__self__, "qualifier", qualifier)
        if path_rewrites is not None:
            pulumi.set(__self__, "path_rewrites", path_rewrites)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        Function name.
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Function namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="pathMatch")
    def path_match(self) -> _builtins.str:
        """
        Path, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        """
        return pulumi.get(self, "path_match")

    @_builtins.property
    @pulumi.getter
    def qualifier(self) -> _builtins.str:
        """
        Function alias or version.
        """
        return pulumi.get(self, "qualifier")

    @_builtins.property
    @pulumi.getter(name="pathRewrites")
    def path_rewrites(self) -> Optional[Sequence['outputs.CustomDomainEndpointsConfigPathRewrite']]:
        """
        Path rewriting policy.
        """
        return pulumi.get(self, "path_rewrites")


@pulumi.output_type
class CustomDomainEndpointsConfigPathRewrite(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 rewrite: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str path: Path that needs to be rerouted, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        :param _builtins.str rewrite: Replacement values: such as/, /$.
        :param _builtins.str type: Matching rules, value range: WildcardRules wildcard matching, ExactRules exact matching.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "rewrite", rewrite)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path that needs to be rerouted, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def rewrite(self) -> _builtins.str:
        """
        Replacement values: such as/, /$.
        """
        return pulumi.get(self, "rewrite")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Matching rules, value range: WildcardRules wildcard matching, ExactRules exact matching.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CustomDomainWafConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wafInstanceId":
            suggest = "waf_instance_id"
        elif key == "wafOpen":
            suggest = "waf_open"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainWafConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainWafConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainWafConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 waf_instance_id: Optional[_builtins.str] = None,
                 waf_open: Optional[_builtins.str] = None):
        """
        :param _builtins.str waf_instance_id: Web Application Firewall Instance ID.
        :param _builtins.str waf_open: Whether the Web Application Firewall is turned on, value range:OPEN, CLOSE.
        """
        if waf_instance_id is not None:
            pulumi.set(__self__, "waf_instance_id", waf_instance_id)
        if waf_open is not None:
            pulumi.set(__self__, "waf_open", waf_open)

    @_builtins.property
    @pulumi.getter(name="wafInstanceId")
    def waf_instance_id(self) -> Optional[_builtins.str]:
        """
        Web Application Firewall Instance ID.
        """
        return pulumi.get(self, "waf_instance_id")

    @_builtins.property
    @pulumi.getter(name="wafOpen")
    def waf_open(self) -> Optional[_builtins.str]:
        """
        Whether the Web Application Firewall is turned on, value range:OPEN, CLOSE.
        """
        return pulumi.get(self, "waf_open")


@pulumi.output_type
class FunctionAliasRoutingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVersionMatches":
            suggest = "additional_version_matches"
        elif key == "additionalVersionWeights":
            suggest = "additional_version_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAliasRoutingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAliasRoutingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAliasRoutingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_version_matches: Optional[Sequence['outputs.FunctionAliasRoutingConfigAdditionalVersionMatch']] = None,
                 additional_version_weights: Optional[Sequence['outputs.FunctionAliasRoutingConfigAdditionalVersionWeight']] = None):
        """
        :param Sequence['FunctionAliasRoutingConfigAdditionalVersionMatchArgs'] additional_version_matches: Additional version with rule-based routing.
        :param Sequence['FunctionAliasRoutingConfigAdditionalVersionWeightArgs'] additional_version_weights: Additional version with random weight-based routing.
        """
        if additional_version_matches is not None:
            pulumi.set(__self__, "additional_version_matches", additional_version_matches)
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionMatches")
    def additional_version_matches(self) -> Optional[Sequence['outputs.FunctionAliasRoutingConfigAdditionalVersionMatch']]:
        """
        Additional version with rule-based routing.
        """
        return pulumi.get(self, "additional_version_matches")

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[Sequence['outputs.FunctionAliasRoutingConfigAdditionalVersionWeight']]:
        """
        Additional version with random weight-based routing.
        """
        return pulumi.get(self, "additional_version_weights")


@pulumi.output_type
class FunctionAliasRoutingConfigAdditionalVersionMatch(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 key: _builtins.str,
                 method: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str expression: Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
        :param _builtins.str key: Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
        :param _builtins.str method: Match method. Valid values:range: Range matchexact: exact string match.
        :param _builtins.str version: Function version name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Match method. Valid values:range: Range matchexact: exact string match.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Function version name.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class FunctionAliasRoutingConfigAdditionalVersionWeight(dict):
    def __init__(__self__, *,
                 version: _builtins.str,
                 weight: _builtins.float):
        """
        :param _builtins.str version: Function version name.
        :param _builtins.float weight: Version weight.
        """
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Function version name.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.float:
        """
        Version weight.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class FunctionCfsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cfsId":
            suggest = "cfs_id"
        elif key == "localMountDir":
            suggest = "local_mount_dir"
        elif key == "mountInsId":
            suggest = "mount_ins_id"
        elif key == "remoteMountDir":
            suggest = "remote_mount_dir"
        elif key == "userGroupId":
            suggest = "user_group_id"
        elif key == "userId":
            suggest = "user_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "mountSubnetId":
            suggest = "mount_subnet_id"
        elif key == "mountVpcId":
            suggest = "mount_vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionCfsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionCfsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionCfsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cfs_id: _builtins.str,
                 local_mount_dir: _builtins.str,
                 mount_ins_id: _builtins.str,
                 remote_mount_dir: _builtins.str,
                 user_group_id: _builtins.str,
                 user_id: _builtins.str,
                 ip_address: Optional[_builtins.str] = None,
                 mount_subnet_id: Optional[_builtins.str] = None,
                 mount_vpc_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cfs_id: File system instance ID.
        :param _builtins.str local_mount_dir: Local mount directory.
        :param _builtins.str mount_ins_id: File system mount instance ID.
        :param _builtins.str remote_mount_dir: Remote mount directory.
        :param _builtins.str user_group_id: ID of user group.
        :param _builtins.str user_id: ID of user.
        :param _builtins.str ip_address: (Readonly) File system ip address.
        :param _builtins.str mount_subnet_id: (Readonly) File system subnet ID.
        :param _builtins.str mount_vpc_id: (Readonly) File system virtual private network ID.
        """
        pulumi.set(__self__, "cfs_id", cfs_id)
        pulumi.set(__self__, "local_mount_dir", local_mount_dir)
        pulumi.set(__self__, "mount_ins_id", mount_ins_id)
        pulumi.set(__self__, "remote_mount_dir", remote_mount_dir)
        pulumi.set(__self__, "user_group_id", user_group_id)
        pulumi.set(__self__, "user_id", user_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mount_subnet_id is not None:
            pulumi.set(__self__, "mount_subnet_id", mount_subnet_id)
        if mount_vpc_id is not None:
            pulumi.set(__self__, "mount_vpc_id", mount_vpc_id)

    @_builtins.property
    @pulumi.getter(name="cfsId")
    def cfs_id(self) -> _builtins.str:
        """
        File system instance ID.
        """
        return pulumi.get(self, "cfs_id")

    @_builtins.property
    @pulumi.getter(name="localMountDir")
    def local_mount_dir(self) -> _builtins.str:
        """
        Local mount directory.
        """
        return pulumi.get(self, "local_mount_dir")

    @_builtins.property
    @pulumi.getter(name="mountInsId")
    def mount_ins_id(self) -> _builtins.str:
        """
        File system mount instance ID.
        """
        return pulumi.get(self, "mount_ins_id")

    @_builtins.property
    @pulumi.getter(name="remoteMountDir")
    def remote_mount_dir(self) -> _builtins.str:
        """
        Remote mount directory.
        """
        return pulumi.get(self, "remote_mount_dir")

    @_builtins.property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> _builtins.str:
        """
        ID of user group.
        """
        return pulumi.get(self, "user_group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        ID of user.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        (Readonly) File system ip address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="mountSubnetId")
    def mount_subnet_id(self) -> Optional[_builtins.str]:
        """
        (Readonly) File system subnet ID.
        """
        return pulumi.get(self, "mount_subnet_id")

    @_builtins.property
    @pulumi.getter(name="mountVpcId")
    def mount_vpc_id(self) -> Optional[_builtins.str]:
        """
        (Readonly) File system virtual private network ID.
        """
        return pulumi.get(self, "mount_vpc_id")


@pulumi.output_type
class FunctionEventInvokeConfigAsyncTriggerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "msgTtl":
            suggest = "msg_ttl"
        elif key == "retryConfigs":
            suggest = "retry_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionEventInvokeConfigAsyncTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionEventInvokeConfigAsyncTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionEventInvokeConfigAsyncTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 msg_ttl: _builtins.int,
                 retry_configs: Sequence['outputs.FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig']):
        """
        :param _builtins.int msg_ttl: Message retention period.
        :param Sequence['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs'] retry_configs: Async retry configuration of function upon user error.
        """
        pulumi.set(__self__, "msg_ttl", msg_ttl)
        pulumi.set(__self__, "retry_configs", retry_configs)

    @_builtins.property
    @pulumi.getter(name="msgTtl")
    def msg_ttl(self) -> _builtins.int:
        """
        Message retention period.
        """
        return pulumi.get(self, "msg_ttl")

    @_builtins.property
    @pulumi.getter(name="retryConfigs")
    def retry_configs(self) -> Sequence['outputs.FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig']:
        """
        Async retry configuration of function upon user error.
        """
        return pulumi.get(self, "retry_configs")


@pulumi.output_type
class FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryNum":
            suggest = "retry_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retry_num: _builtins.int):
        """
        :param _builtins.int retry_num: Number of retry attempts.
        """
        pulumi.set(__self__, "retry_num", retry_num)

    @_builtins.property
    @pulumi.getter(name="retryNum")
    def retry_num(self) -> _builtins.int:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "retry_num")


@pulumi.output_type
class FunctionImageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageType":
            suggest = "image_type"
        elif key == "imageUri":
            suggest = "image_uri"
        elif key == "containerImageAccelerate":
            suggest = "container_image_accelerate"
        elif key == "entryPoint":
            suggest = "entry_point"
        elif key == "imagePort":
            suggest = "image_port"
        elif key == "registryId":
            suggest = "registry_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionImageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_type: _builtins.str,
                 image_uri: _builtins.str,
                 args: Optional[_builtins.str] = None,
                 command: Optional[_builtins.str] = None,
                 container_image_accelerate: Optional[_builtins.bool] = None,
                 entry_point: Optional[_builtins.str] = None,
                 image_port: Optional[_builtins.int] = None,
                 registry_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str image_type: The image type. personal or enterprise.
        :param _builtins.str image_uri: The uri of image.
        :param _builtins.str args: the parameters of command.
        :param _builtins.str command: The command of entrypoint.
        :param _builtins.bool container_image_accelerate: Image accelerate switch.
        :param _builtins.str entry_point: The entrypoint of app.
        :param _builtins.int image_port: Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        :param _builtins.str registry_id: The registry id of TCR. When image type is enterprise, it must be set.
        """
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "image_uri", image_uri)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if container_image_accelerate is not None:
            pulumi.set(__self__, "container_image_accelerate", container_image_accelerate)
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if image_port is not None:
            pulumi.set(__self__, "image_port", image_port)
        if registry_id is not None:
            pulumi.set(__self__, "registry_id", registry_id)

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> _builtins.str:
        """
        The image type. personal or enterprise.
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> _builtins.str:
        """
        The uri of image.
        """
        return pulumi.get(self, "image_uri")

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[_builtins.str]:
        """
        the parameters of command.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        """
        The command of entrypoint.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter(name="containerImageAccelerate")
    def container_image_accelerate(self) -> Optional[_builtins.bool]:
        """
        Image accelerate switch.
        """
        return pulumi.get(self, "container_image_accelerate")

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[_builtins.str]:
        """
        The entrypoint of app.
        """
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="imagePort")
    def image_port(self) -> Optional[_builtins.int]:
        """
        Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        """
        return pulumi.get(self, "image_port")

    @_builtins.property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> Optional[_builtins.str]:
        """
        The registry id of TCR. When image type is enterprise, it must be set.
        """
        return pulumi.get(self, "registry_id")


@pulumi.output_type
class FunctionIntranetConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFixed":
            suggest = "ip_fixed"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionIntranetConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionIntranetConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionIntranetConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_fixed: _builtins.str,
                 ip_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_fixed: Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        :param Sequence[_builtins.str] ip_addresses: If fixed intranet IP is enabled, this field returns the IP list used.
        """
        pulumi.set(__self__, "ip_fixed", ip_fixed)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="ipFixed")
    def ip_fixed(self) -> _builtins.str:
        """
        Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        """
        return pulumi.get(self, "ip_fixed")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        If fixed intranet IP is enabled, this field returns the IP list used.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class FunctionLayer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layerName":
            suggest = "layer_name"
        elif key == "layerVersion":
            suggest = "layer_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionLayer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionLayer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionLayer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer_name: _builtins.str,
                 layer_version: _builtins.int):
        """
        :param _builtins.str layer_name: The name of Layer.
        :param _builtins.int layer_version: The version of layer.
        """
        pulumi.set(__self__, "layer_name", layer_name)
        pulumi.set(__self__, "layer_version", layer_version)

    @_builtins.property
    @pulumi.getter(name="layerName")
    def layer_name(self) -> _builtins.str:
        """
        The name of Layer.
        """
        return pulumi.get(self, "layer_name")

    @_builtins.property
    @pulumi.getter(name="layerVersion")
    def layer_version(self) -> _builtins.int:
        """
        The version of layer.
        """
        return pulumi.get(self, "layer_version")


@pulumi.output_type
class FunctionTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerDesc":
            suggest = "trigger_desc"
        elif key == "cosRegion":
            suggest = "cos_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 trigger_desc: _builtins.str,
                 type: _builtins.str,
                 cos_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
        :param _builtins.str trigger_desc: TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        :param _builtins.str type: Type of the SCF function trigger, support `timer`, `ckafka`, `custom_kafka`, `apigw`, `cmq`, `cos`, `mqtt`, `cls`, `clb`, `mps`, `vod`, `cm`, `eb`, `http`.
        :param _builtins.str cos_region: Region of cos bucket. if `type` is `cos`, `cos_region` is required.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trigger_desc", trigger_desc)
        pulumi.set(__self__, "type", type)
        if cos_region is not None:
            pulumi.set(__self__, "cos_region", cos_region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> _builtins.str:
        """
        TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        """
        return pulumi.get(self, "trigger_desc")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the SCF function trigger, support `timer`, `ckafka`, `custom_kafka`, `apigw`, `cmq`, `cos`, `mqtt`, `cls`, `clb`, `mps`, `vod`, `cm`, `eb`, `http`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="cosRegion")
    def cos_region(self) -> Optional[_builtins.str]:
        """
        Region of cos bucket. if `type` is `cos`, `cos_region` is required.
        """
        return pulumi.get(self, "cos_region")


@pulumi.output_type
class FunctionTriggerInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "customArgument":
            suggest = "custom_argument"
        elif key == "modifyTime":
            suggest = "modify_time"
        elif key == "triggerDesc":
            suggest = "trigger_desc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_time: Optional[_builtins.str] = None,
                 custom_argument: Optional[_builtins.str] = None,
                 enable: Optional[_builtins.bool] = None,
                 modify_time: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 trigger_desc: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: Create time of SCF function trigger.
        :param _builtins.str custom_argument: User-defined parameters of SCF function trigger.
        :param _builtins.bool enable: Whether SCF function trigger is enable.
        :param _builtins.str modify_time: Modify time of SCF function trigger.
        :param _builtins.str name: Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
        :param _builtins.str trigger_desc: TriggerDesc of SCF function trigger.
        :param _builtins.str type: Type of SCF function trigger.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if custom_argument is not None:
            pulumi.set(__self__, "custom_argument", custom_argument)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if trigger_desc is not None:
            pulumi.set(__self__, "trigger_desc", trigger_desc)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Create time of SCF function trigger.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="customArgument")
    def custom_argument(self) -> Optional[_builtins.str]:
        """
        User-defined parameters of SCF function trigger.
        """
        return pulumi.get(self, "custom_argument")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Whether SCF function trigger is enable.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[_builtins.str]:
        """
        Modify time of SCF function trigger.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> Optional[_builtins.str]:
        """
        TriggerDesc of SCF function trigger.
        """
        return pulumi.get(self, "trigger_desc")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of SCF function trigger.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LayerContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosBucketName":
            suggest = "cos_bucket_name"
        elif key == "cosBucketRegion":
            suggest = "cos_bucket_region"
        elif key == "cosObjectName":
            suggest = "cos_object_name"
        elif key == "zipFile":
            suggest = "zip_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cos_bucket_name: Optional[_builtins.str] = None,
                 cos_bucket_region: Optional[_builtins.str] = None,
                 cos_object_name: Optional[_builtins.str] = None,
                 zip_file: Optional[_builtins.str] = None):
        """
        :param _builtins.str cos_bucket_name: Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zip_file`.
        :param _builtins.str cos_bucket_region: Cos bucket region of the SCF layer, conflict with `zip_file`.
        :param _builtins.str cos_object_name: Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
        :param _builtins.str zip_file: Zip file of the SCF layer, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
        """
        if cos_bucket_name is not None:
            pulumi.set(__self__, "cos_bucket_name", cos_bucket_name)
        if cos_bucket_region is not None:
            pulumi.set(__self__, "cos_bucket_region", cos_bucket_region)
        if cos_object_name is not None:
            pulumi.set(__self__, "cos_object_name", cos_object_name)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @_builtins.property
    @pulumi.getter(name="cosBucketName")
    def cos_bucket_name(self) -> Optional[_builtins.str]:
        """
        Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_bucket_name")

    @_builtins.property
    @pulumi.getter(name="cosBucketRegion")
    def cos_bucket_region(self) -> Optional[_builtins.str]:
        """
        Cos bucket region of the SCF layer, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_bucket_region")

    @_builtins.property
    @pulumi.getter(name="cosObjectName")
    def cos_object_name(self) -> Optional[_builtins.str]:
        """
        Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_object_name")

    @_builtins.property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[_builtins.str]:
        """
        Zip file of the SCF layer, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
        """
        return pulumi.get(self, "zip_file")


@pulumi.output_type
class ProvisionedConcurrencyConfigTriggerAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerCronConfig":
            suggest = "trigger_cron_config"
        elif key == "triggerName":
            suggest = "trigger_name"
        elif key == "triggerProvisionedConcurrencyNum":
            suggest = "trigger_provisioned_concurrency_num"
        elif key == "provisionedType":
            suggest = "provisioned_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionedConcurrencyConfigTriggerAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionedConcurrencyConfigTriggerAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionedConcurrencyConfigTriggerAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_cron_config: _builtins.str,
                 trigger_name: _builtins.str,
                 trigger_provisioned_concurrency_num: _builtins.int,
                 provisioned_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str trigger_cron_config: Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.str trigger_name: Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.int trigger_provisioned_concurrency_num: Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.str provisioned_type: The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
        """
        pulumi.set(__self__, "trigger_cron_config", trigger_cron_config)
        pulumi.set(__self__, "trigger_name", trigger_name)
        pulumi.set(__self__, "trigger_provisioned_concurrency_num", trigger_provisioned_concurrency_num)
        if provisioned_type is not None:
            pulumi.set(__self__, "provisioned_type", provisioned_type)

    @_builtins.property
    @pulumi.getter(name="triggerCronConfig")
    def trigger_cron_config(self) -> _builtins.str:
        """
        Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_cron_config")

    @_builtins.property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> _builtins.str:
        """
        Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_name")

    @_builtins.property
    @pulumi.getter(name="triggerProvisionedConcurrencyNum")
    def trigger_provisioned_concurrency_num(self) -> _builtins.int:
        """
        Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_provisioned_concurrency_num")

    @_builtins.property
    @pulumi.getter(name="provisionedType")
    def provisioned_type(self) -> Optional[_builtins.str]:
        """
        The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
        """
        return pulumi.get(self, "provisioned_type")


@pulumi.output_type
class GetAccountInfoAccountLimitResult(dict):
    def __init__(__self__, *,
                 namespaces: Sequence['outputs.GetAccountInfoAccountLimitNamespaceResult'],
                 namespaces_count: _builtins.int):
        """
        :param Sequence['GetAccountInfoAccountLimitNamespaceArgs'] namespaces: Namespace name.
        :param _builtins.int namespaces_count: Number of namespaces.
        """
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "namespaces_count", namespaces_count)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Sequence['outputs.GetAccountInfoAccountLimitNamespaceResult']:
        """
        Namespace name.
        """
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter(name="namespacesCount")
    def namespaces_count(self) -> _builtins.int:
        """
        Number of namespaces.
        """
        return pulumi.get(self, "namespaces_count")


@pulumi.output_type
class GetAccountInfoAccountLimitNamespaceResult(dict):
    def __init__(__self__, *,
                 concurrent_executions: _builtins.int,
                 functions_count: _builtins.int,
                 init_timeout_limit: _builtins.int,
                 max_msg_ttl: _builtins.int,
                 min_msg_ttl: _builtins.int,
                 namespace: _builtins.str,
                 retry_num_limit: _builtins.int,
                 test_model_limit: _builtins.int,
                 timeout_limit: _builtins.int,
                 triggers: Sequence['outputs.GetAccountInfoAccountLimitNamespaceTriggerResult']):
        """
        :param _builtins.int concurrent_executions: Concurrency.
        :param _builtins.int functions_count: Number of functions in namespace.
        :param _builtins.int init_timeout_limit: Initialization timeout limit.
        :param _builtins.int max_msg_ttl: Upper limit of message retention time for async retry.
        :param _builtins.int min_msg_ttl: Lower limit of message retention time for async retry.
        :param _builtins.str namespace: Namespace name.
        :param _builtins.int retry_num_limit: Limit of async retry attempt quantity.
        :param _builtins.int test_model_limit: Test event limit Note: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.int timeout_limit: Timeout limit.
        :param Sequence['GetAccountInfoAccountLimitNamespaceTriggerArgs'] triggers: Trigger information.
        """
        pulumi.set(__self__, "concurrent_executions", concurrent_executions)
        pulumi.set(__self__, "functions_count", functions_count)
        pulumi.set(__self__, "init_timeout_limit", init_timeout_limit)
        pulumi.set(__self__, "max_msg_ttl", max_msg_ttl)
        pulumi.set(__self__, "min_msg_ttl", min_msg_ttl)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "retry_num_limit", retry_num_limit)
        pulumi.set(__self__, "test_model_limit", test_model_limit)
        pulumi.set(__self__, "timeout_limit", timeout_limit)
        pulumi.set(__self__, "triggers", triggers)

    @_builtins.property
    @pulumi.getter(name="concurrentExecutions")
    def concurrent_executions(self) -> _builtins.int:
        """
        Concurrency.
        """
        return pulumi.get(self, "concurrent_executions")

    @_builtins.property
    @pulumi.getter(name="functionsCount")
    def functions_count(self) -> _builtins.int:
        """
        Number of functions in namespace.
        """
        return pulumi.get(self, "functions_count")

    @_builtins.property
    @pulumi.getter(name="initTimeoutLimit")
    def init_timeout_limit(self) -> _builtins.int:
        """
        Initialization timeout limit.
        """
        return pulumi.get(self, "init_timeout_limit")

    @_builtins.property
    @pulumi.getter(name="maxMsgTtl")
    def max_msg_ttl(self) -> _builtins.int:
        """
        Upper limit of message retention time for async retry.
        """
        return pulumi.get(self, "max_msg_ttl")

    @_builtins.property
    @pulumi.getter(name="minMsgTtl")
    def min_msg_ttl(self) -> _builtins.int:
        """
        Lower limit of message retention time for async retry.
        """
        return pulumi.get(self, "min_msg_ttl")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="retryNumLimit")
    def retry_num_limit(self) -> _builtins.int:
        """
        Limit of async retry attempt quantity.
        """
        return pulumi.get(self, "retry_num_limit")

    @_builtins.property
    @pulumi.getter(name="testModelLimit")
    def test_model_limit(self) -> _builtins.int:
        """
        Test event limit Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "test_model_limit")

    @_builtins.property
    @pulumi.getter(name="timeoutLimit")
    def timeout_limit(self) -> _builtins.int:
        """
        Timeout limit.
        """
        return pulumi.get(self, "timeout_limit")

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.GetAccountInfoAccountLimitNamespaceTriggerResult']:
        """
        Trigger information.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GetAccountInfoAccountLimitNamespaceTriggerResult(dict):
    def __init__(__self__, *,
                 apigw: _builtins.int,
                 ckafka: _builtins.int,
                 clb: _builtins.int,
                 cls: _builtins.int,
                 cm: _builtins.int,
                 cmq: _builtins.int,
                 cos: _builtins.int,
                 eb: _builtins.int,
                 mps: _builtins.int,
                 timer: _builtins.int,
                 total: _builtins.int,
                 vod: _builtins.int):
        """
        :param _builtins.int apigw: Number of API Gateway triggers.
        :param _builtins.int ckafka: Number of CKafka triggers.
        :param _builtins.int clb: Number of CLB triggers.
        :param _builtins.int cls: Number of CLS triggers.
        :param _builtins.int cm: Number of CM triggers.
        :param _builtins.int cmq: Number of CMQ triggers.
        :param _builtins.int cos: Number of COS triggers.
        :param _builtins.int eb: Number of EventBridge triggers Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int mps: Number of MPS triggers.
        :param _builtins.int timer: Number of timer triggers.
        :param _builtins.int total: Total number of triggers.
        :param _builtins.int vod: Number of VOD triggers.
        """
        pulumi.set(__self__, "apigw", apigw)
        pulumi.set(__self__, "ckafka", ckafka)
        pulumi.set(__self__, "clb", clb)
        pulumi.set(__self__, "cls", cls)
        pulumi.set(__self__, "cm", cm)
        pulumi.set(__self__, "cmq", cmq)
        pulumi.set(__self__, "cos", cos)
        pulumi.set(__self__, "eb", eb)
        pulumi.set(__self__, "mps", mps)
        pulumi.set(__self__, "timer", timer)
        pulumi.set(__self__, "total", total)
        pulumi.set(__self__, "vod", vod)

    @_builtins.property
    @pulumi.getter
    def apigw(self) -> _builtins.int:
        """
        Number of API Gateway triggers.
        """
        return pulumi.get(self, "apigw")

    @_builtins.property
    @pulumi.getter
    def ckafka(self) -> _builtins.int:
        """
        Number of CKafka triggers.
        """
        return pulumi.get(self, "ckafka")

    @_builtins.property
    @pulumi.getter
    def clb(self) -> _builtins.int:
        """
        Number of CLB triggers.
        """
        return pulumi.get(self, "clb")

    @_builtins.property
    @pulumi.getter
    def cls(self) -> _builtins.int:
        """
        Number of CLS triggers.
        """
        return pulumi.get(self, "cls")

    @_builtins.property
    @pulumi.getter
    def cm(self) -> _builtins.int:
        """
        Number of CM triggers.
        """
        return pulumi.get(self, "cm")

    @_builtins.property
    @pulumi.getter
    def cmq(self) -> _builtins.int:
        """
        Number of CMQ triggers.
        """
        return pulumi.get(self, "cmq")

    @_builtins.property
    @pulumi.getter
    def cos(self) -> _builtins.int:
        """
        Number of COS triggers.
        """
        return pulumi.get(self, "cos")

    @_builtins.property
    @pulumi.getter
    def eb(self) -> _builtins.int:
        """
        Number of EventBridge triggers Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "eb")

    @_builtins.property
    @pulumi.getter
    def mps(self) -> _builtins.int:
        """
        Number of MPS triggers.
        """
        return pulumi.get(self, "mps")

    @_builtins.property
    @pulumi.getter
    def timer(self) -> _builtins.int:
        """
        Number of timer triggers.
        """
        return pulumi.get(self, "timer")

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Total number of triggers.
        """
        return pulumi.get(self, "total")

    @_builtins.property
    @pulumi.getter
    def vod(self) -> _builtins.int:
        """
        Number of VOD triggers.
        """
        return pulumi.get(self, "vod")


@pulumi.output_type
class GetAccountInfoAccountUsageResult(dict):
    def __init__(__self__, *,
                 namespaces: Sequence['outputs.GetAccountInfoAccountUsageNamespaceResult'],
                 namespaces_count: _builtins.int,
                 total_allocated_concurrency_mem: _builtins.int,
                 total_concurrency_mem: _builtins.int,
                 user_concurrency_mem_limit: _builtins.int):
        """
        :param Sequence['GetAccountInfoAccountUsageNamespaceArgs'] namespaces: Namespace name.
        :param _builtins.int namespaces_count: Number of namespaces.
        :param _builtins.int total_allocated_concurrency_mem: Quota of configured user concurrency memory in the current region.
        :param _builtins.int total_concurrency_mem: Upper limit of user concurrency memory in the current region.
        :param _builtins.int user_concurrency_mem_limit: Quota of account concurrency actually configured by user.
        """
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "namespaces_count", namespaces_count)
        pulumi.set(__self__, "total_allocated_concurrency_mem", total_allocated_concurrency_mem)
        pulumi.set(__self__, "total_concurrency_mem", total_concurrency_mem)
        pulumi.set(__self__, "user_concurrency_mem_limit", user_concurrency_mem_limit)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Sequence['outputs.GetAccountInfoAccountUsageNamespaceResult']:
        """
        Namespace name.
        """
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter(name="namespacesCount")
    def namespaces_count(self) -> _builtins.int:
        """
        Number of namespaces.
        """
        return pulumi.get(self, "namespaces_count")

    @_builtins.property
    @pulumi.getter(name="totalAllocatedConcurrencyMem")
    def total_allocated_concurrency_mem(self) -> _builtins.int:
        """
        Quota of configured user concurrency memory in the current region.
        """
        return pulumi.get(self, "total_allocated_concurrency_mem")

    @_builtins.property
    @pulumi.getter(name="totalConcurrencyMem")
    def total_concurrency_mem(self) -> _builtins.int:
        """
        Upper limit of user concurrency memory in the current region.
        """
        return pulumi.get(self, "total_concurrency_mem")

    @_builtins.property
    @pulumi.getter(name="userConcurrencyMemLimit")
    def user_concurrency_mem_limit(self) -> _builtins.int:
        """
        Quota of account concurrency actually configured by user.
        """
        return pulumi.get(self, "user_concurrency_mem_limit")


@pulumi.output_type
class GetAccountInfoAccountUsageNamespaceResult(dict):
    def __init__(__self__, *,
                 functions: Sequence[_builtins.str],
                 functions_count: _builtins.int,
                 namespace: _builtins.str,
                 total_allocated_concurrency_mem: _builtins.int,
                 total_allocated_provisioned_mem: _builtins.int,
                 total_concurrency_mem: _builtins.int):
        """
        :param Sequence[_builtins.str] functions: Function array.
        :param _builtins.int functions_count: Number of functions in namespace.
        :param _builtins.str namespace: Namespace name.
        :param _builtins.int total_allocated_concurrency_mem: Quota of configured user concurrency memory in the current region.
        :param _builtins.int total_allocated_provisioned_mem: Provisioned concurrency usage of the namespace Note: This field may return null, indicating that no valid value can be obtained.
        :param _builtins.int total_concurrency_mem: Upper limit of user concurrency memory in the current region.
        """
        pulumi.set(__self__, "functions", functions)
        pulumi.set(__self__, "functions_count", functions_count)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "total_allocated_concurrency_mem", total_allocated_concurrency_mem)
        pulumi.set(__self__, "total_allocated_provisioned_mem", total_allocated_provisioned_mem)
        pulumi.set(__self__, "total_concurrency_mem", total_concurrency_mem)

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Sequence[_builtins.str]:
        """
        Function array.
        """
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter(name="functionsCount")
    def functions_count(self) -> _builtins.int:
        """
        Number of functions in namespace.
        """
        return pulumi.get(self, "functions_count")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="totalAllocatedConcurrencyMem")
    def total_allocated_concurrency_mem(self) -> _builtins.int:
        """
        Quota of configured user concurrency memory in the current region.
        """
        return pulumi.get(self, "total_allocated_concurrency_mem")

    @_builtins.property
    @pulumi.getter(name="totalAllocatedProvisionedMem")
    def total_allocated_provisioned_mem(self) -> _builtins.int:
        """
        Provisioned concurrency usage of the namespace Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "total_allocated_provisioned_mem")

    @_builtins.property
    @pulumi.getter(name="totalConcurrencyMem")
    def total_concurrency_mem(self) -> _builtins.int:
        """
        Upper limit of user concurrency memory in the current region.
        """
        return pulumi.get(self, "total_concurrency_mem")


@pulumi.output_type
class GetAsyncEventManagementEventListResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 invoke_request_id: _builtins.str,
                 invoke_type: _builtins.str,
                 qualifier: _builtins.str,
                 start_time: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str end_time: Invocation end time in the format of %Y-%m-%d %H:%M:%S.%f.
        :param _builtins.str invoke_request_id: Filter (event invocation request ID).
        :param _builtins.str invoke_type: Filter (invocation type list), Values: CMQ, CKAFKA_TRIGGER, APIGW, COS, TRIGGER_TIMER, MPS_TRIGGER, CLS_TRIGGER, OTHERS.
        :param _builtins.str qualifier: Filter (function version).
        :param _builtins.str start_time: Invocation start time in the format of %Y-%m-%d %H:%M:%S.%f.
        :param _builtins.str status: Filter (event status list), Values: RUNNING, FINISHED, ABORTED, FAILED.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "invoke_request_id", invoke_request_id)
        pulumi.set(__self__, "invoke_type", invoke_type)
        pulumi.set(__self__, "qualifier", qualifier)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Invocation end time in the format of %Y-%m-%d %H:%M:%S.%f.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="invokeRequestId")
    def invoke_request_id(self) -> _builtins.str:
        """
        Filter (event invocation request ID).
        """
        return pulumi.get(self, "invoke_request_id")

    @_builtins.property
    @pulumi.getter(name="invokeType")
    def invoke_type(self) -> _builtins.str:
        """
        Filter (invocation type list), Values: CMQ, CKAFKA_TRIGGER, APIGW, COS, TRIGGER_TIMER, MPS_TRIGGER, CLS_TRIGGER, OTHERS.
        """
        return pulumi.get(self, "invoke_type")

    @_builtins.property
    @pulumi.getter
    def qualifier(self) -> _builtins.str:
        """
        Filter (function version).
        """
        return pulumi.get(self, "qualifier")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Invocation start time in the format of %Y-%m-%d %H:%M:%S.%f.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Filter (event status list), Values: RUNNING, FINISHED, ABORTED, FAILED.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAsyncEventStatusResultResult(dict):
    def __init__(__self__, *,
                 invoke_request_id: _builtins.str,
                 status: _builtins.str,
                 status_code: _builtins.int):
        """
        :param _builtins.str invoke_request_id: ID of the async execution request.
        :param _builtins.str status: Async event status. Values: `RUNNING` (running); `FINISHED` (invoked successfully); `ABORTED` (invocation ended); `FAILED` (invocation failed).
        :param _builtins.int status_code: Request status code.
        """
        pulumi.set(__self__, "invoke_request_id", invoke_request_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="invokeRequestId")
    def invoke_request_id(self) -> _builtins.str:
        """
        ID of the async execution request.
        """
        return pulumi.get(self, "invoke_request_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Async event status. Values: `RUNNING` (running); `FINISHED` (invoked successfully); `ABORTED` (invocation ended); `FAILED` (invocation failed).
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> _builtins.int:
        """
        Request status code.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetFunctionAliasesAliasResult(dict):
    def __init__(__self__, *,
                 add_time: _builtins.str,
                 description: _builtins.str,
                 function_version: _builtins.str,
                 mod_time: _builtins.str,
                 name: _builtins.str,
                 routing_configs: Sequence['outputs.GetFunctionAliasesAliasRoutingConfigResult']):
        """
        :param _builtins.str add_time: Creation timeNote: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.str description: DescriptionNote: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.str function_version: If this parameter is provided, only aliases associated with this function version will be returned.
        :param _builtins.str mod_time: Update timeNote: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.str name: Alias name.
        :param Sequence['GetFunctionAliasesAliasRoutingConfigArgs'] routing_configs: Routing information of aliasNote: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "add_time", add_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "function_version", function_version)
        pulumi.set(__self__, "mod_time", mod_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routing_configs", routing_configs)

    @_builtins.property
    @pulumi.getter(name="addTime")
    def add_time(self) -> _builtins.str:
        """
        Creation timeNote: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "add_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        DescriptionNote: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="functionVersion")
    def function_version(self) -> _builtins.str:
        """
        If this parameter is provided, only aliases associated with this function version will be returned.
        """
        return pulumi.get(self, "function_version")

    @_builtins.property
    @pulumi.getter(name="modTime")
    def mod_time(self) -> _builtins.str:
        """
        Update timeNote: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "mod_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Alias name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="routingConfigs")
    def routing_configs(self) -> Sequence['outputs.GetFunctionAliasesAliasRoutingConfigResult']:
        """
        Routing information of aliasNote: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "routing_configs")


@pulumi.output_type
class GetFunctionAliasesAliasRoutingConfigResult(dict):
    def __init__(__self__, *,
                 addition_version_matchs: Sequence['outputs.GetFunctionAliasesAliasRoutingConfigAdditionVersionMatchResult'],
                 additional_version_weights: Sequence['outputs.GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeightResult']):
        """
        :param Sequence['GetFunctionAliasesAliasRoutingConfigAdditionVersionMatchArgs'] addition_version_matchs: Additional version with rule-based routing.
        :param Sequence['GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeightArgs'] additional_version_weights: Additional version with random weight-based routing.
        """
        pulumi.set(__self__, "addition_version_matchs", addition_version_matchs)
        pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionVersionMatchs")
    def addition_version_matchs(self) -> Sequence['outputs.GetFunctionAliasesAliasRoutingConfigAdditionVersionMatchResult']:
        """
        Additional version with rule-based routing.
        """
        return pulumi.get(self, "addition_version_matchs")

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Sequence['outputs.GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeightResult']:
        """
        Additional version with random weight-based routing.
        """
        return pulumi.get(self, "additional_version_weights")


@pulumi.output_type
class GetFunctionAliasesAliasRoutingConfigAdditionVersionMatchResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 key: _builtins.str,
                 method: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str expression: Rule requirements for range match:It should be described in an open or closed range, i.e., `(a,b)` or `[a,b]`, where both a and b are integersRule requirements for exact match:Exact string match.
        :param _builtins.str key: Matching rule key. When the API is called, pass in the `key` to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for `key` and pass in `RoutingKey:{User:value}` when invoking a function through `invoke` for invocation based on rule matching.
        :param _builtins.str method: Match method. Valid values:range: range matchexact: exact string match.
        :param _builtins.str version: Function version name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Rule requirements for range match:It should be described in an open or closed range, i.e., `(a,b)` or `[a,b]`, where both a and b are integersRule requirements for exact match:Exact string match.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Matching rule key. When the API is called, pass in the `key` to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for `key` and pass in `RoutingKey:{User:value}` when invoking a function through `invoke` for invocation based on rule matching.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Match method. Valid values:range: range matchexact: exact string match.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Function version name.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeightResult(dict):
    def __init__(__self__, *,
                 version: _builtins.str,
                 weight: _builtins.float):
        """
        :param _builtins.str version: Function version name.
        :param _builtins.float weight: Version weight.
        """
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Function version name.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.float:
        """
        Version weight.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetFunctionVersionsVersionResult(dict):
    def __init__(__self__, *,
                 add_time: _builtins.str,
                 description: _builtins.str,
                 mod_time: _builtins.str,
                 status: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str add_time: The creation timeNote: This field may return null, indicating that no valid value was found.
        :param _builtins.str description: Version descriptionNote: This field may return null, indicating that no valid values is found.
        :param _builtins.str mod_time: Update timeNote: This field may return null, indicating that no valid value was found.
        :param _builtins.str status: Version statusNote: this field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.str version: Function version name.
        """
        pulumi.set(__self__, "add_time", add_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "mod_time", mod_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="addTime")
    def add_time(self) -> _builtins.str:
        """
        The creation timeNote: This field may return null, indicating that no valid value was found.
        """
        return pulumi.get(self, "add_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Version descriptionNote: This field may return null, indicating that no valid values is found.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="modTime")
    def mod_time(self) -> _builtins.str:
        """
        Update timeNote: This field may return null, indicating that no valid value was found.
        """
        return pulumi.get(self, "mod_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Version statusNote: this field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Function version name.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetFunctionsFunctionResult(dict):
    def __init__(__self__, *,
                 async_run_enable: _builtins.str,
                 cls_logset_id: _builtins.str,
                 cls_topic_id: _builtins.str,
                 code_error: _builtins.str,
                 code_result: _builtins.str,
                 code_size: _builtins.int,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 dns_cache: _builtins.bool,
                 eip_fixed: _builtins.bool,
                 eips: Sequence[_builtins.str],
                 enable_eip_config: _builtins.bool,
                 enable_public_net: _builtins.bool,
                 environment: Mapping[str, _builtins.str],
                 err_no: _builtins.int,
                 handler: _builtins.str,
                 host: _builtins.str,
                 image_configs: Sequence['outputs.GetFunctionsFunctionImageConfigResult'],
                 install_dependency: _builtins.bool,
                 intranet_configs: Sequence['outputs.GetFunctionsFunctionIntranetConfigResult'],
                 l5_enable: _builtins.bool,
                 mem_size: _builtins.int,
                 modify_time: _builtins.str,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 role: _builtins.str,
                 runtime: _builtins.str,
                 status: _builtins.str,
                 status_desc: _builtins.str,
                 subnet_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 timeout: _builtins.int,
                 trigger_infos: Sequence['outputs.GetFunctionsFunctionTriggerInfoResult'],
                 vip: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str async_run_enable: Whether asynchronous attribute is enabled.
        :param _builtins.str cls_logset_id: CLS logset ID of the SCF function.
        :param _builtins.str cls_topic_id: CLS topic ID of the SCF function.
        :param _builtins.str code_error: Code error of the SCF function.
        :param _builtins.str code_result: Code result of the SCF function.
        :param _builtins.int code_size: Code size of the SCF function.
        :param _builtins.str create_time: Create time of the SCF function trigger.
        :param _builtins.str description: Description of the SCF function to be queried.
        :param _builtins.bool dns_cache: Whether to enable Dns caching capability, only the EVENT function is supported. Default is false.
        :param _builtins.bool eip_fixed: Whether EIP is a fixed IP.
        :param Sequence[_builtins.str] eips: EIP list of the SCF function.
        :param _builtins.bool enable_eip_config: Whether the EIP enabled.
        :param _builtins.bool enable_public_net: Whether the public net enabled.
        :param Mapping[str, _builtins.str] environment: Environment variable of the SCF function.
        :param _builtins.int err_no: Errno of the SCF function.
        :param _builtins.str handler: Handler of the SCF function.
        :param _builtins.str host: Host of the SCF function.
        :param Sequence['GetFunctionsFunctionImageConfigArgs'] image_configs: Image of the SCF function, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`, `zip_file`.
        :param _builtins.bool install_dependency: Whether to automatically install dependencies.
        :param Sequence['GetFunctionsFunctionIntranetConfigArgs'] intranet_configs: Intranet access configuration.
        :param _builtins.bool l5_enable: Whether to enable L5.
        :param _builtins.int mem_size: Memory size of the SCF function runtime, unit is M.
        :param _builtins.str modify_time: Modify time of the SCF function trigger.
        :param _builtins.str name: Name of the SCF function to be queried.
        :param _builtins.str namespace: Namespace of the SCF function to be queried.
        :param _builtins.str role: CAM role of the SCF function.
        :param _builtins.str runtime: Runtime of the SCF function.
        :param _builtins.str status: Status of the SCF function.
        :param _builtins.str status_desc: Status description of the SCF function.
        :param _builtins.str subnet_id: Subnet ID of the SCF function.
        :param Mapping[str, _builtins.str] tags: Tags of the SCF function to be queried, can use up to 10 tags.
        :param _builtins.int timeout: Timeout of the SCF function maximum execution time, unit is second.
        :param Sequence['GetFunctionsFunctionTriggerInfoArgs'] trigger_infos: Trigger details list the SCF function. Each element contains the following attributes:
        :param _builtins.str vip: Vip of the SCF function.
        :param _builtins.str vpc_id: VPC ID of the SCF function.
        """
        pulumi.set(__self__, "async_run_enable", async_run_enable)
        pulumi.set(__self__, "cls_logset_id", cls_logset_id)
        pulumi.set(__self__, "cls_topic_id", cls_topic_id)
        pulumi.set(__self__, "code_error", code_error)
        pulumi.set(__self__, "code_result", code_result)
        pulumi.set(__self__, "code_size", code_size)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dns_cache", dns_cache)
        pulumi.set(__self__, "eip_fixed", eip_fixed)
        pulumi.set(__self__, "eips", eips)
        pulumi.set(__self__, "enable_eip_config", enable_eip_config)
        pulumi.set(__self__, "enable_public_net", enable_public_net)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "err_no", err_no)
        pulumi.set(__self__, "handler", handler)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "image_configs", image_configs)
        pulumi.set(__self__, "install_dependency", install_dependency)
        pulumi.set(__self__, "intranet_configs", intranet_configs)
        pulumi.set(__self__, "l5_enable", l5_enable)
        pulumi.set(__self__, "mem_size", mem_size)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "runtime", runtime)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_desc", status_desc)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "trigger_infos", trigger_infos)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="asyncRunEnable")
    def async_run_enable(self) -> _builtins.str:
        """
        Whether asynchronous attribute is enabled.
        """
        return pulumi.get(self, "async_run_enable")

    @_builtins.property
    @pulumi.getter(name="clsLogsetId")
    def cls_logset_id(self) -> _builtins.str:
        """
        CLS logset ID of the SCF function.
        """
        return pulumi.get(self, "cls_logset_id")

    @_builtins.property
    @pulumi.getter(name="clsTopicId")
    def cls_topic_id(self) -> _builtins.str:
        """
        CLS topic ID of the SCF function.
        """
        return pulumi.get(self, "cls_topic_id")

    @_builtins.property
    @pulumi.getter(name="codeError")
    def code_error(self) -> _builtins.str:
        """
        Code error of the SCF function.
        """
        return pulumi.get(self, "code_error")

    @_builtins.property
    @pulumi.getter(name="codeResult")
    def code_result(self) -> _builtins.str:
        """
        Code result of the SCF function.
        """
        return pulumi.get(self, "code_result")

    @_builtins.property
    @pulumi.getter(name="codeSize")
    def code_size(self) -> _builtins.int:
        """
        Code size of the SCF function.
        """
        return pulumi.get(self, "code_size")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create time of the SCF function trigger.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the SCF function to be queried.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dnsCache")
    def dns_cache(self) -> _builtins.bool:
        """
        Whether to enable Dns caching capability, only the EVENT function is supported. Default is false.
        """
        return pulumi.get(self, "dns_cache")

    @_builtins.property
    @pulumi.getter(name="eipFixed")
    def eip_fixed(self) -> _builtins.bool:
        """
        Whether EIP is a fixed IP.
        """
        return pulumi.get(self, "eip_fixed")

    @_builtins.property
    @pulumi.getter
    def eips(self) -> Sequence[_builtins.str]:
        """
        EIP list of the SCF function.
        """
        return pulumi.get(self, "eips")

    @_builtins.property
    @pulumi.getter(name="enableEipConfig")
    def enable_eip_config(self) -> _builtins.bool:
        """
        Whether the EIP enabled.
        """
        return pulumi.get(self, "enable_eip_config")

    @_builtins.property
    @pulumi.getter(name="enablePublicNet")
    def enable_public_net(self) -> _builtins.bool:
        """
        Whether the public net enabled.
        """
        return pulumi.get(self, "enable_public_net")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Mapping[str, _builtins.str]:
        """
        Environment variable of the SCF function.
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="errNo")
    def err_no(self) -> _builtins.int:
        """
        Errno of the SCF function.
        """
        return pulumi.get(self, "err_no")

    @_builtins.property
    @pulumi.getter
    def handler(self) -> _builtins.str:
        """
        Handler of the SCF function.
        """
        return pulumi.get(self, "handler")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host of the SCF function.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="imageConfigs")
    def image_configs(self) -> Sequence['outputs.GetFunctionsFunctionImageConfigResult']:
        """
        Image of the SCF function, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`, `zip_file`.
        """
        return pulumi.get(self, "image_configs")

    @_builtins.property
    @pulumi.getter(name="installDependency")
    def install_dependency(self) -> _builtins.bool:
        """
        Whether to automatically install dependencies.
        """
        return pulumi.get(self, "install_dependency")

    @_builtins.property
    @pulumi.getter(name="intranetConfigs")
    def intranet_configs(self) -> Sequence['outputs.GetFunctionsFunctionIntranetConfigResult']:
        """
        Intranet access configuration.
        """
        return pulumi.get(self, "intranet_configs")

    @_builtins.property
    @pulumi.getter(name="l5Enable")
    def l5_enable(self) -> _builtins.bool:
        """
        Whether to enable L5.
        """
        return pulumi.get(self, "l5_enable")

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> _builtins.int:
        """
        Memory size of the SCF function runtime, unit is M.
        """
        return pulumi.get(self, "mem_size")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        Modify time of the SCF function trigger.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the SCF function to be queried.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Namespace of the SCF function to be queried.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        CAM role of the SCF function.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> _builtins.str:
        """
        Runtime of the SCF function.
        """
        return pulumi.get(self, "runtime")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the SCF function.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusDesc")
    def status_desc(self) -> _builtins.str:
        """
        Status description of the SCF function.
        """
        return pulumi.get(self, "status_desc")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Subnet ID of the SCF function.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Tags of the SCF function to be queried, can use up to 10 tags.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        Timeout of the SCF function maximum execution time, unit is second.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="triggerInfos")
    def trigger_infos(self) -> Sequence['outputs.GetFunctionsFunctionTriggerInfoResult']:
        """
        Trigger details list the SCF function. Each element contains the following attributes:
        """
        return pulumi.get(self, "trigger_infos")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> _builtins.str:
        """
        Vip of the SCF function.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        VPC ID of the SCF function.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetFunctionsFunctionImageConfigResult(dict):
    def __init__(__self__, *,
                 args: _builtins.str,
                 command: _builtins.str,
                 container_image_accelerate: _builtins.bool,
                 entry_point: _builtins.str,
                 image_port: _builtins.int,
                 image_type: _builtins.str,
                 image_uri: _builtins.str,
                 registry_id: _builtins.str):
        """
        :param _builtins.str args: the parameters of command.
        :param _builtins.str command: The command of entrypoint.
        :param _builtins.bool container_image_accelerate: Image accelerate switch.
        :param _builtins.str entry_point: The entrypoint of app.
        :param _builtins.int image_port: Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        :param _builtins.str image_type: The image type. personal or enterprise.
        :param _builtins.str image_uri: The uri of image.
        :param _builtins.str registry_id: The registry id of TCR. When image type is enterprise, it must be set.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "container_image_accelerate", container_image_accelerate)
        pulumi.set(__self__, "entry_point", entry_point)
        pulumi.set(__self__, "image_port", image_port)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "image_uri", image_uri)
        pulumi.set(__self__, "registry_id", registry_id)

    @_builtins.property
    @pulumi.getter
    def args(self) -> _builtins.str:
        """
        the parameters of command.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def command(self) -> _builtins.str:
        """
        The command of entrypoint.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter(name="containerImageAccelerate")
    def container_image_accelerate(self) -> _builtins.bool:
        """
        Image accelerate switch.
        """
        return pulumi.get(self, "container_image_accelerate")

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> _builtins.str:
        """
        The entrypoint of app.
        """
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="imagePort")
    def image_port(self) -> _builtins.int:
        """
        Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        """
        return pulumi.get(self, "image_port")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> _builtins.str:
        """
        The image type. personal or enterprise.
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> _builtins.str:
        """
        The uri of image.
        """
        return pulumi.get(self, "image_uri")

    @_builtins.property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> _builtins.str:
        """
        The registry id of TCR. When image type is enterprise, it must be set.
        """
        return pulumi.get(self, "registry_id")


@pulumi.output_type
class GetFunctionsFunctionIntranetConfigResult(dict):
    def __init__(__self__, *,
                 ip_addresses: Sequence[_builtins.str],
                 ip_fixed: _builtins.str):
        """
        :param Sequence[_builtins.str] ip_addresses: If fixed intranet IP is enabled, this field returns the IP list used.
        :param _builtins.str ip_fixed: Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        """
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "ip_fixed", ip_fixed)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        """
        If fixed intranet IP is enabled, this field returns the IP list used.
        """
        return pulumi.get(self, "ip_addresses")

    @_builtins.property
    @pulumi.getter(name="ipFixed")
    def ip_fixed(self) -> _builtins.str:
        """
        Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        """
        return pulumi.get(self, "ip_fixed")


@pulumi.output_type
class GetFunctionsFunctionTriggerInfoResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 custom_argument: _builtins.str,
                 enable: _builtins.bool,
                 modify_time: _builtins.str,
                 name: _builtins.str,
                 trigger_desc: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str create_time: Create time of the SCF function trigger.
        :param _builtins.str custom_argument: user-defined parameter of the SCF function trigger.
        :param _builtins.bool enable: Whether to enable SCF function trigger.
        :param _builtins.str modify_time: Modify time of the SCF function trigger.
        :param _builtins.str name: Name of the SCF function to be queried.
        :param _builtins.str trigger_desc: TriggerDesc of the SCF function trigger.
        :param _builtins.str type: Type of the SCF function trigger.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "custom_argument", custom_argument)
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trigger_desc", trigger_desc)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create time of the SCF function trigger.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="customArgument")
    def custom_argument(self) -> _builtins.str:
        """
        user-defined parameter of the SCF function trigger.
        """
        return pulumi.get(self, "custom_argument")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Whether to enable SCF function trigger.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        Modify time of the SCF function trigger.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the SCF function to be queried.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> _builtins.str:
        """
        TriggerDesc of the SCF function trigger.
        """
        return pulumi.get(self, "trigger_desc")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the SCF function trigger.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLayerVersionsLayerVersionResult(dict):
    def __init__(__self__, *,
                 add_time: _builtins.str,
                 compatible_runtimes: Sequence[_builtins.str],
                 description: _builtins.str,
                 layer_name: _builtins.str,
                 layer_version: _builtins.int,
                 license_info: _builtins.str,
                 stamp: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str add_time: Creation time.
        :param Sequence[_builtins.str] compatible_runtimes: Runtime applicable to a versionNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str description: Version descriptionNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str layer_name: Layer name.
        :param _builtins.int layer_version: Version number.
        :param _builtins.str license_info: License informationNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str stamp: StampNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str status: Current status of specific layer version. For valid values, please see [here](https://intl.cloud.tencent.com/document/product/583/47175?from_cn_redirect=1#.E5.B1.82.EF.BC.88layer.EF.BC.89.E7.8A.B6.E6.80.81).
        """
        pulumi.set(__self__, "add_time", add_time)
        pulumi.set(__self__, "compatible_runtimes", compatible_runtimes)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "layer_name", layer_name)
        pulumi.set(__self__, "layer_version", layer_version)
        pulumi.set(__self__, "license_info", license_info)
        pulumi.set(__self__, "stamp", stamp)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="addTime")
    def add_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "add_time")

    @_builtins.property
    @pulumi.getter(name="compatibleRuntimes")
    def compatible_runtimes(self) -> Sequence[_builtins.str]:
        """
        Runtime applicable to a versionNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "compatible_runtimes")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Version descriptionNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="layerName")
    def layer_name(self) -> _builtins.str:
        """
        Layer name.
        """
        return pulumi.get(self, "layer_name")

    @_builtins.property
    @pulumi.getter(name="layerVersion")
    def layer_version(self) -> _builtins.int:
        """
        Version number.
        """
        return pulumi.get(self, "layer_version")

    @_builtins.property
    @pulumi.getter(name="licenseInfo")
    def license_info(self) -> _builtins.str:
        """
        License informationNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "license_info")

    @_builtins.property
    @pulumi.getter
    def stamp(self) -> _builtins.str:
        """
        StampNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "stamp")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current status of specific layer version. For valid values, please see [here](https://intl.cloud.tencent.com/document/product/583/47175?from_cn_redirect=1#.E5.B1.82.EF.BC.88layer.EF.BC.89.E7.8A.B6.E6.80.81).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLayersLayerResult(dict):
    def __init__(__self__, *,
                 add_time: _builtins.str,
                 compatible_runtimes: Sequence[_builtins.str],
                 description: _builtins.str,
                 layer_name: _builtins.str,
                 layer_version: _builtins.int,
                 license_info: _builtins.str,
                 stamp: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str add_time: Creation time.
        :param Sequence[_builtins.str] compatible_runtimes: Runtime applicable to a versionNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str description: Version descriptionNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str layer_name: Layer name.
        :param _builtins.int layer_version: Version number.
        :param _builtins.str license_info: License informationNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str stamp: StampNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str status: Current status of specific layer version. For valid values, please see [here](https://intl.cloud.tencent.com/document/product/583/47175?from_cn_redirect=1#.E5.B1.82.EF.BC.88layer.EF.BC.89.E7.8A.B6.E6.80.81).
        """
        pulumi.set(__self__, "add_time", add_time)
        pulumi.set(__self__, "compatible_runtimes", compatible_runtimes)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "layer_name", layer_name)
        pulumi.set(__self__, "layer_version", layer_version)
        pulumi.set(__self__, "license_info", license_info)
        pulumi.set(__self__, "stamp", stamp)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="addTime")
    def add_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "add_time")

    @_builtins.property
    @pulumi.getter(name="compatibleRuntimes")
    def compatible_runtimes(self) -> Sequence[_builtins.str]:
        """
        Runtime applicable to a versionNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "compatible_runtimes")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Version descriptionNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="layerName")
    def layer_name(self) -> _builtins.str:
        """
        Layer name.
        """
        return pulumi.get(self, "layer_name")

    @_builtins.property
    @pulumi.getter(name="layerVersion")
    def layer_version(self) -> _builtins.int:
        """
        Version number.
        """
        return pulumi.get(self, "layer_version")

    @_builtins.property
    @pulumi.getter(name="licenseInfo")
    def license_info(self) -> _builtins.str:
        """
        License informationNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "license_info")

    @_builtins.property
    @pulumi.getter
    def stamp(self) -> _builtins.str:
        """
        StampNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "stamp")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current status of specific layer version. For valid values, please see [here](https://intl.cloud.tencent.com/document/product/583/47175?from_cn_redirect=1#.E5.B1.82.EF.BC.88layer.EF.BC.89.E7.8A.B6.E6.80.81).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLogsLogResult(dict):
    def __init__(__self__, *,
                 bill_duration: _builtins.int,
                 duration: _builtins.float,
                 function_name: _builtins.str,
                 invoke_finished: _builtins.int,
                 level: _builtins.str,
                 log: _builtins.str,
                 mem_usage: _builtins.int,
                 request_id: _builtins.str,
                 ret_code: _builtins.int,
                 ret_msg: _builtins.str,
                 source: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.int bill_duration: Function billing time, according to duration up to the last 100ms, unit is ms.
        :param _builtins.float duration: Function execution time-consuming, unit is ms.
        :param _builtins.str function_name: Name of the SCF function to be queried.
        :param _builtins.int invoke_finished: Whether the function call ends, `1` means the execution ends, other values indicate the call exception.
        :param _builtins.str level: Log level.
        :param _builtins.str log: Log output during function execution.
        :param _builtins.int mem_usage: The actual memory size consumed in the execution of the function, unit is Byte.
        :param _builtins.str request_id: Execute the requestId corresponding to the function.
        :param _builtins.int ret_code: Use to filter log, optional value: `not0` only returns the error log. `is0` only returns the correct log. `TimeLimitExceeded` returns the log of the function call timeout. `ResourceLimitExceeded` returns the function call generation resource overrun log. `UserCodeException` returns logs of the user code error that occurred in the function call. Not passing the parameter means returning all logs.
        :param _builtins.str ret_msg: Return value after function execution is completed.
        :param _builtins.str source: Log source.
        :param _builtins.str start_time: The start time of the query, the format is `2017-05-16 20:00:00`, which can only be within one day from `end_time`.
        """
        pulumi.set(__self__, "bill_duration", bill_duration)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "invoke_finished", invoke_finished)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "log", log)
        pulumi.set(__self__, "mem_usage", mem_usage)
        pulumi.set(__self__, "request_id", request_id)
        pulumi.set(__self__, "ret_code", ret_code)
        pulumi.set(__self__, "ret_msg", ret_msg)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="billDuration")
    def bill_duration(self) -> _builtins.int:
        """
        Function billing time, according to duration up to the last 100ms, unit is ms.
        """
        return pulumi.get(self, "bill_duration")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.float:
        """
        Function execution time-consuming, unit is ms.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        Name of the SCF function to be queried.
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter(name="invokeFinished")
    def invoke_finished(self) -> _builtins.int:
        """
        Whether the function call ends, `1` means the execution ends, other values indicate the call exception.
        """
        return pulumi.get(self, "invoke_finished")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def log(self) -> _builtins.str:
        """
        Log output during function execution.
        """
        return pulumi.get(self, "log")

    @_builtins.property
    @pulumi.getter(name="memUsage")
    def mem_usage(self) -> _builtins.int:
        """
        The actual memory size consumed in the execution of the function, unit is Byte.
        """
        return pulumi.get(self, "mem_usage")

    @_builtins.property
    @pulumi.getter(name="requestId")
    def request_id(self) -> _builtins.str:
        """
        Execute the requestId corresponding to the function.
        """
        return pulumi.get(self, "request_id")

    @_builtins.property
    @pulumi.getter(name="retCode")
    def ret_code(self) -> _builtins.int:
        """
        Use to filter log, optional value: `not0` only returns the error log. `is0` only returns the correct log. `TimeLimitExceeded` returns the log of the function call timeout. `ResourceLimitExceeded` returns the function call generation resource overrun log. `UserCodeException` returns logs of the user code error that occurred in the function call. Not passing the parameter means returning all logs.
        """
        return pulumi.get(self, "ret_code")

    @_builtins.property
    @pulumi.getter(name="retMsg")
    def ret_msg(self) -> _builtins.str:
        """
        Return value after function execution is completed.
        """
        return pulumi.get(self, "ret_msg")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Log source.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the query, the format is `2017-05-16 20:00:00`, which can only be within one day from `end_time`.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetNamespacesNamespaceResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 modify_time: _builtins.str,
                 namespace: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str create_time: Create time of the SCF namespace.
        :param _builtins.str description: Description of the SCF namespace to be queried.
        :param _builtins.str modify_time: Modify time of the SCF namespace.
        :param _builtins.str namespace: Name of the SCF namespace to be queried.
        :param _builtins.str type: Type of the SCF namespace.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create time of the SCF namespace.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the SCF namespace to be queried.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        Modify time of the SCF namespace.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Name of the SCF namespace to be queried.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the SCF namespace.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRequestStatusDataResult(dict):
    def __init__(__self__, *,
                 duration: _builtins.float,
                 function_name: _builtins.str,
                 mem_usage: _builtins.float,
                 request_id: _builtins.str,
                 ret_code: _builtins.int,
                 ret_msg: _builtins.str,
                 retry_num: _builtins.int,
                 start_time: _builtins.str):
        """
        :param _builtins.float duration: Time consumed for the request in ms.
        :param _builtins.str function_name: Function name.
        :param _builtins.float mem_usage: Time consumed by the request in MB.
        :param _builtins.str request_id: Request ID.
        :param _builtins.int ret_code: Result of the request. `0`: succeeded, `1`: running, `-1`: exception.
        :param _builtins.str ret_msg: Return value after the function is executed.
        :param _builtins.int retry_num: Retry Attempts.
        :param _builtins.str start_time: Start time of the query, for example `2017-05-16 20:00:00`. If it's left empty, it defaults to 15 minutes before the current time.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "mem_usage", mem_usage)
        pulumi.set(__self__, "request_id", request_id)
        pulumi.set(__self__, "ret_code", ret_code)
        pulumi.set(__self__, "ret_msg", ret_msg)
        pulumi.set(__self__, "retry_num", retry_num)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.float:
        """
        Time consumed for the request in ms.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        Function name.
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter(name="memUsage")
    def mem_usage(self) -> _builtins.float:
        """
        Time consumed by the request in MB.
        """
        return pulumi.get(self, "mem_usage")

    @_builtins.property
    @pulumi.getter(name="requestId")
    def request_id(self) -> _builtins.str:
        """
        Request ID.
        """
        return pulumi.get(self, "request_id")

    @_builtins.property
    @pulumi.getter(name="retCode")
    def ret_code(self) -> _builtins.int:
        """
        Result of the request. `0`: succeeded, `1`: running, `-1`: exception.
        """
        return pulumi.get(self, "ret_code")

    @_builtins.property
    @pulumi.getter(name="retMsg")
    def ret_msg(self) -> _builtins.str:
        """
        Return value after the function is executed.
        """
        return pulumi.get(self, "ret_msg")

    @_builtins.property
    @pulumi.getter(name="retryNum")
    def retry_num(self) -> _builtins.int:
        """
        Retry Attempts.
        """
        return pulumi.get(self, "retry_num")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Start time of the query, for example `2017-05-16 20:00:00`. If it's left empty, it defaults to 15 minutes before the current time.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetTriggersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
        :param Sequence[_builtins.str] values: Filter values of the field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter values of the field.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTriggersTriggerResult(dict):
    def __init__(__self__, *,
                 add_time: _builtins.str,
                 available_status: _builtins.str,
                 bind_status: _builtins.str,
                 custom_argument: _builtins.str,
                 enable: _builtins.int,
                 mod_time: _builtins.str,
                 qualifier: _builtins.str,
                 resource_id: _builtins.str,
                 trigger_attribute: _builtins.str,
                 trigger_desc: _builtins.str,
                 trigger_name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str add_time: Trigger creation time.
        :param _builtins.str available_status: Whether the trigger is available.
        :param _builtins.str bind_status: Trigger-Function binding status.
        :param _builtins.str custom_argument: Custom parameterNote: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.int enable: Whether to enable.
        :param _builtins.str mod_time: Trigger last modified time.
        :param _builtins.str qualifier: Function version or alias.
        :param _builtins.str resource_id: Minimum resource ID of trigger.
        :param _builtins.str trigger_attribute: Trigger type. Two-way means that the trigger can be manipulated in both consoles, while one-way means that the trigger can be created only in the SCF Console.
        :param _builtins.str trigger_desc: Detailed configuration of trigger.
        :param _builtins.str trigger_name: Trigger name.
        :param _builtins.str type: Trigger type.
        """
        pulumi.set(__self__, "add_time", add_time)
        pulumi.set(__self__, "available_status", available_status)
        pulumi.set(__self__, "bind_status", bind_status)
        pulumi.set(__self__, "custom_argument", custom_argument)
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "mod_time", mod_time)
        pulumi.set(__self__, "qualifier", qualifier)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "trigger_attribute", trigger_attribute)
        pulumi.set(__self__, "trigger_desc", trigger_desc)
        pulumi.set(__self__, "trigger_name", trigger_name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="addTime")
    def add_time(self) -> _builtins.str:
        """
        Trigger creation time.
        """
        return pulumi.get(self, "add_time")

    @_builtins.property
    @pulumi.getter(name="availableStatus")
    def available_status(self) -> _builtins.str:
        """
        Whether the trigger is available.
        """
        return pulumi.get(self, "available_status")

    @_builtins.property
    @pulumi.getter(name="bindStatus")
    def bind_status(self) -> _builtins.str:
        """
        Trigger-Function binding status.
        """
        return pulumi.get(self, "bind_status")

    @_builtins.property
    @pulumi.getter(name="customArgument")
    def custom_argument(self) -> _builtins.str:
        """
        Custom parameterNote: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "custom_argument")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.int:
        """
        Whether to enable.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="modTime")
    def mod_time(self) -> _builtins.str:
        """
        Trigger last modified time.
        """
        return pulumi.get(self, "mod_time")

    @_builtins.property
    @pulumi.getter
    def qualifier(self) -> _builtins.str:
        """
        Function version or alias.
        """
        return pulumi.get(self, "qualifier")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Minimum resource ID of trigger.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="triggerAttribute")
    def trigger_attribute(self) -> _builtins.str:
        """
        Trigger type. Two-way means that the trigger can be manipulated in both consoles, while one-way means that the trigger can be created only in the SCF Console.
        """
        return pulumi.get(self, "trigger_attribute")

    @_builtins.property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> _builtins.str:
        """
        Detailed configuration of trigger.
        """
        return pulumi.get(self, "trigger_desc")

    @_builtins.property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> _builtins.str:
        """
        Trigger name.
        """
        return pulumi.get(self, "trigger_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Trigger type.
        """
        return pulumi.get(self, "type")


