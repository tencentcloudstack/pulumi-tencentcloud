# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CustomDomainCertConfigArgs',
    'CustomDomainCertConfigArgsDict',
    'CustomDomainEndpointsConfigArgs',
    'CustomDomainEndpointsConfigArgsDict',
    'CustomDomainEndpointsConfigPathRewriteArgs',
    'CustomDomainEndpointsConfigPathRewriteArgsDict',
    'CustomDomainWafConfigArgs',
    'CustomDomainWafConfigArgsDict',
    'FunctionAliasRoutingConfigArgs',
    'FunctionAliasRoutingConfigArgsDict',
    'FunctionAliasRoutingConfigAdditionalVersionMatchArgs',
    'FunctionAliasRoutingConfigAdditionalVersionMatchArgsDict',
    'FunctionAliasRoutingConfigAdditionalVersionWeightArgs',
    'FunctionAliasRoutingConfigAdditionalVersionWeightArgsDict',
    'FunctionCfsConfigArgs',
    'FunctionCfsConfigArgsDict',
    'FunctionEventInvokeConfigAsyncTriggerConfigArgs',
    'FunctionEventInvokeConfigAsyncTriggerConfigArgsDict',
    'FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs',
    'FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgsDict',
    'FunctionImageConfigArgs',
    'FunctionImageConfigArgsDict',
    'FunctionIntranetConfigArgs',
    'FunctionIntranetConfigArgsDict',
    'FunctionLayerArgs',
    'FunctionLayerArgsDict',
    'FunctionTriggerArgs',
    'FunctionTriggerArgsDict',
    'FunctionTriggerInfoArgs',
    'FunctionTriggerInfoArgsDict',
    'LayerContentArgs',
    'LayerContentArgsDict',
    'ProvisionedConcurrencyConfigTriggerActionArgs',
    'ProvisionedConcurrencyConfigTriggerActionArgsDict',
    'GetTriggersFilterArgs',
    'GetTriggersFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CustomDomainCertConfigArgsDict(TypedDict):
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSL Certificates ID.
        """
elif False:
    CustomDomainCertConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainCertConfigArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_id: SSL Certificates ID.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSL Certificates ID.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class CustomDomainEndpointsConfigArgsDict(TypedDict):
        function_name: pulumi.Input[_builtins.str]
        """
        Function name.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Function namespace.
        """
        path_match: pulumi.Input[_builtins.str]
        """
        Path, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        """
        qualifier: pulumi.Input[_builtins.str]
        """
        Function alias or version.
        """
        path_rewrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomDomainEndpointsConfigPathRewriteArgsDict']]]]
        """
        Path rewriting policy.
        """
elif False:
    CustomDomainEndpointsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainEndpointsConfigArgs:
    def __init__(__self__, *,
                 function_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 path_match: pulumi.Input[_builtins.str],
                 qualifier: pulumi.Input[_builtins.str],
                 path_rewrites: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainEndpointsConfigPathRewriteArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] function_name: Function name.
        :param pulumi.Input[_builtins.str] namespace: Function namespace.
        :param pulumi.Input[_builtins.str] path_match: Path, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        :param pulumi.Input[_builtins.str] qualifier: Function alias or version.
        :param pulumi.Input[Sequence[pulumi.Input['CustomDomainEndpointsConfigPathRewriteArgs']]] path_rewrites: Path rewriting policy.
        """
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "path_match", path_match)
        pulumi.set(__self__, "qualifier", qualifier)
        if path_rewrites is not None:
            pulumi.set(__self__, "path_rewrites", path_rewrites)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> pulumi.Input[_builtins.str]:
        """
        Function name.
        """
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Function namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="pathMatch")
    def path_match(self) -> pulumi.Input[_builtins.str]:
        """
        Path, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        """
        return pulumi.get(self, "path_match")

    @path_match.setter
    def path_match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path_match", value)

    @_builtins.property
    @pulumi.getter
    def qualifier(self) -> pulumi.Input[_builtins.str]:
        """
        Function alias or version.
        """
        return pulumi.get(self, "qualifier")

    @qualifier.setter
    def qualifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "qualifier", value)

    @_builtins.property
    @pulumi.getter(name="pathRewrites")
    def path_rewrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainEndpointsConfigPathRewriteArgs']]]]:
        """
        Path rewriting policy.
        """
        return pulumi.get(self, "path_rewrites")

    @path_rewrites.setter
    def path_rewrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainEndpointsConfigPathRewriteArgs']]]]):
        pulumi.set(self, "path_rewrites", value)


if not MYPY:
    class CustomDomainEndpointsConfigPathRewriteArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        Path that needs to be rerouted, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        """
        rewrite: pulumi.Input[_builtins.str]
        """
        Replacement values: such as/, /$.
        """
        type: pulumi.Input[_builtins.str]
        """
        Matching rules, value range: WildcardRules wildcard matching, ExactRules exact matching.
        """
elif False:
    CustomDomainEndpointsConfigPathRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainEndpointsConfigPathRewriteArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 rewrite: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path: Path that needs to be rerouted, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        :param pulumi.Input[_builtins.str] rewrite: Replacement values: such as/, /$.
        :param pulumi.Input[_builtins.str] type: Matching rules, value range: WildcardRules wildcard matching, ExactRules exact matching.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "rewrite", rewrite)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Path that needs to be rerouted, value specification: /,/*,/xxx,/xxx/a,/xxx/*.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def rewrite(self) -> pulumi.Input[_builtins.str]:
        """
        Replacement values: such as/, /$.
        """
        return pulumi.get(self, "rewrite")

    @rewrite.setter
    def rewrite(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rewrite", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Matching rules, value range: WildcardRules wildcard matching, ExactRules exact matching.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CustomDomainWafConfigArgsDict(TypedDict):
        waf_instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Web Application Firewall Instance ID.
        """
        waf_open: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the Web Application Firewall is turned on, value range:OPEN, CLOSE.
        """
elif False:
    CustomDomainWafConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainWafConfigArgs:
    def __init__(__self__, *,
                 waf_instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 waf_open: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] waf_instance_id: Web Application Firewall Instance ID.
        :param pulumi.Input[_builtins.str] waf_open: Whether the Web Application Firewall is turned on, value range:OPEN, CLOSE.
        """
        if waf_instance_id is not None:
            pulumi.set(__self__, "waf_instance_id", waf_instance_id)
        if waf_open is not None:
            pulumi.set(__self__, "waf_open", waf_open)

    @_builtins.property
    @pulumi.getter(name="wafInstanceId")
    def waf_instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Web Application Firewall Instance ID.
        """
        return pulumi.get(self, "waf_instance_id")

    @waf_instance_id.setter
    def waf_instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "waf_instance_id", value)

    @_builtins.property
    @pulumi.getter(name="wafOpen")
    def waf_open(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the Web Application Firewall is turned on, value range:OPEN, CLOSE.
        """
        return pulumi.get(self, "waf_open")

    @waf_open.setter
    def waf_open(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "waf_open", value)


if not MYPY:
    class FunctionAliasRoutingConfigArgsDict(TypedDict):
        additional_version_matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgsDict']]]]
        """
        Additional version with rule-based routing.
        """
        additional_version_weights: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgsDict']]]]
        """
        Additional version with random weight-based routing.
        """
elif False:
    FunctionAliasRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_matches: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]]] = None,
                 additional_version_weights: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]] additional_version_matches: Additional version with rule-based routing.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]] additional_version_weights: Additional version with random weight-based routing.
        """
        if additional_version_matches is not None:
            pulumi.set(__self__, "additional_version_matches", additional_version_matches)
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionMatches")
    def additional_version_matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]]]:
        """
        Additional version with rule-based routing.
        """
        return pulumi.get(self, "additional_version_matches")

    @additional_version_matches.setter
    def additional_version_matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]]]):
        pulumi.set(self, "additional_version_matches", value)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]]]:
        """
        Additional version with random weight-based routing.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]]]):
        pulumi.set(self, "additional_version_weights", value)


if not MYPY:
    class FunctionAliasRoutingConfigAdditionalVersionMatchArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
        """
        key: pulumi.Input[_builtins.str]
        """
        Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
        """
        method: pulumi.Input[_builtins.str]
        """
        Match method. Valid values:range: Range matchexact: exact string match.
        """
        version: pulumi.Input[_builtins.str]
        """
        Function version name.
        """
elif False:
    FunctionAliasRoutingConfigAdditionalVersionMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAliasRoutingConfigAdditionalVersionMatchArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 method: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] expression: Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
        :param pulumi.Input[_builtins.str] key: Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
        :param pulumi.Input[_builtins.str] method: Match method. Valid values:range: Range matchexact: exact string match.
        :param pulumi.Input[_builtins.str] version: Function version name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        Match method. Valid values:range: Range matchexact: exact string match.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        Function version name.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FunctionAliasRoutingConfigAdditionalVersionWeightArgsDict(TypedDict):
        version: pulumi.Input[_builtins.str]
        """
        Function version name.
        """
        weight: pulumi.Input[_builtins.float]
        """
        Version weight.
        """
elif False:
    FunctionAliasRoutingConfigAdditionalVersionWeightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAliasRoutingConfigAdditionalVersionWeightArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.str] version: Function version name.
        :param pulumi.Input[_builtins.float] weight: Version weight.
        """
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        Function version name.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.float]:
        """
        Version weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class FunctionCfsConfigArgsDict(TypedDict):
        cfs_id: pulumi.Input[_builtins.str]
        """
        File system instance ID.
        """
        local_mount_dir: pulumi.Input[_builtins.str]
        """
        Local mount directory.
        """
        mount_ins_id: pulumi.Input[_builtins.str]
        """
        File system mount instance ID.
        """
        remote_mount_dir: pulumi.Input[_builtins.str]
        """
        Remote mount directory.
        """
        user_group_id: pulumi.Input[_builtins.str]
        """
        ID of user group.
        """
        user_id: pulumi.Input[_builtins.str]
        """
        ID of user.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Readonly) File system ip address.
        """
        mount_subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Readonly) File system subnet ID.
        """
        mount_vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Readonly) File system virtual private network ID.
        """
elif False:
    FunctionCfsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCfsConfigArgs:
    def __init__(__self__, *,
                 cfs_id: pulumi.Input[_builtins.str],
                 local_mount_dir: pulumi.Input[_builtins.str],
                 mount_ins_id: pulumi.Input[_builtins.str],
                 remote_mount_dir: pulumi.Input[_builtins.str],
                 user_group_id: pulumi.Input[_builtins.str],
                 user_id: pulumi.Input[_builtins.str],
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cfs_id: File system instance ID.
        :param pulumi.Input[_builtins.str] local_mount_dir: Local mount directory.
        :param pulumi.Input[_builtins.str] mount_ins_id: File system mount instance ID.
        :param pulumi.Input[_builtins.str] remote_mount_dir: Remote mount directory.
        :param pulumi.Input[_builtins.str] user_group_id: ID of user group.
        :param pulumi.Input[_builtins.str] user_id: ID of user.
        :param pulumi.Input[_builtins.str] ip_address: (Readonly) File system ip address.
        :param pulumi.Input[_builtins.str] mount_subnet_id: (Readonly) File system subnet ID.
        :param pulumi.Input[_builtins.str] mount_vpc_id: (Readonly) File system virtual private network ID.
        """
        pulumi.set(__self__, "cfs_id", cfs_id)
        pulumi.set(__self__, "local_mount_dir", local_mount_dir)
        pulumi.set(__self__, "mount_ins_id", mount_ins_id)
        pulumi.set(__self__, "remote_mount_dir", remote_mount_dir)
        pulumi.set(__self__, "user_group_id", user_group_id)
        pulumi.set(__self__, "user_id", user_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mount_subnet_id is not None:
            pulumi.set(__self__, "mount_subnet_id", mount_subnet_id)
        if mount_vpc_id is not None:
            pulumi.set(__self__, "mount_vpc_id", mount_vpc_id)

    @_builtins.property
    @pulumi.getter(name="cfsId")
    def cfs_id(self) -> pulumi.Input[_builtins.str]:
        """
        File system instance ID.
        """
        return pulumi.get(self, "cfs_id")

    @cfs_id.setter
    def cfs_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cfs_id", value)

    @_builtins.property
    @pulumi.getter(name="localMountDir")
    def local_mount_dir(self) -> pulumi.Input[_builtins.str]:
        """
        Local mount directory.
        """
        return pulumi.get(self, "local_mount_dir")

    @local_mount_dir.setter
    def local_mount_dir(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_dir", value)

    @_builtins.property
    @pulumi.getter(name="mountInsId")
    def mount_ins_id(self) -> pulumi.Input[_builtins.str]:
        """
        File system mount instance ID.
        """
        return pulumi.get(self, "mount_ins_id")

    @mount_ins_id.setter
    def mount_ins_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_ins_id", value)

    @_builtins.property
    @pulumi.getter(name="remoteMountDir")
    def remote_mount_dir(self) -> pulumi.Input[_builtins.str]:
        """
        Remote mount directory.
        """
        return pulumi.get(self, "remote_mount_dir")

    @remote_mount_dir.setter
    def remote_mount_dir(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_mount_dir", value)

    @_builtins.property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of user group.
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of user.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Readonly) File system ip address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="mountSubnetId")
    def mount_subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Readonly) File system subnet ID.
        """
        return pulumi.get(self, "mount_subnet_id")

    @mount_subnet_id.setter
    def mount_subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="mountVpcId")
    def mount_vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Readonly) File system virtual private network ID.
        """
        return pulumi.get(self, "mount_vpc_id")

    @mount_vpc_id.setter
    def mount_vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_vpc_id", value)


if not MYPY:
    class FunctionEventInvokeConfigAsyncTriggerConfigArgsDict(TypedDict):
        msg_ttl: pulumi.Input[_builtins.int]
        """
        Message retention period.
        """
        retry_configs: pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgsDict']]]
        """
        Async retry configuration of function upon user error.
        """
elif False:
    FunctionEventInvokeConfigAsyncTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigAsyncTriggerConfigArgs:
    def __init__(__self__, *,
                 msg_ttl: pulumi.Input[_builtins.int],
                 retry_configs: pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]]):
        """
        :param pulumi.Input[_builtins.int] msg_ttl: Message retention period.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]] retry_configs: Async retry configuration of function upon user error.
        """
        pulumi.set(__self__, "msg_ttl", msg_ttl)
        pulumi.set(__self__, "retry_configs", retry_configs)

    @_builtins.property
    @pulumi.getter(name="msgTtl")
    def msg_ttl(self) -> pulumi.Input[_builtins.int]:
        """
        Message retention period.
        """
        return pulumi.get(self, "msg_ttl")

    @msg_ttl.setter
    def msg_ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "msg_ttl", value)

    @_builtins.property
    @pulumi.getter(name="retryConfigs")
    def retry_configs(self) -> pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]]:
        """
        Async retry configuration of function upon user error.
        """
        return pulumi.get(self, "retry_configs")

    @retry_configs.setter
    def retry_configs(self, value: pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]]):
        pulumi.set(self, "retry_configs", value)


if not MYPY:
    class FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgsDict(TypedDict):
        retry_num: pulumi.Input[_builtins.int]
        """
        Number of retry attempts.
        """
elif False:
    FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs:
    def __init__(__self__, *,
                 retry_num: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] retry_num: Number of retry attempts.
        """
        pulumi.set(__self__, "retry_num", retry_num)

    @_builtins.property
    @pulumi.getter(name="retryNum")
    def retry_num(self) -> pulumi.Input[_builtins.int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "retry_num")

    @retry_num.setter
    def retry_num(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "retry_num", value)


if not MYPY:
    class FunctionImageConfigArgsDict(TypedDict):
        image_type: pulumi.Input[_builtins.str]
        """
        The image type. personal or enterprise.
        """
        image_uri: pulumi.Input[_builtins.str]
        """
        The uri of image.
        """
        args: NotRequired[pulumi.Input[_builtins.str]]
        """
        the parameters of command.
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        The command of entrypoint.
        """
        container_image_accelerate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Image accelerate switch.
        """
        entry_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entrypoint of app.
        """
        image_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        """
        registry_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The registry id of TCR. When image type is enterprise, it must be set.
        """
elif False:
    FunctionImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 image_type: pulumi.Input[_builtins.str],
                 image_uri: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[_builtins.str]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 container_image_accelerate: Optional[pulumi.Input[_builtins.bool]] = None,
                 entry_point: Optional[pulumi.Input[_builtins.str]] = None,
                 image_port: Optional[pulumi.Input[_builtins.int]] = None,
                 registry_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image_type: The image type. personal or enterprise.
        :param pulumi.Input[_builtins.str] image_uri: The uri of image.
        :param pulumi.Input[_builtins.str] args: the parameters of command.
        :param pulumi.Input[_builtins.str] command: The command of entrypoint.
        :param pulumi.Input[_builtins.bool] container_image_accelerate: Image accelerate switch.
        :param pulumi.Input[_builtins.str] entry_point: The entrypoint of app.
        :param pulumi.Input[_builtins.int] image_port: Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        :param pulumi.Input[_builtins.str] registry_id: The registry id of TCR. When image type is enterprise, it must be set.
        """
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "image_uri", image_uri)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if container_image_accelerate is not None:
            pulumi.set(__self__, "container_image_accelerate", container_image_accelerate)
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if image_port is not None:
            pulumi.set(__self__, "image_port", image_port)
        if registry_id is not None:
            pulumi.set(__self__, "registry_id", registry_id)

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> pulumi.Input[_builtins.str]:
        """
        The image type. personal or enterprise.
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image_type", value)

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The uri of image.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image_uri", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the parameters of command.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The command of entrypoint.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="containerImageAccelerate")
    def container_image_accelerate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Image accelerate switch.
        """
        return pulumi.get(self, "container_image_accelerate")

    @container_image_accelerate.setter
    def container_image_accelerate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "container_image_accelerate", value)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entrypoint of app.
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entry_point", value)

    @_builtins.property
    @pulumi.getter(name="imagePort")
    def image_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        """
        return pulumi.get(self, "image_port")

    @image_port.setter
    def image_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "image_port", value)

    @_builtins.property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The registry id of TCR. When image type is enterprise, it must be set.
        """
        return pulumi.get(self, "registry_id")

    @registry_id.setter
    def registry_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_id", value)


if not MYPY:
    class FunctionIntranetConfigArgsDict(TypedDict):
        ip_fixed: pulumi.Input[_builtins.str]
        """
        Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        If fixed intranet IP is enabled, this field returns the IP list used.
        """
elif False:
    FunctionIntranetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionIntranetConfigArgs:
    def __init__(__self__, *,
                 ip_fixed: pulumi.Input[_builtins.str],
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_fixed: Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_addresses: If fixed intranet IP is enabled, this field returns the IP list used.
        """
        pulumi.set(__self__, "ip_fixed", ip_fixed)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="ipFixed")
    def ip_fixed(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        """
        return pulumi.get(self, "ip_fixed")

    @ip_fixed.setter
    def ip_fixed(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_fixed", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        If fixed intranet IP is enabled, this field returns the IP list used.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class FunctionLayerArgsDict(TypedDict):
        layer_name: pulumi.Input[_builtins.str]
        """
        The name of Layer.
        """
        layer_version: pulumi.Input[_builtins.int]
        """
        The version of layer.
        """
elif False:
    FunctionLayerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionLayerArgs:
    def __init__(__self__, *,
                 layer_name: pulumi.Input[_builtins.str],
                 layer_version: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] layer_name: The name of Layer.
        :param pulumi.Input[_builtins.int] layer_version: The version of layer.
        """
        pulumi.set(__self__, "layer_name", layer_name)
        pulumi.set(__self__, "layer_version", layer_version)

    @_builtins.property
    @pulumi.getter(name="layerName")
    def layer_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of Layer.
        """
        return pulumi.get(self, "layer_name")

    @layer_name.setter
    def layer_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "layer_name", value)

    @_builtins.property
    @pulumi.getter(name="layerVersion")
    def layer_version(self) -> pulumi.Input[_builtins.int]:
        """
        The version of layer.
        """
        return pulumi.get(self, "layer_version")

    @layer_version.setter
    def layer_version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "layer_version", value)


if not MYPY:
    class FunctionTriggerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
        """
        trigger_desc: pulumi.Input[_builtins.str]
        """
        TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of the SCF function trigger, support `timer`, `ckafka`, `custom_kafka`, `apigw`, `cmq`, `cos`, `mqtt`, `cls`, `clb`, `mps`, `vod`, `cm`, `eb`, `http`.
        """
        cos_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region of cos bucket. if `type` is `cos`, `cos_region` is required.
        """
elif False:
    FunctionTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 trigger_desc: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 cos_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
        :param pulumi.Input[_builtins.str] trigger_desc: TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        :param pulumi.Input[_builtins.str] type: Type of the SCF function trigger, support `timer`, `ckafka`, `custom_kafka`, `apigw`, `cmq`, `cos`, `mqtt`, `cls`, `clb`, `mps`, `vod`, `cm`, `eb`, `http`.
        :param pulumi.Input[_builtins.str] cos_region: Region of cos bucket. if `type` is `cos`, `cos_region` is required.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trigger_desc", trigger_desc)
        pulumi.set(__self__, "type", type)
        if cos_region is not None:
            pulumi.set(__self__, "cos_region", cos_region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> pulumi.Input[_builtins.str]:
        """
        TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        """
        return pulumi.get(self, "trigger_desc")

    @trigger_desc.setter
    def trigger_desc(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trigger_desc", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the SCF function trigger, support `timer`, `ckafka`, `custom_kafka`, `apigw`, `cmq`, `cos`, `mqtt`, `cls`, `clb`, `mps`, `vod`, `cm`, `eb`, `http`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cosRegion")
    def cos_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region of cos bucket. if `type` is `cos`, `cos_region` is required.
        """
        return pulumi.get(self, "cos_region")

    @cos_region.setter
    def cos_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_region", value)


if not MYPY:
    class FunctionTriggerInfoArgsDict(TypedDict):
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Create time of SCF function trigger.
        """
        custom_argument: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-defined parameters of SCF function trigger.
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether SCF function trigger is enable.
        """
        modify_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Modify time of SCF function trigger.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
        """
        trigger_desc: NotRequired[pulumi.Input[_builtins.str]]
        """
        TriggerDesc of SCF function trigger.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of SCF function trigger.
        """
elif False:
    FunctionTriggerInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerInfoArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_argument: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 modify_time: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_desc: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create_time: Create time of SCF function trigger.
        :param pulumi.Input[_builtins.str] custom_argument: User-defined parameters of SCF function trigger.
        :param pulumi.Input[_builtins.bool] enable: Whether SCF function trigger is enable.
        :param pulumi.Input[_builtins.str] modify_time: Modify time of SCF function trigger.
        :param pulumi.Input[_builtins.str] name: Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
        :param pulumi.Input[_builtins.str] trigger_desc: TriggerDesc of SCF function trigger.
        :param pulumi.Input[_builtins.str] type: Type of SCF function trigger.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if custom_argument is not None:
            pulumi.set(__self__, "custom_argument", custom_argument)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if trigger_desc is not None:
            pulumi.set(__self__, "trigger_desc", trigger_desc)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Create time of SCF function trigger.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="customArgument")
    def custom_argument(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-defined parameters of SCF function trigger.
        """
        return pulumi.get(self, "custom_argument")

    @custom_argument.setter
    def custom_argument(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_argument", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether SCF function trigger is enable.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Modify time of SCF function trigger.
        """
        return pulumi.get(self, "modify_time")

    @modify_time.setter
    def modify_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modify_time", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TriggerDesc of SCF function trigger.
        """
        return pulumi.get(self, "trigger_desc")

    @trigger_desc.setter
    def trigger_desc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_desc", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of SCF function trigger.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LayerContentArgsDict(TypedDict):
        cos_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zip_file`.
        """
        cos_bucket_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cos bucket region of the SCF layer, conflict with `zip_file`.
        """
        cos_object_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
        """
        zip_file: NotRequired[pulumi.Input[_builtins.str]]
        """
        Zip file of the SCF layer, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
        """
elif False:
    LayerContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LayerContentArgs:
    def __init__(__self__, *,
                 cos_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cos_bucket_region: Optional[pulumi.Input[_builtins.str]] = None,
                 cos_object_name: Optional[pulumi.Input[_builtins.str]] = None,
                 zip_file: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cos_bucket_name: Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zip_file`.
        :param pulumi.Input[_builtins.str] cos_bucket_region: Cos bucket region of the SCF layer, conflict with `zip_file`.
        :param pulumi.Input[_builtins.str] cos_object_name: Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
        :param pulumi.Input[_builtins.str] zip_file: Zip file of the SCF layer, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
        """
        if cos_bucket_name is not None:
            pulumi.set(__self__, "cos_bucket_name", cos_bucket_name)
        if cos_bucket_region is not None:
            pulumi.set(__self__, "cos_bucket_region", cos_bucket_region)
        if cos_object_name is not None:
            pulumi.set(__self__, "cos_object_name", cos_object_name)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @_builtins.property
    @pulumi.getter(name="cosBucketName")
    def cos_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_bucket_name")

    @cos_bucket_name.setter
    def cos_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="cosBucketRegion")
    def cos_bucket_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cos bucket region of the SCF layer, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_bucket_region")

    @cos_bucket_region.setter
    def cos_bucket_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_bucket_region", value)

    @_builtins.property
    @pulumi.getter(name="cosObjectName")
    def cos_object_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_object_name")

    @cos_object_name.setter
    def cos_object_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_object_name", value)

    @_builtins.property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Zip file of the SCF layer, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
        """
        return pulumi.get(self, "zip_file")

    @zip_file.setter
    def zip_file(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zip_file", value)


if not MYPY:
    class ProvisionedConcurrencyConfigTriggerActionArgsDict(TypedDict):
        trigger_cron_config: pulumi.Input[_builtins.str]
        """
        Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
        """
        trigger_name: pulumi.Input[_builtins.str]
        """
        Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
        """
        trigger_provisioned_concurrency_num: pulumi.Input[_builtins.int]
        """
        Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
        """
        provisioned_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
        """
elif False:
    ProvisionedConcurrencyConfigTriggerActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionedConcurrencyConfigTriggerActionArgs:
    def __init__(__self__, *,
                 trigger_cron_config: pulumi.Input[_builtins.str],
                 trigger_name: pulumi.Input[_builtins.str],
                 trigger_provisioned_concurrency_num: pulumi.Input[_builtins.int],
                 provisioned_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] trigger_cron_config: Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] trigger_name: Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] trigger_provisioned_concurrency_num: Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] provisioned_type: The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
        """
        pulumi.set(__self__, "trigger_cron_config", trigger_cron_config)
        pulumi.set(__self__, "trigger_name", trigger_name)
        pulumi.set(__self__, "trigger_provisioned_concurrency_num", trigger_provisioned_concurrency_num)
        if provisioned_type is not None:
            pulumi.set(__self__, "provisioned_type", provisioned_type)

    @_builtins.property
    @pulumi.getter(name="triggerCronConfig")
    def trigger_cron_config(self) -> pulumi.Input[_builtins.str]:
        """
        Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_cron_config")

    @trigger_cron_config.setter
    def trigger_cron_config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trigger_cron_config", value)

    @_builtins.property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> pulumi.Input[_builtins.str]:
        """
        Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_name")

    @trigger_name.setter
    def trigger_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trigger_name", value)

    @_builtins.property
    @pulumi.getter(name="triggerProvisionedConcurrencyNum")
    def trigger_provisioned_concurrency_num(self) -> pulumi.Input[_builtins.int]:
        """
        Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_provisioned_concurrency_num")

    @trigger_provisioned_concurrency_num.setter
    def trigger_provisioned_concurrency_num(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "trigger_provisioned_concurrency_num", value)

    @_builtins.property
    @pulumi.getter(name="provisionedType")
    def provisioned_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
        """
        return pulumi.get(self, "provisioned_type")

    @provisioned_type.setter
    def provisioned_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provisioned_type", value)


if not MYPY:
    class GetTriggersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
        """
        values: Sequence[_builtins.str]
        """
        Filter values of the field.
        """
elif False:
    GetTriggersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTriggersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
        :param Sequence[_builtins.str] values: Filter values of the field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter values of the field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


