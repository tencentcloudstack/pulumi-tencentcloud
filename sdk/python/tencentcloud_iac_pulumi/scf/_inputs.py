# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'FunctionAliasRoutingConfigArgs',
    'FunctionAliasRoutingConfigAdditionalVersionMatchArgs',
    'FunctionAliasRoutingConfigAdditionalVersionWeightArgs',
    'FunctionCfsConfigArgs',
    'FunctionEventInvokeConfigAsyncTriggerConfigArgs',
    'FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs',
    'FunctionImageConfigArgs',
    'FunctionIntranetConfigArgs',
    'FunctionLayerArgs',
    'FunctionTriggerArgs',
    'FunctionTriggerInfoArgs',
    'LayerContentArgs',
    'ProvisionedConcurrencyConfigTriggerActionArgs',
    'GetTriggersFilterArgs',
]

@pulumi.input_type
class FunctionAliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_matches: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]]] = None,
                 additional_version_weights: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]] additional_version_matches: Additional version with rule-based routing.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]] additional_version_weights: Additional version with random weight-based routing.
        """
        if additional_version_matches is not None:
            pulumi.set(__self__, "additional_version_matches", additional_version_matches)
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @property
    @pulumi.getter(name="additionalVersionMatches")
    def additional_version_matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]]]:
        """
        Additional version with rule-based routing.
        """
        return pulumi.get(self, "additional_version_matches")

    @additional_version_matches.setter
    def additional_version_matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionMatchArgs']]]]):
        pulumi.set(self, "additional_version_matches", value)

    @property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]]]:
        """
        Additional version with random weight-based routing.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAliasRoutingConfigAdditionalVersionWeightArgs']]]]):
        pulumi.set(self, "additional_version_weights", value)


@pulumi.input_type
class FunctionAliasRoutingConfigAdditionalVersionMatchArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 key: pulumi.Input[str],
                 method: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
        :param pulumi.Input[str] key: Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
        :param pulumi.Input[str] method: Match method. Valid values:range: Range matchexact: exact string match.
        :param pulumi.Input[str] version: Function version name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method. Valid values:range: Range matchexact: exact string match.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Function version name.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class FunctionAliasRoutingConfigAdditionalVersionWeightArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 weight: pulumi.Input[float]):
        """
        :param pulumi.Input[str] version: Function version name.
        :param pulumi.Input[float] weight: Version weight.
        """
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Function version name.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[float]:
        """
        Version weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[float]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class FunctionCfsConfigArgs:
    def __init__(__self__, *,
                 cfs_id: pulumi.Input[str],
                 local_mount_dir: pulumi.Input[str],
                 mount_ins_id: pulumi.Input[str],
                 remote_mount_dir: pulumi.Input[str],
                 user_group_id: pulumi.Input[str],
                 user_id: pulumi.Input[str],
                 ip_address: Optional[pulumi.Input[str]] = None,
                 mount_subnet_id: Optional[pulumi.Input[str]] = None,
                 mount_vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cfs_id: File system instance ID.
        :param pulumi.Input[str] local_mount_dir: Local mount directory.
        :param pulumi.Input[str] mount_ins_id: File system mount instance ID.
        :param pulumi.Input[str] remote_mount_dir: Remote mount directory.
        :param pulumi.Input[str] user_group_id: ID of user group.
        :param pulumi.Input[str] user_id: ID of user.
        :param pulumi.Input[str] ip_address: (Readonly) File system ip address.
        :param pulumi.Input[str] mount_subnet_id: (Readonly) File system subnet ID.
        :param pulumi.Input[str] mount_vpc_id: (Readonly) File system virtual private network ID.
        """
        pulumi.set(__self__, "cfs_id", cfs_id)
        pulumi.set(__self__, "local_mount_dir", local_mount_dir)
        pulumi.set(__self__, "mount_ins_id", mount_ins_id)
        pulumi.set(__self__, "remote_mount_dir", remote_mount_dir)
        pulumi.set(__self__, "user_group_id", user_group_id)
        pulumi.set(__self__, "user_id", user_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mount_subnet_id is not None:
            pulumi.set(__self__, "mount_subnet_id", mount_subnet_id)
        if mount_vpc_id is not None:
            pulumi.set(__self__, "mount_vpc_id", mount_vpc_id)

    @property
    @pulumi.getter(name="cfsId")
    def cfs_id(self) -> pulumi.Input[str]:
        """
        File system instance ID.
        """
        return pulumi.get(self, "cfs_id")

    @cfs_id.setter
    def cfs_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "cfs_id", value)

    @property
    @pulumi.getter(name="localMountDir")
    def local_mount_dir(self) -> pulumi.Input[str]:
        """
        Local mount directory.
        """
        return pulumi.get(self, "local_mount_dir")

    @local_mount_dir.setter
    def local_mount_dir(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir", value)

    @property
    @pulumi.getter(name="mountInsId")
    def mount_ins_id(self) -> pulumi.Input[str]:
        """
        File system mount instance ID.
        """
        return pulumi.get(self, "mount_ins_id")

    @mount_ins_id.setter
    def mount_ins_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_ins_id", value)

    @property
    @pulumi.getter(name="remoteMountDir")
    def remote_mount_dir(self) -> pulumi.Input[str]:
        """
        Remote mount directory.
        """
        return pulumi.get(self, "remote_mount_dir")

    @remote_mount_dir.setter
    def remote_mount_dir(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_mount_dir", value)

    @property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> pulumi.Input[str]:
        """
        ID of user group.
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Input[str]:
        """
        ID of user.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        (Readonly) File system ip address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="mountSubnetId")
    def mount_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Readonly) File system subnet ID.
        """
        return pulumi.get(self, "mount_subnet_id")

    @mount_subnet_id.setter
    def mount_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_subnet_id", value)

    @property
    @pulumi.getter(name="mountVpcId")
    def mount_vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Readonly) File system virtual private network ID.
        """
        return pulumi.get(self, "mount_vpc_id")

    @mount_vpc_id.setter
    def mount_vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_vpc_id", value)


@pulumi.input_type
class FunctionEventInvokeConfigAsyncTriggerConfigArgs:
    def __init__(__self__, *,
                 msg_ttl: pulumi.Input[int],
                 retry_configs: pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]]):
        """
        :param pulumi.Input[int] msg_ttl: Message retention period.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]] retry_configs: Async retry configuration of function upon user error.
        """
        pulumi.set(__self__, "msg_ttl", msg_ttl)
        pulumi.set(__self__, "retry_configs", retry_configs)

    @property
    @pulumi.getter(name="msgTtl")
    def msg_ttl(self) -> pulumi.Input[int]:
        """
        Message retention period.
        """
        return pulumi.get(self, "msg_ttl")

    @msg_ttl.setter
    def msg_ttl(self, value: pulumi.Input[int]):
        pulumi.set(self, "msg_ttl", value)

    @property
    @pulumi.getter(name="retryConfigs")
    def retry_configs(self) -> pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]]:
        """
        Async retry configuration of function upon user error.
        """
        return pulumi.get(self, "retry_configs")

    @retry_configs.setter
    def retry_configs(self, value: pulumi.Input[Sequence[pulumi.Input['FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs']]]):
        pulumi.set(self, "retry_configs", value)


@pulumi.input_type
class FunctionEventInvokeConfigAsyncTriggerConfigRetryConfigArgs:
    def __init__(__self__, *,
                 retry_num: pulumi.Input[int]):
        """
        :param pulumi.Input[int] retry_num: Number of retry attempts.
        """
        pulumi.set(__self__, "retry_num", retry_num)

    @property
    @pulumi.getter(name="retryNum")
    def retry_num(self) -> pulumi.Input[int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "retry_num")

    @retry_num.setter
    def retry_num(self, value: pulumi.Input[int]):
        pulumi.set(self, "retry_num", value)


@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 image_type: pulumi.Input[str],
                 image_uri: pulumi.Input[str],
                 args: Optional[pulumi.Input[str]] = None,
                 command: Optional[pulumi.Input[str]] = None,
                 container_image_accelerate: Optional[pulumi.Input[bool]] = None,
                 entry_point: Optional[pulumi.Input[str]] = None,
                 image_port: Optional[pulumi.Input[int]] = None,
                 registry_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_type: The image type. personal or enterprise.
        :param pulumi.Input[str] image_uri: The uri of image.
        :param pulumi.Input[str] args: the parameters of command.
        :param pulumi.Input[str] command: The command of entrypoint.
        :param pulumi.Input[bool] container_image_accelerate: Image accelerate switch.
        :param pulumi.Input[str] entry_point: The entrypoint of app.
        :param pulumi.Input[int] image_port: Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        :param pulumi.Input[str] registry_id: The registry id of TCR. When image type is enterprise, it must be set.
        """
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "image_uri", image_uri)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if container_image_accelerate is not None:
            pulumi.set(__self__, "container_image_accelerate", container_image_accelerate)
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if image_port is not None:
            pulumi.set(__self__, "image_port", image_port)
        if registry_id is not None:
            pulumi.set(__self__, "registry_id", registry_id)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> pulumi.Input[str]:
        """
        The image type. personal or enterprise.
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_type", value)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[str]:
        """
        The uri of image.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[str]]:
        """
        the parameters of command.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        """
        The command of entrypoint.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter(name="containerImageAccelerate")
    def container_image_accelerate(self) -> Optional[pulumi.Input[bool]]:
        """
        Image accelerate switch.
        """
        return pulumi.get(self, "container_image_accelerate")

    @container_image_accelerate.setter
    def container_image_accelerate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_image_accelerate", value)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[str]]:
        """
        The entrypoint of app.
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="imagePort")
    def image_port(self) -> Optional[pulumi.Input[int]]:
        """
        Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
        """
        return pulumi.get(self, "image_port")

    @image_port.setter
    def image_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_port", value)

    @property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> Optional[pulumi.Input[str]]:
        """
        The registry id of TCR. When image type is enterprise, it must be set.
        """
        return pulumi.get(self, "registry_id")

    @registry_id.setter
    def registry_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_id", value)


@pulumi.input_type
class FunctionIntranetConfigArgs:
    def __init__(__self__, *,
                 ip_fixed: pulumi.Input[str],
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] ip_fixed: Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: If fixed intranet IP is enabled, this field returns the IP list used.
        """
        pulumi.set(__self__, "ip_fixed", ip_fixed)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter(name="ipFixed")
    def ip_fixed(self) -> pulumi.Input[str]:
        """
        Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
        """
        return pulumi.get(self, "ip_fixed")

    @ip_fixed.setter
    def ip_fixed(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_fixed", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If fixed intranet IP is enabled, this field returns the IP list used.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)


@pulumi.input_type
class FunctionLayerArgs:
    def __init__(__self__, *,
                 layer_name: pulumi.Input[str],
                 layer_version: pulumi.Input[int]):
        """
        :param pulumi.Input[str] layer_name: The name of Layer.
        :param pulumi.Input[int] layer_version: The version of layer.
        """
        pulumi.set(__self__, "layer_name", layer_name)
        pulumi.set(__self__, "layer_version", layer_version)

    @property
    @pulumi.getter(name="layerName")
    def layer_name(self) -> pulumi.Input[str]:
        """
        The name of Layer.
        """
        return pulumi.get(self, "layer_name")

    @layer_name.setter
    def layer_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "layer_name", value)

    @property
    @pulumi.getter(name="layerVersion")
    def layer_version(self) -> pulumi.Input[int]:
        """
        The version of layer.
        """
        return pulumi.get(self, "layer_version")

    @layer_version.setter
    def layer_version(self, value: pulumi.Input[int]):
        pulumi.set(self, "layer_version", value)


@pulumi.input_type
class FunctionTriggerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 trigger_desc: pulumi.Input[str],
                 type: pulumi.Input[str],
                 cos_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
        :param pulumi.Input[str] trigger_desc: TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        :param pulumi.Input[str] type: Type of the SCF function trigger, support `cos`, `cls`, `timer`, `ckafka`, `http`, `apigw`, `cmq`.
        :param pulumi.Input[str] cos_region: Region of cos bucket. if `type` is `cos`, `cos_region` is required.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trigger_desc", trigger_desc)
        pulumi.set(__self__, "type", type)
        if cos_region is not None:
            pulumi.set(__self__, "cos_region", cos_region)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> pulumi.Input[str]:
        """
        TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        """
        return pulumi.get(self, "trigger_desc")

    @trigger_desc.setter
    def trigger_desc(self, value: pulumi.Input[str]):
        pulumi.set(self, "trigger_desc", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the SCF function trigger, support `cos`, `cls`, `timer`, `ckafka`, `http`, `apigw`, `cmq`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosRegion")
    def cos_region(self) -> Optional[pulumi.Input[str]]:
        """
        Region of cos bucket. if `type` is `cos`, `cos_region` is required.
        """
        return pulumi.get(self, "cos_region")

    @cos_region.setter
    def cos_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cos_region", value)


@pulumi.input_type
class FunctionTriggerInfoArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[str]] = None,
                 custom_argument: Optional[pulumi.Input[str]] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 modify_time: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 trigger_desc: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create_time: Create time of SCF function trigger.
        :param pulumi.Input[str] custom_argument: User-defined parameters of SCF function trigger.
        :param pulumi.Input[bool] enable: Whether SCF function trigger is enable.
        :param pulumi.Input[str] modify_time: Modify time of SCF function trigger.
        :param pulumi.Input[str] name: Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
        :param pulumi.Input[str] trigger_desc: TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        :param pulumi.Input[str] type: Type of the SCF function trigger, support `cos`, `cls`, `timer`, `ckafka`, `http`, `apigw`, `cmq`.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if custom_argument is not None:
            pulumi.set(__self__, "custom_argument", custom_argument)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if trigger_desc is not None:
            pulumi.set(__self__, "trigger_desc", trigger_desc)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        """
        Create time of SCF function trigger.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter(name="customArgument")
    def custom_argument(self) -> Optional[pulumi.Input[str]]:
        """
        User-defined parameters of SCF function trigger.
        """
        return pulumi.get(self, "custom_argument")

    @custom_argument.setter
    def custom_argument(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_argument", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SCF function trigger is enable.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[pulumi.Input[str]]:
        """
        Modify time of SCF function trigger.
        """
        return pulumi.get(self, "modify_time")

    @modify_time.setter
    def modify_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modify_time", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="triggerDesc")
    def trigger_desc(self) -> Optional[pulumi.Input[str]]:
        """
        TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
        """
        return pulumi.get(self, "trigger_desc")

    @trigger_desc.setter
    def trigger_desc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_desc", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the SCF function trigger, support `cos`, `cls`, `timer`, `ckafka`, `http`, `apigw`, `cmq`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class LayerContentArgs:
    def __init__(__self__, *,
                 cos_bucket_name: Optional[pulumi.Input[str]] = None,
                 cos_bucket_region: Optional[pulumi.Input[str]] = None,
                 cos_object_name: Optional[pulumi.Input[str]] = None,
                 zip_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cos_bucket_name: Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zip_file`.
        :param pulumi.Input[str] cos_bucket_region: Cos bucket region of the SCF layer, conflict with `zip_file`.
        :param pulumi.Input[str] cos_object_name: Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
        :param pulumi.Input[str] zip_file: Zip file of the SCF layer, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
        """
        if cos_bucket_name is not None:
            pulumi.set(__self__, "cos_bucket_name", cos_bucket_name)
        if cos_bucket_region is not None:
            pulumi.set(__self__, "cos_bucket_region", cos_bucket_region)
        if cos_object_name is not None:
            pulumi.set(__self__, "cos_object_name", cos_object_name)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @property
    @pulumi.getter(name="cosBucketName")
    def cos_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_bucket_name")

    @cos_bucket_name.setter
    def cos_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cos_bucket_name", value)

    @property
    @pulumi.getter(name="cosBucketRegion")
    def cos_bucket_region(self) -> Optional[pulumi.Input[str]]:
        """
        Cos bucket region of the SCF layer, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_bucket_region")

    @cos_bucket_region.setter
    def cos_bucket_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cos_bucket_region", value)

    @property
    @pulumi.getter(name="cosObjectName")
    def cos_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
        """
        return pulumi.get(self, "cos_object_name")

    @cos_object_name.setter
    def cos_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cos_object_name", value)

    @property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[pulumi.Input[str]]:
        """
        Zip file of the SCF layer, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
        """
        return pulumi.get(self, "zip_file")

    @zip_file.setter
    def zip_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zip_file", value)


@pulumi.input_type
class ProvisionedConcurrencyConfigTriggerActionArgs:
    def __init__(__self__, *,
                 trigger_cron_config: pulumi.Input[str],
                 trigger_name: pulumi.Input[str],
                 trigger_provisioned_concurrency_num: pulumi.Input[int],
                 provisioned_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] trigger_cron_config: Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] trigger_name: Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[int] trigger_provisioned_concurrency_num: Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] provisioned_type: The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
        """
        pulumi.set(__self__, "trigger_cron_config", trigger_cron_config)
        pulumi.set(__self__, "trigger_name", trigger_name)
        pulumi.set(__self__, "trigger_provisioned_concurrency_num", trigger_provisioned_concurrency_num)
        if provisioned_type is not None:
            pulumi.set(__self__, "provisioned_type", provisioned_type)

    @property
    @pulumi.getter(name="triggerCronConfig")
    def trigger_cron_config(self) -> pulumi.Input[str]:
        """
        Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_cron_config")

    @trigger_cron_config.setter
    def trigger_cron_config(self, value: pulumi.Input[str]):
        pulumi.set(self, "trigger_cron_config", value)

    @property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> pulumi.Input[str]:
        """
        Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_name")

    @trigger_name.setter
    def trigger_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "trigger_name", value)

    @property
    @pulumi.getter(name="triggerProvisionedConcurrencyNum")
    def trigger_provisioned_concurrency_num(self) -> pulumi.Input[int]:
        """
        Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "trigger_provisioned_concurrency_num")

    @trigger_provisioned_concurrency_num.setter
    def trigger_provisioned_concurrency_num(self, value: pulumi.Input[int]):
        pulumi.set(self, "trigger_provisioned_concurrency_num", value)

    @property
    @pulumi.getter(name="provisionedType")
    def provisioned_type(self) -> Optional[pulumi.Input[str]]:
        """
        The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
        """
        return pulumi.get(self, "provisioned_type")

    @provisioned_type.setter
    def provisioned_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioned_type", value)


@pulumi.input_type
class GetTriggersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
        :param Sequence[str] values: Filter values of the field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Filter values of the field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


