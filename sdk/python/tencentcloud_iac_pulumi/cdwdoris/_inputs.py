# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'InstanceBeSpecArgs',
    'InstanceBeSpecArgsDict',
    'InstanceChargePropertiesArgs',
    'InstanceChargePropertiesArgsDict',
    'InstanceFeSpecArgs',
    'InstanceFeSpecArgsDict',
    'InstanceTagArgs',
    'InstanceTagArgsDict',
    'InstanceUserMultiZoneInfosArgs',
    'InstanceUserMultiZoneInfosArgsDict',
    'WorkloadGroupWorkloadGroupArgs',
    'WorkloadGroupWorkloadGroupArgsDict',
    'GetInstancesSearchTagArgs',
    'GetInstancesSearchTagArgsDict',
]

MYPY = False

if not MYPY:
    class InstanceBeSpecArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Quantities.
        """
        disk_size: pulumi.Input[_builtins.int]
        """
        Cloud disk size.
        """
        spec_name: pulumi.Input[_builtins.str]
        """
        Specification name.
        """
elif False:
    InstanceBeSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceBeSpecArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 disk_size: pulumi.Input[_builtins.int],
                 spec_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] count: Quantities.
        :param pulumi.Input[_builtins.int] disk_size: Cloud disk size.
        :param pulumi.Input[_builtins.str] spec_name: Specification name.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "spec_name", spec_name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Quantities.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[_builtins.int]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="specName")
    def spec_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specification name.
        """
        return pulumi.get(self, "spec_name")

    @spec_name.setter
    def spec_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "spec_name", value)


if not MYPY:
    class InstanceChargePropertiesArgsDict(TypedDict):
        charge_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Billing type: `PREPAID` for prepayment, and `POSTPAID_BY_HOUR` for postpayment. Note: This field may return null, indicating that no valid values can be obtained.
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Whether to automatically renew. 1 means automatic renewal is enabled. Note: This field may return null, indicating that no valid values can be obtained.
        """
        time_span: NotRequired[pulumi.Input[_builtins.int]]
        """
        Billing duration Note: This field may return null, indicating that no valid values can be obtained.
        """
        time_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Billing time unit, and `m` means month, etc. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    InstanceChargePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceChargePropertiesArgs:
    def __init__(__self__, *,
                 charge_type: Optional[pulumi.Input[_builtins.str]] = None,
                 renew_flag: Optional[pulumi.Input[_builtins.int]] = None,
                 time_span: Optional[pulumi.Input[_builtins.int]] = None,
                 time_unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] charge_type: Billing type: `PREPAID` for prepayment, and `POSTPAID_BY_HOUR` for postpayment. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] renew_flag: Whether to automatically renew. 1 means automatic renewal is enabled. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] time_span: Billing duration Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] time_unit: Billing time unit, and `m` means month, etc. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if charge_type is not None:
            pulumi.set(__self__, "charge_type", charge_type)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)
        if time_span is not None:
            pulumi.set(__self__, "time_span", time_span)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @_builtins.property
    @pulumi.getter(name="chargeType")
    def charge_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Billing type: `PREPAID` for prepayment, and `POSTPAID_BY_HOUR` for postpayment. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "charge_type")

    @charge_type.setter
    def charge_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charge_type", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether to automatically renew. 1 means automatic renewal is enabled. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "renew_flag", value)

    @_builtins.property
    @pulumi.getter(name="timeSpan")
    def time_span(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Billing duration Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_span")

    @time_span.setter
    def time_span(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "time_span", value)

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Billing time unit, and `m` means month, etc. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class InstanceFeSpecArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Quantities.
        """
        disk_size: pulumi.Input[_builtins.int]
        """
        Cloud disk size.
        """
        spec_name: pulumi.Input[_builtins.str]
        """
        Specification name.
        """
elif False:
    InstanceFeSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFeSpecArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 disk_size: pulumi.Input[_builtins.int],
                 spec_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] count: Quantities.
        :param pulumi.Input[_builtins.int] disk_size: Cloud disk size.
        :param pulumi.Input[_builtins.str] spec_name: Specification name.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "spec_name", spec_name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Quantities.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[_builtins.int]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="specName")
    def spec_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specification name.
        """
        return pulumi.get(self, "spec_name")

    @spec_name.setter
    def spec_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "spec_name", value)


if not MYPY:
    class InstanceTagArgsDict(TypedDict):
        tag_key: pulumi.Input[_builtins.str]
        """
        Tag key.
        """
        tag_value: pulumi.Input[_builtins.str]
        """
        Tag value.
        """
elif False:
    InstanceTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceTagArgs:
    def __init__(__self__, *,
                 tag_key: pulumi.Input[_builtins.str],
                 tag_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] tag_key: Tag key.
        :param pulumi.Input[_builtins.str] tag_value: Tag value.
        """
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_value", tag_value)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[_builtins.str]:
        """
        Tag key.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_key", value)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> pulumi.Input[_builtins.str]:
        """
        Tag value.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class InstanceUserMultiZoneInfosArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet ID Note: This field may return null, indicating that no valid values can be obtained.
        """
        subnet_ip_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of available IP addresses in the current subnet Note: This field may return null, indicating that no valid values can be obtained.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Availability zone Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    InstanceUserMultiZoneInfosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceUserMultiZoneInfosArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_ip_num: Optional[pulumi.Input[_builtins.int]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Subnet ID Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] subnet_ip_num: The number of available IP addresses in the current subnet Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] zone: Availability zone Note: This field may return null, indicating that no valid values can be obtained.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if subnet_ip_num is not None:
            pulumi.set(__self__, "subnet_ip_num", subnet_ip_num)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet ID Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetIpNum")
    def subnet_ip_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of available IP addresses in the current subnet Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "subnet_ip_num")

    @subnet_ip_num.setter
    def subnet_ip_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "subnet_ip_num", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Availability zone Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class WorkloadGroupWorkloadGroupArgsDict(TypedDict):
        cpu_hard_limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cpu hard limit. Note: This field may return null, indicating that no valid value can be obtained.
        """
        cpu_share: NotRequired[pulumi.Input[_builtins.int]]
        """
        CPU weight. Note: This field may return null, indicating that no valid value can be obtained.
        """
        enable_memory_over_commit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow over-allocation. Note: This field may return null, indicating that no valid value can be obtained.
        """
        memory_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory limit, the sum of the memory limit values of all resource groups should be less than or equal to 100. Note: This field may return null, indicating that no valid value can be obtained.
        """
        workload_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Workload group name. Note: This field may return null, indicating that no valid value can be obtained.
        """
elif False:
    WorkloadGroupWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadGroupWorkloadGroupArgs:
    def __init__(__self__, *,
                 cpu_hard_limit: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_share: Optional[pulumi.Input[_builtins.int]] = None,
                 enable_memory_over_commit: Optional[pulumi.Input[_builtins.bool]] = None,
                 memory_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 workload_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_hard_limit: Cpu hard limit. Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[_builtins.int] cpu_share: CPU weight. Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[_builtins.bool] enable_memory_over_commit: Whether to allow over-allocation. Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[_builtins.int] memory_limit: Memory limit, the sum of the memory limit values of all resource groups should be less than or equal to 100. Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[_builtins.str] workload_group_name: Workload group name. Note: This field may return null, indicating that no valid value can be obtained.
        """
        if cpu_hard_limit is not None:
            pulumi.set(__self__, "cpu_hard_limit", cpu_hard_limit)
        if cpu_share is not None:
            pulumi.set(__self__, "cpu_share", cpu_share)
        if enable_memory_over_commit is not None:
            pulumi.set(__self__, "enable_memory_over_commit", enable_memory_over_commit)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if workload_group_name is not None:
            pulumi.set(__self__, "workload_group_name", workload_group_name)

    @_builtins.property
    @pulumi.getter(name="cpuHardLimit")
    def cpu_hard_limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cpu hard limit. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cpu_hard_limit")

    @cpu_hard_limit.setter
    def cpu_hard_limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_hard_limit", value)

    @_builtins.property
    @pulumi.getter(name="cpuShare")
    def cpu_share(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        CPU weight. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cpu_share")

    @cpu_share.setter
    def cpu_share(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_share", value)

    @_builtins.property
    @pulumi.getter(name="enableMemoryOverCommit")
    def enable_memory_over_commit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow over-allocation. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "enable_memory_over_commit")

    @enable_memory_over_commit.setter
    def enable_memory_over_commit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_memory_over_commit", value)

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory limit, the sum of the memory limit values of all resource groups should be less than or equal to 100. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory_limit", value)

    @_builtins.property
    @pulumi.getter(name="workloadGroupName")
    def workload_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Workload group name. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "workload_group_name")

    @workload_group_name.setter
    def workload_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_group_name", value)


if not MYPY:
    class GetInstancesSearchTagArgsDict(TypedDict):
        all_value: NotRequired[_builtins.int]
        """
        1 means only the tag key is entered without a value, and 0 means both the key and the value are entered.
        """
        tag_key: NotRequired[_builtins.str]
        """
        Tag key.
        """
        tag_value: NotRequired[_builtins.str]
        """
        Tag value.
        """
elif False:
    GetInstancesSearchTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancesSearchTagArgs:
    def __init__(__self__, *,
                 all_value: Optional[_builtins.int] = None,
                 tag_key: Optional[_builtins.str] = None,
                 tag_value: Optional[_builtins.str] = None):
        """
        :param _builtins.int all_value: 1 means only the tag key is entered without a value, and 0 means both the key and the value are entered.
        :param _builtins.str tag_key: Tag key.
        :param _builtins.str tag_value: Tag value.
        """
        if all_value is not None:
            pulumi.set(__self__, "all_value", all_value)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @_builtins.property
    @pulumi.getter(name="allValue")
    def all_value(self) -> Optional[_builtins.int]:
        """
        1 means only the tag key is entered without a value, and 0 means both the key and the value are entered.
        """
        return pulumi.get(self, "all_value")

    @all_value.setter
    def all_value(self, value: Optional[_builtins.int]):
        pulumi.set(self, "all_value", value)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[_builtins.str]:
        """
        Tag key.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tag_key", value)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[_builtins.str]:
        """
        Tag value.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tag_value", value)


