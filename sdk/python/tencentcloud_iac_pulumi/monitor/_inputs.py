# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlarmNoticeClsNoticeArgs',
    'AlarmNoticeClsNoticeArgsDict',
    'AlarmNoticeUrlNoticeArgs',
    'AlarmNoticeUrlNoticeArgsDict',
    'AlarmNoticeUserNoticeArgs',
    'AlarmNoticeUserNoticeArgsDict',
    'AlarmPolicyConditionsArgs',
    'AlarmPolicyConditionsArgsDict',
    'AlarmPolicyConditionsRuleArgs',
    'AlarmPolicyConditionsRuleArgsDict',
    'AlarmPolicyConditionsRuleFilterArgs',
    'AlarmPolicyConditionsRuleFilterArgsDict',
    'AlarmPolicyEventConditionArgs',
    'AlarmPolicyEventConditionArgsDict',
    'AlarmPolicyEventConditionFilterArgs',
    'AlarmPolicyEventConditionFilterArgsDict',
    'AlarmPolicyFilterArgs',
    'AlarmPolicyFilterArgsDict',
    'AlarmPolicyPolicyTagArgs',
    'AlarmPolicyPolicyTagArgsDict',
    'AlarmPolicyTriggerTaskArgs',
    'AlarmPolicyTriggerTaskArgsDict',
    'BindingReceiverReceiversArgs',
    'BindingReceiverReceiversArgsDict',
    'GrafanaSsoAccountRoleArgs',
    'GrafanaSsoAccountRoleArgsDict',
    'PolicyBindingObjectDimensionArgs',
    'PolicyBindingObjectDimensionArgsDict',
    'TmpAlertGroupCustomReceiverArgs',
    'TmpAlertGroupCustomReceiverArgsDict',
    'TmpAlertGroupCustomReceiverAllowedTimeRangeArgs',
    'TmpAlertGroupCustomReceiverAllowedTimeRangeArgsDict',
    'TmpAlertGroupRuleArgs',
    'TmpAlertGroupRuleArgsDict',
    'TmpAlertRuleAnnotationArgs',
    'TmpAlertRuleAnnotationArgsDict',
    'TmpAlertRuleLabelArgs',
    'TmpAlertRuleLabelArgsDict',
    'TmpMultipleWritesListRemoteWriteArgs',
    'TmpMultipleWritesListRemoteWriteArgsDict',
    'TmpMultipleWritesListRemoteWriteBasicAuthArgs',
    'TmpMultipleWritesListRemoteWriteBasicAuthArgsDict',
    'TmpMultipleWritesListRemoteWriteHeaderArgs',
    'TmpMultipleWritesListRemoteWriteHeaderArgsDict',
    'TmpTkeAlertPolicyAlertRuleArgs',
    'TmpTkeAlertPolicyAlertRuleArgsDict',
    'TmpTkeAlertPolicyAlertRuleNotificationArgs',
    'TmpTkeAlertPolicyAlertRuleNotificationArgsDict',
    'TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgs',
    'TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgsDict',
    'TmpTkeAlertPolicyAlertRuleRuleArgs',
    'TmpTkeAlertPolicyAlertRuleRuleArgsDict',
    'TmpTkeAlertPolicyAlertRuleRuleAnnotationArgs',
    'TmpTkeAlertPolicyAlertRuleRuleAnnotationArgsDict',
    'TmpTkeAlertPolicyAlertRuleRuleLabelArgs',
    'TmpTkeAlertPolicyAlertRuleRuleLabelArgsDict',
    'TmpTkeClusterAgentAgentsArgs',
    'TmpTkeClusterAgentAgentsArgsDict',
    'TmpTkeClusterAgentAgentsExternalLabelArgs',
    'TmpTkeClusterAgentAgentsExternalLabelArgsDict',
    'TmpTkeClusterAgentAgentsInClusterPodConfigArgs',
    'TmpTkeClusterAgentAgentsInClusterPodConfigArgsDict',
    'TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgs',
    'TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgsDict',
    'TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgs',
    'TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgsDict',
    'TmpTkeConfigPodMonitorArgs',
    'TmpTkeConfigPodMonitorArgsDict',
    'TmpTkeConfigRawJobArgs',
    'TmpTkeConfigRawJobArgsDict',
    'TmpTkeConfigServiceMonitorArgs',
    'TmpTkeConfigServiceMonitorArgsDict',
    'TmpTkeGlobalNotificationNotificationArgs',
    'TmpTkeGlobalNotificationNotificationArgsDict',
    'TmpTkeGlobalNotificationNotificationAlertManagerArgs',
    'TmpTkeGlobalNotificationNotificationAlertManagerArgsDict',
    'TmpTkeTemplateAttachmentTargetsArgs',
    'TmpTkeTemplateAttachmentTargetsArgsDict',
    'TmpTkeTemplateTemplateArgs',
    'TmpTkeTemplateTemplateArgsDict',
    'TmpTkeTemplateTemplatePodMonitorArgs',
    'TmpTkeTemplateTemplatePodMonitorArgsDict',
    'TmpTkeTemplateTemplateRawJobArgs',
    'TmpTkeTemplateTemplateRawJobArgsDict',
    'TmpTkeTemplateTemplateRecordRuleArgs',
    'TmpTkeTemplateTemplateRecordRuleArgsDict',
    'TmpTkeTemplateTemplateServiceMonitorArgs',
    'TmpTkeTemplateTemplateServiceMonitorArgsDict',
    'GetAlarmHistoryNamespaceArgs',
    'GetAlarmHistoryNamespaceArgsDict',
    'GetAlarmPolicyTriggerTaskArgs',
    'GetAlarmPolicyTriggerTaskArgsDict',
    'GetDataDimensionArgs',
    'GetDataDimensionArgsDict',
    'GetProductEventDimensionArgs',
    'GetProductEventDimensionArgsDict',
    'GetStatisticDataConditionArgs',
    'GetStatisticDataConditionArgsDict',
    'GetTmpInstancesTagFilterArgs',
    'GetTmpInstancesTagFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AlarmNoticeClsNoticeArgsDict(TypedDict):
        log_set_id: pulumi.Input[_builtins.str]
        """
        Log collection Id.
        """
        region: pulumi.Input[_builtins.str]
        """
        Regional.
        """
        topic_id: pulumi.Input[_builtins.str]
        """
        Theme Id.
        """
        enable: NotRequired[pulumi.Input[_builtins.int]]
        """
        Start-stop status, can not be transmitted, default enabled. 0= Disabled, 1= enabled.
        """
elif False:
    AlarmNoticeClsNoticeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmNoticeClsNoticeArgs:
    def __init__(__self__, *,
                 log_set_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 topic_id: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] log_set_id: Log collection Id.
        :param pulumi.Input[_builtins.str] region: Regional.
        :param pulumi.Input[_builtins.str] topic_id: Theme Id.
        :param pulumi.Input[_builtins.int] enable: Start-stop status, can not be transmitted, default enabled. 0= Disabled, 1= enabled.
        """
        pulumi.set(__self__, "log_set_id", log_set_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "topic_id", topic_id)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter(name="logSetId")
    def log_set_id(self) -> pulumi.Input[_builtins.str]:
        """
        Log collection Id.
        """
        return pulumi.get(self, "log_set_id")

    @log_set_id.setter
    def log_set_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_set_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Regional.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[_builtins.str]:
        """
        Theme Id.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_id", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Start-stop status, can not be transmitted, default enabled. 0= Disabled, 1= enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class AlarmNoticeUrlNoticeArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Callback URL (limited to 256 characters).
        """
        end_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Notification End Time Seconds at the start of a day.
        """
        is_valid: NotRequired[pulumi.Input[_builtins.int]]
        """
        If passed verification `0` is no, `1` is yes. Default `0`.
        """
        start_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Notification Start Time Number of seconds at the start of a day.
        """
        validation_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Verification code.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Notification period 1-7 indicates Monday to Sunday.
        """
elif False:
    AlarmNoticeUrlNoticeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmNoticeUrlNoticeArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.int]] = None,
                 is_valid: Optional[pulumi.Input[_builtins.int]] = None,
                 start_time: Optional[pulumi.Input[_builtins.int]] = None,
                 validation_code: Optional[pulumi.Input[_builtins.str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Callback URL (limited to 256 characters).
        :param pulumi.Input[_builtins.int] end_time: Notification End Time Seconds at the start of a day.
        :param pulumi.Input[_builtins.int] is_valid: If passed verification `0` is no, `1` is yes. Default `0`.
        :param pulumi.Input[_builtins.int] start_time: Notification Start Time Number of seconds at the start of a day.
        :param pulumi.Input[_builtins.str] validation_code: Verification code.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] weekdays: Notification period 1-7 indicates Monday to Sunday.
        """
        pulumi.set(__self__, "url", url)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if is_valid is not None:
            pulumi.set(__self__, "is_valid", is_valid)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if validation_code is not None:
            pulumi.set(__self__, "validation_code", validation_code)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Callback URL (limited to 256 characters).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Notification End Time Seconds at the start of a day.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="isValid")
    def is_valid(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If passed verification `0` is no, `1` is yes. Default `0`.
        """
        return pulumi.get(self, "is_valid")

    @is_valid.setter
    def is_valid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_valid", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Notification Start Time Number of seconds at the start of a day.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="validationCode")
    def validation_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Verification code.
        """
        return pulumi.get(self, "validation_code")

    @validation_code.setter
    def validation_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_code", value)

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Notification period 1-7 indicates Monday to Sunday.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "weekdays", value)


if not MYPY:
    class AlarmNoticeUserNoticeArgsDict(TypedDict):
        end_time: pulumi.Input[_builtins.int]
        """
        The number of seconds since the notification end time 00:00:00 (value range 0-86399).
        """
        notice_ways: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Notification Channel List EMAIL=Mail SMS=SMS CALL=Telephone WECHAT=WeChat RTX=Enterprise WeChat.
        """
        receiver_type: pulumi.Input[_builtins.str]
        """
        Recipient Type USER=User GROUP=User Group.
        """
        start_time: pulumi.Input[_builtins.int]
        """
        The number of seconds since the notification start time 00:00:00 (value range 0-86399).
        """
        group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        User group ID list.
        """
        need_phone_arrive_notice: NotRequired[pulumi.Input[_builtins.int]]
        """
        Contact notification required 0= No 1= Yes.
        """
        phone_call_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Call type SYNC= Simultaneous call CIRCLE= Round call If this parameter is not specified, the default value is round call.
        """
        phone_circle_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds between polls (value range: 60-900).
        """
        phone_circle_times: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of telephone polls (value range: 1-5).
        """
        phone_inner_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds between calls in a polling session (value range: 60-900).
        """
        phone_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Telephone polling list.
        """
        user_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        User UID List.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Notification period 1-7 indicates Monday to Sunday.
        """
elif False:
    AlarmNoticeUserNoticeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmNoticeUserNoticeArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[_builtins.int],
                 notice_ways: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 receiver_type: pulumi.Input[_builtins.str],
                 start_time: pulumi.Input[_builtins.int],
                 group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 need_phone_arrive_notice: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_call_type: Optional[pulumi.Input[_builtins.str]] = None,
                 phone_circle_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_circle_times: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_inner_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_orders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.int] end_time: The number of seconds since the notification end time 00:00:00 (value range 0-86399).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notice_ways: Notification Channel List EMAIL=Mail SMS=SMS CALL=Telephone WECHAT=WeChat RTX=Enterprise WeChat.
        :param pulumi.Input[_builtins.str] receiver_type: Recipient Type USER=User GROUP=User Group.
        :param pulumi.Input[_builtins.int] start_time: The number of seconds since the notification start time 00:00:00 (value range 0-86399).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] group_ids: User group ID list.
        :param pulumi.Input[_builtins.int] need_phone_arrive_notice: Contact notification required 0= No 1= Yes.
        :param pulumi.Input[_builtins.str] phone_call_type: Call type SYNC= Simultaneous call CIRCLE= Round call If this parameter is not specified, the default value is round call.
        :param pulumi.Input[_builtins.int] phone_circle_interval: Number of seconds between polls (value range: 60-900).
        :param pulumi.Input[_builtins.int] phone_circle_times: Number of telephone polls (value range: 1-5).
        :param pulumi.Input[_builtins.int] phone_inner_interval: Number of seconds between calls in a polling session (value range: 60-900).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] phone_orders: Telephone polling list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] user_ids: User UID List.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] weekdays: Notification period 1-7 indicates Monday to Sunday.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "notice_ways", notice_ways)
        pulumi.set(__self__, "receiver_type", receiver_type)
        pulumi.set(__self__, "start_time", start_time)
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if need_phone_arrive_notice is not None:
            pulumi.set(__self__, "need_phone_arrive_notice", need_phone_arrive_notice)
        if phone_call_type is not None:
            pulumi.set(__self__, "phone_call_type", phone_call_type)
        if phone_circle_interval is not None:
            pulumi.set(__self__, "phone_circle_interval", phone_circle_interval)
        if phone_circle_times is not None:
            pulumi.set(__self__, "phone_circle_times", phone_circle_times)
        if phone_inner_interval is not None:
            pulumi.set(__self__, "phone_inner_interval", phone_inner_interval)
        if phone_orders is not None:
            pulumi.set(__self__, "phone_orders", phone_orders)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[_builtins.int]:
        """
        The number of seconds since the notification end time 00:00:00 (value range 0-86399).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="noticeWays")
    def notice_ways(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Notification Channel List EMAIL=Mail SMS=SMS CALL=Telephone WECHAT=WeChat RTX=Enterprise WeChat.
        """
        return pulumi.get(self, "notice_ways")

    @notice_ways.setter
    def notice_ways(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notice_ways", value)

    @_builtins.property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> pulumi.Input[_builtins.str]:
        """
        Recipient Type USER=User GROUP=User Group.
        """
        return pulumi.get(self, "receiver_type")

    @receiver_type.setter
    def receiver_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "receiver_type", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.int]:
        """
        The number of seconds since the notification start time 00:00:00 (value range 0-86399).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        User group ID list.
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "group_ids", value)

    @_builtins.property
    @pulumi.getter(name="needPhoneArriveNotice")
    def need_phone_arrive_notice(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Contact notification required 0= No 1= Yes.
        """
        return pulumi.get(self, "need_phone_arrive_notice")

    @need_phone_arrive_notice.setter
    def need_phone_arrive_notice(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "need_phone_arrive_notice", value)

    @_builtins.property
    @pulumi.getter(name="phoneCallType")
    def phone_call_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Call type SYNC= Simultaneous call CIRCLE= Round call If this parameter is not specified, the default value is round call.
        """
        return pulumi.get(self, "phone_call_type")

    @phone_call_type.setter
    def phone_call_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phone_call_type", value)

    @_builtins.property
    @pulumi.getter(name="phoneCircleInterval")
    def phone_circle_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds between polls (value range: 60-900).
        """
        return pulumi.get(self, "phone_circle_interval")

    @phone_circle_interval.setter
    def phone_circle_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_circle_interval", value)

    @_builtins.property
    @pulumi.getter(name="phoneCircleTimes")
    def phone_circle_times(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of telephone polls (value range: 1-5).
        """
        return pulumi.get(self, "phone_circle_times")

    @phone_circle_times.setter
    def phone_circle_times(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_circle_times", value)

    @_builtins.property
    @pulumi.getter(name="phoneInnerInterval")
    def phone_inner_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds between calls in a polling session (value range: 60-900).
        """
        return pulumi.get(self, "phone_inner_interval")

    @phone_inner_interval.setter
    def phone_inner_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_inner_interval", value)

    @_builtins.property
    @pulumi.getter(name="phoneOrders")
    def phone_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Telephone polling list.
        """
        return pulumi.get(self, "phone_orders")

    @phone_orders.setter
    def phone_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "phone_orders", value)

    @_builtins.property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        User UID List.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "user_ids", value)

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Notification period 1-7 indicates Monday to Sunday.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "weekdays", value)


if not MYPY:
    class AlarmPolicyConditionsArgsDict(TypedDict):
        is_union_rule: NotRequired[pulumi.Input[_builtins.int]]
        """
        The and or relation of indicator alarm rule.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyConditionsRuleArgsDict']]]]
        """
        A list of metric trigger condition.
        """
elif False:
    AlarmPolicyConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyConditionsArgs:
    def __init__(__self__, *,
                 is_union_rule: Optional[pulumi.Input[_builtins.int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyConditionsRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] is_union_rule: The and or relation of indicator alarm rule.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmPolicyConditionsRuleArgs']]] rules: A list of metric trigger condition.
        """
        if is_union_rule is not None:
            pulumi.set(__self__, "is_union_rule", is_union_rule)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="isUnionRule")
    def is_union_rule(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The and or relation of indicator alarm rule.
        """
        return pulumi.get(self, "is_union_rule")

    @is_union_rule.setter
    def is_union_rule(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_union_rule", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyConditionsRuleArgs']]]]:
        """
        A list of metric trigger condition.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyConditionsRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AlarmPolicyConditionsRuleArgsDict(TypedDict):
        continue_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of periods.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric display name, which is used in the output parameter.
        """
        filter: NotRequired[pulumi.Input['AlarmPolicyConditionsRuleFilterArgsDict']]
        """
        Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
        """
        is_power_notice: NotRequired[pulumi.Input[_builtins.int]]
        """
        Whether the alarm frequency increases exponentially.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric name or event name.
        """
        notice_frequency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm interval in seconds.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator.
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Statistical period in seconds.
        """
        rule_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Trigger condition type.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unit, which is used in the output parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threshold.
        """
elif False:
    AlarmPolicyConditionsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyConditionsRuleArgs:
    def __init__(__self__, *,
                 continue_period: Optional[pulumi.Input[_builtins.int]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 filter: Optional[pulumi.Input['AlarmPolicyConditionsRuleFilterArgs']] = None,
                 is_power_notice: Optional[pulumi.Input[_builtins.int]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 notice_frequency: Optional[pulumi.Input[_builtins.int]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_type: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] continue_period: Number of periods.
        :param pulumi.Input[_builtins.str] description: Metric display name, which is used in the output parameter.
        :param pulumi.Input['AlarmPolicyConditionsRuleFilterArgs'] filter: Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
        :param pulumi.Input[_builtins.int] is_power_notice: Whether the alarm frequency increases exponentially.
        :param pulumi.Input[_builtins.str] metric_name: Metric name or event name.
        :param pulumi.Input[_builtins.int] notice_frequency: Alarm interval in seconds.
        :param pulumi.Input[_builtins.str] operator: Operator.
        :param pulumi.Input[_builtins.int] period: Statistical period in seconds.
        :param pulumi.Input[_builtins.str] rule_type: Trigger condition type.
        :param pulumi.Input[_builtins.str] unit: Unit, which is used in the output parameter.
        :param pulumi.Input[_builtins.str] value: Threshold.
        """
        if continue_period is not None:
            pulumi.set(__self__, "continue_period", continue_period)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if is_power_notice is not None:
            pulumi.set(__self__, "is_power_notice", is_power_notice)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if notice_frequency is not None:
            pulumi.set(__self__, "notice_frequency", notice_frequency)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="continuePeriod")
    def continue_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of periods.
        """
        return pulumi.get(self, "continue_period")

    @continue_period.setter
    def continue_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "continue_period", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric display name, which is used in the output parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['AlarmPolicyConditionsRuleFilterArgs']]:
        """
        Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['AlarmPolicyConditionsRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="isPowerNotice")
    def is_power_notice(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether the alarm frequency increases exponentially.
        """
        return pulumi.get(self, "is_power_notice")

    @is_power_notice.setter
    def is_power_notice(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_power_notice", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric name or event name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="noticeFrequency")
    def notice_frequency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm interval in seconds.
        """
        return pulumi.get(self, "notice_frequency")

    @notice_frequency.setter
    def notice_frequency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "notice_frequency", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Statistical period in seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Trigger condition type.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unit, which is used in the output parameter.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threshold.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmPolicyConditionsRuleFilterArgsDict(TypedDict):
        dimensions: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
elif False:
    AlarmPolicyConditionsRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyConditionsRuleFilterArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dimensions: JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        :param pulumi.Input[_builtins.str] type: Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmPolicyEventConditionArgsDict(TypedDict):
        continue_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of periods.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric display name, which is used in the output parameter.
        """
        filter: NotRequired[pulumi.Input['AlarmPolicyEventConditionFilterArgsDict']]
        """
        Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
        """
        is_power_notice: NotRequired[pulumi.Input[_builtins.int]]
        """
        Whether the alarm frequency increases exponentially.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric name or event name.
        """
        notice_frequency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm interval in seconds.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator.
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Statistical period in seconds.
        """
        rule_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Trigger condition type.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unit, which is used in the output parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threshold.
        """
elif False:
    AlarmPolicyEventConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyEventConditionArgs:
    def __init__(__self__, *,
                 continue_period: Optional[pulumi.Input[_builtins.int]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 filter: Optional[pulumi.Input['AlarmPolicyEventConditionFilterArgs']] = None,
                 is_power_notice: Optional[pulumi.Input[_builtins.int]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 notice_frequency: Optional[pulumi.Input[_builtins.int]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_type: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] continue_period: Number of periods.
        :param pulumi.Input[_builtins.str] description: Metric display name, which is used in the output parameter.
        :param pulumi.Input['AlarmPolicyEventConditionFilterArgs'] filter: Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
        :param pulumi.Input[_builtins.int] is_power_notice: Whether the alarm frequency increases exponentially.
        :param pulumi.Input[_builtins.str] metric_name: Metric name or event name.
        :param pulumi.Input[_builtins.int] notice_frequency: Alarm interval in seconds.
        :param pulumi.Input[_builtins.str] operator: Operator.
        :param pulumi.Input[_builtins.int] period: Statistical period in seconds.
        :param pulumi.Input[_builtins.str] rule_type: Trigger condition type.
        :param pulumi.Input[_builtins.str] unit: Unit, which is used in the output parameter.
        :param pulumi.Input[_builtins.str] value: Threshold.
        """
        if continue_period is not None:
            pulumi.set(__self__, "continue_period", continue_period)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if is_power_notice is not None:
            pulumi.set(__self__, "is_power_notice", is_power_notice)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if notice_frequency is not None:
            pulumi.set(__self__, "notice_frequency", notice_frequency)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="continuePeriod")
    def continue_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of periods.
        """
        return pulumi.get(self, "continue_period")

    @continue_period.setter
    def continue_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "continue_period", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric display name, which is used in the output parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['AlarmPolicyEventConditionFilterArgs']]:
        """
        Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['AlarmPolicyEventConditionFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="isPowerNotice")
    def is_power_notice(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether the alarm frequency increases exponentially.
        """
        return pulumi.get(self, "is_power_notice")

    @is_power_notice.setter
    def is_power_notice(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_power_notice", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric name or event name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="noticeFrequency")
    def notice_frequency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm interval in seconds.
        """
        return pulumi.get(self, "notice_frequency")

    @notice_frequency.setter
    def notice_frequency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "notice_frequency", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Statistical period in seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Trigger condition type.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unit, which is used in the output parameter.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threshold.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmPolicyEventConditionFilterArgsDict(TypedDict):
        dimensions: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
elif False:
    AlarmPolicyEventConditionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyEventConditionFilterArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dimensions: JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        :param pulumi.Input[_builtins.str] type: Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmPolicyFilterArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
        dimensions: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        """
elif False:
    AlarmPolicyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 dimensions: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        :param pulumi.Input[_builtins.str] dimensions: JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        """
        pulumi.set(__self__, "type", type)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class AlarmPolicyPolicyTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Tag value.
        """
elif False:
    AlarmPolicyPolicyTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyPolicyTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Tag key.
        :param pulumi.Input[_builtins.str] value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmPolicyTriggerTaskArgsDict(TypedDict):
        task_config: pulumi.Input[_builtins.str]
        """
        Configuration information in JSON format.
        """
        type: pulumi.Input[_builtins.str]
        """
        Triggered task type.
        """
elif False:
    AlarmPolicyTriggerTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyTriggerTaskArgs:
    def __init__(__self__, *,
                 task_config: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] task_config: Configuration information in JSON format.
        :param pulumi.Input[_builtins.str] type: Triggered task type.
        """
        pulumi.set(__self__, "task_config", task_config)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="taskConfig")
    def task_config(self) -> pulumi.Input[_builtins.str]:
        """
        Configuration information in JSON format.
        """
        return pulumi.get(self, "task_config")

    @task_config.setter
    def task_config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "task_config", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Triggered task type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class BindingReceiverReceiversArgsDict(TypedDict):
        notify_ways: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Method of warning notification.Optional `CALL`,`EMAIL`,`SITE`,`SMS`,`WECHAT`.
        """
        receiver_type: pulumi.Input[_builtins.str]
        """
        Receive type. Optional `group`,`user`.
        """
        end_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        End of alarm period. Meaning with `start_time`.
        """
        receive_language: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alert sending language. Optional `en-US`,`zh-CN`.
        """
        receiver_group_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Alarm receive group ID list.
        """
        receiver_user_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Alarm receiver ID list.
        """
        start_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm period start time. Valid value ranges: (0~86399). which removes the date after it is converted to Beijing time as a Unix timestamp, for example 7200 means '10:0:0'.
        """
elif False:
    BindingReceiverReceiversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BindingReceiverReceiversArgs:
    def __init__(__self__, *,
                 notify_ways: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 receiver_type: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.int]] = None,
                 receive_language: Optional[pulumi.Input[_builtins.str]] = None,
                 receiver_group_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 receiver_user_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 start_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notify_ways: Method of warning notification.Optional `CALL`,`EMAIL`,`SITE`,`SMS`,`WECHAT`.
        :param pulumi.Input[_builtins.str] receiver_type: Receive type. Optional `group`,`user`.
        :param pulumi.Input[_builtins.int] end_time: End of alarm period. Meaning with `start_time`.
        :param pulumi.Input[_builtins.str] receive_language: Alert sending language. Optional `en-US`,`zh-CN`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] receiver_group_lists: Alarm receive group ID list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] receiver_user_lists: Alarm receiver ID list.
        :param pulumi.Input[_builtins.int] start_time: Alarm period start time. Valid value ranges: (0~86399). which removes the date after it is converted to Beijing time as a Unix timestamp, for example 7200 means '10:0:0'.
        """
        pulumi.set(__self__, "notify_ways", notify_ways)
        pulumi.set(__self__, "receiver_type", receiver_type)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if receive_language is not None:
            pulumi.set(__self__, "receive_language", receive_language)
        if receiver_group_lists is not None:
            pulumi.set(__self__, "receiver_group_lists", receiver_group_lists)
        if receiver_user_lists is not None:
            pulumi.set(__self__, "receiver_user_lists", receiver_user_lists)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="notifyWays")
    def notify_ways(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Method of warning notification.Optional `CALL`,`EMAIL`,`SITE`,`SMS`,`WECHAT`.
        """
        return pulumi.get(self, "notify_ways")

    @notify_ways.setter
    def notify_ways(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notify_ways", value)

    @_builtins.property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> pulumi.Input[_builtins.str]:
        """
        Receive type. Optional `group`,`user`.
        """
        return pulumi.get(self, "receiver_type")

    @receiver_type.setter
    def receiver_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "receiver_type", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        End of alarm period. Meaning with `start_time`.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="receiveLanguage")
    def receive_language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alert sending language. Optional `en-US`,`zh-CN`.
        """
        return pulumi.get(self, "receive_language")

    @receive_language.setter
    def receive_language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "receive_language", value)

    @_builtins.property
    @pulumi.getter(name="receiverGroupLists")
    def receiver_group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Alarm receive group ID list.
        """
        return pulumi.get(self, "receiver_group_lists")

    @receiver_group_lists.setter
    def receiver_group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "receiver_group_lists", value)

    @_builtins.property
    @pulumi.getter(name="receiverUserLists")
    def receiver_user_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Alarm receiver ID list.
        """
        return pulumi.get(self, "receiver_user_lists")

    @receiver_user_lists.setter
    def receiver_user_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "receiver_user_lists", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm period start time. Valid value ranges: (0~86399). which removes the date after it is converted to Beijing time as a Unix timestamp, for example 7200 means '10:0:0'.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class GrafanaSsoAccountRoleArgsDict(TypedDict):
        organization: pulumi.Input[_builtins.str]
        """
        Grafana organization id string.
        """
        role: pulumi.Input[_builtins.str]
        """
        Grafana role, one of {Admin,Editor,Viewer}.
        """
elif False:
    GrafanaSsoAccountRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrafanaSsoAccountRoleArgs:
    def __init__(__self__, *,
                 organization: pulumi.Input[_builtins.str],
                 role: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] organization: Grafana organization id string.
        :param pulumi.Input[_builtins.str] role: Grafana role, one of {Admin,Editor,Viewer}.
        """
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> pulumi.Input[_builtins.str]:
        """
        Grafana organization id string.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        Grafana role, one of {Admin,Editor,Viewer}.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)


if not MYPY:
    class PolicyBindingObjectDimensionArgsDict(TypedDict):
        dimensions_json: pulumi.Input[_builtins.str]
        """
        Represents a collection of dimensions of an object instance, json format.eg:'{"unInstanceId":"ins-ot3cq4bi"}'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region.
        """
        unique_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object unique ID.
        """
elif False:
    PolicyBindingObjectDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyBindingObjectDimensionArgs:
    def __init__(__self__, *,
                 dimensions_json: pulumi.Input[_builtins.str],
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 unique_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dimensions_json: Represents a collection of dimensions of an object instance, json format.eg:'{"unInstanceId":"ins-ot3cq4bi"}'.
        :param pulumi.Input[_builtins.str] region: Region.
        :param pulumi.Input[_builtins.str] unique_id: Object unique ID.
        """
        pulumi.set(__self__, "dimensions_json", dimensions_json)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if unique_id is not None:
            pulumi.set(__self__, "unique_id", unique_id)

    @_builtins.property
    @pulumi.getter(name="dimensionsJson")
    def dimensions_json(self) -> pulumi.Input[_builtins.str]:
        """
        Represents a collection of dimensions of an object instance, json format.eg:'{"unInstanceId":"ins-ot3cq4bi"}'.
        """
        return pulumi.get(self, "dimensions_json")

    @dimensions_json.setter
    def dimensions_json(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dimensions_json", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object unique ID.
        """
        return pulumi.get(self, "unique_id")

    @unique_id.setter
    def unique_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unique_id", value)


if not MYPY:
    class TmpAlertGroupCustomReceiverArgsDict(TypedDict):
        allowed_time_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpAlertGroupCustomReceiverAllowedTimeRangeArgsDict']]]]
        """
        Time ranges which allow alert message send.
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Only effect when alertmanager in user cluster, this cluster id.
        """
        cluster_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Only effect when alertmanager in user cluster, this cluster type (tke|eks|tdcc).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom receiver type, webhook|alertmanager.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom receiver address, can be accessed by process in prometheus instance subnet.
        """
elif False:
    TmpAlertGroupCustomReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpAlertGroupCustomReceiverArgs:
    def __init__(__self__, *,
                 allowed_time_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['TmpAlertGroupCustomReceiverAllowedTimeRangeArgs']]]] = None,
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TmpAlertGroupCustomReceiverAllowedTimeRangeArgs']]] allowed_time_ranges: Time ranges which allow alert message send.
        :param pulumi.Input[_builtins.str] cluster_id: Only effect when alertmanager in user cluster, this cluster id.
        :param pulumi.Input[_builtins.str] cluster_type: Only effect when alertmanager in user cluster, this cluster type (tke|eks|tdcc).
        :param pulumi.Input[_builtins.str] type: Custom receiver type, webhook|alertmanager.
        :param pulumi.Input[_builtins.str] url: Custom receiver address, can be accessed by process in prometheus instance subnet.
        """
        if allowed_time_ranges is not None:
            pulumi.set(__self__, "allowed_time_ranges", allowed_time_ranges)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="allowedTimeRanges")
    def allowed_time_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpAlertGroupCustomReceiverAllowedTimeRangeArgs']]]]:
        """
        Time ranges which allow alert message send.
        """
        return pulumi.get(self, "allowed_time_ranges")

    @allowed_time_ranges.setter
    def allowed_time_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpAlertGroupCustomReceiverAllowedTimeRangeArgs']]]]):
        pulumi.set(self, "allowed_time_ranges", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only effect when alertmanager in user cluster, this cluster id.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only effect when alertmanager in user cluster, this cluster type (tke|eks|tdcc).
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom receiver type, webhook|alertmanager.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom receiver address, can be accessed by process in prometheus instance subnet.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class TmpAlertGroupCustomReceiverAllowedTimeRangeArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time range end, seconds since 0 o'clock.
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time range start, seconds since 0 o'clock.
        """
elif False:
    TmpAlertGroupCustomReceiverAllowedTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpAlertGroupCustomReceiverAllowedTimeRangeArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end: Time range end, seconds since 0 o'clock.
        :param pulumi.Input[_builtins.str] start: Time range start, seconds since 0 o'clock.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time range end, seconds since 0 o'clock.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time range start, seconds since 0 o'clock.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class TmpAlertGroupRuleArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotation of alert rule. `summary`, `description` is special annotation in prometheus, mapping `Alarm Object`, `Alarm Information` in alarm message.
        """
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule alarm duration.
        """
        expr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prometheus alert expression.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels of alert rule.
        """
        rule_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alert rule name.
        """
        state: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rule state. `2`-enable, `3`-disable, default `2`.
        """
elif False:
    TmpAlertGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpAlertGroupRuleArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 expr: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 rule_name: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotation of alert rule. `summary`, `description` is special annotation in prometheus, mapping `Alarm Object`, `Alarm Information` in alarm message.
        :param pulumi.Input[_builtins.str] duration: Rule alarm duration.
        :param pulumi.Input[_builtins.str] expr: Prometheus alert expression.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels of alert rule.
        :param pulumi.Input[_builtins.str] rule_name: Alert rule name.
        :param pulumi.Input[_builtins.int] state: Rule state. `2`-enable, `3`-disable, default `2`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotation of alert rule. `summary`, `description` is special annotation in prometheus, mapping `Alarm Object`, `Alarm Information` in alarm message.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule alarm duration.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prometheus alert expression.
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels of alert rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alert rule name.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_name", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule state. `2`-enable, `3`-disable, default `2`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class TmpAlertRuleAnnotationArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        key.
        """
        value: pulumi.Input[_builtins.str]
        """
        value.
        """
elif False:
    TmpAlertRuleAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpAlertRuleAnnotationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: key.
        :param pulumi.Input[_builtins.str] value: value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TmpAlertRuleLabelArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        key.
        """
        value: pulumi.Input[_builtins.str]
        """
        value.
        """
elif False:
    TmpAlertRuleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpAlertRuleLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: key.
        :param pulumi.Input[_builtins.str] value: value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TmpMultipleWritesListRemoteWriteArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Data multiple write url.
        """
        basic_auth: NotRequired[pulumi.Input['TmpMultipleWritesListRemoteWriteBasicAuthArgsDict']]
        """
        Authentication information.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpMultipleWritesListRemoteWriteHeaderArgsDict']]]]
        """
        HTTP additional headers.
        """
        label: NotRequired[pulumi.Input[_builtins.str]]
        """
        Label.
        """
        max_block_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum block.
        """
        url_relabel_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        RelabelConfig.
        """
elif False:
    TmpMultipleWritesListRemoteWriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpMultipleWritesListRemoteWriteArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 basic_auth: Optional[pulumi.Input['TmpMultipleWritesListRemoteWriteBasicAuthArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['TmpMultipleWritesListRemoteWriteHeaderArgs']]]] = None,
                 label: Optional[pulumi.Input[_builtins.str]] = None,
                 max_block_size: Optional[pulumi.Input[_builtins.str]] = None,
                 url_relabel_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Data multiple write url.
        :param pulumi.Input['TmpMultipleWritesListRemoteWriteBasicAuthArgs'] basic_auth: Authentication information.
        :param pulumi.Input[Sequence[pulumi.Input['TmpMultipleWritesListRemoteWriteHeaderArgs']]] headers: HTTP additional headers.
        :param pulumi.Input[_builtins.str] label: Label.
        :param pulumi.Input[_builtins.str] max_block_size: Maximum block.
        :param pulumi.Input[_builtins.str] url_relabel_config: RelabelConfig.
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max_block_size is not None:
            pulumi.set(__self__, "max_block_size", max_block_size)
        if url_relabel_config is not None:
            pulumi.set(__self__, "url_relabel_config", url_relabel_config)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Data multiple write url.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['TmpMultipleWritesListRemoteWriteBasicAuthArgs']]:
        """
        Authentication information.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['TmpMultipleWritesListRemoteWriteBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpMultipleWritesListRemoteWriteHeaderArgs']]]]:
        """
        HTTP additional headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpMultipleWritesListRemoteWriteHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Label.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter(name="maxBlockSize")
    def max_block_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum block.
        """
        return pulumi.get(self, "max_block_size")

    @max_block_size.setter
    def max_block_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_block_size", value)

    @_builtins.property
    @pulumi.getter(name="urlRelabelConfig")
    def url_relabel_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RelabelConfig.
        """
        return pulumi.get(self, "url_relabel_config")

    @url_relabel_config.setter
    def url_relabel_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_relabel_config", value)


if not MYPY:
    class TmpMultipleWritesListRemoteWriteBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name.
        """
elif False:
    TmpMultipleWritesListRemoteWriteBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpMultipleWritesListRemoteWriteBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password.
        :param pulumi.Input[_builtins.str] user_name: User name.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class TmpMultipleWritesListRemoteWriteHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        HTTP header key.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP header value.
        """
elif False:
    TmpMultipleWritesListRemoteWriteHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpMultipleWritesListRemoteWriteHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: HTTP header key.
        :param pulumi.Input[_builtins.str] value: HTTP header value.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        HTTP header key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TmpTkeAlertPolicyAlertRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Rule name.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleArgsDict']]]
        """
        A list of rules.
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        If the alarm policy is derived from the CRD resource definition of the user cluster, the ClusterId is the cluster ID to which it belongs.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alarm policy ID. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        notification: NotRequired[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationArgsDict']]
        """
        Alarm channels, which may be returned using null in the template.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        If the alarm is sent from a template, the TemplateId is the template id.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last modified time.
        """
elif False:
    TmpTkeAlertPolicyAlertRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeAlertPolicyAlertRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 rules: pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleArgs']]],
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 notification: Optional[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationArgs']] = None,
                 template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Rule name.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleArgs']]] rules: A list of rules.
        :param pulumi.Input[_builtins.str] cluster_id: If the alarm policy is derived from the CRD resource definition of the user cluster, the ClusterId is the cluster ID to which it belongs.
        :param pulumi.Input[_builtins.str] id: Alarm policy ID. Note: This field may return null, indicating that a valid value could not be retrieved.
        :param pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationArgs'] notification: Alarm channels, which may be returned using null in the template.
        :param pulumi.Input[_builtins.str] template_id: If the alarm is sent from a template, the TemplateId is the template id.
        :param pulumi.Input[_builtins.str] updated_at: Last modified time.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rules", rules)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if notification is not None:
            pulumi.set(__self__, "notification", notification)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleArgs']]]:
        """
        A list of rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If the alarm policy is derived from the CRD resource definition of the user cluster, the ClusterId is the cluster ID to which it belongs.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alarm policy ID. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def notification(self) -> Optional[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationArgs']]:
        """
        Alarm channels, which may be returned using null in the template.
        """
        return pulumi.get(self, "notification")

    @notification.setter
    def notification(self, value: Optional[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationArgs']]):
        pulumi.set(self, "notification", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If the alarm is sent from a template, the TemplateId is the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last modified time.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class TmpTkeAlertPolicyAlertRuleNotificationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether it is enabled.
        """
        type: pulumi.Input[_builtins.str]
        """
        The channel type, which defaults to amp, supports the following `amp`, `webhook`, `alertmanager`.
        """
        alert_manager: NotRequired[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgsDict']]
        """
        If Type is alertmanager, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved..
        """
        notify_ways: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Alarm notification method. At present, there are SMS, EMAIL, CALL, WECHAT methods.
        """
        phone_arrive_notice: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Telephone alerts reach notifications.
        """
        phone_circle_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Effective end timeTelephone alarm wheel interval. Units: Seconds.
        """
        phone_circle_times: NotRequired[pulumi.Input[_builtins.int]]
        """
        PhoneCircleTimes.
        """
        phone_inner_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Telephone alarm wheel intervals. Units: Seconds.
        """
        phone_notify_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Telephone alarm sequence.
        """
        receiver_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Alert Receiving Group (User Group).
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Convergence time.
        """
        time_range_end: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effective end time.
        """
        time_range_start: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time from which it takes effect.
        """
        web_hook: NotRequired[pulumi.Input[_builtins.str]]
        """
        If Type is webhook, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
elif False:
    TmpTkeAlertPolicyAlertRuleNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeAlertPolicyAlertRuleNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 type: pulumi.Input[_builtins.str],
                 alert_manager: Optional[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgs']] = None,
                 notify_ways: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 phone_arrive_notice: Optional[pulumi.Input[_builtins.bool]] = None,
                 phone_circle_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_circle_times: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_inner_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_notify_orders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 receiver_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 time_range_end: Optional[pulumi.Input[_builtins.str]] = None,
                 time_range_start: Optional[pulumi.Input[_builtins.str]] = None,
                 web_hook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether it is enabled.
        :param pulumi.Input[_builtins.str] type: The channel type, which defaults to amp, supports the following `amp`, `webhook`, `alertmanager`.
        :param pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgs'] alert_manager: If Type is alertmanager, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved..
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notify_ways: Alarm notification method. At present, there are SMS, EMAIL, CALL, WECHAT methods.
        :param pulumi.Input[_builtins.bool] phone_arrive_notice: Telephone alerts reach notifications.
        :param pulumi.Input[_builtins.int] phone_circle_interval: Effective end timeTelephone alarm wheel interval. Units: Seconds.
        :param pulumi.Input[_builtins.int] phone_circle_times: PhoneCircleTimes.
        :param pulumi.Input[_builtins.int] phone_inner_interval: Telephone alarm wheel intervals. Units: Seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] phone_notify_orders: Telephone alarm sequence.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] receiver_groups: Alert Receiving Group (User Group).
        :param pulumi.Input[_builtins.str] repeat_interval: Convergence time.
        :param pulumi.Input[_builtins.str] time_range_end: Effective end time.
        :param pulumi.Input[_builtins.str] time_range_start: The time from which it takes effect.
        :param pulumi.Input[_builtins.str] web_hook: If Type is webhook, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)
        if alert_manager is not None:
            pulumi.set(__self__, "alert_manager", alert_manager)
        if notify_ways is not None:
            pulumi.set(__self__, "notify_ways", notify_ways)
        if phone_arrive_notice is not None:
            pulumi.set(__self__, "phone_arrive_notice", phone_arrive_notice)
        if phone_circle_interval is not None:
            pulumi.set(__self__, "phone_circle_interval", phone_circle_interval)
        if phone_circle_times is not None:
            pulumi.set(__self__, "phone_circle_times", phone_circle_times)
        if phone_inner_interval is not None:
            pulumi.set(__self__, "phone_inner_interval", phone_inner_interval)
        if phone_notify_orders is not None:
            pulumi.set(__self__, "phone_notify_orders", phone_notify_orders)
        if receiver_groups is not None:
            pulumi.set(__self__, "receiver_groups", receiver_groups)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)
        if time_range_end is not None:
            pulumi.set(__self__, "time_range_end", time_range_end)
        if time_range_start is not None:
            pulumi.set(__self__, "time_range_start", time_range_start)
        if web_hook is not None:
            pulumi.set(__self__, "web_hook", web_hook)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether it is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The channel type, which defaults to amp, supports the following `amp`, `webhook`, `alertmanager`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="alertManager")
    def alert_manager(self) -> Optional[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgs']]:
        """
        If Type is alertmanager, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved..
        """
        return pulumi.get(self, "alert_manager")

    @alert_manager.setter
    def alert_manager(self, value: Optional[pulumi.Input['TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgs']]):
        pulumi.set(self, "alert_manager", value)

    @_builtins.property
    @pulumi.getter(name="notifyWays")
    def notify_ways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Alarm notification method. At present, there are SMS, EMAIL, CALL, WECHAT methods.
        """
        return pulumi.get(self, "notify_ways")

    @notify_ways.setter
    def notify_ways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "notify_ways", value)

    @_builtins.property
    @pulumi.getter(name="phoneArriveNotice")
    def phone_arrive_notice(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Telephone alerts reach notifications.
        """
        return pulumi.get(self, "phone_arrive_notice")

    @phone_arrive_notice.setter
    def phone_arrive_notice(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "phone_arrive_notice", value)

    @_builtins.property
    @pulumi.getter(name="phoneCircleInterval")
    def phone_circle_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Effective end timeTelephone alarm wheel interval. Units: Seconds.
        """
        return pulumi.get(self, "phone_circle_interval")

    @phone_circle_interval.setter
    def phone_circle_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_circle_interval", value)

    @_builtins.property
    @pulumi.getter(name="phoneCircleTimes")
    def phone_circle_times(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        PhoneCircleTimes.
        """
        return pulumi.get(self, "phone_circle_times")

    @phone_circle_times.setter
    def phone_circle_times(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_circle_times", value)

    @_builtins.property
    @pulumi.getter(name="phoneInnerInterval")
    def phone_inner_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Telephone alarm wheel intervals. Units: Seconds.
        """
        return pulumi.get(self, "phone_inner_interval")

    @phone_inner_interval.setter
    def phone_inner_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_inner_interval", value)

    @_builtins.property
    @pulumi.getter(name="phoneNotifyOrders")
    def phone_notify_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Telephone alarm sequence.
        """
        return pulumi.get(self, "phone_notify_orders")

    @phone_notify_orders.setter
    def phone_notify_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "phone_notify_orders", value)

    @_builtins.property
    @pulumi.getter(name="receiverGroups")
    def receiver_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Alert Receiving Group (User Group).
        """
        return pulumi.get(self, "receiver_groups")

    @receiver_groups.setter
    def receiver_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "receiver_groups", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Convergence time.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)

    @_builtins.property
    @pulumi.getter(name="timeRangeEnd")
    def time_range_end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effective end time.
        """
        return pulumi.get(self, "time_range_end")

    @time_range_end.setter
    def time_range_end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_range_end", value)

    @_builtins.property
    @pulumi.getter(name="timeRangeStart")
    def time_range_start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time from which it takes effect.
        """
        return pulumi.get(self, "time_range_start")

    @time_range_start.setter
    def time_range_start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_range_start", value)

    @_builtins.property
    @pulumi.getter(name="webHook")
    def web_hook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If Type is webhook, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        return pulumi.get(self, "web_hook")

    @web_hook.setter
    def web_hook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_hook", value)


if not MYPY:
    class TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Alertmanager url.
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the cluster where the alertmanager is deployed. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        cluster_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alertmanager is deployed in the cluster type. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
elif False:
    TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeAlertPolicyAlertRuleNotificationAlertManagerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Alertmanager url.
        :param pulumi.Input[_builtins.str] cluster_id: The ID of the cluster where the alertmanager is deployed. Note: This field may return null, indicating that a valid value could not be retrieved.
        :param pulumi.Input[_builtins.str] cluster_type: Alertmanager is deployed in the cluster type. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        pulumi.set(__self__, "url", url)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Alertmanager url.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the cluster where the alertmanager is deployed. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alertmanager is deployed in the cluster type. Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_type", value)


if not MYPY:
    class TmpTkeAlertPolicyAlertRuleRuleArgsDict(TypedDict):
        for_: pulumi.Input[_builtins.str]
        """
        Time of duration.
        """
        labels: pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleLabelArgsDict']]]
        """
        Extra labels.
        """
        name: pulumi.Input[_builtins.str]
        """
        Rule name.
        """
        rule: pulumi.Input[_builtins.str]
        """
        Prometheus statement.
        """
        template: pulumi.Input[_builtins.str]
        """
        Alert sending template.
        """
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleAnnotationArgsDict']]]]
        """
        Refer to annotations in prometheus rule.
        """
        describe: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the rule.
        """
        rule_state: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm rule status.
        """
elif False:
    TmpTkeAlertPolicyAlertRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeAlertPolicyAlertRuleRuleArgs:
    def __init__(__self__, *,
                 for_: pulumi.Input[_builtins.str],
                 labels: pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleLabelArgs']]],
                 name: pulumi.Input[_builtins.str],
                 rule: pulumi.Input[_builtins.str],
                 template: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleAnnotationArgs']]]] = None,
                 describe: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_state: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] for_: Time of duration.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleLabelArgs']]] labels: Extra labels.
        :param pulumi.Input[_builtins.str] name: Rule name.
        :param pulumi.Input[_builtins.str] rule: Prometheus statement.
        :param pulumi.Input[_builtins.str] template: Alert sending template.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleAnnotationArgs']]] annotations: Refer to annotations in prometheus rule.
        :param pulumi.Input[_builtins.str] describe: A description of the rule.
        :param pulumi.Input[_builtins.int] rule_state: Alarm rule status.
        """
        pulumi.set(__self__, "for_", for_)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "template", template)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if describe is not None:
            pulumi.set(__self__, "describe", describe)
        if rule_state is not None:
            pulumi.set(__self__, "rule_state", rule_state)

    @_builtins.property
    @pulumi.getter(name="for")
    def for_(self) -> pulumi.Input[_builtins.str]:
        """
        Time of duration.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "for_", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleLabelArgs']]]:
        """
        Extra labels.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleLabelArgs']]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> pulumi.Input[_builtins.str]:
        """
        Prometheus statement.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> pulumi.Input[_builtins.str]:
        """
        Alert sending template.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleAnnotationArgs']]]]:
        """
        Refer to annotations in prometheus rule.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeAlertPolicyAlertRuleRuleAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def describe(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the rule.
        """
        return pulumi.get(self, "describe")

    @describe.setter
    def describe(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "describe", value)

    @_builtins.property
    @pulumi.getter(name="ruleState")
    def rule_state(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm rule status.
        """
        return pulumi.get(self, "rule_state")

    @rule_state.setter
    def rule_state(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_state", value)


if not MYPY:
    class TmpTkeAlertPolicyAlertRuleRuleAnnotationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of map.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of map.
        """
elif False:
    TmpTkeAlertPolicyAlertRuleRuleAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeAlertPolicyAlertRuleRuleAnnotationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name of map.
        :param pulumi.Input[_builtins.str] value: Value of map.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of map.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of map.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TmpTkeAlertPolicyAlertRuleRuleLabelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of map.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of map.
        """
elif False:
    TmpTkeAlertPolicyAlertRuleRuleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeAlertPolicyAlertRuleRuleLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name of map.
        :param pulumi.Input[_builtins.str] value: Value of map.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of map.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of map.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TmpTkeClusterAgentAgentsArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        An id identify the cluster, like `cls-xxxxxx`.
        """
        cluster_type: pulumi.Input[_builtins.str]
        """
        Type of cluster.
        """
        enable_external: pulumi.Input[_builtins.bool]
        """
        Whether to enable the public network CLB.
        """
        region: pulumi.Input[_builtins.str]
        """
        Limitation of region.
        """
        cluster_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        the name of the cluster.
        """
        external_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsExternalLabelArgsDict']]]]
        """
        All metrics collected by the cluster will carry these labels.
        """
        in_cluster_pod_config: NotRequired[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigArgsDict']]
        """
        Pod configuration for components deployed in the cluster.
        """
        not_install_basic_scrape: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to install the default collection configuration.
        """
        not_scrape: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to collect indicators, true means drop all indicators, false means collect default indicators.
        """
        open_default_record: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable the default pre-aggregation rule.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        agent state, `normal`, `abnormal`.
        """
elif False:
    TmpTkeClusterAgentAgentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeClusterAgentAgentsArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str],
                 cluster_type: pulumi.Input[_builtins.str],
                 enable_external: pulumi.Input[_builtins.bool],
                 region: pulumi.Input[_builtins.str],
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 external_labels: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsExternalLabelArgs']]]] = None,
                 in_cluster_pod_config: Optional[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigArgs']] = None,
                 not_install_basic_scrape: Optional[pulumi.Input[_builtins.bool]] = None,
                 not_scrape: Optional[pulumi.Input[_builtins.bool]] = None,
                 open_default_record: Optional[pulumi.Input[_builtins.bool]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: An id identify the cluster, like `cls-xxxxxx`.
        :param pulumi.Input[_builtins.str] cluster_type: Type of cluster.
        :param pulumi.Input[_builtins.bool] enable_external: Whether to enable the public network CLB.
        :param pulumi.Input[_builtins.str] region: Limitation of region.
        :param pulumi.Input[_builtins.str] cluster_name: the name of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsExternalLabelArgs']]] external_labels: All metrics collected by the cluster will carry these labels.
        :param pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigArgs'] in_cluster_pod_config: Pod configuration for components deployed in the cluster.
        :param pulumi.Input[_builtins.bool] not_install_basic_scrape: Whether to install the default collection configuration.
        :param pulumi.Input[_builtins.bool] not_scrape: Whether to collect indicators, true means drop all indicators, false means collect default indicators.
        :param pulumi.Input[_builtins.bool] open_default_record: Whether to enable the default pre-aggregation rule.
        :param pulumi.Input[_builtins.str] status: agent state, `normal`, `abnormal`.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "enable_external", enable_external)
        pulumi.set(__self__, "region", region)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if external_labels is not None:
            pulumi.set(__self__, "external_labels", external_labels)
        if in_cluster_pod_config is not None:
            pulumi.set(__self__, "in_cluster_pod_config", in_cluster_pod_config)
        if not_install_basic_scrape is not None:
            pulumi.set(__self__, "not_install_basic_scrape", not_install_basic_scrape)
        if not_scrape is not None:
            pulumi.set(__self__, "not_scrape", not_scrape)
        if open_default_record is not None:
            pulumi.set(__self__, "open_default_record", open_default_record)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        An id identify the cluster, like `cls-xxxxxx`.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of cluster.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter(name="enableExternal")
    def enable_external(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether to enable the public network CLB.
        """
        return pulumi.get(self, "enable_external")

    @enable_external.setter
    def enable_external(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_external", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Limitation of region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter(name="externalLabels")
    def external_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsExternalLabelArgs']]]]:
        """
        All metrics collected by the cluster will carry these labels.
        """
        return pulumi.get(self, "external_labels")

    @external_labels.setter
    def external_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsExternalLabelArgs']]]]):
        pulumi.set(self, "external_labels", value)

    @_builtins.property
    @pulumi.getter(name="inClusterPodConfig")
    def in_cluster_pod_config(self) -> Optional[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigArgs']]:
        """
        Pod configuration for components deployed in the cluster.
        """
        return pulumi.get(self, "in_cluster_pod_config")

    @in_cluster_pod_config.setter
    def in_cluster_pod_config(self, value: Optional[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigArgs']]):
        pulumi.set(self, "in_cluster_pod_config", value)

    @_builtins.property
    @pulumi.getter(name="notInstallBasicScrape")
    def not_install_basic_scrape(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to install the default collection configuration.
        """
        return pulumi.get(self, "not_install_basic_scrape")

    @not_install_basic_scrape.setter
    def not_install_basic_scrape(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "not_install_basic_scrape", value)

    @_builtins.property
    @pulumi.getter(name="notScrape")
    def not_scrape(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to collect indicators, true means drop all indicators, false means collect default indicators.
        """
        return pulumi.get(self, "not_scrape")

    @not_scrape.setter
    def not_scrape(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "not_scrape", value)

    @_builtins.property
    @pulumi.getter(name="openDefaultRecord")
    def open_default_record(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable the default pre-aggregation rule.
        """
        return pulumi.get(self, "open_default_record")

    @open_default_record.setter
    def open_default_record(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "open_default_record", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        agent state, `normal`, `abnormal`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class TmpTkeClusterAgentAgentsExternalLabelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Indicator name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Index value.
        """
elif False:
    TmpTkeClusterAgentAgentsExternalLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeClusterAgentAgentsExternalLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Indicator name.
        :param pulumi.Input[_builtins.str] value: Index value.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Indicator name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Index value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TmpTkeClusterAgentAgentsInClusterPodConfigArgsDict(TypedDict):
        host_net: pulumi.Input[_builtins.bool]
        """
        Whether to use HostNetWork.
        """
        node_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgsDict']]]]
        """
        Specify the pod to run the node.
        """
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgsDict']]]]
        """
        Tolerate Stain.
        """
elif False:
    TmpTkeClusterAgentAgentsInClusterPodConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeClusterAgentAgentsInClusterPodConfigArgs:
    def __init__(__self__, *,
                 host_net: pulumi.Input[_builtins.bool],
                 node_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgs']]]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] host_net: Whether to use HostNetWork.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgs']]] node_selectors: Specify the pod to run the node.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgs']]] tolerations: Tolerate Stain.
        """
        pulumi.set(__self__, "host_net", host_net)
        if node_selectors is not None:
            pulumi.set(__self__, "node_selectors", node_selectors)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @_builtins.property
    @pulumi.getter(name="hostNet")
    def host_net(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether to use HostNetWork.
        """
        return pulumi.get(self, "host_net")

    @host_net.setter
    def host_net(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "host_net", value)

    @_builtins.property
    @pulumi.getter(name="nodeSelectors")
    def node_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgs']]]]:
        """
        Specify the pod to run the node.
        """
        return pulumi.get(self, "node_selectors")

    @node_selectors.setter
    def node_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgs']]]]):
        pulumi.set(self, "node_selectors", value)

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgs']]]]:
        """
        Tolerate Stain.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)


if not MYPY:
    class TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pod configuration name of the component deployed in the cluster.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Pod configuration values for components deployed in the cluster.
        """
elif False:
    TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelectorArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The pod configuration name of the component deployed in the cluster.
        :param pulumi.Input[_builtins.str] value: Pod configuration values for components deployed in the cluster.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pod configuration name of the component deployed in the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Pod configuration values for components deployed in the cluster.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        """
        blemish effect to match.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The taint key to which the tolerance applies.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        key-value relationship.
        """
elif False:
    TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeClusterAgentAgentsInClusterPodConfigTolerationArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: blemish effect to match.
        :param pulumi.Input[_builtins.str] key: The taint key to which the tolerance applies.
        :param pulumi.Input[_builtins.str] operator: key-value relationship.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        blemish effect to match.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The taint key to which the tolerance applies.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        key-value relationship.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class TmpTkeConfigPodMonitorArgsDict(TypedDict):
        config: pulumi.Input[_builtins.str]
        """
        Config.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used for output parameters, if the configuration comes from a template, it is the template id.
        """
elif False:
    TmpTkeConfigPodMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeConfigPodMonitorArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: Config.
        :param pulumi.Input[_builtins.str] name: Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
        :param pulumi.Input[_builtins.str] template_id: Used for output parameters, if the configuration comes from a template, it is the template id.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input[_builtins.str]:
        """
        Config.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used for output parameters, if the configuration comes from a template, it is the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class TmpTkeConfigRawJobArgsDict(TypedDict):
        config: pulumi.Input[_builtins.str]
        """
        Config.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used for output parameters, if the configuration comes from a template, it is the template id.
        """
elif False:
    TmpTkeConfigRawJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeConfigRawJobArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: Config.
        :param pulumi.Input[_builtins.str] name: Name.
        :param pulumi.Input[_builtins.str] template_id: Used for output parameters, if the configuration comes from a template, it is the template id.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input[_builtins.str]:
        """
        Config.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used for output parameters, if the configuration comes from a template, it is the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class TmpTkeConfigServiceMonitorArgsDict(TypedDict):
        config: pulumi.Input[_builtins.str]
        """
        Config.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used for output parameters, if the configuration comes from a template, it is the template id.
        """
elif False:
    TmpTkeConfigServiceMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeConfigServiceMonitorArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: Config.
        :param pulumi.Input[_builtins.str] name: Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
        :param pulumi.Input[_builtins.str] template_id: Used for output parameters, if the configuration comes from a template, it is the template id.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input[_builtins.str]:
        """
        Config.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used for output parameters, if the configuration comes from a template, it is the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class TmpTkeGlobalNotificationNotificationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Alarm notification switch.
        """
        type: pulumi.Input[_builtins.str]
        """
        Alarm notification type, Valid values: `amp`, `webhook`, `alertmanager`.
        """
        alert_managers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeGlobalNotificationNotificationAlertManagerArgsDict']]]]
        """
        Alert manager, if Type is `alertmanager`, this field is required.
        """
        notify_ways: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Alarm notification method, Valid values: `SMS`, `EMAIL`, `CALL`, `WECHAT`.
        """
        phone_arrive_notice: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Phone Alarm Reach Notification, NotifyWay is `CALL`, and this parameter is used.
        """
        phone_circle_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Telephone alarm off-wheel interval, NotifyWay is `CALL`, and this parameter is used.
        """
        phone_circle_times: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of phone alerts (user group), NotifyWay is `CALL`, and this parameter is used.
        """
        phone_inner_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interval between telephone alarm rounds, NotifyWay is `CALL`, and this parameter is used.
        """
        phone_notify_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Phone alert sequence, NotifyWay is `CALL`, and this parameter is used.
        """
        receiver_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Alarm receiving group(user group).
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Convergence time.
        """
        time_range_end: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effective end time.
        """
        time_range_start: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effective start time.
        """
        web_hook: NotRequired[pulumi.Input[_builtins.str]]
        """
        Web hook, if Type is `webhook`, this field is required.
        """
elif False:
    TmpTkeGlobalNotificationNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeGlobalNotificationNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 type: pulumi.Input[_builtins.str],
                 alert_managers: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeGlobalNotificationNotificationAlertManagerArgs']]]] = None,
                 notify_ways: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 phone_arrive_notice: Optional[pulumi.Input[_builtins.bool]] = None,
                 phone_circle_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_circle_times: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_inner_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 phone_notify_orders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 receiver_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 time_range_end: Optional[pulumi.Input[_builtins.str]] = None,
                 time_range_start: Optional[pulumi.Input[_builtins.str]] = None,
                 web_hook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Alarm notification switch.
        :param pulumi.Input[_builtins.str] type: Alarm notification type, Valid values: `amp`, `webhook`, `alertmanager`.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeGlobalNotificationNotificationAlertManagerArgs']]] alert_managers: Alert manager, if Type is `alertmanager`, this field is required.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notify_ways: Alarm notification method, Valid values: `SMS`, `EMAIL`, `CALL`, `WECHAT`.
        :param pulumi.Input[_builtins.bool] phone_arrive_notice: Phone Alarm Reach Notification, NotifyWay is `CALL`, and this parameter is used.
        :param pulumi.Input[_builtins.int] phone_circle_interval: Telephone alarm off-wheel interval, NotifyWay is `CALL`, and this parameter is used.
        :param pulumi.Input[_builtins.int] phone_circle_times: Number of phone alerts (user group), NotifyWay is `CALL`, and this parameter is used.
        :param pulumi.Input[_builtins.int] phone_inner_interval: Interval between telephone alarm rounds, NotifyWay is `CALL`, and this parameter is used.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] phone_notify_orders: Phone alert sequence, NotifyWay is `CALL`, and this parameter is used.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] receiver_groups: Alarm receiving group(user group).
        :param pulumi.Input[_builtins.str] repeat_interval: Convergence time.
        :param pulumi.Input[_builtins.str] time_range_end: Effective end time.
        :param pulumi.Input[_builtins.str] time_range_start: Effective start time.
        :param pulumi.Input[_builtins.str] web_hook: Web hook, if Type is `webhook`, this field is required.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)
        if alert_managers is not None:
            pulumi.set(__self__, "alert_managers", alert_managers)
        if notify_ways is not None:
            pulumi.set(__self__, "notify_ways", notify_ways)
        if phone_arrive_notice is not None:
            pulumi.set(__self__, "phone_arrive_notice", phone_arrive_notice)
        if phone_circle_interval is not None:
            pulumi.set(__self__, "phone_circle_interval", phone_circle_interval)
        if phone_circle_times is not None:
            pulumi.set(__self__, "phone_circle_times", phone_circle_times)
        if phone_inner_interval is not None:
            pulumi.set(__self__, "phone_inner_interval", phone_inner_interval)
        if phone_notify_orders is not None:
            pulumi.set(__self__, "phone_notify_orders", phone_notify_orders)
        if receiver_groups is not None:
            pulumi.set(__self__, "receiver_groups", receiver_groups)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)
        if time_range_end is not None:
            pulumi.set(__self__, "time_range_end", time_range_end)
        if time_range_start is not None:
            pulumi.set(__self__, "time_range_start", time_range_start)
        if web_hook is not None:
            pulumi.set(__self__, "web_hook", web_hook)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Alarm notification switch.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Alarm notification type, Valid values: `amp`, `webhook`, `alertmanager`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="alertManagers")
    def alert_managers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeGlobalNotificationNotificationAlertManagerArgs']]]]:
        """
        Alert manager, if Type is `alertmanager`, this field is required.
        """
        return pulumi.get(self, "alert_managers")

    @alert_managers.setter
    def alert_managers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeGlobalNotificationNotificationAlertManagerArgs']]]]):
        pulumi.set(self, "alert_managers", value)

    @_builtins.property
    @pulumi.getter(name="notifyWays")
    def notify_ways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Alarm notification method, Valid values: `SMS`, `EMAIL`, `CALL`, `WECHAT`.
        """
        return pulumi.get(self, "notify_ways")

    @notify_ways.setter
    def notify_ways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "notify_ways", value)

    @_builtins.property
    @pulumi.getter(name="phoneArriveNotice")
    def phone_arrive_notice(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Phone Alarm Reach Notification, NotifyWay is `CALL`, and this parameter is used.
        """
        return pulumi.get(self, "phone_arrive_notice")

    @phone_arrive_notice.setter
    def phone_arrive_notice(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "phone_arrive_notice", value)

    @_builtins.property
    @pulumi.getter(name="phoneCircleInterval")
    def phone_circle_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Telephone alarm off-wheel interval, NotifyWay is `CALL`, and this parameter is used.
        """
        return pulumi.get(self, "phone_circle_interval")

    @phone_circle_interval.setter
    def phone_circle_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_circle_interval", value)

    @_builtins.property
    @pulumi.getter(name="phoneCircleTimes")
    def phone_circle_times(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of phone alerts (user group), NotifyWay is `CALL`, and this parameter is used.
        """
        return pulumi.get(self, "phone_circle_times")

    @phone_circle_times.setter
    def phone_circle_times(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_circle_times", value)

    @_builtins.property
    @pulumi.getter(name="phoneInnerInterval")
    def phone_inner_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interval between telephone alarm rounds, NotifyWay is `CALL`, and this parameter is used.
        """
        return pulumi.get(self, "phone_inner_interval")

    @phone_inner_interval.setter
    def phone_inner_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phone_inner_interval", value)

    @_builtins.property
    @pulumi.getter(name="phoneNotifyOrders")
    def phone_notify_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Phone alert sequence, NotifyWay is `CALL`, and this parameter is used.
        """
        return pulumi.get(self, "phone_notify_orders")

    @phone_notify_orders.setter
    def phone_notify_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "phone_notify_orders", value)

    @_builtins.property
    @pulumi.getter(name="receiverGroups")
    def receiver_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Alarm receiving group(user group).
        """
        return pulumi.get(self, "receiver_groups")

    @receiver_groups.setter
    def receiver_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "receiver_groups", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Convergence time.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)

    @_builtins.property
    @pulumi.getter(name="timeRangeEnd")
    def time_range_end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effective end time.
        """
        return pulumi.get(self, "time_range_end")

    @time_range_end.setter
    def time_range_end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_range_end", value)

    @_builtins.property
    @pulumi.getter(name="timeRangeStart")
    def time_range_start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effective start time.
        """
        return pulumi.get(self, "time_range_start")

    @time_range_start.setter
    def time_range_start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_range_start", value)

    @_builtins.property
    @pulumi.getter(name="webHook")
    def web_hook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Web hook, if Type is `webhook`, this field is required.
        """
        return pulumi.get(self, "web_hook")

    @web_hook.setter
    def web_hook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_hook", value)


if not MYPY:
    class TmpTkeGlobalNotificationNotificationAlertManagerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Alert manager url.
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster id.
        """
        cluster_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster type.
        """
elif False:
    TmpTkeGlobalNotificationNotificationAlertManagerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeGlobalNotificationNotificationAlertManagerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Alert manager url.
        :param pulumi.Input[_builtins.str] cluster_id: Cluster id.
        :param pulumi.Input[_builtins.str] cluster_type: Cluster type.
        """
        pulumi.set(__self__, "url", url)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Alert manager url.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster id.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster type.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_type", value)


if not MYPY:
    class TmpTkeTemplateAttachmentTargetsArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        instance id.
        """
        region: pulumi.Input[_builtins.str]
        """
        target area.
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the cluster.
        """
        cluster_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name the cluster.
        """
        cluster_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster type.
        """
        instance_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the prometheus instance.
        """
        sync_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last sync template time.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template version currently in use.
        """
elif False:
    TmpTkeTemplateAttachmentTargetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeTemplateAttachmentTargetsArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sync_time: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_id: instance id.
        :param pulumi.Input[_builtins.str] region: target area.
        :param pulumi.Input[_builtins.str] cluster_id: ID of the cluster.
        :param pulumi.Input[_builtins.str] cluster_name: Name the cluster.
        :param pulumi.Input[_builtins.str] cluster_type: Cluster type.
        :param pulumi.Input[_builtins.str] instance_name: Name of the prometheus instance.
        :param pulumi.Input[_builtins.str] sync_time: Last sync template time.
        :param pulumi.Input[_builtins.str] version: Template version currently in use.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "region", region)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if sync_time is not None:
            pulumi.set(__self__, "sync_time", sync_time)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        instance id.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        target area.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster type.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the prometheus instance.
        """
        return pulumi.get(self, "instance_name")

    @instance_name.setter
    def instance_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_name", value)

    @_builtins.property
    @pulumi.getter(name="syncTime")
    def sync_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last sync template time.
        """
        return pulumi.get(self, "sync_time")

    @sync_time.setter
    def sync_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sync_time", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template version currently in use.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TmpTkeTemplateTemplateArgsDict(TypedDict):
        level: pulumi.Input[_builtins.str]
        """
        Template dimensions, the following types are supported `instance` instance level, `cluster` cluster level.
        """
        name: pulumi.Input[_builtins.str]
        """
        Template name.
        """
        describe: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template description.
        """
        is_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the system-supplied default template is used for outgoing references.
        """
        pod_monitors: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplatePodMonitorArgsDict']]]]
        """
        Effective when Level is a cluster, A list of PodMonitors rules in the template.
        """
        raw_jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRawJobArgsDict']]]]
        """
        Effective when Level is a cluster, A list of RawJobs rules in the template.
        """
        record_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRecordRuleArgsDict']]]]
        """
        Effective when Level is instance, A list of aggregation rules in the template.
        """
        service_monitors: NotRequired[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateServiceMonitorArgsDict']]]]
        """
        Effective when Level is a cluster, A list of ServiceMonitor rules in the template.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the template, which is used for the outgoing reference.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last updated, for outgoing references.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the system-supplied default template is used for outgoing references.
        """
elif False:
    TmpTkeTemplateTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeTemplateTemplateArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 describe: Optional[pulumi.Input[_builtins.str]] = None,
                 is_default: Optional[pulumi.Input[_builtins.bool]] = None,
                 pod_monitors: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplatePodMonitorArgs']]]] = None,
                 raw_jobs: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRawJobArgs']]]] = None,
                 record_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRecordRuleArgs']]]] = None,
                 service_monitors: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateServiceMonitorArgs']]]] = None,
                 template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] level: Template dimensions, the following types are supported `instance` instance level, `cluster` cluster level.
        :param pulumi.Input[_builtins.str] name: Template name.
        :param pulumi.Input[_builtins.str] describe: Template description.
        :param pulumi.Input[_builtins.bool] is_default: Whether the system-supplied default template is used for outgoing references.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplatePodMonitorArgs']]] pod_monitors: Effective when Level is a cluster, A list of PodMonitors rules in the template.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRawJobArgs']]] raw_jobs: Effective when Level is a cluster, A list of RawJobs rules in the template.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRecordRuleArgs']]] record_rules: Effective when Level is instance, A list of aggregation rules in the template.
        :param pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateServiceMonitorArgs']]] service_monitors: Effective when Level is a cluster, A list of ServiceMonitor rules in the template.
        :param pulumi.Input[_builtins.str] template_id: The ID of the template, which is used for the outgoing reference.
        :param pulumi.Input[_builtins.str] update_time: Last updated, for outgoing references.
        :param pulumi.Input[_builtins.str] version: Whether the system-supplied default template is used for outgoing references.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "name", name)
        if describe is not None:
            pulumi.set(__self__, "describe", describe)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if pod_monitors is not None:
            pulumi.set(__self__, "pod_monitors", pod_monitors)
        if raw_jobs is not None:
            pulumi.set(__self__, "raw_jobs", raw_jobs)
        if record_rules is not None:
            pulumi.set(__self__, "record_rules", record_rules)
        if service_monitors is not None:
            pulumi.set(__self__, "service_monitors", service_monitors)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def level(self) -> pulumi.Input[_builtins.str]:
        """
        Template dimensions, the following types are supported `instance` instance level, `cluster` cluster level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Template name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def describe(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template description.
        """
        return pulumi.get(self, "describe")

    @describe.setter
    def describe(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "describe", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the system-supplied default template is used for outgoing references.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter(name="podMonitors")
    def pod_monitors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplatePodMonitorArgs']]]]:
        """
        Effective when Level is a cluster, A list of PodMonitors rules in the template.
        """
        return pulumi.get(self, "pod_monitors")

    @pod_monitors.setter
    def pod_monitors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplatePodMonitorArgs']]]]):
        pulumi.set(self, "pod_monitors", value)

    @_builtins.property
    @pulumi.getter(name="rawJobs")
    def raw_jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRawJobArgs']]]]:
        """
        Effective when Level is a cluster, A list of RawJobs rules in the template.
        """
        return pulumi.get(self, "raw_jobs")

    @raw_jobs.setter
    def raw_jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRawJobArgs']]]]):
        pulumi.set(self, "raw_jobs", value)

    @_builtins.property
    @pulumi.getter(name="recordRules")
    def record_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRecordRuleArgs']]]]:
        """
        Effective when Level is instance, A list of aggregation rules in the template.
        """
        return pulumi.get(self, "record_rules")

    @record_rules.setter
    def record_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateRecordRuleArgs']]]]):
        pulumi.set(self, "record_rules", value)

    @_builtins.property
    @pulumi.getter(name="serviceMonitors")
    def service_monitors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateServiceMonitorArgs']]]]:
        """
        Effective when Level is a cluster, A list of ServiceMonitor rules in the template.
        """
        return pulumi.get(self, "service_monitors")

    @service_monitors.setter
    def service_monitors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TmpTkeTemplateTemplateServiceMonitorArgs']]]]):
        pulumi.set(self, "service_monitors", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the template, which is used for the outgoing reference.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last updated, for outgoing references.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the system-supplied default template is used for outgoing references.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TmpTkeTemplateTemplatePodMonitorArgsDict(TypedDict):
        config: pulumi.Input[_builtins.str]
        """
        Config.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
elif False:
    TmpTkeTemplateTemplatePodMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeTemplateTemplatePodMonitorArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: Config.
        :param pulumi.Input[_builtins.str] name: Name.
        :param pulumi.Input[_builtins.str] template_id: Used for the argument, if the configuration comes to the template, the template id.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input[_builtins.str]:
        """
        Config.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class TmpTkeTemplateTemplateRawJobArgsDict(TypedDict):
        config: pulumi.Input[_builtins.str]
        """
        Config.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
elif False:
    TmpTkeTemplateTemplateRawJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeTemplateTemplateRawJobArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: Config.
        :param pulumi.Input[_builtins.str] name: Name.
        :param pulumi.Input[_builtins.str] template_id: Used for the argument, if the configuration comes to the template, the template id.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input[_builtins.str]:
        """
        Config.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class TmpTkeTemplateTemplateRecordRuleArgsDict(TypedDict):
        config: pulumi.Input[_builtins.str]
        """
        Config.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
elif False:
    TmpTkeTemplateTemplateRecordRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeTemplateTemplateRecordRuleArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: Config.
        :param pulumi.Input[_builtins.str] name: Name.
        :param pulumi.Input[_builtins.str] template_id: Used for the argument, if the configuration comes to the template, the template id.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input[_builtins.str]:
        """
        Config.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class TmpTkeTemplateTemplateServiceMonitorArgsDict(TypedDict):
        config: pulumi.Input[_builtins.str]
        """
        Config.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
elif False:
    TmpTkeTemplateTemplateServiceMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TmpTkeTemplateTemplateServiceMonitorArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: Config.
        :param pulumi.Input[_builtins.str] name: Name.
        :param pulumi.Input[_builtins.str] template_id: Used for the argument, if the configuration comes to the template, the template id.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input[_builtins.str]:
        """
        Config.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used for the argument, if the configuration comes to the template, the template id.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class GetAlarmHistoryNamespaceArgsDict(TypedDict):
        monitor_type: _builtins.str
        """
        Monitor type.
        """
        namespace: _builtins.str
        """
        Policy type.
        """
elif False:
    GetAlarmHistoryNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlarmHistoryNamespaceArgs:
    def __init__(__self__, *,
                 monitor_type: _builtins.str,
                 namespace: _builtins.str):
        """
        :param _builtins.str monitor_type: Monitor type.
        :param _builtins.str namespace: Policy type.
        """
        pulumi.set(__self__, "monitor_type", monitor_type)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> _builtins.str:
        """
        Monitor type.
        """
        return pulumi.get(self, "monitor_type")

    @monitor_type.setter
    def monitor_type(self, value: _builtins.str):
        pulumi.set(self, "monitor_type", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Policy type.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: _builtins.str):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GetAlarmPolicyTriggerTaskArgsDict(TypedDict):
        task_config: _builtins.str
        """
        Configuration information in JSON format, such as {Key1:Value1,Key2:Value2}Note: this field may return null, indicating that no valid values can be obtained.
        """
        type: _builtins.str
        """
        Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
        """
elif False:
    GetAlarmPolicyTriggerTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlarmPolicyTriggerTaskArgs:
    def __init__(__self__, *,
                 task_config: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str task_config: Configuration information in JSON format, such as {Key1:Value1,Key2:Value2}Note: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.str type: Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "task_config", task_config)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="taskConfig")
    def task_config(self) -> _builtins.str:
        """
        Configuration information in JSON format, such as {Key1:Value1,Key2:Value2}Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "task_config")

    @task_config.setter
    def task_config(self, value: _builtins.str):
        pulumi.set(self, "task_config", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetDataDimensionArgsDict(TypedDict):
        name: _builtins.str
        """
        Instance dimension name, eg: `InstanceId` for cvm.
        """
        value: _builtins.str
        """
        Instance dimension value, eg: `ins-j0hk02zo` for cvm.
        """
elif False:
    GetDataDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDataDimensionArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Instance dimension name, eg: `InstanceId` for cvm.
        :param _builtins.str value: Instance dimension value, eg: `ins-j0hk02zo` for cvm.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Instance dimension name, eg: `InstanceId` for cvm.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Instance dimension value, eg: `ins-j0hk02zo` for cvm.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetProductEventDimensionArgsDict(TypedDict):
        name: NotRequired[_builtins.str]
        """
        Instance dimension name, eg: `deviceWanIp` for internet ip.
        """
        value: NotRequired[_builtins.str]
        """
        Instance dimension value, eg: `119.119.119.119` for internet ip.
        """
elif False:
    GetProductEventDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProductEventDimensionArgs:
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Instance dimension name, eg: `deviceWanIp` for internet ip.
        :param _builtins.str value: Instance dimension value, eg: `119.119.119.119` for internet ip.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Instance dimension name, eg: `deviceWanIp` for internet ip.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Instance dimension value, eg: `119.119.119.119` for internet ip.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetStatisticDataConditionArgsDict(TypedDict):
        key: _builtins.str
        """
        Dimension.
        """
        operator: _builtins.str
        """
        Operator. Valid values: eq (equal to), ne (not equal to), in.
        """
        values: Sequence[_builtins.str]
        """
        Dimension value. If Operator is eq or ne, only the first element will be used.
        """
elif False:
    GetStatisticDataConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStatisticDataConditionArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Dimension.
        :param _builtins.str operator: Operator. Valid values: eq (equal to), ne (not equal to), in.
        :param Sequence[_builtins.str] values: Dimension value. If Operator is eq or ne, only the first element will be used.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Dimension.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operator. Valid values: eq (equal to), ne (not equal to), in.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Dimension value. If Operator is eq or ne, only the first element will be used.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTmpInstancesTagFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        The key of the tag.
        """
        value: _builtins.str
        """
        The value of the tag.
        """
elif False:
    GetTmpInstancesTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTmpInstancesTagFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key of the tag.
        :param _builtins.str value: The value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


