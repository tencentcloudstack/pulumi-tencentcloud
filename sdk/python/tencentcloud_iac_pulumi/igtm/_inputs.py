# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AddressPoolAddressSetArgs',
    'AddressPoolAddressSetArgsDict',
    'StrategyFallbackAddressPoolSetArgs',
    'StrategyFallbackAddressPoolSetArgsDict',
    'StrategyFallbackAddressPoolSetAddressPoolArgs',
    'StrategyFallbackAddressPoolSetAddressPoolArgsDict',
    'StrategyMainAddressPoolSetArgs',
    'StrategyMainAddressPoolSetArgsDict',
    'StrategyMainAddressPoolSetAddressPoolArgs',
    'StrategyMainAddressPoolSetAddressPoolArgsDict',
    'StrategySourceArgs',
    'StrategySourceArgsDict',
    'GetAddressPoolListFilterArgs',
    'GetAddressPoolListFilterArgsDict',
    'GetDetectTaskPackageListFilterArgs',
    'GetDetectTaskPackageListFilterArgsDict',
    'GetInstanceListFilterArgs',
    'GetInstanceListFilterArgsDict',
    'GetInstancePackageListFilterArgs',
    'GetInstancePackageListFilterArgsDict',
    'GetMonitorsFilterArgs',
    'GetMonitorsFilterArgsDict',
    'GetStrategyListFilterArgs',
    'GetStrategyListFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AddressPoolAddressSetArgsDict(TypedDict):
        addr: pulumi.Input[_builtins.str]
        """
        Address value: only supports IPv4, IPv6, and domain name formats.
        Loopback addresses, reserved addresses, internal addresses, and Tencent reserved network segments are not supported.
        """
        is_enable: pulumi.Input[_builtins.str]
        """
        Whether to enable: DISABLED for disabled, ENABLED for enabled.
        """
        address_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Address ID.
        """
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        OK for normal, DOWN for failure, WARN for risk, UNKNOWN for probing, UNMONITORED for unknown.
        """
        updated_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        Modification time.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight, required when traffic strategy is WEIGHT; range 1-100.
        """
elif False:
    AddressPoolAddressSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressPoolAddressSetArgs:
    def __init__(__self__, *,
                 addr: pulumi.Input[_builtins.str],
                 is_enable: pulumi.Input[_builtins.str],
                 address_id: Optional[pulumi.Input[_builtins.int]] = None,
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_on: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] addr: Address value: only supports IPv4, IPv6, and domain name formats.
               Loopback addresses, reserved addresses, internal addresses, and Tencent reserved network segments are not supported.
        :param pulumi.Input[_builtins.str] is_enable: Whether to enable: DISABLED for disabled, ENABLED for enabled.
        :param pulumi.Input[_builtins.int] address_id: Address ID.
        :param pulumi.Input[_builtins.str] created_on: Creation time.
        :param pulumi.Input[_builtins.str] location: Address name.
        :param pulumi.Input[_builtins.str] status: OK for normal, DOWN for failure, WARN for risk, UNKNOWN for probing, UNMONITORED for unknown.
        :param pulumi.Input[_builtins.str] updated_on: Modification time.
        :param pulumi.Input[_builtins.int] weight: Weight, required when traffic strategy is WEIGHT; range 1-100.
        """
        pulumi.set(__self__, "addr", addr)
        pulumi.set(__self__, "is_enable", is_enable)
        if address_id is not None:
            pulumi.set(__self__, "address_id", address_id)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_on is not None:
            pulumi.set(__self__, "updated_on", updated_on)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def addr(self) -> pulumi.Input[_builtins.str]:
        """
        Address value: only supports IPv4, IPv6, and domain name formats.
        Loopback addresses, reserved addresses, internal addresses, and Tencent reserved network segments are not supported.
        """
        return pulumi.get(self, "addr")

    @addr.setter
    def addr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "addr", value)

    @_builtins.property
    @pulumi.getter(name="isEnable")
    def is_enable(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to enable: DISABLED for disabled, ENABLED for enabled.
        """
        return pulumi.get(self, "is_enable")

    @is_enable.setter
    def is_enable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "is_enable", value)

    @_builtins.property
    @pulumi.getter(name="addressId")
    def address_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Address ID.
        """
        return pulumi.get(self, "address_id")

    @address_id.setter
    def address_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "address_id", value)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address name.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OK for normal, DOWN for failure, WARN for risk, UNKNOWN for probing, UNMONITORED for unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedOn")
    def updated_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Modification time.
        """
        return pulumi.get(self, "updated_on")

    @updated_on.setter
    def updated_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_on", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight, required when traffic strategy is WEIGHT; range 1-100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class StrategyFallbackAddressPoolSetArgsDict(TypedDict):
        address_pools: pulumi.Input[Sequence[pulumi.Input['StrategyFallbackAddressPoolSetAddressPoolArgsDict']]]
        """
        Address pool IDs and weights in the set, array.
        """
        main_address_pool_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Address pool set ID.
        """
        min_survive_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Switch threshold, cannot exceed the total number of addresses in the main set.
        """
        traffic_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch strategy: ALL resolves all addresses; WEIGHT: load balancing. When ALL, the weight value of resolved addresses is 1; when WEIGHT, weight is address pool weight * address weight.
        """
elif False:
    StrategyFallbackAddressPoolSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StrategyFallbackAddressPoolSetArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['StrategyFallbackAddressPoolSetAddressPoolArgs']]],
                 main_address_pool_id: Optional[pulumi.Input[_builtins.int]] = None,
                 min_survive_num: Optional[pulumi.Input[_builtins.int]] = None,
                 traffic_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StrategyFallbackAddressPoolSetAddressPoolArgs']]] address_pools: Address pool IDs and weights in the set, array.
        :param pulumi.Input[_builtins.int] main_address_pool_id: Address pool set ID.
        :param pulumi.Input[_builtins.int] min_survive_num: Switch threshold, cannot exceed the total number of addresses in the main set.
        :param pulumi.Input[_builtins.str] traffic_strategy: Switch strategy: ALL resolves all addresses; WEIGHT: load balancing. When ALL, the weight value of resolved addresses is 1; when WEIGHT, weight is address pool weight * address weight.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        if main_address_pool_id is not None:
            pulumi.set(__self__, "main_address_pool_id", main_address_pool_id)
        if min_survive_num is not None:
            pulumi.set(__self__, "min_survive_num", min_survive_num)
        if traffic_strategy is not None:
            pulumi.set(__self__, "traffic_strategy", traffic_strategy)

    @_builtins.property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['StrategyFallbackAddressPoolSetAddressPoolArgs']]]:
        """
        Address pool IDs and weights in the set, array.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['StrategyFallbackAddressPoolSetAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)

    @_builtins.property
    @pulumi.getter(name="mainAddressPoolId")
    def main_address_pool_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Address pool set ID.
        """
        return pulumi.get(self, "main_address_pool_id")

    @main_address_pool_id.setter
    def main_address_pool_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "main_address_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="minSurviveNum")
    def min_survive_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Switch threshold, cannot exceed the total number of addresses in the main set.
        """
        return pulumi.get(self, "min_survive_num")

    @min_survive_num.setter
    def min_survive_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_survive_num", value)

    @_builtins.property
    @pulumi.getter(name="trafficStrategy")
    def traffic_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch strategy: ALL resolves all addresses; WEIGHT: load balancing. When ALL, the weight value of resolved addresses is 1; when WEIGHT, weight is address pool weight * address weight.
        """
        return pulumi.get(self, "traffic_strategy")

    @traffic_strategy.setter
    def traffic_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic_strategy", value)


if not MYPY:
    class StrategyFallbackAddressPoolSetAddressPoolArgsDict(TypedDict):
        pool_id: pulumi.Input[_builtins.int]
        """
        Address pool ID.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight.
        """
elif False:
    StrategyFallbackAddressPoolSetAddressPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StrategyFallbackAddressPoolSetAddressPoolArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[_builtins.int],
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] pool_id: Address pool ID.
        :param pulumi.Input[_builtins.int] weight: Weight.
        """
        pulumi.set(__self__, "pool_id", pool_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[_builtins.int]:
        """
        Address pool ID.
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "pool_id", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class StrategyMainAddressPoolSetArgsDict(TypedDict):
        address_pools: pulumi.Input[Sequence[pulumi.Input['StrategyMainAddressPoolSetAddressPoolArgsDict']]]
        """
        Address pool IDs and weights in the set, array.
        """
        main_address_pool_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Address pool set ID.
        """
        min_survive_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Switch threshold, cannot exceed the total number of addresses in the main set.
        """
        traffic_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch strategy: ALL resolves all addresses; WEIGHT: load balancing. When ALL, the weight value of resolved addresses is 1; when WEIGHT, weight is address pool weight * address weight.
        """
elif False:
    StrategyMainAddressPoolSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StrategyMainAddressPoolSetArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['StrategyMainAddressPoolSetAddressPoolArgs']]],
                 main_address_pool_id: Optional[pulumi.Input[_builtins.int]] = None,
                 min_survive_num: Optional[pulumi.Input[_builtins.int]] = None,
                 traffic_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StrategyMainAddressPoolSetAddressPoolArgs']]] address_pools: Address pool IDs and weights in the set, array.
        :param pulumi.Input[_builtins.int] main_address_pool_id: Address pool set ID.
        :param pulumi.Input[_builtins.int] min_survive_num: Switch threshold, cannot exceed the total number of addresses in the main set.
        :param pulumi.Input[_builtins.str] traffic_strategy: Switch strategy: ALL resolves all addresses; WEIGHT: load balancing. When ALL, the weight value of resolved addresses is 1; when WEIGHT, weight is address pool weight * address weight.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        if main_address_pool_id is not None:
            pulumi.set(__self__, "main_address_pool_id", main_address_pool_id)
        if min_survive_num is not None:
            pulumi.set(__self__, "min_survive_num", min_survive_num)
        if traffic_strategy is not None:
            pulumi.set(__self__, "traffic_strategy", traffic_strategy)

    @_builtins.property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['StrategyMainAddressPoolSetAddressPoolArgs']]]:
        """
        Address pool IDs and weights in the set, array.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['StrategyMainAddressPoolSetAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)

    @_builtins.property
    @pulumi.getter(name="mainAddressPoolId")
    def main_address_pool_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Address pool set ID.
        """
        return pulumi.get(self, "main_address_pool_id")

    @main_address_pool_id.setter
    def main_address_pool_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "main_address_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="minSurviveNum")
    def min_survive_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Switch threshold, cannot exceed the total number of addresses in the main set.
        """
        return pulumi.get(self, "min_survive_num")

    @min_survive_num.setter
    def min_survive_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_survive_num", value)

    @_builtins.property
    @pulumi.getter(name="trafficStrategy")
    def traffic_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch strategy: ALL resolves all addresses; WEIGHT: load balancing. When ALL, the weight value of resolved addresses is 1; when WEIGHT, weight is address pool weight * address weight.
        """
        return pulumi.get(self, "traffic_strategy")

    @traffic_strategy.setter
    def traffic_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic_strategy", value)


if not MYPY:
    class StrategyMainAddressPoolSetAddressPoolArgsDict(TypedDict):
        pool_id: pulumi.Input[_builtins.int]
        """
        Address pool ID.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight.
        """
elif False:
    StrategyMainAddressPoolSetAddressPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StrategyMainAddressPoolSetAddressPoolArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[_builtins.int],
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] pool_id: Address pool ID.
        :param pulumi.Input[_builtins.int] weight: Weight.
        """
        pulumi.set(__self__, "pool_id", pool_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[_builtins.int]:
        """
        Address pool ID.
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "pool_id", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class StrategySourceArgsDict(TypedDict):
        dns_line_id: pulumi.Input[_builtins.int]
        """
        Resolution request source line ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolution request source line name.
        """
elif False:
    StrategySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StrategySourceArgs:
    def __init__(__self__, *,
                 dns_line_id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] dns_line_id: Resolution request source line ID.
        :param pulumi.Input[_builtins.str] name: Resolution request source line name.
        """
        pulumi.set(__self__, "dns_line_id", dns_line_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dnsLineId")
    def dns_line_id(self) -> pulumi.Input[_builtins.int]:
        """
        Resolution request source line ID.
        """
        return pulumi.get(self, "dns_line_id")

    @dns_line_id.setter
    def dns_line_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "dns_line_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolution request source line name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetAddressPoolListFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter field name, supported list as follows:
        - PoolName: Address pool name.
        - MonitorId: Monitor ID. This is a required parameter, failure to provide will cause interface query failure.
        """
        values: Sequence[_builtins.str]
        """
        Filter field value.
        """
        fuzzy: NotRequired[_builtins.bool]
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, currently not used).
        """
elif False:
    GetAddressPoolListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAddressPoolListFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 fuzzy: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Filter field name, supported list as follows:
               - PoolName: Address pool name.
               - MonitorId: Monitor ID. This is a required parameter, failure to provide will cause interface query failure.
        :param Sequence[_builtins.str] values: Filter field value.
        :param _builtins.bool fuzzy: Whether to enable fuzzy query, only supports filter field name as domain.
               When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, currently not used).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if fuzzy is not None:
            pulumi.set(__self__, "fuzzy", fuzzy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter field name, supported list as follows:
        - PoolName: Address pool name.
        - MonitorId: Monitor ID. This is a required parameter, failure to provide will cause interface query failure.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter field value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def fuzzy(self) -> Optional[_builtins.bool]:
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, currently not used).
        """
        return pulumi.get(self, "fuzzy")

    @fuzzy.setter
    def fuzzy(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "fuzzy", value)


if not MYPY:
    class GetDetectTaskPackageListFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter field name, supported list as follows:
        - ResourceId: detect task resource id.
        - PeriodStart: minimum expiration time.
        - PeriodEnd: maximum expiration time.
        """
        values: Sequence[_builtins.str]
        """
        Filter field value.
        """
        fuzzy: NotRequired[_builtins.bool]
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
elif False:
    GetDetectTaskPackageListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDetectTaskPackageListFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 fuzzy: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Filter field name, supported list as follows:
               - ResourceId: detect task resource id.
               - PeriodStart: minimum expiration time.
               - PeriodEnd: maximum expiration time.
        :param Sequence[_builtins.str] values: Filter field value.
        :param _builtins.bool fuzzy: Whether to enable fuzzy query, only supports filter field name as domain.
               When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if fuzzy is not None:
            pulumi.set(__self__, "fuzzy", fuzzy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter field name, supported list as follows:
        - ResourceId: detect task resource id.
        - PeriodStart: minimum expiration time.
        - PeriodEnd: maximum expiration time.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter field value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def fuzzy(self) -> Optional[_builtins.bool]:
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
        return pulumi.get(self, "fuzzy")

    @fuzzy.setter
    def fuzzy(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "fuzzy", value)


if not MYPY:
    class GetInstanceListFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter field name, supported list as follows:
        - InstanceId: IGTM instance ID.
        - Domain: IGTM instance domain.
        - MonitorId: Monitor ID.
        - PoolId: Pool ID. This is a required parameter, not passing it will cause interface query failure.
        """
        values: Sequence[_builtins.str]
        """
        Filter field value.
        """
        fuzzy: NotRequired[_builtins.bool]
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
elif False:
    GetInstanceListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceListFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 fuzzy: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Filter field name, supported list as follows:
               - InstanceId: IGTM instance ID.
               - Domain: IGTM instance domain.
               - MonitorId: Monitor ID.
               - PoolId: Pool ID. This is a required parameter, not passing it will cause interface query failure.
        :param Sequence[_builtins.str] values: Filter field value.
        :param _builtins.bool fuzzy: Whether to enable fuzzy query, only supports filter field name as domain.
               When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if fuzzy is not None:
            pulumi.set(__self__, "fuzzy", fuzzy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter field name, supported list as follows:
        - InstanceId: IGTM instance ID.
        - Domain: IGTM instance domain.
        - MonitorId: Monitor ID.
        - PoolId: Pool ID. This is a required parameter, not passing it will cause interface query failure.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter field value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def fuzzy(self) -> Optional[_builtins.bool]:
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
        return pulumi.get(self, "fuzzy")

    @fuzzy.setter
    def fuzzy(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "fuzzy", value)


if not MYPY:
    class GetInstancePackageListFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter field name, supported list as follows:
        - InstanceId: instance ID.
        - InstanceName: instance name.
        - ResourceId: package ID.
        - PackageType: package type. This is a required parameter, not passing it will cause interface query failure.
        """
        values: Sequence[_builtins.str]
        """
        Filter field value.
        """
        fuzzy: NotRequired[_builtins.bool]
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
elif False:
    GetInstancePackageListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePackageListFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 fuzzy: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Filter field name, supported list as follows:
               - InstanceId: instance ID.
               - InstanceName: instance name.
               - ResourceId: package ID.
               - PackageType: package type. This is a required parameter, not passing it will cause interface query failure.
        :param Sequence[_builtins.str] values: Filter field value.
        :param _builtins.bool fuzzy: Whether to enable fuzzy query, only supports filter field name as domain.
               When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if fuzzy is not None:
            pulumi.set(__self__, "fuzzy", fuzzy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter field name, supported list as follows:
        - InstanceId: instance ID.
        - InstanceName: instance name.
        - ResourceId: package ID.
        - PackageType: package type. This is a required parameter, not passing it will cause interface query failure.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter field value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def fuzzy(self) -> Optional[_builtins.bool]:
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, maximum Value length is 1, otherwise maximum Value length is 5. (Reserved field, not currently used).
        """
        return pulumi.get(self, "fuzzy")

    @fuzzy.setter
    def fuzzy(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "fuzzy", value)


if not MYPY:
    class GetMonitorsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter field name, supported MonitorName: monitor name; MonitorId: monitor ID.
        """
        values: Sequence[_builtins.str]
        """
        Filter field values.
        """
        fuzzy: NotRequired[_builtins.bool]
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, Value maximum length is 1, otherwise Value maximum length is 5. (Reserved field, currently unused).
        """
elif False:
    GetMonitorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMonitorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 fuzzy: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Filter field name, supported MonitorName: monitor name; MonitorId: monitor ID.
        :param Sequence[_builtins.str] values: Filter field values.
        :param _builtins.bool fuzzy: Whether to enable fuzzy query, only supports filter field name as domain.
               When fuzzy query is enabled, Value maximum length is 1, otherwise Value maximum length is 5. (Reserved field, currently unused).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if fuzzy is not None:
            pulumi.set(__self__, "fuzzy", fuzzy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter field name, supported MonitorName: monitor name; MonitorId: monitor ID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter field values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def fuzzy(self) -> Optional[_builtins.bool]:
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, Value maximum length is 1, otherwise Value maximum length is 5. (Reserved field, currently unused).
        """
        return pulumi.get(self, "fuzzy")

    @fuzzy.setter
    def fuzzy(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "fuzzy", value)


if not MYPY:
    class GetStrategyListFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter field name, supported list as follows:
        - type: main resource type, CDN.
        - instanceId: IGTM instance ID. This is a required parameter, failure to pass will cause interface query failure.
        """
        values: Sequence[_builtins.str]
        """
        Filter field values.
        """
        fuzzy: NotRequired[_builtins.bool]
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, Value maximum length is 1, otherwise Value maximum length is 5. (Reserved field, currently unused).
        """
elif False:
    GetStrategyListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStrategyListFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 fuzzy: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Filter field name, supported list as follows:
               - type: main resource type, CDN.
               - instanceId: IGTM instance ID. This is a required parameter, failure to pass will cause interface query failure.
        :param Sequence[_builtins.str] values: Filter field values.
        :param _builtins.bool fuzzy: Whether to enable fuzzy query, only supports filter field name as domain.
               When fuzzy query is enabled, Value maximum length is 1, otherwise Value maximum length is 5. (Reserved field, currently unused).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if fuzzy is not None:
            pulumi.set(__self__, "fuzzy", fuzzy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter field name, supported list as follows:
        - type: main resource type, CDN.
        - instanceId: IGTM instance ID. This is a required parameter, failure to pass will cause interface query failure.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter field values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def fuzzy(self) -> Optional[_builtins.bool]:
        """
        Whether to enable fuzzy query, only supports filter field name as domain.
        When fuzzy query is enabled, Value maximum length is 1, otherwise Value maximum length is 5. (Reserved field, currently unused).
        """
        return pulumi.get(self, "fuzzy")

    @fuzzy.setter
    def fuzzy(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "fuzzy", value)


