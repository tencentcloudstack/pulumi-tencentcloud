# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccessLogConfigClsArgs',
    'AccessLogConfigClsArgsDict',
    'AccessLogConfigSelectedRangeArgs',
    'AccessLogConfigSelectedRangeArgsDict',
    'AccessLogConfigSelectedRangeItemArgs',
    'AccessLogConfigSelectedRangeItemArgsDict',
    'ClusterAttachmentClusterListArgs',
    'ClusterAttachmentClusterListArgsDict',
    'MeshConfigArgs',
    'MeshConfigArgsDict',
    'MeshConfigInjectArgs',
    'MeshConfigInjectArgsDict',
    'MeshConfigIstioArgs',
    'MeshConfigIstioArgsDict',
    'MeshConfigIstioSmartDnsArgs',
    'MeshConfigIstioSmartDnsArgsDict',
    'MeshConfigIstioTracingArgs',
    'MeshConfigIstioTracingArgsDict',
    'MeshConfigIstioTracingApmArgs',
    'MeshConfigIstioTracingApmArgsDict',
    'MeshConfigIstioTracingZipkinArgs',
    'MeshConfigIstioTracingZipkinArgsDict',
    'MeshConfigPrometheusArgs',
    'MeshConfigPrometheusArgsDict',
    'MeshConfigPrometheusCustomPromArgs',
    'MeshConfigPrometheusCustomPromArgsDict',
    'MeshConfigSidecarResourcesArgs',
    'MeshConfigSidecarResourcesArgsDict',
    'MeshConfigSidecarResourcesLimitArgs',
    'MeshConfigSidecarResourcesLimitArgsDict',
    'MeshConfigSidecarResourcesRequestArgs',
    'MeshConfigSidecarResourcesRequestArgsDict',
    'MeshConfigTracingArgs',
    'MeshConfigTracingArgsDict',
    'MeshConfigTracingApmArgs',
    'MeshConfigTracingApmArgsDict',
    'MeshConfigTracingZipkinArgs',
    'MeshConfigTracingZipkinArgsDict',
    'MeshTagListArgs',
    'MeshTagListArgsDict',
    'PrometheusAttachmentPrometheusArgs',
    'PrometheusAttachmentPrometheusArgsDict',
    'PrometheusAttachmentPrometheusCustomPromArgs',
    'PrometheusAttachmentPrometheusCustomPromArgsDict',
    'TracingConfigApmArgs',
    'TracingConfigApmArgsDict',
    'TracingConfigZipkinArgs',
    'TracingConfigZipkinArgsDict',
]

MYPY = False

if not MYPY:
    class AccessLogConfigClsArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Whether enable CLS.
        """
        log_set: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log set of CLS.
        """
        topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log topic of CLS.
        """
elif False:
    AccessLogConfigClsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessLogConfigClsArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool],
                 log_set: Optional[pulumi.Input[_builtins.str]] = None,
                 topic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether enable CLS.
        :param pulumi.Input[_builtins.str] log_set: Log set of CLS.
        :param pulumi.Input[_builtins.str] topic: Log topic of CLS.
        """
        pulumi.set(__self__, "enable", enable)
        if log_set is not None:
            pulumi.set(__self__, "log_set", log_set)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether enable CLS.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="logSet")
    def log_set(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log set of CLS.
        """
        return pulumi.get(self, "log_set")

    @log_set.setter
    def log_set(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_set", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log topic of CLS.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class AccessLogConfigSelectedRangeArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Select all if true, default false.
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessLogConfigSelectedRangeItemArgsDict']]]]
        """
        Items.
        """
elif False:
    AccessLogConfigSelectedRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessLogConfigSelectedRangeArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[_builtins.bool]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['AccessLogConfigSelectedRangeItemArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] all: Select all if true, default false.
        :param pulumi.Input[Sequence[pulumi.Input['AccessLogConfigSelectedRangeItemArgs']]] items: Items.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Select all if true, default false.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessLogConfigSelectedRangeItemArgs']]]]:
        """
        Items.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessLogConfigSelectedRangeItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class AccessLogConfigSelectedRangeItemArgsDict(TypedDict):
        gateways: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Ingress gateway list.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace.
        """
elif False:
    AccessLogConfigSelectedRangeItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessLogConfigSelectedRangeItemArgs:
    def __init__(__self__, *,
                 gateways: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] gateways: Ingress gateway list.
        :param pulumi.Input[_builtins.str] namespace: Namespace.
        """
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Ingress gateway list.
        """
        return pulumi.get(self, "gateways")

    @gateways.setter
    def gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "gateways", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ClusterAttachmentClusterListArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        TKE Cluster id.
        """
        region: pulumi.Input[_builtins.str]
        """
        TKE cluster region.
        """
        role: pulumi.Input[_builtins.str]
        """
        Cluster role in mesh, REMOTE or MASTER.
        """
        type: pulumi.Input[_builtins.str]
        """
        Cluster type.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        Cluster&#39;s VpcId.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet id, only needed if it&#39;s standalone mesh.
        """
elif False:
    ClusterAttachmentClusterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAttachmentClusterListArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 role: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: TKE Cluster id.
        :param pulumi.Input[_builtins.str] region: TKE cluster region.
        :param pulumi.Input[_builtins.str] role: Cluster role in mesh, REMOTE or MASTER.
        :param pulumi.Input[_builtins.str] type: Cluster type.
        :param pulumi.Input[_builtins.str] vpc_id: Cluster&#39;s VpcId.
        :param pulumi.Input[_builtins.str] subnet_id: Subnet id, only needed if it&#39;s standalone mesh.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        TKE Cluster id.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        TKE cluster region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        Cluster role in mesh, REMOTE or MASTER.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Cluster type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        Cluster&#39;s VpcId.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet id, only needed if it&#39;s standalone mesh.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class MeshConfigArgsDict(TypedDict):
        inject: NotRequired[pulumi.Input['MeshConfigInjectArgsDict']]
        """
        Sidecar inject configuration.
        """
        istio: NotRequired[pulumi.Input['MeshConfigIstioArgsDict']]
        """
        Istio configuration.
        """
        prometheus: NotRequired[pulumi.Input['MeshConfigPrometheusArgsDict']]
        """
        Prometheus configuration.
        """
        sidecar_resources: NotRequired[pulumi.Input['MeshConfigSidecarResourcesArgsDict']]
        """
        Default sidecar requests and limits.
        """
        tracing: NotRequired[pulumi.Input['MeshConfigTracingArgsDict']]
        """
        Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
elif False:
    MeshConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigArgs:
    def __init__(__self__, *,
                 inject: Optional[pulumi.Input['MeshConfigInjectArgs']] = None,
                 istio: Optional[pulumi.Input['MeshConfigIstioArgs']] = None,
                 prometheus: Optional[pulumi.Input['MeshConfigPrometheusArgs']] = None,
                 sidecar_resources: Optional[pulumi.Input['MeshConfigSidecarResourcesArgs']] = None,
                 tracing: Optional[pulumi.Input['MeshConfigTracingArgs']] = None):
        """
        :param pulumi.Input['MeshConfigInjectArgs'] inject: Sidecar inject configuration.
        :param pulumi.Input['MeshConfigIstioArgs'] istio: Istio configuration.
        :param pulumi.Input['MeshConfigPrometheusArgs'] prometheus: Prometheus configuration.
        :param pulumi.Input['MeshConfigSidecarResourcesArgs'] sidecar_resources: Default sidecar requests and limits.
        :param pulumi.Input['MeshConfigTracingArgs'] tracing: Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
        if inject is not None:
            pulumi.set(__self__, "inject", inject)
        if istio is not None:
            pulumi.set(__self__, "istio", istio)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if sidecar_resources is not None:
            pulumi.set(__self__, "sidecar_resources", sidecar_resources)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @_builtins.property
    @pulumi.getter
    def inject(self) -> Optional[pulumi.Input['MeshConfigInjectArgs']]:
        """
        Sidecar inject configuration.
        """
        return pulumi.get(self, "inject")

    @inject.setter
    def inject(self, value: Optional[pulumi.Input['MeshConfigInjectArgs']]):
        pulumi.set(self, "inject", value)

    @_builtins.property
    @pulumi.getter
    def istio(self) -> Optional[pulumi.Input['MeshConfigIstioArgs']]:
        """
        Istio configuration.
        """
        return pulumi.get(self, "istio")

    @istio.setter
    def istio(self, value: Optional[pulumi.Input['MeshConfigIstioArgs']]):
        pulumi.set(self, "istio", value)

    @_builtins.property
    @pulumi.getter
    def prometheus(self) -> Optional[pulumi.Input['MeshConfigPrometheusArgs']]:
        """
        Prometheus configuration.
        """
        return pulumi.get(self, "prometheus")

    @prometheus.setter
    def prometheus(self, value: Optional[pulumi.Input['MeshConfigPrometheusArgs']]):
        pulumi.set(self, "prometheus", value)

    @_builtins.property
    @pulumi.getter(name="sidecarResources")
    def sidecar_resources(self) -> Optional[pulumi.Input['MeshConfigSidecarResourcesArgs']]:
        """
        Default sidecar requests and limits.
        """
        return pulumi.get(self, "sidecar_resources")

    @sidecar_resources.setter
    def sidecar_resources(self, value: Optional[pulumi.Input['MeshConfigSidecarResourcesArgs']]):
        pulumi.set(self, "sidecar_resources", value)

    @_builtins.property
    @pulumi.getter
    def tracing(self) -> Optional[pulumi.Input['MeshConfigTracingArgs']]:
        """
        Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
        return pulumi.get(self, "tracing")

    @tracing.setter
    def tracing(self, value: Optional[pulumi.Input['MeshConfigTracingArgs']]):
        pulumi.set(self, "tracing", value)


if not MYPY:
    class MeshConfigInjectArgsDict(TypedDict):
        exclude_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges that should not be proxied.
        """
        hold_application_until_proxy_starts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Let istio-proxy(sidecar) start first, before app container.
        """
        hold_proxy_until_application_ends: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Let istio-proxy(sidecar) stop last, after app container.
        """
elif False:
    MeshConfigInjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigInjectArgs:
    def __init__(__self__, *,
                 exclude_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 hold_application_until_proxy_starts: Optional[pulumi.Input[_builtins.bool]] = None,
                 hold_proxy_until_application_ends: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_ip_ranges: IP ranges that should not be proxied.
        :param pulumi.Input[_builtins.bool] hold_application_until_proxy_starts: Let istio-proxy(sidecar) start first, before app container.
        :param pulumi.Input[_builtins.bool] hold_proxy_until_application_ends: Let istio-proxy(sidecar) stop last, after app container.
        """
        if exclude_ip_ranges is not None:
            pulumi.set(__self__, "exclude_ip_ranges", exclude_ip_ranges)
        if hold_application_until_proxy_starts is not None:
            pulumi.set(__self__, "hold_application_until_proxy_starts", hold_application_until_proxy_starts)
        if hold_proxy_until_application_ends is not None:
            pulumi.set(__self__, "hold_proxy_until_application_ends", hold_proxy_until_application_ends)

    @_builtins.property
    @pulumi.getter(name="excludeIpRanges")
    def exclude_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges that should not be proxied.
        """
        return pulumi.get(self, "exclude_ip_ranges")

    @exclude_ip_ranges.setter
    def exclude_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_ip_ranges", value)

    @_builtins.property
    @pulumi.getter(name="holdApplicationUntilProxyStarts")
    def hold_application_until_proxy_starts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Let istio-proxy(sidecar) start first, before app container.
        """
        return pulumi.get(self, "hold_application_until_proxy_starts")

    @hold_application_until_proxy_starts.setter
    def hold_application_until_proxy_starts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hold_application_until_proxy_starts", value)

    @_builtins.property
    @pulumi.getter(name="holdProxyUntilApplicationEnds")
    def hold_proxy_until_application_ends(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Let istio-proxy(sidecar) stop last, after app container.
        """
        return pulumi.get(self, "hold_proxy_until_application_ends")

    @hold_proxy_until_application_ends.setter
    def hold_proxy_until_application_ends(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hold_proxy_until_application_ends", value)


if not MYPY:
    class MeshConfigIstioArgsDict(TypedDict):
        outbound_traffic_policy: pulumi.Input[_builtins.str]
        """
        Outbound traffic policy, REGISTRY_ONLY or ALLOW_ANY, see https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode.
        """
        disable_http_retry: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable http retry.
        """
        disable_policy_checks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable policy checks.
        """
        enable_pilot_http: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable HTTP/1.0 support.
        """
        smart_dns: NotRequired[pulumi.Input['MeshConfigIstioSmartDnsArgsDict']]
        """
        SmartDNS configuration.
        """
        tracing: NotRequired[pulumi.Input['MeshConfigIstioTracingArgsDict']]
        """
        Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
elif False:
    MeshConfigIstioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigIstioArgs:
    def __init__(__self__, *,
                 outbound_traffic_policy: pulumi.Input[_builtins.str],
                 disable_http_retry: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_policy_checks: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_pilot_http: Optional[pulumi.Input[_builtins.bool]] = None,
                 smart_dns: Optional[pulumi.Input['MeshConfigIstioSmartDnsArgs']] = None,
                 tracing: Optional[pulumi.Input['MeshConfigIstioTracingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] outbound_traffic_policy: Outbound traffic policy, REGISTRY_ONLY or ALLOW_ANY, see https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode.
        :param pulumi.Input[_builtins.bool] disable_http_retry: Disable http retry.
        :param pulumi.Input[_builtins.bool] disable_policy_checks: Disable policy checks.
        :param pulumi.Input[_builtins.bool] enable_pilot_http: Enable HTTP/1.0 support.
        :param pulumi.Input['MeshConfigIstioSmartDnsArgs'] smart_dns: SmartDNS configuration.
        :param pulumi.Input['MeshConfigIstioTracingArgs'] tracing: Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
        pulumi.set(__self__, "outbound_traffic_policy", outbound_traffic_policy)
        if disable_http_retry is not None:
            pulumi.set(__self__, "disable_http_retry", disable_http_retry)
        if disable_policy_checks is not None:
            pulumi.set(__self__, "disable_policy_checks", disable_policy_checks)
        if enable_pilot_http is not None:
            pulumi.set(__self__, "enable_pilot_http", enable_pilot_http)
        if smart_dns is not None:
            pulumi.set(__self__, "smart_dns", smart_dns)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @_builtins.property
    @pulumi.getter(name="outboundTrafficPolicy")
    def outbound_traffic_policy(self) -> pulumi.Input[_builtins.str]:
        """
        Outbound traffic policy, REGISTRY_ONLY or ALLOW_ANY, see https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode.
        """
        return pulumi.get(self, "outbound_traffic_policy")

    @outbound_traffic_policy.setter
    def outbound_traffic_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "outbound_traffic_policy", value)

    @_builtins.property
    @pulumi.getter(name="disableHttpRetry")
    def disable_http_retry(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable http retry.
        """
        return pulumi.get(self, "disable_http_retry")

    @disable_http_retry.setter
    def disable_http_retry(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_http_retry", value)

    @_builtins.property
    @pulumi.getter(name="disablePolicyChecks")
    def disable_policy_checks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable policy checks.
        """
        return pulumi.get(self, "disable_policy_checks")

    @disable_policy_checks.setter
    def disable_policy_checks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_policy_checks", value)

    @_builtins.property
    @pulumi.getter(name="enablePilotHttp")
    def enable_pilot_http(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable HTTP/1.0 support.
        """
        return pulumi.get(self, "enable_pilot_http")

    @enable_pilot_http.setter
    def enable_pilot_http(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_pilot_http", value)

    @_builtins.property
    @pulumi.getter(name="smartDns")
    def smart_dns(self) -> Optional[pulumi.Input['MeshConfigIstioSmartDnsArgs']]:
        """
        SmartDNS configuration.
        """
        return pulumi.get(self, "smart_dns")

    @smart_dns.setter
    def smart_dns(self, value: Optional[pulumi.Input['MeshConfigIstioSmartDnsArgs']]):
        pulumi.set(self, "smart_dns", value)

    @_builtins.property
    @pulumi.getter
    def tracing(self) -> Optional[pulumi.Input['MeshConfigIstioTracingArgs']]:
        """
        Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
        return pulumi.get(self, "tracing")

    @tracing.setter
    def tracing(self, value: Optional[pulumi.Input['MeshConfigIstioTracingArgs']]):
        pulumi.set(self, "tracing", value)


if not MYPY:
    class MeshConfigIstioSmartDnsArgsDict(TypedDict):
        istio_meta_dns_auto_allocate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable auto allocate address.
        """
        istio_meta_dns_capture: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable dns proxy.
        """
elif False:
    MeshConfigIstioSmartDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigIstioSmartDnsArgs:
    def __init__(__self__, *,
                 istio_meta_dns_auto_allocate: Optional[pulumi.Input[_builtins.bool]] = None,
                 istio_meta_dns_capture: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] istio_meta_dns_auto_allocate: Enable auto allocate address.
        :param pulumi.Input[_builtins.bool] istio_meta_dns_capture: Enable dns proxy.
        """
        if istio_meta_dns_auto_allocate is not None:
            pulumi.set(__self__, "istio_meta_dns_auto_allocate", istio_meta_dns_auto_allocate)
        if istio_meta_dns_capture is not None:
            pulumi.set(__self__, "istio_meta_dns_capture", istio_meta_dns_capture)

    @_builtins.property
    @pulumi.getter(name="istioMetaDnsAutoAllocate")
    def istio_meta_dns_auto_allocate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable auto allocate address.
        """
        return pulumi.get(self, "istio_meta_dns_auto_allocate")

    @istio_meta_dns_auto_allocate.setter
    def istio_meta_dns_auto_allocate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "istio_meta_dns_auto_allocate", value)

    @_builtins.property
    @pulumi.getter(name="istioMetaDnsCapture")
    def istio_meta_dns_capture(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable dns proxy.
        """
        return pulumi.get(self, "istio_meta_dns_capture")

    @istio_meta_dns_capture.setter
    def istio_meta_dns_capture(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "istio_meta_dns_capture", value)


if not MYPY:
    class MeshConfigIstioTracingArgsDict(TypedDict):
        apm: NotRequired[pulumi.Input['MeshConfigIstioTracingApmArgsDict']]
        """
        APM config.
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether enable tracing.
        """
        sampling: NotRequired[pulumi.Input[_builtins.float]]
        """
        Tracing sampling, 0.0-1.0.
        """
        zipkin: NotRequired[pulumi.Input['MeshConfigIstioTracingZipkinArgsDict']]
        """
        Third party zipkin config.
        """
elif False:
    MeshConfigIstioTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigIstioTracingArgs:
    def __init__(__self__, *,
                 apm: Optional[pulumi.Input['MeshConfigIstioTracingApmArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 sampling: Optional[pulumi.Input[_builtins.float]] = None,
                 zipkin: Optional[pulumi.Input['MeshConfigIstioTracingZipkinArgs']] = None):
        """
        :param pulumi.Input['MeshConfigIstioTracingApmArgs'] apm: APM config.
        :param pulumi.Input[_builtins.bool] enable: Whether enable tracing.
        :param pulumi.Input[_builtins.float] sampling: Tracing sampling, 0.0-1.0.
        :param pulumi.Input['MeshConfigIstioTracingZipkinArgs'] zipkin: Third party zipkin config.
        """
        if apm is not None:
            pulumi.set(__self__, "apm", apm)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sampling is not None:
            pulumi.set(__self__, "sampling", sampling)
        if zipkin is not None:
            pulumi.set(__self__, "zipkin", zipkin)

    @_builtins.property
    @pulumi.getter
    def apm(self) -> Optional[pulumi.Input['MeshConfigIstioTracingApmArgs']]:
        """
        APM config.
        """
        return pulumi.get(self, "apm")

    @apm.setter
    def apm(self, value: Optional[pulumi.Input['MeshConfigIstioTracingApmArgs']]):
        pulumi.set(self, "apm", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether enable tracing.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Tracing sampling, 0.0-1.0.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter
    def zipkin(self) -> Optional[pulumi.Input['MeshConfigIstioTracingZipkinArgs']]:
        """
        Third party zipkin config.
        """
        return pulumi.get(self, "zipkin")

    @zipkin.setter
    def zipkin(self, value: Optional[pulumi.Input['MeshConfigIstioTracingZipkinArgs']]):
        pulumi.set(self, "zipkin", value)


if not MYPY:
    class MeshConfigIstioTracingApmArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Whether enable APM.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance id of the APM.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region.
        """
elif False:
    MeshConfigIstioTracingApmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigIstioTracingApmArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool],
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether enable APM.
        :param pulumi.Input[_builtins.str] instance_id: Instance id of the APM.
        :param pulumi.Input[_builtins.str] region: Region.
        """
        pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether enable APM.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance id of the APM.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class MeshConfigIstioTracingZipkinArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        Zipkin address.
        """
elif False:
    MeshConfigIstioTracingZipkinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigIstioTracingZipkinArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] address: Zipkin address.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        Zipkin address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)


if not MYPY:
    class MeshConfigPrometheusArgsDict(TypedDict):
        custom_prom: NotRequired[pulumi.Input['MeshConfigPrometheusCustomPromArgsDict']]
        """
        Custom prometheus.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance id.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet id.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vpc id.
        """
elif False:
    MeshConfigPrometheusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigPrometheusArgs:
    def __init__(__self__, *,
                 custom_prom: Optional[pulumi.Input['MeshConfigPrometheusCustomPromArgs']] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['MeshConfigPrometheusCustomPromArgs'] custom_prom: Custom prometheus.
        :param pulumi.Input[_builtins.str] instance_id: Instance id.
        :param pulumi.Input[_builtins.str] region: Region.
        :param pulumi.Input[_builtins.str] subnet_id: Subnet id.
        :param pulumi.Input[_builtins.str] vpc_id: Vpc id.
        """
        if custom_prom is not None:
            pulumi.set(__self__, "custom_prom", custom_prom)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="customProm")
    def custom_prom(self) -> Optional[pulumi.Input['MeshConfigPrometheusCustomPromArgs']]:
        """
        Custom prometheus.
        """
        return pulumi.get(self, "custom_prom")

    @custom_prom.setter
    def custom_prom(self, value: Optional[pulumi.Input['MeshConfigPrometheusCustomPromArgs']]):
        pulumi.set(self, "custom_prom", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance id.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class MeshConfigPrometheusCustomPromArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        Authentication type of the prometheus.
        """
        url: pulumi.Input[_builtins.str]
        """
        Url of the prometheus.
        """
        is_public_addr: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether it is public address, default false.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password of the prometheus, used in basic authentication type.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username of the prometheus, used in basic authentication type.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vpc id.
        """
elif False:
    MeshConfigPrometheusCustomPromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigPrometheusCustomPromArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 is_public_addr: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_type: Authentication type of the prometheus.
        :param pulumi.Input[_builtins.str] url: Url of the prometheus.
        :param pulumi.Input[_builtins.bool] is_public_addr: Whether it is public address, default false.
        :param pulumi.Input[_builtins.str] password: Password of the prometheus, used in basic authentication type.
        :param pulumi.Input[_builtins.str] username: Username of the prometheus, used in basic authentication type.
        :param pulumi.Input[_builtins.str] vpc_id: Vpc id.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "url", url)
        if is_public_addr is not None:
            pulumi.set(__self__, "is_public_addr", is_public_addr)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        Authentication type of the prometheus.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Url of the prometheus.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="isPublicAddr")
    def is_public_addr(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether it is public address, default false.
        """
        return pulumi.get(self, "is_public_addr")

    @is_public_addr.setter
    def is_public_addr(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_public_addr", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class MeshConfigSidecarResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesLimitArgsDict']]]]
        """
        Sidecar limits.
        """
        requests: NotRequired[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesRequestArgsDict']]]]
        """
        Sidecar requests.
        """
elif False:
    MeshConfigSidecarResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigSidecarResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesLimitArgs']]]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesRequestArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesLimitArgs']]] limits: Sidecar limits.
        :param pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesRequestArgs']]] requests: Sidecar requests.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesLimitArgs']]]]:
        """
        Sidecar limits.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesLimitArgs']]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesRequestArgs']]]]:
        """
        Sidecar requests.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MeshConfigSidecarResourcesRequestArgs']]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class MeshConfigSidecarResourcesLimitArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource type name, `cpu/memory`.
        """
        quantity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
elif False:
    MeshConfigSidecarResourcesLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigSidecarResourcesLimitArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 quantity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Resource type name, `cpu/memory`.
        :param pulumi.Input[_builtins.str] quantity: Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource type name, `cpu/memory`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quantity", value)


if not MYPY:
    class MeshConfigSidecarResourcesRequestArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource type name, `cpu/memory`.
        """
        quantity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
elif False:
    MeshConfigSidecarResourcesRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigSidecarResourcesRequestArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 quantity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Resource type name, `cpu/memory`.
        :param pulumi.Input[_builtins.str] quantity: Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource type name, `cpu/memory`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quantity", value)


if not MYPY:
    class MeshConfigTracingArgsDict(TypedDict):
        apm: NotRequired[pulumi.Input['MeshConfigTracingApmArgsDict']]
        """
        APM config.
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether enable tracing.
        """
        sampling: NotRequired[pulumi.Input[_builtins.float]]
        """
        Tracing sampling, 0.0-1.0.
        """
        zipkin: NotRequired[pulumi.Input['MeshConfigTracingZipkinArgsDict']]
        """
        Third party zipkin config.
        """
elif False:
    MeshConfigTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigTracingArgs:
    def __init__(__self__, *,
                 apm: Optional[pulumi.Input['MeshConfigTracingApmArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 sampling: Optional[pulumi.Input[_builtins.float]] = None,
                 zipkin: Optional[pulumi.Input['MeshConfigTracingZipkinArgs']] = None):
        """
        :param pulumi.Input['MeshConfigTracingApmArgs'] apm: APM config.
        :param pulumi.Input[_builtins.bool] enable: Whether enable tracing.
        :param pulumi.Input[_builtins.float] sampling: Tracing sampling, 0.0-1.0.
        :param pulumi.Input['MeshConfigTracingZipkinArgs'] zipkin: Third party zipkin config.
        """
        if apm is not None:
            pulumi.set(__self__, "apm", apm)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sampling is not None:
            pulumi.set(__self__, "sampling", sampling)
        if zipkin is not None:
            pulumi.set(__self__, "zipkin", zipkin)

    @_builtins.property
    @pulumi.getter
    def apm(self) -> Optional[pulumi.Input['MeshConfigTracingApmArgs']]:
        """
        APM config.
        """
        return pulumi.get(self, "apm")

    @apm.setter
    def apm(self, value: Optional[pulumi.Input['MeshConfigTracingApmArgs']]):
        pulumi.set(self, "apm", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether enable tracing.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Tracing sampling, 0.0-1.0.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter
    def zipkin(self) -> Optional[pulumi.Input['MeshConfigTracingZipkinArgs']]:
        """
        Third party zipkin config.
        """
        return pulumi.get(self, "zipkin")

    @zipkin.setter
    def zipkin(self, value: Optional[pulumi.Input['MeshConfigTracingZipkinArgs']]):
        pulumi.set(self, "zipkin", value)


if not MYPY:
    class MeshConfigTracingApmArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether enable APM.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance id of the APM.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region.
        """
elif False:
    MeshConfigTracingApmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigTracingApmArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether enable APM.
        :param pulumi.Input[_builtins.str] instance_id: Instance id of the APM.
        :param pulumi.Input[_builtins.str] region: Region.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether enable APM.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance id of the APM.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class MeshConfigTracingZipkinArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        Zipkin address.
        """
elif False:
    MeshConfigTracingZipkinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshConfigTracingZipkinArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] address: Zipkin address.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        Zipkin address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)


if not MYPY:
    class MeshTagListArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Tag value.
        """
        passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Passthrough to other related product.
        """
elif False:
    MeshTagListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshTagListArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 passthrough: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Tag key.
        :param pulumi.Input[_builtins.str] value: Tag value.
        :param pulumi.Input[_builtins.bool] passthrough: Passthrough to other related product.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Passthrough to other related product.
        """
        return pulumi.get(self, "passthrough")

    @passthrough.setter
    def passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passthrough", value)


if not MYPY:
    class PrometheusAttachmentPrometheusArgsDict(TypedDict):
        custom_prom: NotRequired[pulumi.Input['PrometheusAttachmentPrometheusCustomPromArgsDict']]
        """
        Third party prometheus.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Existed TMP id, auto create TMP if empty.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region for TMP.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet id for TMP.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vpc id for TMP.
        """
elif False:
    PrometheusAttachmentPrometheusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusAttachmentPrometheusArgs:
    def __init__(__self__, *,
                 custom_prom: Optional[pulumi.Input['PrometheusAttachmentPrometheusCustomPromArgs']] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['PrometheusAttachmentPrometheusCustomPromArgs'] custom_prom: Third party prometheus.
        :param pulumi.Input[_builtins.str] instance_id: Existed TMP id, auto create TMP if empty.
        :param pulumi.Input[_builtins.str] region: Region for TMP.
        :param pulumi.Input[_builtins.str] subnet_id: Subnet id for TMP.
        :param pulumi.Input[_builtins.str] vpc_id: Vpc id for TMP.
        """
        if custom_prom is not None:
            pulumi.set(__self__, "custom_prom", custom_prom)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="customProm")
    def custom_prom(self) -> Optional[pulumi.Input['PrometheusAttachmentPrometheusCustomPromArgs']]:
        """
        Third party prometheus.
        """
        return pulumi.get(self, "custom_prom")

    @custom_prom.setter
    def custom_prom(self, value: Optional[pulumi.Input['PrometheusAttachmentPrometheusCustomPromArgs']]):
        pulumi.set(self, "custom_prom", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Existed TMP id, auto create TMP if empty.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region for TMP.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet id for TMP.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vpc id for TMP.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class PrometheusAttachmentPrometheusCustomPromArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        Authentication type of the prometheus.
        """
        url: pulumi.Input[_builtins.str]
        """
        Url of the prometheus.
        """
        is_public_addr: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether it is public address, default false.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password of the prometheus, used in basic authentication type.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username of the prometheus, used in basic authentication type.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vpc id.
        """
elif False:
    PrometheusAttachmentPrometheusCustomPromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusAttachmentPrometheusCustomPromArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 is_public_addr: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_type: Authentication type of the prometheus.
        :param pulumi.Input[_builtins.str] url: Url of the prometheus.
        :param pulumi.Input[_builtins.bool] is_public_addr: Whether it is public address, default false.
        :param pulumi.Input[_builtins.str] password: Password of the prometheus, used in basic authentication type.
        :param pulumi.Input[_builtins.str] username: Username of the prometheus, used in basic authentication type.
        :param pulumi.Input[_builtins.str] vpc_id: Vpc id.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "url", url)
        if is_public_addr is not None:
            pulumi.set(__self__, "is_public_addr", is_public_addr)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        Authentication type of the prometheus.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Url of the prometheus.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="isPublicAddr")
    def is_public_addr(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether it is public address, default false.
        """
        return pulumi.get(self, "is_public_addr")

    @is_public_addr.setter
    def is_public_addr(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_public_addr", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class TracingConfigApmArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether enable APM.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance id of the APM.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region.
        """
elif False:
    TracingConfigApmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TracingConfigApmArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether enable APM.
        :param pulumi.Input[_builtins.str] instance_id: Instance id of the APM.
        :param pulumi.Input[_builtins.str] region: Region.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether enable APM.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance id of the APM.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class TracingConfigZipkinArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        Zipkin address.
        """
elif False:
    TracingConfigZipkinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TracingConfigZipkinArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] address: Zipkin address.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        Zipkin address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)


