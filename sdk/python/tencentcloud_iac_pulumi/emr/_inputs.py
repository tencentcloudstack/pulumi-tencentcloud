# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AutoScaleStrategyLoadAutoScaleStrategyArgs',
    'AutoScaleStrategyLoadAutoScaleStrategyArgsDict',
    'AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgs',
    'AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgsDict',
    'AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgs',
    'AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgsDict',
    'AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgs',
    'AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgsDict',
    'AutoScaleStrategyLoadAutoScaleStrategyTagArgs',
    'AutoScaleStrategyLoadAutoScaleStrategyTagArgsDict',
    'AutoScaleStrategyTimeAutoScaleStrategyArgs',
    'AutoScaleStrategyTimeAutoScaleStrategyArgsDict',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgs',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgsDict',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgs',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgsDict',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgs',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgsDict',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgs',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgsDict',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgs',
    'AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgsDict',
    'AutoScaleStrategyTimeAutoScaleStrategyTagArgs',
    'AutoScaleStrategyTimeAutoScaleStrategyTagArgsDict',
    'ClusterMultiZoneSettingArgs',
    'ClusterMultiZoneSettingArgsDict',
    'ClusterMultiZoneSettingPlacementArgs',
    'ClusterMultiZoneSettingPlacementArgsDict',
    'ClusterMultiZoneSettingResourceSpecArgs',
    'ClusterMultiZoneSettingResourceSpecArgsDict',
    'ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgs',
    'ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgsDict',
    'ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgs',
    'ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgsDict',
    'ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgs',
    'ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgsDict',
    'ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgs',
    'ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgsDict',
    'ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgs',
    'ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgsDict',
    'ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgs',
    'ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgsDict',
    'ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgs',
    'ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgsDict',
    'ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgs',
    'ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgsDict',
    'ClusterPlacementInfoArgs',
    'ClusterPlacementInfoArgsDict',
    'ClusterPreExecutedFileSettingArgs',
    'ClusterPreExecutedFileSettingArgsDict',
    'ClusterResourceSpecArgs',
    'ClusterResourceSpecArgsDict',
    'ClusterResourceSpecCommonResourceSpecArgs',
    'ClusterResourceSpecCommonResourceSpecArgsDict',
    'ClusterResourceSpecCommonResourceSpecMultiDiskArgs',
    'ClusterResourceSpecCommonResourceSpecMultiDiskArgsDict',
    'ClusterResourceSpecCoreResourceSpecArgs',
    'ClusterResourceSpecCoreResourceSpecArgsDict',
    'ClusterResourceSpecCoreResourceSpecMultiDiskArgs',
    'ClusterResourceSpecCoreResourceSpecMultiDiskArgsDict',
    'ClusterResourceSpecMasterResourceSpecArgs',
    'ClusterResourceSpecMasterResourceSpecArgsDict',
    'ClusterResourceSpecMasterResourceSpecMultiDiskArgs',
    'ClusterResourceSpecMasterResourceSpecMultiDiskArgsDict',
    'ClusterResourceSpecTaskResourceSpecArgs',
    'ClusterResourceSpecTaskResourceSpecArgsDict',
    'ClusterResourceSpecTaskResourceSpecMultiDiskArgs',
    'ClusterResourceSpecTaskResourceSpecMultiDiskArgsDict',
    'ClusterTerminateNodeInfoArgs',
    'ClusterTerminateNodeInfoArgsDict',
    'YarnCapacityGlobalConfigArgs',
    'YarnCapacityGlobalConfigArgsDict',
    'YarnCapacityGlobalConfigDefaultSettingArgs',
    'YarnCapacityGlobalConfigDefaultSettingArgsDict',
    'YarnFairGlobalConfigArgs',
    'YarnFairGlobalConfigArgsDict',
    'GetAutoScaleRecordsFilterArgs',
    'GetAutoScaleRecordsFilterArgsDict',
    'GetJobStatusDetailFlowParamArgs',
    'GetJobStatusDetailFlowParamArgsDict',
    'GetServiceNodeInfosSearchFieldArgs',
    'GetServiceNodeInfosSearchFieldArgsDict',
]

MYPY = False

if not MYPY:
    class AutoScaleStrategyLoadAutoScaleStrategyArgsDict(TypedDict):
        calm_down_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cooling time for rules to take effect.
        """
        config_group_assigned: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default configuration group.
        """
        grace_down_flag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Elegant shrink switch.
        """
        grace_down_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Graceful downsizing waiting time.
        """
        load_metrics_conditions: NotRequired[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgsDict']]
        """
        Multiple indicator trigger conditions.
        """
        measure_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expansion resource calculation methods, "DEFAULT", "INSTANCE", "CPU", "MEMORYGB".
        "DEFAULT" means the default mode, which has the same meaning as "INSTANCE".
        "INSTANCE" means calculation based on nodes, the default method.
        "CPU" means calculated based on the number of cores of the machine.
        "MEMORYGB" means calculated based on the number of machine memory.
        """
        period_valid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effective time for the rule to take effect.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rule priority, invalid when added, defaults to auto-increment.
        """
        process_method: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicator processing method, 1 represents MAX, 2 represents MIN, and 3 represents AVG.
        """
        scale_action: NotRequired[pulumi.Input[_builtins.int]]
        """
        Expansion and contraction actions, 1 means expansion, 2 means shrinkage.
        """
        scale_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of expansion and contraction each time the rule takes effect.
        """
        strategy_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rule ID.
        """
        strategy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule name.
        """
        strategy_status: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rule status, 1 means enabled, 3 means disabled.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyTagArgsDict']]]]
        """
        Binding tag list.
        """
        yarn_node_label: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule expansion specifies yarn node label.
        """
elif False:
    AutoScaleStrategyLoadAutoScaleStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyLoadAutoScaleStrategyArgs:
    def __init__(__self__, *,
                 calm_down_time: Optional[pulumi.Input[_builtins.int]] = None,
                 config_group_assigned: Optional[pulumi.Input[_builtins.str]] = None,
                 grace_down_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 grace_down_time: Optional[pulumi.Input[_builtins.int]] = None,
                 load_metrics_conditions: Optional[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgs']] = None,
                 measure_method: Optional[pulumi.Input[_builtins.str]] = None,
                 period_valid: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 process_method: Optional[pulumi.Input[_builtins.int]] = None,
                 scale_action: Optional[pulumi.Input[_builtins.int]] = None,
                 scale_num: Optional[pulumi.Input[_builtins.int]] = None,
                 strategy_id: Optional[pulumi.Input[_builtins.int]] = None,
                 strategy_name: Optional[pulumi.Input[_builtins.str]] = None,
                 strategy_status: Optional[pulumi.Input[_builtins.int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyTagArgs']]]] = None,
                 yarn_node_label: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] calm_down_time: Cooling time for rules to take effect.
        :param pulumi.Input[_builtins.str] config_group_assigned: Default configuration group.
        :param pulumi.Input[_builtins.bool] grace_down_flag: Elegant shrink switch.
        :param pulumi.Input[_builtins.int] grace_down_time: Graceful downsizing waiting time.
        :param pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgs'] load_metrics_conditions: Multiple indicator trigger conditions.
        :param pulumi.Input[_builtins.str] measure_method: Expansion resource calculation methods, "DEFAULT", "INSTANCE", "CPU", "MEMORYGB".
               "DEFAULT" means the default mode, which has the same meaning as "INSTANCE".
               "INSTANCE" means calculation based on nodes, the default method.
               "CPU" means calculated based on the number of cores of the machine.
               "MEMORYGB" means calculated based on the number of machine memory.
        :param pulumi.Input[_builtins.str] period_valid: Effective time for the rule to take effect.
        :param pulumi.Input[_builtins.int] priority: Rule priority, invalid when added, defaults to auto-increment.
        :param pulumi.Input[_builtins.int] process_method: Indicator processing method, 1 represents MAX, 2 represents MIN, and 3 represents AVG.
        :param pulumi.Input[_builtins.int] scale_action: Expansion and contraction actions, 1 means expansion, 2 means shrinkage.
        :param pulumi.Input[_builtins.int] scale_num: The amount of expansion and contraction each time the rule takes effect.
        :param pulumi.Input[_builtins.int] strategy_id: Rule ID.
        :param pulumi.Input[_builtins.str] strategy_name: Rule name.
        :param pulumi.Input[_builtins.int] strategy_status: Rule status, 1 means enabled, 3 means disabled.
        :param pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyTagArgs']]] tags: Binding tag list.
        :param pulumi.Input[_builtins.str] yarn_node_label: Rule expansion specifies yarn node label.
        """
        if calm_down_time is not None:
            pulumi.set(__self__, "calm_down_time", calm_down_time)
        if config_group_assigned is not None:
            pulumi.set(__self__, "config_group_assigned", config_group_assigned)
        if grace_down_flag is not None:
            pulumi.set(__self__, "grace_down_flag", grace_down_flag)
        if grace_down_time is not None:
            pulumi.set(__self__, "grace_down_time", grace_down_time)
        if load_metrics_conditions is not None:
            pulumi.set(__self__, "load_metrics_conditions", load_metrics_conditions)
        if measure_method is not None:
            pulumi.set(__self__, "measure_method", measure_method)
        if period_valid is not None:
            pulumi.set(__self__, "period_valid", period_valid)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if process_method is not None:
            pulumi.set(__self__, "process_method", process_method)
        if scale_action is not None:
            pulumi.set(__self__, "scale_action", scale_action)
        if scale_num is not None:
            pulumi.set(__self__, "scale_num", scale_num)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)
        if strategy_name is not None:
            pulumi.set(__self__, "strategy_name", strategy_name)
        if strategy_status is not None:
            pulumi.set(__self__, "strategy_status", strategy_status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if yarn_node_label is not None:
            pulumi.set(__self__, "yarn_node_label", yarn_node_label)

    @_builtins.property
    @pulumi.getter(name="calmDownTime")
    def calm_down_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cooling time for rules to take effect.
        """
        return pulumi.get(self, "calm_down_time")

    @calm_down_time.setter
    def calm_down_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "calm_down_time", value)

    @_builtins.property
    @pulumi.getter(name="configGroupAssigned")
    def config_group_assigned(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default configuration group.
        """
        return pulumi.get(self, "config_group_assigned")

    @config_group_assigned.setter
    def config_group_assigned(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_group_assigned", value)

    @_builtins.property
    @pulumi.getter(name="graceDownFlag")
    def grace_down_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Elegant shrink switch.
        """
        return pulumi.get(self, "grace_down_flag")

    @grace_down_flag.setter
    def grace_down_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "grace_down_flag", value)

    @_builtins.property
    @pulumi.getter(name="graceDownTime")
    def grace_down_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Graceful downsizing waiting time.
        """
        return pulumi.get(self, "grace_down_time")

    @grace_down_time.setter
    def grace_down_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grace_down_time", value)

    @_builtins.property
    @pulumi.getter(name="loadMetricsConditions")
    def load_metrics_conditions(self) -> Optional[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgs']]:
        """
        Multiple indicator trigger conditions.
        """
        return pulumi.get(self, "load_metrics_conditions")

    @load_metrics_conditions.setter
    def load_metrics_conditions(self, value: Optional[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgs']]):
        pulumi.set(self, "load_metrics_conditions", value)

    @_builtins.property
    @pulumi.getter(name="measureMethod")
    def measure_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expansion resource calculation methods, "DEFAULT", "INSTANCE", "CPU", "MEMORYGB".
        "DEFAULT" means the default mode, which has the same meaning as "INSTANCE".
        "INSTANCE" means calculation based on nodes, the default method.
        "CPU" means calculated based on the number of cores of the machine.
        "MEMORYGB" means calculated based on the number of machine memory.
        """
        return pulumi.get(self, "measure_method")

    @measure_method.setter
    def measure_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "measure_method", value)

    @_builtins.property
    @pulumi.getter(name="periodValid")
    def period_valid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effective time for the rule to take effect.
        """
        return pulumi.get(self, "period_valid")

    @period_valid.setter
    def period_valid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "period_valid", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule priority, invalid when added, defaults to auto-increment.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="processMethod")
    def process_method(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicator processing method, 1 represents MAX, 2 represents MIN, and 3 represents AVG.
        """
        return pulumi.get(self, "process_method")

    @process_method.setter
    def process_method(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "process_method", value)

    @_builtins.property
    @pulumi.getter(name="scaleAction")
    def scale_action(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Expansion and contraction actions, 1 means expansion, 2 means shrinkage.
        """
        return pulumi.get(self, "scale_action")

    @scale_action.setter
    def scale_action(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "scale_action", value)

    @_builtins.property
    @pulumi.getter(name="scaleNum")
    def scale_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of expansion and contraction each time the rule takes effect.
        """
        return pulumi.get(self, "scale_num")

    @scale_num.setter
    def scale_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "scale_num", value)

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule ID.
        """
        return pulumi.get(self, "strategy_id")

    @strategy_id.setter
    def strategy_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "strategy_id", value)

    @_builtins.property
    @pulumi.getter(name="strategyName")
    def strategy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule name.
        """
        return pulumi.get(self, "strategy_name")

    @strategy_name.setter
    def strategy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strategy_name", value)

    @_builtins.property
    @pulumi.getter(name="strategyStatus")
    def strategy_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule status, 1 means enabled, 3 means disabled.
        """
        return pulumi.get(self, "strategy_status")

    @strategy_status.setter
    def strategy_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "strategy_status", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyTagArgs']]]]:
        """
        Binding tag list.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="yarnNodeLabel")
    def yarn_node_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule expansion specifies yarn node label.
        """
        return pulumi.get(self, "yarn_node_label")

    @yarn_node_label.setter
    def yarn_node_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "yarn_node_label", value)


if not MYPY:
    class AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgsDict(TypedDict):
        load_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgsDict']]]]
        """
        Expansion and contraction load indicators.
        """
elif False:
    AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsArgs:
    def __init__(__self__, *,
                 load_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgs']]] load_metrics: Expansion and contraction load indicators.
        """
        if load_metrics is not None:
            pulumi.set(__self__, "load_metrics", load_metrics)

    @_builtins.property
    @pulumi.getter(name="loadMetrics")
    def load_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgs']]]]:
        """
        Expansion and contraction load indicators.
        """
        return pulumi.get(self, "load_metrics")

    @load_metrics.setter
    def load_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgs']]]]):
        pulumi.set(self, "load_metrics", value)


if not MYPY:
    class AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgsDict']]]]
        """
        Trigger condition.
        """
        load_metrics: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expansion and contraction load indicators.
        """
        metric_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rule metadata record ID.
        """
        statistic_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The regular statistical period provides 1min, 3min, and 5min.
        """
        trigger_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of triggers. When the number of consecutive triggers exceeds TriggerThreshold, the expansion and contraction will begin.
        """
elif False:
    AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgs']]]] = None,
                 load_metrics: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_id: Optional[pulumi.Input[_builtins.int]] = None,
                 statistic_period: Optional[pulumi.Input[_builtins.int]] = None,
                 trigger_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgs']]] conditions: Trigger condition.
        :param pulumi.Input[_builtins.str] load_metrics: Expansion and contraction load indicators.
        :param pulumi.Input[_builtins.int] metric_id: Rule metadata record ID.
        :param pulumi.Input[_builtins.int] statistic_period: The regular statistical period provides 1min, 3min, and 5min.
        :param pulumi.Input[_builtins.int] trigger_threshold: The number of triggers. When the number of consecutive triggers exceeds TriggerThreshold, the expansion and contraction will begin.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if load_metrics is not None:
            pulumi.set(__self__, "load_metrics", load_metrics)
        if metric_id is not None:
            pulumi.set(__self__, "metric_id", metric_id)
        if statistic_period is not None:
            pulumi.set(__self__, "statistic_period", statistic_period)
        if trigger_threshold is not None:
            pulumi.set(__self__, "trigger_threshold", trigger_threshold)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgs']]]]:
        """
        Trigger condition.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="loadMetrics")
    def load_metrics(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expansion and contraction load indicators.
        """
        return pulumi.get(self, "load_metrics")

    @load_metrics.setter
    def load_metrics(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_metrics", value)

    @_builtins.property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule metadata record ID.
        """
        return pulumi.get(self, "metric_id")

    @metric_id.setter
    def metric_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric_id", value)

    @_builtins.property
    @pulumi.getter(name="statisticPeriod")
    def statistic_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The regular statistical period provides 1min, 3min, and 5min.
        """
        return pulumi.get(self, "statistic_period")

    @statistic_period.setter
    def statistic_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "statistic_period", value)

    @_builtins.property
    @pulumi.getter(name="triggerThreshold")
    def trigger_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of triggers. When the number of consecutive triggers exceeds TriggerThreshold, the expansion and contraction will begin.
        """
        return pulumi.get(self, "trigger_threshold")

    @trigger_threshold.setter
    def trigger_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "trigger_threshold", value)


if not MYPY:
    class AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgsDict(TypedDict):
        compare_method: pulumi.Input[_builtins.int]
        """
        Conditional comparison method, 1 means greater than, 2 means less than, 3 means greater than or equal to, 4 means less than or equal to.
        """
        threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Conditional threshold.
        """
elif False:
    AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyLoadAutoScaleStrategyLoadMetricsConditionsLoadMetricConditionArgs:
    def __init__(__self__, *,
                 compare_method: pulumi.Input[_builtins.int],
                 threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] compare_method: Conditional comparison method, 1 means greater than, 2 means less than, 3 means greater than or equal to, 4 means less than or equal to.
        :param pulumi.Input[_builtins.float] threshold: Conditional threshold.
        """
        pulumi.set(__self__, "compare_method", compare_method)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="compareMethod")
    def compare_method(self) -> pulumi.Input[_builtins.int]:
        """
        Conditional comparison method, 1 means greater than, 2 means less than, 3 means greater than or equal to, 4 means less than or equal to.
        """
        return pulumi.get(self, "compare_method")

    @compare_method.setter
    def compare_method(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "compare_method", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Conditional threshold.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class AutoScaleStrategyLoadAutoScaleStrategyTagArgsDict(TypedDict):
        tag_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        tag key.
        """
        tag_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        tag value.
        """
elif False:
    AutoScaleStrategyLoadAutoScaleStrategyTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyLoadAutoScaleStrategyTagArgs:
    def __init__(__self__, *,
                 tag_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tag_key: tag key.
        :param pulumi.Input[_builtins.str] tag_value: tag value.
        """
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        tag key.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_key", value)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        tag value.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AutoScaleStrategyTimeAutoScaleStrategyArgsDict(TypedDict):
        interval_time: pulumi.Input[_builtins.int]
        """
        The cooling time after the policy is triggered. During this period, elastic expansion and contraction will not be triggered.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Rule priority, the smaller it is, the higher it is.
        """
        repeat_strategy: pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgsDict']
        """
        Time expansion and contraction repetition strategy.
        """
        retry_valid_time: pulumi.Input[_builtins.int]
        """
        When multiple rules are triggered at the same time and some of them are not actually executed, retries will be made within this time range.
        """
        scale_action: pulumi.Input[_builtins.int]
        """
        Expansion and contraction actions, 1 means expansion, 2 means shrinkage.
        """
        scale_num: pulumi.Input[_builtins.int]
        """
        The number of expansions and contractions.
        """
        strategy_name: pulumi.Input[_builtins.str]
        """
        Policy name, unique within the cluster.
        """
        strategy_status: pulumi.Input[_builtins.int]
        """
        Rule status, 1 means valid, 2 means invalid, and 3 means suspended. Required.
        """
        compensate_flag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Compensation expansion, 0 means not enabled, 1 means enabled.
        """
        config_group_assigned: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default configuration group.
        """
        grace_down_flag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Elegant shrink switch.
        """
        grace_down_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Graceful downsizing waiting time.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        scaling group id.
        """
        max_use: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum usage time, seconds, minimum 1 hour, maximum 24 hours.
        """
        measure_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expansion resource calculation methods, "DEFAULT", "INSTANCE", "CPU", "MEMORYGB".
        "DEFAULT" means the default mode, which has the same meaning as "INSTANCE".
        "INSTANCE" means calculation based on nodes, the default method.
        "CPU" means calculated based on the number of cores of the machine.
        "MEMORYGB" means calculated based on the number of machine memory.
        """
        service_node_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Start process list.
        """
        soft_deploy_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Node deployment service list. Only fill in HDFS and YARN for deployment services. [Mapping relationship table corresponding to component names](https://cloud.tencent.com/document/product/589/98760).
        """
        strategy_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Policy unique ID.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyTagArgsDict']]]]
        """
        Binding tag list.
        """
        terminate_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destruction strategy, "DEFAULT", the default destruction strategy, shrinkage is triggered by shrinkage rules, "TIMING" means scheduled destruction.
        """
elif False:
    AutoScaleStrategyTimeAutoScaleStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyTimeAutoScaleStrategyArgs:
    def __init__(__self__, *,
                 interval_time: pulumi.Input[_builtins.int],
                 priority: pulumi.Input[_builtins.int],
                 repeat_strategy: pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgs'],
                 retry_valid_time: pulumi.Input[_builtins.int],
                 scale_action: pulumi.Input[_builtins.int],
                 scale_num: pulumi.Input[_builtins.int],
                 strategy_name: pulumi.Input[_builtins.str],
                 strategy_status: pulumi.Input[_builtins.int],
                 compensate_flag: Optional[pulumi.Input[_builtins.int]] = None,
                 config_group_assigned: Optional[pulumi.Input[_builtins.str]] = None,
                 grace_down_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 grace_down_time: Optional[pulumi.Input[_builtins.int]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 max_use: Optional[pulumi.Input[_builtins.int]] = None,
                 measure_method: Optional[pulumi.Input[_builtins.str]] = None,
                 service_node_infos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 soft_deploy_infos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 strategy_id: Optional[pulumi.Input[_builtins.int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyTagArgs']]]] = None,
                 terminate_policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] interval_time: The cooling time after the policy is triggered. During this period, elastic expansion and contraction will not be triggered.
        :param pulumi.Input[_builtins.int] priority: Rule priority, the smaller it is, the higher it is.
        :param pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgs'] repeat_strategy: Time expansion and contraction repetition strategy.
        :param pulumi.Input[_builtins.int] retry_valid_time: When multiple rules are triggered at the same time and some of them are not actually executed, retries will be made within this time range.
        :param pulumi.Input[_builtins.int] scale_action: Expansion and contraction actions, 1 means expansion, 2 means shrinkage.
        :param pulumi.Input[_builtins.int] scale_num: The number of expansions and contractions.
        :param pulumi.Input[_builtins.str] strategy_name: Policy name, unique within the cluster.
        :param pulumi.Input[_builtins.int] strategy_status: Rule status, 1 means valid, 2 means invalid, and 3 means suspended. Required.
        :param pulumi.Input[_builtins.int] compensate_flag: Compensation expansion, 0 means not enabled, 1 means enabled.
        :param pulumi.Input[_builtins.str] config_group_assigned: Default configuration group.
        :param pulumi.Input[_builtins.bool] grace_down_flag: Elegant shrink switch.
        :param pulumi.Input[_builtins.int] grace_down_time: Graceful downsizing waiting time.
        :param pulumi.Input[_builtins.int] group_id: scaling group id.
        :param pulumi.Input[_builtins.int] max_use: Maximum usage time, seconds, minimum 1 hour, maximum 24 hours.
        :param pulumi.Input[_builtins.str] measure_method: Expansion resource calculation methods, "DEFAULT", "INSTANCE", "CPU", "MEMORYGB".
               "DEFAULT" means the default mode, which has the same meaning as "INSTANCE".
               "INSTANCE" means calculation based on nodes, the default method.
               "CPU" means calculated based on the number of cores of the machine.
               "MEMORYGB" means calculated based on the number of machine memory.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] service_node_infos: Start process list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] soft_deploy_infos: Node deployment service list. Only fill in HDFS and YARN for deployment services. [Mapping relationship table corresponding to component names](https://cloud.tencent.com/document/product/589/98760).
        :param pulumi.Input[_builtins.int] strategy_id: Policy unique ID.
        :param pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyTagArgs']]] tags: Binding tag list.
        :param pulumi.Input[_builtins.str] terminate_policy: Destruction strategy, "DEFAULT", the default destruction strategy, shrinkage is triggered by shrinkage rules, "TIMING" means scheduled destruction.
        """
        pulumi.set(__self__, "interval_time", interval_time)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "repeat_strategy", repeat_strategy)
        pulumi.set(__self__, "retry_valid_time", retry_valid_time)
        pulumi.set(__self__, "scale_action", scale_action)
        pulumi.set(__self__, "scale_num", scale_num)
        pulumi.set(__self__, "strategy_name", strategy_name)
        pulumi.set(__self__, "strategy_status", strategy_status)
        if compensate_flag is not None:
            pulumi.set(__self__, "compensate_flag", compensate_flag)
        if config_group_assigned is not None:
            pulumi.set(__self__, "config_group_assigned", config_group_assigned)
        if grace_down_flag is not None:
            pulumi.set(__self__, "grace_down_flag", grace_down_flag)
        if grace_down_time is not None:
            pulumi.set(__self__, "grace_down_time", grace_down_time)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if max_use is not None:
            pulumi.set(__self__, "max_use", max_use)
        if measure_method is not None:
            pulumi.set(__self__, "measure_method", measure_method)
        if service_node_infos is not None:
            pulumi.set(__self__, "service_node_infos", service_node_infos)
        if soft_deploy_infos is not None:
            pulumi.set(__self__, "soft_deploy_infos", soft_deploy_infos)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if terminate_policy is not None:
            pulumi.set(__self__, "terminate_policy", terminate_policy)

    @_builtins.property
    @pulumi.getter(name="intervalTime")
    def interval_time(self) -> pulumi.Input[_builtins.int]:
        """
        The cooling time after the policy is triggered. During this period, elastic expansion and contraction will not be triggered.
        """
        return pulumi.get(self, "interval_time")

    @interval_time.setter
    def interval_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "interval_time", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Rule priority, the smaller it is, the higher it is.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="repeatStrategy")
    def repeat_strategy(self) -> pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgs']:
        """
        Time expansion and contraction repetition strategy.
        """
        return pulumi.get(self, "repeat_strategy")

    @repeat_strategy.setter
    def repeat_strategy(self, value: pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgs']):
        pulumi.set(self, "repeat_strategy", value)

    @_builtins.property
    @pulumi.getter(name="retryValidTime")
    def retry_valid_time(self) -> pulumi.Input[_builtins.int]:
        """
        When multiple rules are triggered at the same time and some of them are not actually executed, retries will be made within this time range.
        """
        return pulumi.get(self, "retry_valid_time")

    @retry_valid_time.setter
    def retry_valid_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "retry_valid_time", value)

    @_builtins.property
    @pulumi.getter(name="scaleAction")
    def scale_action(self) -> pulumi.Input[_builtins.int]:
        """
        Expansion and contraction actions, 1 means expansion, 2 means shrinkage.
        """
        return pulumi.get(self, "scale_action")

    @scale_action.setter
    def scale_action(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "scale_action", value)

    @_builtins.property
    @pulumi.getter(name="scaleNum")
    def scale_num(self) -> pulumi.Input[_builtins.int]:
        """
        The number of expansions and contractions.
        """
        return pulumi.get(self, "scale_num")

    @scale_num.setter
    def scale_num(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "scale_num", value)

    @_builtins.property
    @pulumi.getter(name="strategyName")
    def strategy_name(self) -> pulumi.Input[_builtins.str]:
        """
        Policy name, unique within the cluster.
        """
        return pulumi.get(self, "strategy_name")

    @strategy_name.setter
    def strategy_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "strategy_name", value)

    @_builtins.property
    @pulumi.getter(name="strategyStatus")
    def strategy_status(self) -> pulumi.Input[_builtins.int]:
        """
        Rule status, 1 means valid, 2 means invalid, and 3 means suspended. Required.
        """
        return pulumi.get(self, "strategy_status")

    @strategy_status.setter
    def strategy_status(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "strategy_status", value)

    @_builtins.property
    @pulumi.getter(name="compensateFlag")
    def compensate_flag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Compensation expansion, 0 means not enabled, 1 means enabled.
        """
        return pulumi.get(self, "compensate_flag")

    @compensate_flag.setter
    def compensate_flag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "compensate_flag", value)

    @_builtins.property
    @pulumi.getter(name="configGroupAssigned")
    def config_group_assigned(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default configuration group.
        """
        return pulumi.get(self, "config_group_assigned")

    @config_group_assigned.setter
    def config_group_assigned(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_group_assigned", value)

    @_builtins.property
    @pulumi.getter(name="graceDownFlag")
    def grace_down_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Elegant shrink switch.
        """
        return pulumi.get(self, "grace_down_flag")

    @grace_down_flag.setter
    def grace_down_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "grace_down_flag", value)

    @_builtins.property
    @pulumi.getter(name="graceDownTime")
    def grace_down_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Graceful downsizing waiting time.
        """
        return pulumi.get(self, "grace_down_time")

    @grace_down_time.setter
    def grace_down_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grace_down_time", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        scaling group id.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="maxUse")
    def max_use(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum usage time, seconds, minimum 1 hour, maximum 24 hours.
        """
        return pulumi.get(self, "max_use")

    @max_use.setter
    def max_use(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_use", value)

    @_builtins.property
    @pulumi.getter(name="measureMethod")
    def measure_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expansion resource calculation methods, "DEFAULT", "INSTANCE", "CPU", "MEMORYGB".
        "DEFAULT" means the default mode, which has the same meaning as "INSTANCE".
        "INSTANCE" means calculation based on nodes, the default method.
        "CPU" means calculated based on the number of cores of the machine.
        "MEMORYGB" means calculated based on the number of machine memory.
        """
        return pulumi.get(self, "measure_method")

    @measure_method.setter
    def measure_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "measure_method", value)

    @_builtins.property
    @pulumi.getter(name="serviceNodeInfos")
    def service_node_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Start process list.
        """
        return pulumi.get(self, "service_node_infos")

    @service_node_infos.setter
    def service_node_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "service_node_infos", value)

    @_builtins.property
    @pulumi.getter(name="softDeployInfos")
    def soft_deploy_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Node deployment service list. Only fill in HDFS and YARN for deployment services. [Mapping relationship table corresponding to component names](https://cloud.tencent.com/document/product/589/98760).
        """
        return pulumi.get(self, "soft_deploy_infos")

    @soft_deploy_infos.setter
    def soft_deploy_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "soft_deploy_infos", value)

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Policy unique ID.
        """
        return pulumi.get(self, "strategy_id")

    @strategy_id.setter
    def strategy_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "strategy_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyTagArgs']]]]:
        """
        Binding tag list.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="terminatePolicy")
    def terminate_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destruction strategy, "DEFAULT", the default destruction strategy, shrinkage is triggered by shrinkage rules, "TIMING" means scheduled destruction.
        """
        return pulumi.get(self, "terminate_policy")

    @terminate_policy.setter
    def terminate_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "terminate_policy", value)


if not MYPY:
    class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgsDict(TypedDict):
        repeat_type: pulumi.Input[_builtins.str]
        """
        The value range is "DAY", "DOW", "DOM", and "NONE", which respectively represent daily repetition, weekly repetition, monthly repetition and one-time execution. Required.
        """
        day_repeat: NotRequired[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgsDict']]
        """
        Repeat rules by day, valid when RepeatType is "DAY".
        """
        expire: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule expiration time. After this time, the rule will automatically be placed in a suspended state, in the form of "2020-07-23 00:00:00". Required.
        """
        month_repeat: NotRequired[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgsDict']]
        """
        Repeat rules by month, valid when RepeatType is "DOM".
        """
        not_repeat: NotRequired[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgsDict']]
        """
        Execute the rule once, effective when RepeatType is "NONE".
        """
        week_repeat: NotRequired[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgsDict']]
        """
        Repeat rules by week, valid when RepeatType is "DOW".
        """
elif False:
    AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyArgs:
    def __init__(__self__, *,
                 repeat_type: pulumi.Input[_builtins.str],
                 day_repeat: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgs']] = None,
                 expire: Optional[pulumi.Input[_builtins.str]] = None,
                 month_repeat: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgs']] = None,
                 not_repeat: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgs']] = None,
                 week_repeat: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] repeat_type: The value range is "DAY", "DOW", "DOM", and "NONE", which respectively represent daily repetition, weekly repetition, monthly repetition and one-time execution. Required.
        :param pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgs'] day_repeat: Repeat rules by day, valid when RepeatType is "DAY".
        :param pulumi.Input[_builtins.str] expire: Rule expiration time. After this time, the rule will automatically be placed in a suspended state, in the form of "2020-07-23 00:00:00". Required.
        :param pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgs'] month_repeat: Repeat rules by month, valid when RepeatType is "DOM".
        :param pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgs'] not_repeat: Execute the rule once, effective when RepeatType is "NONE".
        :param pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgs'] week_repeat: Repeat rules by week, valid when RepeatType is "DOW".
        """
        pulumi.set(__self__, "repeat_type", repeat_type)
        if day_repeat is not None:
            pulumi.set(__self__, "day_repeat", day_repeat)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if month_repeat is not None:
            pulumi.set(__self__, "month_repeat", month_repeat)
        if not_repeat is not None:
            pulumi.set(__self__, "not_repeat", not_repeat)
        if week_repeat is not None:
            pulumi.set(__self__, "week_repeat", week_repeat)

    @_builtins.property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> pulumi.Input[_builtins.str]:
        """
        The value range is "DAY", "DOW", "DOM", and "NONE", which respectively represent daily repetition, weekly repetition, monthly repetition and one-time execution. Required.
        """
        return pulumi.get(self, "repeat_type")

    @repeat_type.setter
    def repeat_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repeat_type", value)

    @_builtins.property
    @pulumi.getter(name="dayRepeat")
    def day_repeat(self) -> Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgs']]:
        """
        Repeat rules by day, valid when RepeatType is "DAY".
        """
        return pulumi.get(self, "day_repeat")

    @day_repeat.setter
    def day_repeat(self, value: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgs']]):
        pulumi.set(self, "day_repeat", value)

    @_builtins.property
    @pulumi.getter
    def expire(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule expiration time. After this time, the rule will automatically be placed in a suspended state, in the form of "2020-07-23 00:00:00". Required.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire", value)

    @_builtins.property
    @pulumi.getter(name="monthRepeat")
    def month_repeat(self) -> Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgs']]:
        """
        Repeat rules by month, valid when RepeatType is "DOM".
        """
        return pulumi.get(self, "month_repeat")

    @month_repeat.setter
    def month_repeat(self, value: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgs']]):
        pulumi.set(self, "month_repeat", value)

    @_builtins.property
    @pulumi.getter(name="notRepeat")
    def not_repeat(self) -> Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgs']]:
        """
        Execute the rule once, effective when RepeatType is "NONE".
        """
        return pulumi.get(self, "not_repeat")

    @not_repeat.setter
    def not_repeat(self, value: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgs']]):
        pulumi.set(self, "not_repeat", value)

    @_builtins.property
    @pulumi.getter(name="weekRepeat")
    def week_repeat(self) -> Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgs']]:
        """
        Repeat rules by week, valid when RepeatType is "DOW".
        """
        return pulumi.get(self, "week_repeat")

    @week_repeat.setter
    def week_repeat(self, value: Optional[pulumi.Input['AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgs']]):
        pulumi.set(self, "week_repeat", value)


if not MYPY:
    class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgsDict(TypedDict):
        execute_at_time_of_day: pulumi.Input[_builtins.str]
        """
        Repeat the specific time when the task is executed, such as "01:02:00".
        """
        step: pulumi.Input[_builtins.int]
        """
        Executed every Step day.
        """
elif False:
    AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyDayRepeatArgs:
    def __init__(__self__, *,
                 execute_at_time_of_day: pulumi.Input[_builtins.str],
                 step: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] execute_at_time_of_day: Repeat the specific time when the task is executed, such as "01:02:00".
        :param pulumi.Input[_builtins.int] step: Executed every Step day.
        """
        pulumi.set(__self__, "execute_at_time_of_day", execute_at_time_of_day)
        pulumi.set(__self__, "step", step)

    @_builtins.property
    @pulumi.getter(name="executeAtTimeOfDay")
    def execute_at_time_of_day(self) -> pulumi.Input[_builtins.str]:
        """
        Repeat the specific time when the task is executed, such as "01:02:00".
        """
        return pulumi.get(self, "execute_at_time_of_day")

    @execute_at_time_of_day.setter
    def execute_at_time_of_day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execute_at_time_of_day", value)

    @_builtins.property
    @pulumi.getter
    def step(self) -> pulumi.Input[_builtins.int]:
        """
        Executed every Step day.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "step", value)


if not MYPY:
    class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgsDict(TypedDict):
        days_of_month_ranges: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        The description of the day period in each month, the length can only be 2, for example, [2,10] means the 2-10th of each month.
        """
        execute_at_time_of_day: pulumi.Input[_builtins.str]
        """
        Repeat the specific time when the task is executed, such as "01:02:00".
        """
elif False:
    AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyMonthRepeatArgs:
    def __init__(__self__, *,
                 days_of_month_ranges: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 execute_at_time_of_day: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days_of_month_ranges: The description of the day period in each month, the length can only be 2, for example, [2,10] means the 2-10th of each month.
        :param pulumi.Input[_builtins.str] execute_at_time_of_day: Repeat the specific time when the task is executed, such as "01:02:00".
        """
        pulumi.set(__self__, "days_of_month_ranges", days_of_month_ranges)
        pulumi.set(__self__, "execute_at_time_of_day", execute_at_time_of_day)

    @_builtins.property
    @pulumi.getter(name="daysOfMonthRanges")
    def days_of_month_ranges(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        The description of the day period in each month, the length can only be 2, for example, [2,10] means the 2-10th of each month.
        """
        return pulumi.get(self, "days_of_month_ranges")

    @days_of_month_ranges.setter
    def days_of_month_ranges(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "days_of_month_ranges", value)

    @_builtins.property
    @pulumi.getter(name="executeAtTimeOfDay")
    def execute_at_time_of_day(self) -> pulumi.Input[_builtins.str]:
        """
        Repeat the specific time when the task is executed, such as "01:02:00".
        """
        return pulumi.get(self, "execute_at_time_of_day")

    @execute_at_time_of_day.setter
    def execute_at_time_of_day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execute_at_time_of_day", value)


if not MYPY:
    class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgsDict(TypedDict):
        execute_at: pulumi.Input[_builtins.str]
        """
        The specific and complete time of the task execution, the format is "2020-07-13 00:00:00".
        """
elif False:
    AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyNotRepeatArgs:
    def __init__(__self__, *,
                 execute_at: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] execute_at: The specific and complete time of the task execution, the format is "2020-07-13 00:00:00".
        """
        pulumi.set(__self__, "execute_at", execute_at)

    @_builtins.property
    @pulumi.getter(name="executeAt")
    def execute_at(self) -> pulumi.Input[_builtins.str]:
        """
        The specific and complete time of the task execution, the format is "2020-07-13 00:00:00".
        """
        return pulumi.get(self, "execute_at")

    @execute_at.setter
    def execute_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execute_at", value)


if not MYPY:
    class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgsDict(TypedDict):
        days_of_weeks: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        The numerical description of the days of the week, for example, [1,3,4] means Monday, Wednesday, and Thursday every week.
        """
        execute_at_time_of_day: pulumi.Input[_builtins.str]
        """
        Repeat the specific time when the task is executed, such as "01:02:00".
        """
elif False:
    AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategyWeekRepeatArgs:
    def __init__(__self__, *,
                 days_of_weeks: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 execute_at_time_of_day: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days_of_weeks: The numerical description of the days of the week, for example, [1,3,4] means Monday, Wednesday, and Thursday every week.
        :param pulumi.Input[_builtins.str] execute_at_time_of_day: Repeat the specific time when the task is executed, such as "01:02:00".
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "execute_at_time_of_day", execute_at_time_of_day)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        The numerical description of the days of the week, for example, [1,3,4] means Monday, Wednesday, and Thursday every week.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "days_of_weeks", value)

    @_builtins.property
    @pulumi.getter(name="executeAtTimeOfDay")
    def execute_at_time_of_day(self) -> pulumi.Input[_builtins.str]:
        """
        Repeat the specific time when the task is executed, such as "01:02:00".
        """
        return pulumi.get(self, "execute_at_time_of_day")

    @execute_at_time_of_day.setter
    def execute_at_time_of_day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execute_at_time_of_day", value)


if not MYPY:
    class AutoScaleStrategyTimeAutoScaleStrategyTagArgsDict(TypedDict):
        tag_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        tag key.
        """
        tag_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        tag value.
        """
elif False:
    AutoScaleStrategyTimeAutoScaleStrategyTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoScaleStrategyTimeAutoScaleStrategyTagArgs:
    def __init__(__self__, *,
                 tag_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tag_key: tag key.
        :param pulumi.Input[_builtins.str] tag_value: tag value.
        """
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        tag key.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_key", value)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        tag value.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class ClusterMultiZoneSettingArgsDict(TypedDict):
        vpc_settings: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        The private net config of EMR instance.
        """
        placement: NotRequired[pulumi.Input['ClusterMultiZoneSettingPlacementArgsDict']]
        """
        The location of the instance.
        """
        resource_spec: NotRequired[pulumi.Input['ClusterMultiZoneSettingResourceSpecArgsDict']]
        """
        Resource specification of EMR instance.
        """
elif False:
    ClusterMultiZoneSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingArgs:
    def __init__(__self__, *,
                 vpc_settings: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 placement: Optional[pulumi.Input['ClusterMultiZoneSettingPlacementArgs']] = None,
                 resource_spec: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] vpc_settings: The private net config of EMR instance.
        :param pulumi.Input['ClusterMultiZoneSettingPlacementArgs'] placement: The location of the instance.
        :param pulumi.Input['ClusterMultiZoneSettingResourceSpecArgs'] resource_spec: Resource specification of EMR instance.
        """
        pulumi.set(__self__, "vpc_settings", vpc_settings)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if resource_spec is not None:
            pulumi.set(__self__, "resource_spec", resource_spec)

    @_builtins.property
    @pulumi.getter(name="vpcSettings")
    def vpc_settings(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        The private net config of EMR instance.
        """
        return pulumi.get(self, "vpc_settings")

    @vpc_settings.setter
    def vpc_settings(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "vpc_settings", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['ClusterMultiZoneSettingPlacementArgs']]:
        """
        The location of the instance.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['ClusterMultiZoneSettingPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="resourceSpec")
    def resource_spec(self) -> Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecArgs']]:
        """
        Resource specification of EMR instance.
        """
        return pulumi.get(self, "resource_spec")

    @resource_spec.setter
    def resource_spec(self, value: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecArgs']]):
        pulumi.set(self, "resource_spec", value)


if not MYPY:
    class ClusterMultiZoneSettingPlacementArgsDict(TypedDict):
        zone: pulumi.Input[_builtins.str]
        """
        Zone.
        """
elif False:
    ClusterMultiZoneSettingPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingPlacementArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] zone: Zone.
        """
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        Zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecArgsDict(TypedDict):
        common_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of common node.
        """
        common_resource_spec: NotRequired[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgsDict']]
        """
        Resource details.
        """
        core_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of core node.
        """
        core_resource_spec: NotRequired[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgsDict']]
        """
        Resource details.
        """
        master_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of master node.
        """
        master_resource_spec: NotRequired[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgsDict']]
        """
        Resource details.
        """
        task_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of core node.
        """
        task_resource_spec: NotRequired[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgsDict']]
        """
        Resource details.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecArgs:
    def __init__(__self__, *,
                 common_count: Optional[pulumi.Input[_builtins.int]] = None,
                 common_resource_spec: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgs']] = None,
                 core_count: Optional[pulumi.Input[_builtins.int]] = None,
                 core_resource_spec: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgs']] = None,
                 master_count: Optional[pulumi.Input[_builtins.int]] = None,
                 master_resource_spec: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgs']] = None,
                 task_count: Optional[pulumi.Input[_builtins.int]] = None,
                 task_resource_spec: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] common_count: The number of common node.
        :param pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgs'] common_resource_spec: Resource details.
        :param pulumi.Input[_builtins.int] core_count: The number of core node.
        :param pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgs'] core_resource_spec: Resource details.
        :param pulumi.Input[_builtins.int] master_count: The number of master node.
        :param pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgs'] master_resource_spec: Resource details.
        :param pulumi.Input[_builtins.int] task_count: The number of core node.
        :param pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgs'] task_resource_spec: Resource details.
        """
        if common_count is not None:
            pulumi.set(__self__, "common_count", common_count)
        if common_resource_spec is not None:
            pulumi.set(__self__, "common_resource_spec", common_resource_spec)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if core_resource_spec is not None:
            pulumi.set(__self__, "core_resource_spec", core_resource_spec)
        if master_count is not None:
            pulumi.set(__self__, "master_count", master_count)
        if master_resource_spec is not None:
            pulumi.set(__self__, "master_resource_spec", master_resource_spec)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)
        if task_resource_spec is not None:
            pulumi.set(__self__, "task_resource_spec", task_resource_spec)

    @_builtins.property
    @pulumi.getter(name="commonCount")
    def common_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of common node.
        """
        return pulumi.get(self, "common_count")

    @common_count.setter
    def common_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "common_count", value)

    @_builtins.property
    @pulumi.getter(name="commonResourceSpec")
    def common_resource_spec(self) -> Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "common_resource_spec")

    @common_resource_spec.setter
    def common_resource_spec(self, value: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgs']]):
        pulumi.set(self, "common_resource_spec", value)

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of core node.
        """
        return pulumi.get(self, "core_count")

    @core_count.setter
    def core_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "core_count", value)

    @_builtins.property
    @pulumi.getter(name="coreResourceSpec")
    def core_resource_spec(self) -> Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "core_resource_spec")

    @core_resource_spec.setter
    def core_resource_spec(self, value: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgs']]):
        pulumi.set(self, "core_resource_spec", value)

    @_builtins.property
    @pulumi.getter(name="masterCount")
    def master_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of master node.
        """
        return pulumi.get(self, "master_count")

    @master_count.setter
    def master_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "master_count", value)

    @_builtins.property
    @pulumi.getter(name="masterResourceSpec")
    def master_resource_spec(self) -> Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "master_resource_spec")

    @master_resource_spec.setter
    def master_resource_spec(self, value: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgs']]):
        pulumi.set(self, "master_resource_spec", value)

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of core node.
        """
        return pulumi.get(self, "task_count")

    @task_count.setter
    def task_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "task_count", value)

    @_builtins.property
    @pulumi.getter(name="taskResourceSpec")
    def task_resource_spec(self) -> Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "task_resource_spec")

    @task_resource_spec.setter
    def task_resource_spec(self, value: Optional[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgs']]):
        pulumi.set(self, "task_resource_spec", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecCommonResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecCommonResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecCoreResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecCoreResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecMasterResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecMasterResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        disk types. Value range:
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_BASIC: Represents Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecTaskResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: disk types. Value range:
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_BASIC: Represents Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        disk types. Value range:
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_BASIC: Represents Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMultiZoneSettingResourceSpecTaskResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterPlacementInfoArgsDict(TypedDict):
        zone: pulumi.Input[_builtins.str]
        """
        Zone.
        """
        project_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Project id.
        """
elif False:
    ClusterPlacementInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPlacementInfoArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[_builtins.str],
                 project_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] zone: Zone.
        :param pulumi.Input[_builtins.int] project_id: Project id.
        """
        pulumi.set(__self__, "zone", zone)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        Zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Project id.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class ClusterPreExecutedFileSettingArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Execution script parameters.
        """
        cos_file_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Script file name.
        """
        cos_file_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cos address of the script.
        """
        cos_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cos secretId.
        """
        cos_secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cos secretKey.
        """
        remark: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remark.
        """
        run_order: NotRequired[pulumi.Input[_builtins.int]]
        """
        Run order.
        """
        when_run: NotRequired[pulumi.Input[_builtins.str]]
        """
        `resourceAfter` or `clusterAfter`.
        """
elif False:
    ClusterPreExecutedFileSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPreExecutedFileSettingArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 cos_file_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cos_file_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 cos_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cos_secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 remark: Optional[pulumi.Input[_builtins.str]] = None,
                 run_order: Optional[pulumi.Input[_builtins.int]] = None,
                 when_run: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Execution script parameters.
        :param pulumi.Input[_builtins.str] cos_file_name: Script file name.
        :param pulumi.Input[_builtins.str] cos_file_uri: The cos address of the script.
        :param pulumi.Input[_builtins.str] cos_secret_id: Cos secretId.
        :param pulumi.Input[_builtins.str] cos_secret_key: Cos secretKey.
        :param pulumi.Input[_builtins.str] remark: Remark.
        :param pulumi.Input[_builtins.int] run_order: Run order.
        :param pulumi.Input[_builtins.str] when_run: `resourceAfter` or `clusterAfter`.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if cos_file_name is not None:
            pulumi.set(__self__, "cos_file_name", cos_file_name)
        if cos_file_uri is not None:
            pulumi.set(__self__, "cos_file_uri", cos_file_uri)
        if cos_secret_id is not None:
            pulumi.set(__self__, "cos_secret_id", cos_secret_id)
        if cos_secret_key is not None:
            pulumi.set(__self__, "cos_secret_key", cos_secret_key)
        if remark is not None:
            pulumi.set(__self__, "remark", remark)
        if run_order is not None:
            pulumi.set(__self__, "run_order", run_order)
        if when_run is not None:
            pulumi.set(__self__, "when_run", when_run)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Execution script parameters.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="cosFileName")
    def cos_file_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Script file name.
        """
        return pulumi.get(self, "cos_file_name")

    @cos_file_name.setter
    def cos_file_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_file_name", value)

    @_builtins.property
    @pulumi.getter(name="cosFileUri")
    def cos_file_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cos address of the script.
        """
        return pulumi.get(self, "cos_file_uri")

    @cos_file_uri.setter
    def cos_file_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_file_uri", value)

    @_builtins.property
    @pulumi.getter(name="cosSecretId")
    def cos_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cos secretId.
        """
        return pulumi.get(self, "cos_secret_id")

    @cos_secret_id.setter
    def cos_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="cosSecretKey")
    def cos_secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cos secretKey.
        """
        return pulumi.get(self, "cos_secret_key")

    @cos_secret_key.setter
    def cos_secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cos_secret_key", value)

    @_builtins.property
    @pulumi.getter
    def remark(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remark.
        """
        return pulumi.get(self, "remark")

    @remark.setter
    def remark(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remark", value)

    @_builtins.property
    @pulumi.getter(name="runOrder")
    def run_order(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Run order.
        """
        return pulumi.get(self, "run_order")

    @run_order.setter
    def run_order(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_order", value)

    @_builtins.property
    @pulumi.getter(name="whenRun")
    def when_run(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `resourceAfter` or `clusterAfter`.
        """
        return pulumi.get(self, "when_run")

    @when_run.setter
    def when_run(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "when_run", value)


if not MYPY:
    class ClusterResourceSpecArgsDict(TypedDict):
        common_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of common node.
        """
        common_resource_spec: NotRequired[pulumi.Input['ClusterResourceSpecCommonResourceSpecArgsDict']]
        """
        Resource details.
        """
        core_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of core node.
        """
        core_resource_spec: NotRequired[pulumi.Input['ClusterResourceSpecCoreResourceSpecArgsDict']]
        """
        Resource details.
        """
        master_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of master node.
        """
        master_resource_spec: NotRequired[pulumi.Input['ClusterResourceSpecMasterResourceSpecArgsDict']]
        """
        Resource details.
        """
        task_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of core node.
        """
        task_resource_spec: NotRequired[pulumi.Input['ClusterResourceSpecTaskResourceSpecArgsDict']]
        """
        Resource details.
        """
elif False:
    ClusterResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecArgs:
    def __init__(__self__, *,
                 common_count: Optional[pulumi.Input[_builtins.int]] = None,
                 common_resource_spec: Optional[pulumi.Input['ClusterResourceSpecCommonResourceSpecArgs']] = None,
                 core_count: Optional[pulumi.Input[_builtins.int]] = None,
                 core_resource_spec: Optional[pulumi.Input['ClusterResourceSpecCoreResourceSpecArgs']] = None,
                 master_count: Optional[pulumi.Input[_builtins.int]] = None,
                 master_resource_spec: Optional[pulumi.Input['ClusterResourceSpecMasterResourceSpecArgs']] = None,
                 task_count: Optional[pulumi.Input[_builtins.int]] = None,
                 task_resource_spec: Optional[pulumi.Input['ClusterResourceSpecTaskResourceSpecArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] common_count: The number of common node.
        :param pulumi.Input['ClusterResourceSpecCommonResourceSpecArgs'] common_resource_spec: Resource details.
        :param pulumi.Input[_builtins.int] core_count: The number of core node.
        :param pulumi.Input['ClusterResourceSpecCoreResourceSpecArgs'] core_resource_spec: Resource details.
        :param pulumi.Input[_builtins.int] master_count: The number of master node.
        :param pulumi.Input['ClusterResourceSpecMasterResourceSpecArgs'] master_resource_spec: Resource details.
        :param pulumi.Input[_builtins.int] task_count: The number of core node.
        :param pulumi.Input['ClusterResourceSpecTaskResourceSpecArgs'] task_resource_spec: Resource details.
        """
        if common_count is not None:
            pulumi.set(__self__, "common_count", common_count)
        if common_resource_spec is not None:
            pulumi.set(__self__, "common_resource_spec", common_resource_spec)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if core_resource_spec is not None:
            pulumi.set(__self__, "core_resource_spec", core_resource_spec)
        if master_count is not None:
            pulumi.set(__self__, "master_count", master_count)
        if master_resource_spec is not None:
            pulumi.set(__self__, "master_resource_spec", master_resource_spec)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)
        if task_resource_spec is not None:
            pulumi.set(__self__, "task_resource_spec", task_resource_spec)

    @_builtins.property
    @pulumi.getter(name="commonCount")
    def common_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of common node.
        """
        return pulumi.get(self, "common_count")

    @common_count.setter
    def common_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "common_count", value)

    @_builtins.property
    @pulumi.getter(name="commonResourceSpec")
    def common_resource_spec(self) -> Optional[pulumi.Input['ClusterResourceSpecCommonResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "common_resource_spec")

    @common_resource_spec.setter
    def common_resource_spec(self, value: Optional[pulumi.Input['ClusterResourceSpecCommonResourceSpecArgs']]):
        pulumi.set(self, "common_resource_spec", value)

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of core node.
        """
        return pulumi.get(self, "core_count")

    @core_count.setter
    def core_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "core_count", value)

    @_builtins.property
    @pulumi.getter(name="coreResourceSpec")
    def core_resource_spec(self) -> Optional[pulumi.Input['ClusterResourceSpecCoreResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "core_resource_spec")

    @core_resource_spec.setter
    def core_resource_spec(self, value: Optional[pulumi.Input['ClusterResourceSpecCoreResourceSpecArgs']]):
        pulumi.set(self, "core_resource_spec", value)

    @_builtins.property
    @pulumi.getter(name="masterCount")
    def master_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of master node.
        """
        return pulumi.get(self, "master_count")

    @master_count.setter
    def master_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "master_count", value)

    @_builtins.property
    @pulumi.getter(name="masterResourceSpec")
    def master_resource_spec(self) -> Optional[pulumi.Input['ClusterResourceSpecMasterResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "master_resource_spec")

    @master_resource_spec.setter
    def master_resource_spec(self, value: Optional[pulumi.Input['ClusterResourceSpecMasterResourceSpecArgs']]):
        pulumi.set(self, "master_resource_spec", value)

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of core node.
        """
        return pulumi.get(self, "task_count")

    @task_count.setter
    def task_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "task_count", value)

    @_builtins.property
    @pulumi.getter(name="taskResourceSpec")
    def task_resource_spec(self) -> Optional[pulumi.Input['ClusterResourceSpecTaskResourceSpecArgs']]:
        """
        Resource details.
        """
        return pulumi.get(self, "task_resource_spec")

    @task_resource_spec.setter
    def task_resource_spec(self, value: Optional[pulumi.Input['ClusterResourceSpecTaskResourceSpecArgs']]):
        pulumi.set(self, "task_resource_spec", value)


if not MYPY:
    class ClusterResourceSpecCommonResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCommonResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterResourceSpecCommonResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecCommonResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCommonResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCommonResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCommonResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCommonResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterResourceSpecCommonResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterResourceSpecCommonResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecCommonResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterResourceSpecCoreResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCoreResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterResourceSpecCoreResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecCoreResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCoreResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCoreResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCoreResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecCoreResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterResourceSpecCoreResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterResourceSpecCoreResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecCoreResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterResourceSpecMasterResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecMasterResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterResourceSpecMasterResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecMasterResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecMasterResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecMasterResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecMasterResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecMasterResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterResourceSpecMasterResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterResourceSpecMasterResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecMasterResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterResourceSpecTaskResourceSpecArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of CPU cores.
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk capacity.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        disk types. Value range:
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_BASIC: Represents Cloud Block Storage.
        """
        mem_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory size in M.
        """
        multi_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecTaskResourceSpecMultiDiskArgsDict']]]]
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        root_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Root disk capacity.
        """
        spec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node specification description, such as CVM.SA2.
        """
        storage_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
elif False:
    ClusterResourceSpecTaskResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecTaskResourceSpecArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_size: Optional[pulumi.Input[_builtins.int]] = None,
                 multi_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecTaskResourceSpecMultiDiskArgs']]]] = None,
                 root_size: Optional[pulumi.Input[_builtins.int]] = None,
                 spec: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] disk_size: Data disk capacity.
        :param pulumi.Input[_builtins.str] disk_type: disk types. Value range:
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_BASIC: Represents Cloud Block Storage.
        :param pulumi.Input[_builtins.int] mem_size: Memory size in M.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecTaskResourceSpecMultiDiskArgs']]] multi_disks: Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        :param pulumi.Input[_builtins.int] root_size: Root disk capacity.
        :param pulumi.Input[_builtins.str] spec: Node specification description, such as CVM.SA2.
        :param pulumi.Input[_builtins.int] storage_type: Storage type. Value range:
               - 4: Represents cloud SSD;
               - 5: Represents efficient cloud disk;
               - 6: Represents enhanced SSD Cloud Block Storage;
               - 11: Represents throughput Cloud Block Storage;
               - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if mem_size is not None:
            pulumi.set(__self__, "mem_size", mem_size)
        if multi_disks is not None:
            pulumi.set(__self__, "multi_disks", multi_disks)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk capacity.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        disk types. Value range:
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_BASIC: Represents Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory size in M.
        """
        return pulumi.get(self, "mem_size")

    @mem_size.setter
    def mem_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_size", value)

    @_builtins.property
    @pulumi.getter(name="multiDisks")
    def multi_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecTaskResourceSpecMultiDiskArgs']]]]:
        """
        Cloud disk list. When the data disk is a cloud disk, use disk_type and disk_size parameters directly, and use multi_disks for excess parts.
        """
        return pulumi.get(self, "multi_disks")

    @multi_disks.setter
    def multi_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterResourceSpecTaskResourceSpecMultiDiskArgs']]]]):
        pulumi.set(self, "multi_disks", value)

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Root disk capacity.
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "root_size", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node specification description, such as CVM.SA2.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Storage type. Value range:
        - 4: Represents cloud SSD;
        - 5: Represents efficient cloud disk;
        - 6: Represents enhanced SSD Cloud Block Storage;
        - 11: Represents throughput Cloud Block Storage;
        - 12: Represents extremely fast SSD Cloud Block Storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class ClusterResourceSpecTaskResourceSpecMultiDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of cloud disks of this type.
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        volume: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cloud disk size.
        """
elif False:
    ClusterResourceSpecTaskResourceSpecMultiDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourceSpecTaskResourceSpecMultiDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of cloud disks of this type.
        :param pulumi.Input[_builtins.str] disk_type: Cloud disk type
               - CLOUD_SSD: Represents cloud SSD;
               - CLOUD_PREMIUM: Represents efficient cloud disk;
               - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        :param pulumi.Input[_builtins.int] volume: Cloud disk size.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of cloud disks of this type.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud disk type
        - CLOUD_SSD: Represents cloud SSD;
        - CLOUD_PREMIUM: Represents efficient cloud disk;
        - CLOUD_HSSD: Represents enhanced SSD Cloud Block Storage.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cloud disk size.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterTerminateNodeInfoArgsDict(TypedDict):
        cvm_instance_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Destroy resource list.
        """
        node_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value range of destruction node type: `MASTER`, `TASK`, `CORE`, `ROUTER`.
        """
elif False:
    ClusterTerminateNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTerminateNodeInfoArgs:
    def __init__(__self__, *,
                 cvm_instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 node_flag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cvm_instance_ids: Destroy resource list.
        :param pulumi.Input[_builtins.str] node_flag: Value range of destruction node type: `MASTER`, `TASK`, `CORE`, `ROUTER`.
        """
        if cvm_instance_ids is not None:
            pulumi.set(__self__, "cvm_instance_ids", cvm_instance_ids)
        if node_flag is not None:
            pulumi.set(__self__, "node_flag", node_flag)

    @_builtins.property
    @pulumi.getter(name="cvmInstanceIds")
    def cvm_instance_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Destroy resource list.
        """
        return pulumi.get(self, "cvm_instance_ids")

    @cvm_instance_ids.setter
    def cvm_instance_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cvm_instance_ids", value)

    @_builtins.property
    @pulumi.getter(name="nodeFlag")
    def node_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value range of destruction node type: `MASTER`, `TASK`, `CORE`, `ROUTER`.
        """
        return pulumi.get(self, "node_flag")

    @node_flag.setter
    def node_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_flag", value)


if not MYPY:
    class YarnCapacityGlobalConfigArgsDict(TypedDict):
        default_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['YarnCapacityGlobalConfigDefaultSettingArgsDict']]]]
        """
        Advanced settings.
        """
        enable_label: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether label scheduling is turned on.
        """
        label_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        If label scheduling is enabled, the path where label information is stored.
        """
        queue_mapping_override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to overwrite the user-specified queue. True means overwriting.
        """
elif False:
    YarnCapacityGlobalConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YarnCapacityGlobalConfigArgs:
    def __init__(__self__, *,
                 default_settings: Optional[pulumi.Input[Sequence[pulumi.Input['YarnCapacityGlobalConfigDefaultSettingArgs']]]] = None,
                 enable_label: Optional[pulumi.Input[_builtins.bool]] = None,
                 label_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_mapping_override: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['YarnCapacityGlobalConfigDefaultSettingArgs']]] default_settings: Advanced settings.
        :param pulumi.Input[_builtins.bool] enable_label: Whether label scheduling is turned on.
        :param pulumi.Input[_builtins.str] label_dir: If label scheduling is enabled, the path where label information is stored.
        :param pulumi.Input[_builtins.bool] queue_mapping_override: Whether to overwrite the user-specified queue. True means overwriting.
        """
        if default_settings is not None:
            pulumi.set(__self__, "default_settings", default_settings)
        if enable_label is not None:
            pulumi.set(__self__, "enable_label", enable_label)
        if label_dir is not None:
            pulumi.set(__self__, "label_dir", label_dir)
        if queue_mapping_override is not None:
            pulumi.set(__self__, "queue_mapping_override", queue_mapping_override)

    @_builtins.property
    @pulumi.getter(name="defaultSettings")
    def default_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['YarnCapacityGlobalConfigDefaultSettingArgs']]]]:
        """
        Advanced settings.
        """
        return pulumi.get(self, "default_settings")

    @default_settings.setter
    def default_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['YarnCapacityGlobalConfigDefaultSettingArgs']]]]):
        pulumi.set(self, "default_settings", value)

    @_builtins.property
    @pulumi.getter(name="enableLabel")
    def enable_label(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether label scheduling is turned on.
        """
        return pulumi.get(self, "enable_label")

    @enable_label.setter
    def enable_label(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_label", value)

    @_builtins.property
    @pulumi.getter(name="labelDir")
    def label_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If label scheduling is enabled, the path where label information is stored.
        """
        return pulumi.get(self, "label_dir")

    @label_dir.setter
    def label_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label_dir", value)

    @_builtins.property
    @pulumi.getter(name="queueMappingOverride")
    def queue_mapping_override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to overwrite the user-specified queue. True means overwriting.
        """
        return pulumi.get(self, "queue_mapping_override")

    @queue_mapping_override.setter
    def queue_mapping_override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "queue_mapping_override", value)


if not MYPY:
    class YarnCapacityGlobalConfigDefaultSettingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name, as the key for the input parameter.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value corresponding to tame.
        """
        desc: NotRequired[pulumi.Input[_builtins.str]]
        """
        Described.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key, used for display. This configuration corresponds to the configuration item in the configuration file.
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prompt.
        """
elif False:
    YarnCapacityGlobalConfigDefaultSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YarnCapacityGlobalConfigDefaultSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 desc: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name, as the key for the input parameter.
        :param pulumi.Input[_builtins.str] value: Value corresponding to tame.
        :param pulumi.Input[_builtins.str] desc: Described.
        :param pulumi.Input[_builtins.str] key: Key, used for display. This configuration corresponds to the configuration item in the configuration file.
        :param pulumi.Input[_builtins.str] prompt: Prompt.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if desc is not None:
            pulumi.set(__self__, "desc", desc)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name, as the key for the input parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value corresponding to tame.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def desc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Described.
        """
        return pulumi.get(self, "desc")

    @desc.setter
    def desc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "desc", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key, used for display. This configuration corresponds to the configuration item in the configuration file.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prompt.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class YarnFairGlobalConfigArgsDict(TypedDict):
        user_max_apps_default: NotRequired[pulumi.Input[_builtins.int]]
        """
        Corresponding to the page procedural upper limit.
        """
elif False:
    YarnFairGlobalConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YarnFairGlobalConfigArgs:
    def __init__(__self__, *,
                 user_max_apps_default: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] user_max_apps_default: Corresponding to the page procedural upper limit.
        """
        if user_max_apps_default is not None:
            pulumi.set(__self__, "user_max_apps_default", user_max_apps_default)

    @_builtins.property
    @pulumi.getter(name="userMaxAppsDefault")
    def user_max_apps_default(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Corresponding to the page procedural upper limit.
        """
        return pulumi.get(self, "user_max_apps_default")

    @user_max_apps_default.setter
    def user_max_apps_default(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_max_apps_default", value)


if not MYPY:
    class GetAutoScaleRecordsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Key. Note: This field may return null, indicating that no valid value can be obtained.
        """
        value: _builtins.str
        """
        Value. Note: This field may return null, indicating that no valid value can be obtained.
        """
elif False:
    GetAutoScaleRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutoScaleRecordsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Key. Note: This field may return null, indicating that no valid value can be obtained.
        :param _builtins.str value: Value. Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetJobStatusDetailFlowParamArgsDict(TypedDict):
        f_key: _builtins.str
        """
        Process Parameter Key: value range: TraceId: Query by TraceId FlowId: Query by FlowId.
        """
        f_value: _builtins.str
        """
        Parameter Value.
        """
elif False:
    GetJobStatusDetailFlowParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobStatusDetailFlowParamArgs:
    def __init__(__self__, *,
                 f_key: _builtins.str,
                 f_value: _builtins.str):
        """
        :param _builtins.str f_key: Process Parameter Key: value range: TraceId: Query by TraceId FlowId: Query by FlowId.
        :param _builtins.str f_value: Parameter Value.
        """
        pulumi.set(__self__, "f_key", f_key)
        pulumi.set(__self__, "f_value", f_value)

    @_builtins.property
    @pulumi.getter(name="fKey")
    def f_key(self) -> _builtins.str:
        """
        Process Parameter Key: value range: TraceId: Query by TraceId FlowId: Query by FlowId.
        """
        return pulumi.get(self, "f_key")

    @f_key.setter
    def f_key(self, value: _builtins.str):
        pulumi.set(self, "f_key", value)

    @_builtins.property
    @pulumi.getter(name="fValue")
    def f_value(self) -> _builtins.str:
        """
        Parameter Value.
        """
        return pulumi.get(self, "f_value")

    @f_value.setter
    def f_value(self, value: _builtins.str):
        pulumi.set(self, "f_value", value)


if not MYPY:
    class GetServiceNodeInfosSearchFieldArgsDict(TypedDict):
        search_type: _builtins.str
        """
        Types Supported for Search.
        """
        search_value: _builtins.str
        """
        Values Supported for Search.
        """
elif False:
    GetServiceNodeInfosSearchFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceNodeInfosSearchFieldArgs:
    def __init__(__self__, *,
                 search_type: _builtins.str,
                 search_value: _builtins.str):
        """
        :param _builtins.str search_type: Types Supported for Search.
        :param _builtins.str search_value: Values Supported for Search.
        """
        pulumi.set(__self__, "search_type", search_type)
        pulumi.set(__self__, "search_value", search_value)

    @_builtins.property
    @pulumi.getter(name="searchType")
    def search_type(self) -> _builtins.str:
        """
        Types Supported for Search.
        """
        return pulumi.get(self, "search_type")

    @search_type.setter
    def search_type(self, value: _builtins.str):
        pulumi.set(self, "search_type", value)

    @_builtins.property
    @pulumi.getter(name="searchValue")
    def search_value(self) -> _builtins.str:
        """
        Values Supported for Search.
        """
        return pulumi.get(self, "search_value")

    @search_value.setter
    def search_value(self, value: _builtins.str):
        pulumi.set(self, "search_value", value)


