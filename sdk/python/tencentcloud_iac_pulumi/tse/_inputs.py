# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CngwCanaryRuleCanaryRuleArgs',
    'CngwCanaryRuleCanaryRuleArgsDict',
    'CngwCanaryRuleCanaryRuleBalancedServiceListArgs',
    'CngwCanaryRuleCanaryRuleBalancedServiceListArgsDict',
    'CngwCanaryRuleCanaryRuleConditionListArgs',
    'CngwCanaryRuleCanaryRuleConditionListArgsDict',
    'CngwGatewayInstancePortArgs',
    'CngwGatewayInstancePortArgsDict',
    'CngwGatewayInternetConfigArgs',
    'CngwGatewayInternetConfigArgsDict',
    'CngwGatewayNodeConfigArgs',
    'CngwGatewayNodeConfigArgsDict',
    'CngwGatewayVpcConfigArgs',
    'CngwGatewayVpcConfigArgsDict',
    'CngwGroupInternetConfigArgs',
    'CngwGroupInternetConfigArgsDict',
    'CngwGroupNodeConfigArgs',
    'CngwGroupNodeConfigArgsDict',
    'CngwNetworkAccessControlAccessControlArgs',
    'CngwNetworkAccessControlAccessControlArgsDict',
    'CngwRouteHeaderArgs',
    'CngwRouteHeaderArgsDict',
    'CngwRouteRateLimitLimitDetailArgs',
    'CngwRouteRateLimitLimitDetailArgsDict',
    'CngwRouteRateLimitLimitDetailExternalRedisArgs',
    'CngwRouteRateLimitLimitDetailExternalRedisArgsDict',
    'CngwRouteRateLimitLimitDetailQpsThresholdArgs',
    'CngwRouteRateLimitLimitDetailQpsThresholdArgsDict',
    'CngwRouteRateLimitLimitDetailRateLimitResponseArgs',
    'CngwRouteRateLimitLimitDetailRateLimitResponseArgsDict',
    'CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgs',
    'CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgsDict',
    'CngwServiceRateLimitLimitDetailArgs',
    'CngwServiceRateLimitLimitDetailArgsDict',
    'CngwServiceRateLimitLimitDetailExternalRedisArgs',
    'CngwServiceRateLimitLimitDetailExternalRedisArgsDict',
    'CngwServiceRateLimitLimitDetailQpsThresholdArgs',
    'CngwServiceRateLimitLimitDetailQpsThresholdArgsDict',
    'CngwServiceRateLimitLimitDetailRateLimitResponseArgs',
    'CngwServiceRateLimitLimitDetailRateLimitResponseArgsDict',
    'CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgs',
    'CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgsDict',
    'CngwServiceUpstreamInfoArgs',
    'CngwServiceUpstreamInfoArgsDict',
    'CngwServiceUpstreamInfoTargetArgs',
    'CngwServiceUpstreamInfoTargetArgsDict',
    'CngwStrategyConfigArgs',
    'CngwStrategyConfigArgsDict',
    'CngwStrategyConfigBehaviorArgs',
    'CngwStrategyConfigBehaviorArgsDict',
    'CngwStrategyConfigBehaviorScaleDownArgs',
    'CngwStrategyConfigBehaviorScaleDownArgsDict',
    'CngwStrategyConfigBehaviorScaleDownPolicyArgs',
    'CngwStrategyConfigBehaviorScaleDownPolicyArgsDict',
    'CngwStrategyConfigBehaviorScaleUpArgs',
    'CngwStrategyConfigBehaviorScaleUpArgsDict',
    'CngwStrategyConfigBehaviorScaleUpPolicyArgs',
    'CngwStrategyConfigBehaviorScaleUpPolicyArgsDict',
    'CngwStrategyConfigMetricArgs',
    'CngwStrategyConfigMetricArgsDict',
    'CngwStrategyCronConfigArgs',
    'CngwStrategyCronConfigArgsDict',
    'CngwStrategyCronConfigParamArgs',
    'CngwStrategyCronConfigParamArgsDict',
    'InstanceEngineRegionInfoArgs',
    'InstanceEngineRegionInfoArgsDict',
    'InstanceEngineRegionInfoVpcInfoArgs',
    'InstanceEngineRegionInfoVpcInfoArgsDict',
    'GetGatewayCertificatesFilterArgs',
    'GetGatewayCertificatesFilterArgsDict',
    'GetGatewayServicesFilterArgs',
    'GetGatewayServicesFilterArgsDict',
    'GetGatewaysFilterArgs',
    'GetGatewaysFilterArgsDict',
    'GetGroupsFilterArgs',
    'GetGroupsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CngwCanaryRuleCanaryRuleArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        the status of canary rule.
        """
        priority: pulumi.Input[_builtins.int]
        """
        priority. The value ranges from 0 to 100; the larger the value, the higher the priority; the priority cannot be repeated between different rules.
        """
        balanced_service_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleBalancedServiceListArgsDict']]]]
        """
        service weight configuration.
        """
        condition_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleConditionListArgsDict']]]]
        """
        parameter matching condition list.
        """
        service_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        service ID.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        service name.
        """
elif False:
    CngwCanaryRuleCanaryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwCanaryRuleCanaryRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 priority: pulumi.Input[_builtins.int],
                 balanced_service_lists: Optional[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleBalancedServiceListArgs']]]] = None,
                 condition_lists: Optional[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleConditionListArgs']]]] = None,
                 service_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: the status of canary rule.
        :param pulumi.Input[_builtins.int] priority: priority. The value ranges from 0 to 100; the larger the value, the higher the priority; the priority cannot be repeated between different rules.
        :param pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleBalancedServiceListArgs']]] balanced_service_lists: service weight configuration.
        :param pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleConditionListArgs']]] condition_lists: parameter matching condition list.
        :param pulumi.Input[_builtins.str] service_id: service ID.
        :param pulumi.Input[_builtins.str] service_name: service name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "priority", priority)
        if balanced_service_lists is not None:
            pulumi.set(__self__, "balanced_service_lists", balanced_service_lists)
        if condition_lists is not None:
            pulumi.set(__self__, "condition_lists", condition_lists)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        the status of canary rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        priority. The value ranges from 0 to 100; the larger the value, the higher the priority; the priority cannot be repeated between different rules.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="balancedServiceLists")
    def balanced_service_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleBalancedServiceListArgs']]]]:
        """
        service weight configuration.
        """
        return pulumi.get(self, "balanced_service_lists")

    @balanced_service_lists.setter
    def balanced_service_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleBalancedServiceListArgs']]]]):
        pulumi.set(self, "balanced_service_lists", value)

    @_builtins.property
    @pulumi.getter(name="conditionLists")
    def condition_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleConditionListArgs']]]]:
        """
        parameter matching condition list.
        """
        return pulumi.get(self, "condition_lists")

    @condition_lists.setter
    def condition_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwCanaryRuleCanaryRuleConditionListArgs']]]]):
        pulumi.set(self, "condition_lists", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        service ID.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        service name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class CngwCanaryRuleCanaryRuleBalancedServiceListArgsDict(TypedDict):
        percent: NotRequired[pulumi.Input[_builtins.float]]
        """
        percent, 10 is 10%, valid values:0 to 100.
        """
        service_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        service ID, required when used as an input parameter.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        service name, meaningless when used as an input parameter.
        """
        upstream_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        upstream name, meaningless when used as an input parameter.
        """
elif False:
    CngwCanaryRuleCanaryRuleBalancedServiceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwCanaryRuleCanaryRuleBalancedServiceListArgs:
    def __init__(__self__, *,
                 percent: Optional[pulumi.Input[_builtins.float]] = None,
                 service_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] percent: percent, 10 is 10%, valid values:0 to 100.
        :param pulumi.Input[_builtins.str] service_id: service ID, required when used as an input parameter.
        :param pulumi.Input[_builtins.str] service_name: service name, meaningless when used as an input parameter.
        :param pulumi.Input[_builtins.str] upstream_name: upstream name, meaningless when used as an input parameter.
        """
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if upstream_name is not None:
            pulumi.set(__self__, "upstream_name", upstream_name)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        percent, 10 is 10%, valid values:0 to 100.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "percent", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        service ID, required when used as an input parameter.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        service name, meaningless when used as an input parameter.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="upstreamName")
    def upstream_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        upstream name, meaningless when used as an input parameter.
        """
        return pulumi.get(self, "upstream_name")

    @upstream_name.setter
    def upstream_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_name", value)


if not MYPY:
    class CngwCanaryRuleCanaryRuleConditionListArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        type.Reference value:`path`,`method`,`query`,`header`,`cookie`,`body`,`system`.
        """
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        delimiter. valid when operator is in or not in, reference value:`,`, `;`,`\\n`.
        """
        global_config_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        global configuration ID.
        """
        global_config_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        global configuration name.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        parameter name.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        operator.Reference value:`le`,`eq`,`lt`,`ne`,`ge`,`gt`,`regex`,`exists`,`in`,`not in`,`prefix`,`exact`,`regex`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        parameter value.
        """
elif False:
    CngwCanaryRuleCanaryRuleConditionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwCanaryRuleCanaryRuleConditionListArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 global_config_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_config_name: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: type.Reference value:`path`,`method`,`query`,`header`,`cookie`,`body`,`system`.
        :param pulumi.Input[_builtins.str] delimiter: delimiter. valid when operator is in or not in, reference value:`,`, `;`,`\\n`.
        :param pulumi.Input[_builtins.str] global_config_id: global configuration ID.
        :param pulumi.Input[_builtins.str] global_config_name: global configuration name.
        :param pulumi.Input[_builtins.str] key: parameter name.
        :param pulumi.Input[_builtins.str] operator: operator.Reference value:`le`,`eq`,`lt`,`ne`,`ge`,`gt`,`regex`,`exists`,`in`,`not in`,`prefix`,`exact`,`regex`.
        :param pulumi.Input[_builtins.str] value: parameter value.
        """
        pulumi.set(__self__, "type", type)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if global_config_id is not None:
            pulumi.set(__self__, "global_config_id", global_config_id)
        if global_config_name is not None:
            pulumi.set(__self__, "global_config_name", global_config_name)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        type.Reference value:`path`,`method`,`query`,`header`,`cookie`,`body`,`system`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        delimiter. valid when operator is in or not in, reference value:`,`, `;`,`\\n`.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="globalConfigId")
    def global_config_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        global configuration ID.
        """
        return pulumi.get(self, "global_config_id")

    @global_config_id.setter
    def global_config_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_config_id", value)

    @_builtins.property
    @pulumi.getter(name="globalConfigName")
    def global_config_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        global configuration name.
        """
        return pulumi.get(self, "global_config_name")

    @global_config_name.setter
    def global_config_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_config_name", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        parameter name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        operator.Reference value:`le`,`eq`,`lt`,`ne`,`ge`,`gt`,`regex`,`exists`,`in`,`not in`,`prefix`,`exact`,`regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CngwGatewayInstancePortArgsDict(TypedDict):
        http_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Http port range.
        """
        https_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Https port range.
        """
        tcp_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tcp port range.
        """
        udp_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Udp port range.
        """
elif False:
    CngwGatewayInstancePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwGatewayInstancePortArgs:
    def __init__(__self__, *,
                 http_port: Optional[pulumi.Input[_builtins.str]] = None,
                 https_port: Optional[pulumi.Input[_builtins.str]] = None,
                 tcp_port: Optional[pulumi.Input[_builtins.str]] = None,
                 udp_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] http_port: Http port range.
        :param pulumi.Input[_builtins.str] https_port: Https port range.
        :param pulumi.Input[_builtins.str] tcp_port: Tcp port range.
        :param pulumi.Input[_builtins.str] udp_port: Udp port range.
        """
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if tcp_port is not None:
            pulumi.set(__self__, "tcp_port", tcp_port)
        if udp_port is not None:
            pulumi.set(__self__, "udp_port", udp_port)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Http port range.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Https port range.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="tcpPort")
    def tcp_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tcp port range.
        """
        return pulumi.get(self, "tcp_port")

    @tcp_port.setter
    def tcp_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tcp_port", value)

    @_builtins.property
    @pulumi.getter(name="udpPort")
    def udp_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Udp port range.
        """
        return pulumi.get(self, "udp_port")

    @udp_port.setter
    def udp_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "udp_port", value)


if not MYPY:
    class CngwGatewayInternetConfigArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        description of clb.
        """
        internet_address_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        internet type. Reference value: `IPV4`(default value), `IPV6`.
        """
        internet_max_bandwidth_out: NotRequired[pulumi.Input[_builtins.int]]
        """
        public network bandwidth.
        """
        internet_pay_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        trade type of internet. Reference value: `BANDWIDTH`, `TRAFFIC`(default value).
        """
        master_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        primary availability zone.
        """
        multi_zone_flag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether load balancing has multiple availability zones.
        """
        sla_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
        """
        slave_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        alternate availability zone.
        """
elif False:
    CngwGatewayInternetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwGatewayInternetConfigArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_address_version: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_max_bandwidth_out: Optional[pulumi.Input[_builtins.int]] = None,
                 internet_pay_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 master_zone_id: Optional[pulumi.Input[_builtins.str]] = None,
                 multi_zone_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 sla_type: Optional[pulumi.Input[_builtins.str]] = None,
                 slave_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: description of clb.
        :param pulumi.Input[_builtins.str] internet_address_version: internet type. Reference value: `IPV4`(default value), `IPV6`.
        :param pulumi.Input[_builtins.int] internet_max_bandwidth_out: public network bandwidth.
        :param pulumi.Input[_builtins.str] internet_pay_mode: trade type of internet. Reference value: `BANDWIDTH`, `TRAFFIC`(default value).
        :param pulumi.Input[_builtins.str] master_zone_id: primary availability zone.
        :param pulumi.Input[_builtins.bool] multi_zone_flag: Whether load balancing has multiple availability zones.
        :param pulumi.Input[_builtins.str] sla_type: specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
        :param pulumi.Input[_builtins.str] slave_zone_id: alternate availability zone.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if internet_address_version is not None:
            pulumi.set(__self__, "internet_address_version", internet_address_version)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if internet_pay_mode is not None:
            pulumi.set(__self__, "internet_pay_mode", internet_pay_mode)
        if master_zone_id is not None:
            pulumi.set(__self__, "master_zone_id", master_zone_id)
        if multi_zone_flag is not None:
            pulumi.set(__self__, "multi_zone_flag", multi_zone_flag)
        if sla_type is not None:
            pulumi.set(__self__, "sla_type", sla_type)
        if slave_zone_id is not None:
            pulumi.set(__self__, "slave_zone_id", slave_zone_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        description of clb.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="internetAddressVersion")
    def internet_address_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        internet type. Reference value: `IPV4`(default value), `IPV6`.
        """
        return pulumi.get(self, "internet_address_version")

    @internet_address_version.setter
    def internet_address_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "internet_address_version", value)

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        public network bandwidth.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @internet_max_bandwidth_out.setter
    def internet_max_bandwidth_out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "internet_max_bandwidth_out", value)

    @_builtins.property
    @pulumi.getter(name="internetPayMode")
    def internet_pay_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        trade type of internet. Reference value: `BANDWIDTH`, `TRAFFIC`(default value).
        """
        return pulumi.get(self, "internet_pay_mode")

    @internet_pay_mode.setter
    def internet_pay_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "internet_pay_mode", value)

    @_builtins.property
    @pulumi.getter(name="masterZoneId")
    def master_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        primary availability zone.
        """
        return pulumi.get(self, "master_zone_id")

    @master_zone_id.setter
    def master_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_zone_id", value)

    @_builtins.property
    @pulumi.getter(name="multiZoneFlag")
    def multi_zone_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether load balancing has multiple availability zones.
        """
        return pulumi.get(self, "multi_zone_flag")

    @multi_zone_flag.setter
    def multi_zone_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multi_zone_flag", value)

    @_builtins.property
    @pulumi.getter(name="slaType")
    def sla_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
        """
        return pulumi.get(self, "sla_type")

    @sla_type.setter
    def sla_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sla_type", value)

    @_builtins.property
    @pulumi.getter(name="slaveZoneId")
    def slave_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        alternate availability zone.
        """
        return pulumi.get(self, "slave_zone_id")

    @slave_zone_id.setter
    def slave_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slave_zone_id", value)


if not MYPY:
    class CngwGatewayNodeConfigArgsDict(TypedDict):
        number: pulumi.Input[_builtins.int]
        """
        node number, 2-50.
        """
        specification: pulumi.Input[_builtins.str]
        """
        specification, 1c2g|2c4g|4c8g|8c16g.
        """
elif False:
    CngwGatewayNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwGatewayNodeConfigArgs:
    def __init__(__self__, *,
                 number: pulumi.Input[_builtins.int],
                 specification: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] number: node number, 2-50.
        :param pulumi.Input[_builtins.str] specification: specification, 1c2g|2c4g|4c8g|8c16g.
        """
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "specification", specification)

    @_builtins.property
    @pulumi.getter
    def number(self) -> pulumi.Input[_builtins.int]:
        """
        node number, 2-50.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def specification(self) -> pulumi.Input[_builtins.str]:
        """
        specification, 1c2g|2c4g|4c8g|8c16g.
        """
        return pulumi.get(self, "specification")

    @specification.setter
    def specification(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "specification", value)


if not MYPY:
    class CngwGatewayVpcConfigArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        subnet ID. Assign an IP address to the engine in the VPC subnet. Reference value: subnet-ahde9me9.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        VPC ID. Assign an IP address to the engine in the VPC subnet. Reference value: vpc-conz6aix.
        """
elif False:
    CngwGatewayVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwGatewayVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: subnet ID. Assign an IP address to the engine in the VPC subnet. Reference value: subnet-ahde9me9.
        :param pulumi.Input[_builtins.str] vpc_id: VPC ID. Assign an IP address to the engine in the VPC subnet. Reference value: vpc-conz6aix.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        subnet ID. Assign an IP address to the engine in the VPC subnet. Reference value: subnet-ahde9me9.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VPC ID. Assign an IP address to the engine in the VPC subnet. Reference value: vpc-conz6aix.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class CngwGroupInternetConfigArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        description of clb.
        """
        internet_address_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        internet type. Reference value:- IPV4 (default value)- IPV6.
        """
        internet_max_bandwidth_out: NotRequired[pulumi.Input[_builtins.int]]
        """
        public network bandwidth.
        """
        internet_pay_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        trade type of internet. Reference value:- BANDWIDTH- TRAFFIC (default value).
        """
        master_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        primary availability zone.
        """
        multi_zone_flag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether load balancing has multiple availability zones.
        """
        sla_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
        """
        slave_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        alternate availability zone.
        """
elif False:
    CngwGroupInternetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwGroupInternetConfigArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_address_version: Optional[pulumi.Input[_builtins.str]] = None,
                 internet_max_bandwidth_out: Optional[pulumi.Input[_builtins.int]] = None,
                 internet_pay_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 master_zone_id: Optional[pulumi.Input[_builtins.str]] = None,
                 multi_zone_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 sla_type: Optional[pulumi.Input[_builtins.str]] = None,
                 slave_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: description of clb.
        :param pulumi.Input[_builtins.str] internet_address_version: internet type. Reference value:- IPV4 (default value)- IPV6.
        :param pulumi.Input[_builtins.int] internet_max_bandwidth_out: public network bandwidth.
        :param pulumi.Input[_builtins.str] internet_pay_mode: trade type of internet. Reference value:- BANDWIDTH- TRAFFIC (default value).
        :param pulumi.Input[_builtins.str] master_zone_id: primary availability zone.
        :param pulumi.Input[_builtins.bool] multi_zone_flag: Whether load balancing has multiple availability zones.
        :param pulumi.Input[_builtins.str] sla_type: specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
        :param pulumi.Input[_builtins.str] slave_zone_id: alternate availability zone.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if internet_address_version is not None:
            pulumi.set(__self__, "internet_address_version", internet_address_version)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if internet_pay_mode is not None:
            pulumi.set(__self__, "internet_pay_mode", internet_pay_mode)
        if master_zone_id is not None:
            pulumi.set(__self__, "master_zone_id", master_zone_id)
        if multi_zone_flag is not None:
            pulumi.set(__self__, "multi_zone_flag", multi_zone_flag)
        if sla_type is not None:
            pulumi.set(__self__, "sla_type", sla_type)
        if slave_zone_id is not None:
            pulumi.set(__self__, "slave_zone_id", slave_zone_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        description of clb.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="internetAddressVersion")
    def internet_address_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        internet type. Reference value:- IPV4 (default value)- IPV6.
        """
        return pulumi.get(self, "internet_address_version")

    @internet_address_version.setter
    def internet_address_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "internet_address_version", value)

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        public network bandwidth.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @internet_max_bandwidth_out.setter
    def internet_max_bandwidth_out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "internet_max_bandwidth_out", value)

    @_builtins.property
    @pulumi.getter(name="internetPayMode")
    def internet_pay_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        trade type of internet. Reference value:- BANDWIDTH- TRAFFIC (default value).
        """
        return pulumi.get(self, "internet_pay_mode")

    @internet_pay_mode.setter
    def internet_pay_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "internet_pay_mode", value)

    @_builtins.property
    @pulumi.getter(name="masterZoneId")
    def master_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        primary availability zone.
        """
        return pulumi.get(self, "master_zone_id")

    @master_zone_id.setter
    def master_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_zone_id", value)

    @_builtins.property
    @pulumi.getter(name="multiZoneFlag")
    def multi_zone_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether load balancing has multiple availability zones.
        """
        return pulumi.get(self, "multi_zone_flag")

    @multi_zone_flag.setter
    def multi_zone_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multi_zone_flag", value)

    @_builtins.property
    @pulumi.getter(name="slaType")
    def sla_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
        """
        return pulumi.get(self, "sla_type")

    @sla_type.setter
    def sla_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sla_type", value)

    @_builtins.property
    @pulumi.getter(name="slaveZoneId")
    def slave_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        alternate availability zone.
        """
        return pulumi.get(self, "slave_zone_id")

    @slave_zone_id.setter
    def slave_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slave_zone_id", value)


if not MYPY:
    class CngwGroupNodeConfigArgsDict(TypedDict):
        number: pulumi.Input[_builtins.int]
        """
        group node number, 2-50.
        """
        specification: pulumi.Input[_builtins.str]
        """
        group specification, 1c2g|2c4g|4c8g|8c16g.
        """
elif False:
    CngwGroupNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwGroupNodeConfigArgs:
    def __init__(__self__, *,
                 number: pulumi.Input[_builtins.int],
                 specification: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] number: group node number, 2-50.
        :param pulumi.Input[_builtins.str] specification: group specification, 1c2g|2c4g|4c8g|8c16g.
        """
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "specification", specification)

    @_builtins.property
    @pulumi.getter
    def number(self) -> pulumi.Input[_builtins.int]:
        """
        group node number, 2-50.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def specification(self) -> pulumi.Input[_builtins.str]:
        """
        group specification, 1c2g|2c4g|4c8g|8c16g.
        """
        return pulumi.get(self, "specification")

    @specification.setter
    def specification(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "specification", value)


if not MYPY:
    class CngwNetworkAccessControlAccessControlArgsDict(TypedDict):
        cidr_black_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Black list.
        """
        cidr_white_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        White list.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access mode: `Whitelist`, `Blacklist`.
        """
elif False:
    CngwNetworkAccessControlAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwNetworkAccessControlAccessControlArgs:
    def __init__(__self__, *,
                 cidr_black_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 cidr_white_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cidr_black_lists: Black list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cidr_white_lists: White list.
        :param pulumi.Input[_builtins.str] mode: Access mode: `Whitelist`, `Blacklist`.
        """
        if cidr_black_lists is not None:
            pulumi.set(__self__, "cidr_black_lists", cidr_black_lists)
        if cidr_white_lists is not None:
            pulumi.set(__self__, "cidr_white_lists", cidr_white_lists)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="cidrBlackLists")
    def cidr_black_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Black list.
        """
        return pulumi.get(self, "cidr_black_lists")

    @cidr_black_lists.setter
    def cidr_black_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cidr_black_lists", value)

    @_builtins.property
    @pulumi.getter(name="cidrWhiteLists")
    def cidr_white_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        White list.
        """
        return pulumi.get(self, "cidr_white_lists")

    @cidr_white_lists.setter
    def cidr_white_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cidr_white_lists", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access mode: `Whitelist`, `Blacklist`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class CngwRouteHeaderArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        key of header.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        value of header.
        """
elif False:
    CngwRouteHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwRouteHeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: key of header.
        :param pulumi.Input[_builtins.str] value: value of header.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        key of header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        value of header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CngwRouteRateLimitLimitDetailArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        status of service rate limit.
        """
        hide_client_headers: pulumi.Input[_builtins.bool]
        """
        whether to hide the headers of client.
        """
        is_delay: pulumi.Input[_builtins.bool]
        """
        whether to enable request queuing.
        """
        limit_by: pulumi.Input[_builtins.str]
        """
        basis for service rate limit.Reference value:`ip`,`service`,`consumer`,`credential`,`path`,`header`.
        """
        qps_thresholds: pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailQpsThresholdArgsDict']]]
        """
        qps threshold.
        """
        response_type: pulumi.Input[_builtins.str]
        """
        response strategy.Reference value:`url`: forward request according to url,`text`: response configuration,`default`: return directly.
        """
        external_redis: NotRequired[pulumi.Input['CngwRouteRateLimitLimitDetailExternalRedisArgsDict']]
        """
        external redis information, maybe null.
        """
        header: NotRequired[pulumi.Input[_builtins.str]]
        """
        request headers that require rate limit.
        """
        line_up_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        queue time.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        request paths that require rate limit.
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        counter policy.Reference value:`local`,`redis`,`external_redis`.
        """
        rate_limit_response: NotRequired[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseArgsDict']]
        """
        response configuration, the response strategy is text, maybe null.
        """
        rate_limit_response_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        request forwarding address, maybe null.
        """
elif False:
    CngwRouteRateLimitLimitDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwRouteRateLimitLimitDetailArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 hide_client_headers: pulumi.Input[_builtins.bool],
                 is_delay: pulumi.Input[_builtins.bool],
                 limit_by: pulumi.Input[_builtins.str],
                 qps_thresholds: pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailQpsThresholdArgs']]],
                 response_type: pulumi.Input[_builtins.str],
                 external_redis: Optional[pulumi.Input['CngwRouteRateLimitLimitDetailExternalRedisArgs']] = None,
                 header: Optional[pulumi.Input[_builtins.str]] = None,
                 line_up_time: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 rate_limit_response: Optional[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseArgs']] = None,
                 rate_limit_response_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: status of service rate limit.
        :param pulumi.Input[_builtins.bool] hide_client_headers: whether to hide the headers of client.
        :param pulumi.Input[_builtins.bool] is_delay: whether to enable request queuing.
        :param pulumi.Input[_builtins.str] limit_by: basis for service rate limit.Reference value:`ip`,`service`,`consumer`,`credential`,`path`,`header`.
        :param pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailQpsThresholdArgs']]] qps_thresholds: qps threshold.
        :param pulumi.Input[_builtins.str] response_type: response strategy.Reference value:`url`: forward request according to url,`text`: response configuration,`default`: return directly.
        :param pulumi.Input['CngwRouteRateLimitLimitDetailExternalRedisArgs'] external_redis: external redis information, maybe null.
        :param pulumi.Input[_builtins.str] header: request headers that require rate limit.
        :param pulumi.Input[_builtins.int] line_up_time: queue time.
        :param pulumi.Input[_builtins.str] path: request paths that require rate limit.
        :param pulumi.Input[_builtins.str] policy: counter policy.Reference value:`local`,`redis`,`external_redis`.
        :param pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseArgs'] rate_limit_response: response configuration, the response strategy is text, maybe null.
        :param pulumi.Input[_builtins.str] rate_limit_response_url: request forwarding address, maybe null.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "hide_client_headers", hide_client_headers)
        pulumi.set(__self__, "is_delay", is_delay)
        pulumi.set(__self__, "limit_by", limit_by)
        pulumi.set(__self__, "qps_thresholds", qps_thresholds)
        pulumi.set(__self__, "response_type", response_type)
        if external_redis is not None:
            pulumi.set(__self__, "external_redis", external_redis)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if line_up_time is not None:
            pulumi.set(__self__, "line_up_time", line_up_time)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if rate_limit_response is not None:
            pulumi.set(__self__, "rate_limit_response", rate_limit_response)
        if rate_limit_response_url is not None:
            pulumi.set(__self__, "rate_limit_response_url", rate_limit_response_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        status of service rate limit.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="hideClientHeaders")
    def hide_client_headers(self) -> pulumi.Input[_builtins.bool]:
        """
        whether to hide the headers of client.
        """
        return pulumi.get(self, "hide_client_headers")

    @hide_client_headers.setter
    def hide_client_headers(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "hide_client_headers", value)

    @_builtins.property
    @pulumi.getter(name="isDelay")
    def is_delay(self) -> pulumi.Input[_builtins.bool]:
        """
        whether to enable request queuing.
        """
        return pulumi.get(self, "is_delay")

    @is_delay.setter
    def is_delay(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_delay", value)

    @_builtins.property
    @pulumi.getter(name="limitBy")
    def limit_by(self) -> pulumi.Input[_builtins.str]:
        """
        basis for service rate limit.Reference value:`ip`,`service`,`consumer`,`credential`,`path`,`header`.
        """
        return pulumi.get(self, "limit_by")

    @limit_by.setter
    def limit_by(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "limit_by", value)

    @_builtins.property
    @pulumi.getter(name="qpsThresholds")
    def qps_thresholds(self) -> pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailQpsThresholdArgs']]]:
        """
        qps threshold.
        """
        return pulumi.get(self, "qps_thresholds")

    @qps_thresholds.setter
    def qps_thresholds(self, value: pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailQpsThresholdArgs']]]):
        pulumi.set(self, "qps_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="responseType")
    def response_type(self) -> pulumi.Input[_builtins.str]:
        """
        response strategy.Reference value:`url`: forward request according to url,`text`: response configuration,`default`: return directly.
        """
        return pulumi.get(self, "response_type")

    @response_type.setter
    def response_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "response_type", value)

    @_builtins.property
    @pulumi.getter(name="externalRedis")
    def external_redis(self) -> Optional[pulumi.Input['CngwRouteRateLimitLimitDetailExternalRedisArgs']]:
        """
        external redis information, maybe null.
        """
        return pulumi.get(self, "external_redis")

    @external_redis.setter
    def external_redis(self, value: Optional[pulumi.Input['CngwRouteRateLimitLimitDetailExternalRedisArgs']]):
        pulumi.set(self, "external_redis", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        request headers that require rate limit.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter(name="lineUpTime")
    def line_up_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        queue time.
        """
        return pulumi.get(self, "line_up_time")

    @line_up_time.setter
    def line_up_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "line_up_time", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        request paths that require rate limit.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        counter policy.Reference value:`local`,`redis`,`external_redis`.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter(name="rateLimitResponse")
    def rate_limit_response(self) -> Optional[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseArgs']]:
        """
        response configuration, the response strategy is text, maybe null.
        """
        return pulumi.get(self, "rate_limit_response")

    @rate_limit_response.setter
    def rate_limit_response(self, value: Optional[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseArgs']]):
        pulumi.set(self, "rate_limit_response", value)

    @_builtins.property
    @pulumi.getter(name="rateLimitResponseUrl")
    def rate_limit_response_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        request forwarding address, maybe null.
        """
        return pulumi.get(self, "rate_limit_response_url")

    @rate_limit_response_url.setter
    def rate_limit_response_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rate_limit_response_url", value)


if not MYPY:
    class CngwRouteRateLimitLimitDetailExternalRedisArgsDict(TypedDict):
        redis_host: pulumi.Input[_builtins.str]
        """
        redis ip, maybe null.
        """
        redis_password: pulumi.Input[_builtins.str]
        """
        redis password, maybe null.
        """
        redis_port: pulumi.Input[_builtins.int]
        """
        redis port, maybe null.
        """
        redis_timeout: pulumi.Input[_builtins.int]
        """
        redis timeout, unit: `ms`, maybe null.
        """
elif False:
    CngwRouteRateLimitLimitDetailExternalRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwRouteRateLimitLimitDetailExternalRedisArgs:
    def __init__(__self__, *,
                 redis_host: pulumi.Input[_builtins.str],
                 redis_password: pulumi.Input[_builtins.str],
                 redis_port: pulumi.Input[_builtins.int],
                 redis_timeout: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] redis_host: redis ip, maybe null.
        :param pulumi.Input[_builtins.str] redis_password: redis password, maybe null.
        :param pulumi.Input[_builtins.int] redis_port: redis port, maybe null.
        :param pulumi.Input[_builtins.int] redis_timeout: redis timeout, unit: `ms`, maybe null.
        """
        pulumi.set(__self__, "redis_host", redis_host)
        pulumi.set(__self__, "redis_password", redis_password)
        pulumi.set(__self__, "redis_port", redis_port)
        pulumi.set(__self__, "redis_timeout", redis_timeout)

    @_builtins.property
    @pulumi.getter(name="redisHost")
    def redis_host(self) -> pulumi.Input[_builtins.str]:
        """
        redis ip, maybe null.
        """
        return pulumi.get(self, "redis_host")

    @redis_host.setter
    def redis_host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "redis_host", value)

    @_builtins.property
    @pulumi.getter(name="redisPassword")
    def redis_password(self) -> pulumi.Input[_builtins.str]:
        """
        redis password, maybe null.
        """
        return pulumi.get(self, "redis_password")

    @redis_password.setter
    def redis_password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "redis_password", value)

    @_builtins.property
    @pulumi.getter(name="redisPort")
    def redis_port(self) -> pulumi.Input[_builtins.int]:
        """
        redis port, maybe null.
        """
        return pulumi.get(self, "redis_port")

    @redis_port.setter
    def redis_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "redis_port", value)

    @_builtins.property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> pulumi.Input[_builtins.int]:
        """
        redis timeout, unit: `ms`, maybe null.
        """
        return pulumi.get(self, "redis_timeout")

    @redis_timeout.setter
    def redis_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "redis_timeout", value)


if not MYPY:
    class CngwRouteRateLimitLimitDetailQpsThresholdArgsDict(TypedDict):
        max: pulumi.Input[_builtins.int]
        """
        the max threshold.
        """
        unit: pulumi.Input[_builtins.str]
        """
        qps threshold unit.Reference value:`second`,`minute`,`hour`,`day`,`month`,`year`.
        """
elif False:
    CngwRouteRateLimitLimitDetailQpsThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwRouteRateLimitLimitDetailQpsThresholdArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[_builtins.int],
                 unit: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] max: the max threshold.
        :param pulumi.Input[_builtins.str] unit: qps threshold unit.Reference value:`second`,`minute`,`hour`,`day`,`month`,`year`.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def max(self) -> pulumi.Input[_builtins.int]:
        """
        the max threshold.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        """
        qps threshold unit.Reference value:`second`,`minute`,`hour`,`day`,`month`,`year`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class CngwRouteRateLimitLimitDetailRateLimitResponseArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        custom response body, maybe bull.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgsDict']]]]
        """
        headrs.
        """
        http_status: NotRequired[pulumi.Input[_builtins.int]]
        """
        http status code.
        """
elif False:
    CngwRouteRateLimitLimitDetailRateLimitResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwRouteRateLimitLimitDetailRateLimitResponseArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgs']]]] = None,
                 http_status: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] body: custom response body, maybe bull.
        :param pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgs']]] headers: headrs.
        :param pulumi.Input[_builtins.int] http_status: http status code.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        custom response body, maybe bull.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgs']]]]:
        """
        headrs.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        http status code.
        """
        return pulumi.get(self, "http_status")

    @http_status.setter
    def http_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_status", value)


if not MYPY:
    class CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        key of header.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        value of header.
        """
elif False:
    CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwRouteRateLimitLimitDetailRateLimitResponseHeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: key of header.
        :param pulumi.Input[_builtins.str] value: value of header.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        key of header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        value of header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CngwServiceRateLimitLimitDetailArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        status of service rate limit.
        """
        hide_client_headers: pulumi.Input[_builtins.bool]
        """
        whether to hide the headers of client.
        """
        is_delay: pulumi.Input[_builtins.bool]
        """
        whether to enable request queuing.
        """
        limit_by: pulumi.Input[_builtins.str]
        """
        basis for service rate limit.Reference value: `ip`, `service`, `consumer`, `credential`, `path`, `header`.
        """
        qps_thresholds: pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailQpsThresholdArgsDict']]]
        """
        qps threshold.
        """
        response_type: pulumi.Input[_builtins.str]
        """
        response strategy.Reference value: `url`: forward request according to url, `text`: response configuration, `default`: return directly.
        """
        external_redis: NotRequired[pulumi.Input['CngwServiceRateLimitLimitDetailExternalRedisArgsDict']]
        """
        external redis information, maybe null.
        """
        header: NotRequired[pulumi.Input[_builtins.str]]
        """
        request headers that require rate limit.
        """
        line_up_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        queue time.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        request paths that require rate limit.
        """
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        counter policy.Reference value: `local`, `redis`, `external_redis`.
        """
        rate_limit_response: NotRequired[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseArgsDict']]
        """
        response configuration, the response strategy is text, maybe null.
        """
        rate_limit_response_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        request forwarding address, maybe null.
        """
elif False:
    CngwServiceRateLimitLimitDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwServiceRateLimitLimitDetailArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 hide_client_headers: pulumi.Input[_builtins.bool],
                 is_delay: pulumi.Input[_builtins.bool],
                 limit_by: pulumi.Input[_builtins.str],
                 qps_thresholds: pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailQpsThresholdArgs']]],
                 response_type: pulumi.Input[_builtins.str],
                 external_redis: Optional[pulumi.Input['CngwServiceRateLimitLimitDetailExternalRedisArgs']] = None,
                 header: Optional[pulumi.Input[_builtins.str]] = None,
                 line_up_time: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 rate_limit_response: Optional[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseArgs']] = None,
                 rate_limit_response_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: status of service rate limit.
        :param pulumi.Input[_builtins.bool] hide_client_headers: whether to hide the headers of client.
        :param pulumi.Input[_builtins.bool] is_delay: whether to enable request queuing.
        :param pulumi.Input[_builtins.str] limit_by: basis for service rate limit.Reference value: `ip`, `service`, `consumer`, `credential`, `path`, `header`.
        :param pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailQpsThresholdArgs']]] qps_thresholds: qps threshold.
        :param pulumi.Input[_builtins.str] response_type: response strategy.Reference value: `url`: forward request according to url, `text`: response configuration, `default`: return directly.
        :param pulumi.Input['CngwServiceRateLimitLimitDetailExternalRedisArgs'] external_redis: external redis information, maybe null.
        :param pulumi.Input[_builtins.str] header: request headers that require rate limit.
        :param pulumi.Input[_builtins.int] line_up_time: queue time.
        :param pulumi.Input[_builtins.str] path: request paths that require rate limit.
        :param pulumi.Input[_builtins.str] policy: counter policy.Reference value: `local`, `redis`, `external_redis`.
        :param pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseArgs'] rate_limit_response: response configuration, the response strategy is text, maybe null.
        :param pulumi.Input[_builtins.str] rate_limit_response_url: request forwarding address, maybe null.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "hide_client_headers", hide_client_headers)
        pulumi.set(__self__, "is_delay", is_delay)
        pulumi.set(__self__, "limit_by", limit_by)
        pulumi.set(__self__, "qps_thresholds", qps_thresholds)
        pulumi.set(__self__, "response_type", response_type)
        if external_redis is not None:
            pulumi.set(__self__, "external_redis", external_redis)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if line_up_time is not None:
            pulumi.set(__self__, "line_up_time", line_up_time)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if rate_limit_response is not None:
            pulumi.set(__self__, "rate_limit_response", rate_limit_response)
        if rate_limit_response_url is not None:
            pulumi.set(__self__, "rate_limit_response_url", rate_limit_response_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        status of service rate limit.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="hideClientHeaders")
    def hide_client_headers(self) -> pulumi.Input[_builtins.bool]:
        """
        whether to hide the headers of client.
        """
        return pulumi.get(self, "hide_client_headers")

    @hide_client_headers.setter
    def hide_client_headers(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "hide_client_headers", value)

    @_builtins.property
    @pulumi.getter(name="isDelay")
    def is_delay(self) -> pulumi.Input[_builtins.bool]:
        """
        whether to enable request queuing.
        """
        return pulumi.get(self, "is_delay")

    @is_delay.setter
    def is_delay(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_delay", value)

    @_builtins.property
    @pulumi.getter(name="limitBy")
    def limit_by(self) -> pulumi.Input[_builtins.str]:
        """
        basis for service rate limit.Reference value: `ip`, `service`, `consumer`, `credential`, `path`, `header`.
        """
        return pulumi.get(self, "limit_by")

    @limit_by.setter
    def limit_by(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "limit_by", value)

    @_builtins.property
    @pulumi.getter(name="qpsThresholds")
    def qps_thresholds(self) -> pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailQpsThresholdArgs']]]:
        """
        qps threshold.
        """
        return pulumi.get(self, "qps_thresholds")

    @qps_thresholds.setter
    def qps_thresholds(self, value: pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailQpsThresholdArgs']]]):
        pulumi.set(self, "qps_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="responseType")
    def response_type(self) -> pulumi.Input[_builtins.str]:
        """
        response strategy.Reference value: `url`: forward request according to url, `text`: response configuration, `default`: return directly.
        """
        return pulumi.get(self, "response_type")

    @response_type.setter
    def response_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "response_type", value)

    @_builtins.property
    @pulumi.getter(name="externalRedis")
    def external_redis(self) -> Optional[pulumi.Input['CngwServiceRateLimitLimitDetailExternalRedisArgs']]:
        """
        external redis information, maybe null.
        """
        return pulumi.get(self, "external_redis")

    @external_redis.setter
    def external_redis(self, value: Optional[pulumi.Input['CngwServiceRateLimitLimitDetailExternalRedisArgs']]):
        pulumi.set(self, "external_redis", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        request headers that require rate limit.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter(name="lineUpTime")
    def line_up_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        queue time.
        """
        return pulumi.get(self, "line_up_time")

    @line_up_time.setter
    def line_up_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "line_up_time", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        request paths that require rate limit.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        counter policy.Reference value: `local`, `redis`, `external_redis`.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter(name="rateLimitResponse")
    def rate_limit_response(self) -> Optional[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseArgs']]:
        """
        response configuration, the response strategy is text, maybe null.
        """
        return pulumi.get(self, "rate_limit_response")

    @rate_limit_response.setter
    def rate_limit_response(self, value: Optional[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseArgs']]):
        pulumi.set(self, "rate_limit_response", value)

    @_builtins.property
    @pulumi.getter(name="rateLimitResponseUrl")
    def rate_limit_response_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        request forwarding address, maybe null.
        """
        return pulumi.get(self, "rate_limit_response_url")

    @rate_limit_response_url.setter
    def rate_limit_response_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rate_limit_response_url", value)


if not MYPY:
    class CngwServiceRateLimitLimitDetailExternalRedisArgsDict(TypedDict):
        redis_host: pulumi.Input[_builtins.str]
        """
        redis ip, maybe null.
        """
        redis_password: pulumi.Input[_builtins.str]
        """
        redis password, maybe null.
        """
        redis_port: pulumi.Input[_builtins.int]
        """
        redis port, maybe null.
        """
        redis_timeout: pulumi.Input[_builtins.int]
        """
        redis timeout, unit: `ms`, maybe null.
        """
elif False:
    CngwServiceRateLimitLimitDetailExternalRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwServiceRateLimitLimitDetailExternalRedisArgs:
    def __init__(__self__, *,
                 redis_host: pulumi.Input[_builtins.str],
                 redis_password: pulumi.Input[_builtins.str],
                 redis_port: pulumi.Input[_builtins.int],
                 redis_timeout: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] redis_host: redis ip, maybe null.
        :param pulumi.Input[_builtins.str] redis_password: redis password, maybe null.
        :param pulumi.Input[_builtins.int] redis_port: redis port, maybe null.
        :param pulumi.Input[_builtins.int] redis_timeout: redis timeout, unit: `ms`, maybe null.
        """
        pulumi.set(__self__, "redis_host", redis_host)
        pulumi.set(__self__, "redis_password", redis_password)
        pulumi.set(__self__, "redis_port", redis_port)
        pulumi.set(__self__, "redis_timeout", redis_timeout)

    @_builtins.property
    @pulumi.getter(name="redisHost")
    def redis_host(self) -> pulumi.Input[_builtins.str]:
        """
        redis ip, maybe null.
        """
        return pulumi.get(self, "redis_host")

    @redis_host.setter
    def redis_host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "redis_host", value)

    @_builtins.property
    @pulumi.getter(name="redisPassword")
    def redis_password(self) -> pulumi.Input[_builtins.str]:
        """
        redis password, maybe null.
        """
        return pulumi.get(self, "redis_password")

    @redis_password.setter
    def redis_password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "redis_password", value)

    @_builtins.property
    @pulumi.getter(name="redisPort")
    def redis_port(self) -> pulumi.Input[_builtins.int]:
        """
        redis port, maybe null.
        """
        return pulumi.get(self, "redis_port")

    @redis_port.setter
    def redis_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "redis_port", value)

    @_builtins.property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> pulumi.Input[_builtins.int]:
        """
        redis timeout, unit: `ms`, maybe null.
        """
        return pulumi.get(self, "redis_timeout")

    @redis_timeout.setter
    def redis_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "redis_timeout", value)


if not MYPY:
    class CngwServiceRateLimitLimitDetailQpsThresholdArgsDict(TypedDict):
        max: pulumi.Input[_builtins.int]
        """
        the max threshold.
        """
        unit: pulumi.Input[_builtins.str]
        """
        qps threshold unit.Reference value:`second`, `minute`, `hour`, `day`, `month`, `year`.
        """
elif False:
    CngwServiceRateLimitLimitDetailQpsThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwServiceRateLimitLimitDetailQpsThresholdArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[_builtins.int],
                 unit: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] max: the max threshold.
        :param pulumi.Input[_builtins.str] unit: qps threshold unit.Reference value:`second`, `minute`, `hour`, `day`, `month`, `year`.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def max(self) -> pulumi.Input[_builtins.int]:
        """
        the max threshold.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        """
        qps threshold unit.Reference value:`second`, `minute`, `hour`, `day`, `month`, `year`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class CngwServiceRateLimitLimitDetailRateLimitResponseArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        custom response body, maybe bull.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgsDict']]]]
        """
        headrs.
        """
        http_status: NotRequired[pulumi.Input[_builtins.int]]
        """
        http status code.
        """
elif False:
    CngwServiceRateLimitLimitDetailRateLimitResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwServiceRateLimitLimitDetailRateLimitResponseArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgs']]]] = None,
                 http_status: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] body: custom response body, maybe bull.
        :param pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgs']]] headers: headrs.
        :param pulumi.Input[_builtins.int] http_status: http status code.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        custom response body, maybe bull.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgs']]]]:
        """
        headrs.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        http status code.
        """
        return pulumi.get(self, "http_status")

    @http_status.setter
    def http_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_status", value)


if not MYPY:
    class CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        key of header.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        value of header.
        """
elif False:
    CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwServiceRateLimitLimitDetailRateLimitResponseHeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: key of header.
        :param pulumi.Input[_builtins.str] value: value of header.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        key of header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        value of header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CngwServiceUpstreamInfoArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        load balance algorithm,default: `round-robin`, `least-connections` and `consisten_hashing` also support.
        """
        auto_scaling_cvm_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        auto scaling group port of cvm.
        """
        auto_scaling_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        auto scaling group ID of cvm.
        """
        auto_scaling_hook_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        hook status in auto scaling group of cvm.
        """
        auto_scaling_tat_cmd_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        tat cmd status in auto scaling group of cvm.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        an IP address or domain name.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        namespace.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        backend service port.valid values: `1` to `65535`.
        """
        real_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        exact source service type.
        """
        scf_lambda_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        scf lambda name.
        """
        scf_lambda_qualifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        scf lambda version.
        """
        scf_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        scf lambda namespace.
        """
        scf_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        scf lambda type.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        the name of the service in registry or kubernetes.
        """
        slow_start: NotRequired[pulumi.Input[_builtins.int]]
        """
        slow start time, unit: `second`, when it is enabled, weight of the node is increased from 1 to the target value gradually.
        """
        source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        service source ID.
        """
        source_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        the name of source service.
        """
        source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        source service type.
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwServiceUpstreamInfoTargetArgsDict']]]]
        """
        provided when service type is IPList.
        """
elif False:
    CngwServiceUpstreamInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwServiceUpstreamInfoArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 auto_scaling_cvm_port: Optional[pulumi.Input[_builtins.int]] = None,
                 auto_scaling_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 auto_scaling_hook_status: Optional[pulumi.Input[_builtins.str]] = None,
                 auto_scaling_tat_cmd_status: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 real_source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 scf_lambda_name: Optional[pulumi.Input[_builtins.str]] = None,
                 scf_lambda_qualifier: Optional[pulumi.Input[_builtins.str]] = None,
                 scf_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 scf_type: Optional[pulumi.Input[_builtins.str]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 slow_start: Optional[pulumi.Input[_builtins.int]] = None,
                 source_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_name: Optional[pulumi.Input[_builtins.str]] = None,
                 source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input['CngwServiceUpstreamInfoTargetArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] algorithm: load balance algorithm,default: `round-robin`, `least-connections` and `consisten_hashing` also support.
        :param pulumi.Input[_builtins.int] auto_scaling_cvm_port: auto scaling group port of cvm.
        :param pulumi.Input[_builtins.str] auto_scaling_group_id: auto scaling group ID of cvm.
        :param pulumi.Input[_builtins.str] auto_scaling_hook_status: hook status in auto scaling group of cvm.
        :param pulumi.Input[_builtins.str] auto_scaling_tat_cmd_status: tat cmd status in auto scaling group of cvm.
        :param pulumi.Input[_builtins.str] host: an IP address or domain name.
        :param pulumi.Input[_builtins.str] namespace: namespace.
        :param pulumi.Input[_builtins.int] port: backend service port.valid values: `1` to `65535`.
        :param pulumi.Input[_builtins.str] real_source_type: exact source service type.
        :param pulumi.Input[_builtins.str] scf_lambda_name: scf lambda name.
        :param pulumi.Input[_builtins.str] scf_lambda_qualifier: scf lambda version.
        :param pulumi.Input[_builtins.str] scf_namespace: scf lambda namespace.
        :param pulumi.Input[_builtins.str] scf_type: scf lambda type.
        :param pulumi.Input[_builtins.str] service_name: the name of the service in registry or kubernetes.
        :param pulumi.Input[_builtins.int] slow_start: slow start time, unit: `second`, when it is enabled, weight of the node is increased from 1 to the target value gradually.
        :param pulumi.Input[_builtins.str] source_id: service source ID.
        :param pulumi.Input[_builtins.str] source_name: the name of source service.
        :param pulumi.Input[_builtins.str] source_type: source service type.
        :param pulumi.Input[Sequence[pulumi.Input['CngwServiceUpstreamInfoTargetArgs']]] targets: provided when service type is IPList.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if auto_scaling_cvm_port is not None:
            pulumi.set(__self__, "auto_scaling_cvm_port", auto_scaling_cvm_port)
        if auto_scaling_group_id is not None:
            pulumi.set(__self__, "auto_scaling_group_id", auto_scaling_group_id)
        if auto_scaling_hook_status is not None:
            pulumi.set(__self__, "auto_scaling_hook_status", auto_scaling_hook_status)
        if auto_scaling_tat_cmd_status is not None:
            pulumi.set(__self__, "auto_scaling_tat_cmd_status", auto_scaling_tat_cmd_status)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if real_source_type is not None:
            pulumi.set(__self__, "real_source_type", real_source_type)
        if scf_lambda_name is not None:
            pulumi.set(__self__, "scf_lambda_name", scf_lambda_name)
        if scf_lambda_qualifier is not None:
            pulumi.set(__self__, "scf_lambda_qualifier", scf_lambda_qualifier)
        if scf_namespace is not None:
            pulumi.set(__self__, "scf_namespace", scf_namespace)
        if scf_type is not None:
            pulumi.set(__self__, "scf_type", scf_type)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if slow_start is not None:
            pulumi.set(__self__, "slow_start", slow_start)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        load balance algorithm,default: `round-robin`, `least-connections` and `consisten_hashing` also support.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="autoScalingCvmPort")
    def auto_scaling_cvm_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        auto scaling group port of cvm.
        """
        return pulumi.get(self, "auto_scaling_cvm_port")

    @auto_scaling_cvm_port.setter
    def auto_scaling_cvm_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auto_scaling_cvm_port", value)

    @_builtins.property
    @pulumi.getter(name="autoScalingGroupId")
    def auto_scaling_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        auto scaling group ID of cvm.
        """
        return pulumi.get(self, "auto_scaling_group_id")

    @auto_scaling_group_id.setter
    def auto_scaling_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_scaling_group_id", value)

    @_builtins.property
    @pulumi.getter(name="autoScalingHookStatus")
    def auto_scaling_hook_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hook status in auto scaling group of cvm.
        """
        return pulumi.get(self, "auto_scaling_hook_status")

    @auto_scaling_hook_status.setter
    def auto_scaling_hook_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_scaling_hook_status", value)

    @_builtins.property
    @pulumi.getter(name="autoScalingTatCmdStatus")
    def auto_scaling_tat_cmd_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        tat cmd status in auto scaling group of cvm.
        """
        return pulumi.get(self, "auto_scaling_tat_cmd_status")

    @auto_scaling_tat_cmd_status.setter
    def auto_scaling_tat_cmd_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_scaling_tat_cmd_status", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        an IP address or domain name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        backend service port.valid values: `1` to `65535`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="realSourceType")
    def real_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        exact source service type.
        """
        return pulumi.get(self, "real_source_type")

    @real_source_type.setter
    def real_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "real_source_type", value)

    @_builtins.property
    @pulumi.getter(name="scfLambdaName")
    def scf_lambda_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        scf lambda name.
        """
        return pulumi.get(self, "scf_lambda_name")

    @scf_lambda_name.setter
    def scf_lambda_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scf_lambda_name", value)

    @_builtins.property
    @pulumi.getter(name="scfLambdaQualifier")
    def scf_lambda_qualifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        scf lambda version.
        """
        return pulumi.get(self, "scf_lambda_qualifier")

    @scf_lambda_qualifier.setter
    def scf_lambda_qualifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scf_lambda_qualifier", value)

    @_builtins.property
    @pulumi.getter(name="scfNamespace")
    def scf_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        scf lambda namespace.
        """
        return pulumi.get(self, "scf_namespace")

    @scf_namespace.setter
    def scf_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scf_namespace", value)

    @_builtins.property
    @pulumi.getter(name="scfType")
    def scf_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        scf lambda type.
        """
        return pulumi.get(self, "scf_type")

    @scf_type.setter
    def scf_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scf_type", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the name of the service in registry or kubernetes.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="slowStart")
    def slow_start(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        slow start time, unit: `second`, when it is enabled, weight of the node is increased from 1 to the target value gradually.
        """
        return pulumi.get(self, "slow_start")

    @slow_start.setter
    def slow_start(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "slow_start", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        service source ID.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the name of source service.
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_name", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        source service type.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwServiceUpstreamInfoTargetArgs']]]]:
        """
        provided when service type is IPList.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwServiceUpstreamInfoTargetArgs']]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class CngwServiceUpstreamInfoTargetArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        host.
        """
        port: pulumi.Input[_builtins.int]
        """
        port.
        """
        weight: pulumi.Input[_builtins.int]
        """
        weight.
        """
        created_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        created time.
        """
        health: NotRequired[pulumi.Input[_builtins.str]]
        """
        health.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        source of target.
        """
elif False:
    CngwServiceUpstreamInfoTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwServiceUpstreamInfoTargetArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 weight: pulumi.Input[_builtins.int],
                 created_time: Optional[pulumi.Input[_builtins.str]] = None,
                 health: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: host.
        :param pulumi.Input[_builtins.int] port: port.
        :param pulumi.Input[_builtins.int] weight: weight.
        :param pulumi.Input[_builtins.str] created_time: created time.
        :param pulumi.Input[_builtins.str] health: health.
        :param pulumi.Input[_builtins.str] source: source of target.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        created time.
        """
        return pulumi.get(self, "created_time")

    @created_time.setter
    def created_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_time", value)

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        health.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        source of target.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class CngwStrategyConfigArgsDict(TypedDict):
        behavior: NotRequired[pulumi.Input['CngwStrategyConfigBehaviorArgsDict']]
        """
        behavior configuration of metric
        Note: This field may return null, indicating that a valid value is not available.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        create time
        Note: This field may return null, indicating that a valid value is not available.
        """
        max_replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        max number of replica for metric scaling.
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigMetricArgsDict']]]]
        """
        metric list.
        """
        modify_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        modify time
        Note: This field may return null, indicating that a valid value is not available.
        """
        strategy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        strategy ID
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyConfigArgs:
    def __init__(__self__, *,
                 behavior: Optional[pulumi.Input['CngwStrategyConfigBehaviorArgs']] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 max_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigMetricArgs']]]] = None,
                 modify_time: Optional[pulumi.Input[_builtins.str]] = None,
                 strategy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CngwStrategyConfigBehaviorArgs'] behavior: behavior configuration of metric
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] create_time: create time
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.int] max_replicas: max number of replica for metric scaling.
        :param pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigMetricArgs']]] metrics: metric list.
        :param pulumi.Input[_builtins.str] modify_time: modify time
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] strategy_id: strategy ID
               Note: This field may return null, indicating that a valid value is not available.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[pulumi.Input['CngwStrategyConfigBehaviorArgs']]:
        """
        behavior configuration of metric
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Optional[pulumi.Input['CngwStrategyConfigBehaviorArgs']]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        create time
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        max number of replica for metric scaling.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_replicas", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigMetricArgs']]]]:
        """
        metric list.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigMetricArgs']]]]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        modify time
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "modify_time")

    @modify_time.setter
    def modify_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modify_time", value)

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        strategy ID
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "strategy_id")

    @strategy_id.setter
    def strategy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strategy_id", value)


if not MYPY:
    class CngwStrategyConfigBehaviorArgsDict(TypedDict):
        scale_down: NotRequired[pulumi.Input['CngwStrategyConfigBehaviorScaleDownArgsDict']]
        """
        configuration of down scale
        Note: This field may return null, indicating that a valid value is not available.
        """
        scale_up: NotRequired[pulumi.Input['CngwStrategyConfigBehaviorScaleUpArgsDict']]
        """
        configuration of up scale
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyConfigBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyConfigBehaviorArgs:
    def __init__(__self__, *,
                 scale_down: Optional[pulumi.Input['CngwStrategyConfigBehaviorScaleDownArgs']] = None,
                 scale_up: Optional[pulumi.Input['CngwStrategyConfigBehaviorScaleUpArgs']] = None):
        """
        :param pulumi.Input['CngwStrategyConfigBehaviorScaleDownArgs'] scale_down: configuration of down scale
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input['CngwStrategyConfigBehaviorScaleUpArgs'] scale_up: configuration of up scale
               Note: This field may return null, indicating that a valid value is not available.
        """
        if scale_down is not None:
            pulumi.set(__self__, "scale_down", scale_down)
        if scale_up is not None:
            pulumi.set(__self__, "scale_up", scale_up)

    @_builtins.property
    @pulumi.getter(name="scaleDown")
    def scale_down(self) -> Optional[pulumi.Input['CngwStrategyConfigBehaviorScaleDownArgs']]:
        """
        configuration of down scale
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "scale_down")

    @scale_down.setter
    def scale_down(self, value: Optional[pulumi.Input['CngwStrategyConfigBehaviorScaleDownArgs']]):
        pulumi.set(self, "scale_down", value)

    @_builtins.property
    @pulumi.getter(name="scaleUp")
    def scale_up(self) -> Optional[pulumi.Input['CngwStrategyConfigBehaviorScaleUpArgs']]:
        """
        configuration of up scale
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "scale_up")

    @scale_up.setter
    def scale_up(self, value: Optional[pulumi.Input['CngwStrategyConfigBehaviorScaleUpArgs']]):
        pulumi.set(self, "scale_up", value)


if not MYPY:
    class CngwStrategyConfigBehaviorScaleDownArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleDownPolicyArgsDict']]]]
        """
        policies of scale down
        Note: This field may return null, indicating that a valid value is not available.
        """
        select_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        type of policy, default value: max
        Note: This field may return null, indicating that a valid value is not available.
        """
        stabilization_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        stability window time, unit:second, default 300 when scale down
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyConfigBehaviorScaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyConfigBehaviorScaleDownArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleDownPolicyArgs']]]] = None,
                 select_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleDownPolicyArgs']]] policies: policies of scale down
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] select_policy: type of policy, default value: max
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.int] stabilization_window_seconds: stability window time, unit:second, default 300 when scale down
               Note: This field may return null, indicating that a valid value is not available.
        """
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if select_policy is not None:
            pulumi.set(__self__, "select_policy", select_policy)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleDownPolicyArgs']]]]:
        """
        policies of scale down
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleDownPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="selectPolicy")
    def select_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        type of policy, default value: max
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "select_policy")

    @select_policy.setter
    def select_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "select_policy", value)

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        stability window time, unit:second, default 300 when scale down
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stabilization_window_seconds", value)


if not MYPY:
    class CngwStrategyConfigBehaviorScaleDownPolicyArgsDict(TypedDict):
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        period of scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        type, default value: Pods
        Note: This field may return null, indicating that a valid value is not available.
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        value
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyConfigBehaviorScaleDownPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyConfigBehaviorScaleDownPolicyArgs:
    def __init__(__self__, *,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] period_seconds: period of scale up
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] type: type, default value: Pods
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.int] value: value
               Note: This field may return null, indicating that a valid value is not available.
        """
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        period of scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        type, default value: Pods
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        value
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CngwStrategyConfigBehaviorScaleUpArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleUpPolicyArgsDict']]]]
        """
        policies of scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
        select_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        type of policy, default value: max
        Note: This field may return null, indicating that a valid value is not available.
        """
        stabilization_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        stability window time, unit:second, default 0 when scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyConfigBehaviorScaleUpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyConfigBehaviorScaleUpArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleUpPolicyArgs']]]] = None,
                 select_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleUpPolicyArgs']]] policies: policies of scale up
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] select_policy: type of policy, default value: max
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.int] stabilization_window_seconds: stability window time, unit:second, default 0 when scale up
               Note: This field may return null, indicating that a valid value is not available.
        """
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if select_policy is not None:
            pulumi.set(__self__, "select_policy", select_policy)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleUpPolicyArgs']]]]:
        """
        policies of scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyConfigBehaviorScaleUpPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="selectPolicy")
    def select_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        type of policy, default value: max
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "select_policy")

    @select_policy.setter
    def select_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "select_policy", value)

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        stability window time, unit:second, default 0 when scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stabilization_window_seconds", value)


if not MYPY:
    class CngwStrategyConfigBehaviorScaleUpPolicyArgsDict(TypedDict):
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        period of scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        type, default value: Pods
        Note: This field may return null, indicating that a valid value is not available.
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        value
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyConfigBehaviorScaleUpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyConfigBehaviorScaleUpPolicyArgs:
    def __init__(__self__, *,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] period_seconds: period of scale up
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] type: type, default value: Pods
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.int] value: value
               Note: This field may return null, indicating that a valid value is not available.
        """
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        period of scale up
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        type, default value: Pods
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        value
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CngwStrategyConfigMetricArgsDict(TypedDict):
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        metric name. Reference value:
        - cpu
        - memory
        Note: This field may return null, indicating that a valid value is not available.
        """
        target_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        target type of metric, currently only supports `Utilization`
        Note: This field may return null, indicating that a valid value is not available.
        """
        target_value: NotRequired[pulumi.Input[_builtins.int]]
        """
        target value of metric
        Note: This field may return null, indicating that a valid value is not available.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        metric type. Deafault value
        - Resource.
        """
elif False:
    CngwStrategyConfigMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyConfigMetricArgs:
    def __init__(__self__, *,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_type: Optional[pulumi.Input[_builtins.str]] = None,
                 target_value: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_name: metric name. Reference value:
               - cpu
               - memory
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] target_type: target type of metric, currently only supports `Utilization`
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.int] target_value: target value of metric
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] type: metric type. Deafault value
               - Resource.
        """
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)
        if target_value is not None:
            pulumi.set(__self__, "target_value", target_value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        metric name. Reference value:
        - cpu
        - memory
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        target type of metric, currently only supports `Utilization`
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_type", value)

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        target value of metric
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "target_value")

    @target_value.setter
    def target_value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        metric type. Deafault value
        - Resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CngwStrategyCronConfigArgsDict(TypedDict):
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['CngwStrategyCronConfigParamArgsDict']]]]
        """
        parameter list of timed scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
        strategy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        strategy ID
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyCronConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyCronConfigArgs:
    def __init__(__self__, *,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyCronConfigParamArgs']]]] = None,
                 strategy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CngwStrategyCronConfigParamArgs']]] params: parameter list of timed scaling
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] strategy_id: strategy ID
               Note: This field may return null, indicating that a valid value is not available.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyCronConfigParamArgs']]]]:
        """
        parameter list of timed scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CngwStrategyCronConfigParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        strategy ID
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "strategy_id")

    @strategy_id.setter
    def strategy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strategy_id", value)


if not MYPY:
    class CngwStrategyCronConfigParamArgsDict(TypedDict):
        crontab: NotRequired[pulumi.Input[_builtins.str]]
        """
        cron expression of timed scaling, no input required
        Note: This field may return null, indicating that a valid value is not available.
        """
        period: NotRequired[pulumi.Input[_builtins.str]]
        """
        period of timed scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
        start_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        start time of timed scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
        target_replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        the number of target nodes for the timed scaling. Do not exceed the max number of replica for metric scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
elif False:
    CngwStrategyCronConfigParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CngwStrategyCronConfigParamArgs:
    def __init__(__self__, *,
                 crontab: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.str]] = None,
                 start_at: Optional[pulumi.Input[_builtins.str]] = None,
                 target_replicas: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] crontab: cron expression of timed scaling, no input required
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] period: period of timed scaling
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.str] start_at: start time of timed scaling
               Note: This field may return null, indicating that a valid value is not available.
        :param pulumi.Input[_builtins.int] target_replicas: the number of target nodes for the timed scaling. Do not exceed the max number of replica for metric scaling
               Note: This field may return null, indicating that a valid value is not available.
        """
        if crontab is not None:
            pulumi.set(__self__, "crontab", crontab)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if start_at is not None:
            pulumi.set(__self__, "start_at", start_at)
        if target_replicas is not None:
            pulumi.set(__self__, "target_replicas", target_replicas)

    @_builtins.property
    @pulumi.getter
    def crontab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        cron expression of timed scaling, no input required
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "crontab")

    @crontab.setter
    def crontab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crontab", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        period of timed scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        start time of timed scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "start_at")

    @start_at.setter
    def start_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_at", value)

    @_builtins.property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        the number of target nodes for the timed scaling. Do not exceed the max number of replica for metric scaling
        Note: This field may return null, indicating that a valid value is not available.
        """
        return pulumi.get(self, "target_replicas")

    @target_replicas.setter
    def target_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_replicas", value)


if not MYPY:
    class InstanceEngineRegionInfoArgsDict(TypedDict):
        engine_region: pulumi.Input[_builtins.str]
        """
        Engine node region.
        """
        replica: pulumi.Input[_builtins.int]
        """
        The number of nodes allocated in this region.
        """
        vpc_infos: pulumi.Input[Sequence[pulumi.Input['InstanceEngineRegionInfoVpcInfoArgsDict']]]
        """
        Cluster network information.
        """
elif False:
    InstanceEngineRegionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEngineRegionInfoArgs:
    def __init__(__self__, *,
                 engine_region: pulumi.Input[_builtins.str],
                 replica: pulumi.Input[_builtins.int],
                 vpc_infos: pulumi.Input[Sequence[pulumi.Input['InstanceEngineRegionInfoVpcInfoArgs']]]):
        """
        :param pulumi.Input[_builtins.str] engine_region: Engine node region.
        :param pulumi.Input[_builtins.int] replica: The number of nodes allocated in this region.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceEngineRegionInfoVpcInfoArgs']]] vpc_infos: Cluster network information.
        """
        pulumi.set(__self__, "engine_region", engine_region)
        pulumi.set(__self__, "replica", replica)
        pulumi.set(__self__, "vpc_infos", vpc_infos)

    @_builtins.property
    @pulumi.getter(name="engineRegion")
    def engine_region(self) -> pulumi.Input[_builtins.str]:
        """
        Engine node region.
        """
        return pulumi.get(self, "engine_region")

    @engine_region.setter
    def engine_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "engine_region", value)

    @_builtins.property
    @pulumi.getter
    def replica(self) -> pulumi.Input[_builtins.int]:
        """
        The number of nodes allocated in this region.
        """
        return pulumi.get(self, "replica")

    @replica.setter
    def replica(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "replica", value)

    @_builtins.property
    @pulumi.getter(name="vpcInfos")
    def vpc_infos(self) -> pulumi.Input[Sequence[pulumi.Input['InstanceEngineRegionInfoVpcInfoArgs']]]:
        """
        Cluster network information.
        """
        return pulumi.get(self, "vpc_infos")

    @vpc_infos.setter
    def vpc_infos(self, value: pulumi.Input[Sequence[pulumi.Input['InstanceEngineRegionInfoVpcInfoArgs']]]):
        pulumi.set(self, "vpc_infos", value)


if not MYPY:
    class InstanceEngineRegionInfoVpcInfoArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        Subnet ID.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        Vpc Id.
        """
        intranet_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Intranet access addressNote: This field may return null, indicating that a valid value is not available..
        """
elif False:
    InstanceEngineRegionInfoVpcInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEngineRegionInfoVpcInfoArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 intranet_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Subnet ID.
        :param pulumi.Input[_builtins.str] vpc_id: Vpc Id.
        :param pulumi.Input[_builtins.str] intranet_address: Intranet access addressNote: This field may return null, indicating that a valid value is not available..
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if intranet_address is not None:
            pulumi.set(__self__, "intranet_address", intranet_address)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        Vpc Id.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="intranetAddress")
    def intranet_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Intranet access addressNote: This field may return null, indicating that a valid value is not available..
        """
        return pulumi.get(self, "intranet_address")

    @intranet_address.setter
    def intranet_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intranet_address", value)


if not MYPY:
    class GetGatewayCertificatesFilterArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        """
        Filter name.
        """
        value: NotRequired[_builtins.str]
        """
        Filter value.
        """
elif False:
    GetGatewayCertificatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGatewayCertificatesFilterArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter name.
        :param _builtins.str value: Filter value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Filter name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetGatewayServicesFilterArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        """
        filter name.
        """
        value: NotRequired[_builtins.str]
        """
        filter value.
        """
elif False:
    GetGatewayServicesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGatewayServicesFilterArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: filter name.
        :param _builtins.str value: filter value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        filter name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetGatewaysFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        filter name.
        """
        values: Sequence[_builtins.str]
        """
        filter value.
        """
elif False:
    GetGatewaysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: filter name.
        :param Sequence[_builtins.str] values: filter value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        filter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        filter value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        filter name.
        """
        values: Sequence[_builtins.str]
        """
        filter values.
        """
elif False:
    GetGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: filter name.
        :param Sequence[_builtins.str] values: filter values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        filter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


