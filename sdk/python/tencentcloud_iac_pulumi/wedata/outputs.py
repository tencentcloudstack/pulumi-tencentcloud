# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AddCalcEnginesToProjectOperationDlcInfo',
    'CodeFileCodeFileConfig',
    'CodeFileCodeFileConfigNotebookSessionInfo',
    'DataBackfillPlanOperationDataBackfillRangeList',
    'DataBackfillPlanOperationRedefineParamList',
    'DqRuleCompareRule',
    'DqRuleCompareRuleItem',
    'DqRuleCompareRuleItemValueList',
    'DqRuleFieldConfig',
    'DqRuleFieldConfigTableConfig',
    'DqRuleFieldConfigTableConfigFieldConfig',
    'DqRuleFieldConfigWhereConfig',
    'FunctionResourceList',
    'IntegrationOfflineTaskTaskInfo',
    'IntegrationOfflineTaskTaskInfoConfig',
    'IntegrationOfflineTaskTaskInfoExecuteContext',
    'IntegrationOfflineTaskTaskInfoExtConfig',
    'IntegrationOfflineTaskTaskInfoMapping',
    'IntegrationOfflineTaskTaskInfoMappingExtConfig',
    'IntegrationOfflineTaskTaskInfoMappingSchemaMapping',
    'IntegrationOfflineTaskTaskInfoMappingSourceSchema',
    'IntegrationOfflineTaskTaskInfoMappingSourceSchemaProperty',
    'IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity',
    'IntegrationRealtimeTaskTaskInfo',
    'IntegrationRealtimeTaskTaskInfoConfig',
    'IntegrationRealtimeTaskTaskInfoExecuteContext',
    'IntegrationRealtimeTaskTaskInfoExtConfig',
    'IntegrationRealtimeTaskTaskInfoMapping',
    'IntegrationRealtimeTaskTaskInfoMappingExtConfig',
    'IntegrationRealtimeTaskTaskInfoMappingSchemaMapping',
    'IntegrationRealtimeTaskTaskInfoMappingSourceSchema',
    'IntegrationRealtimeTaskTaskInfoMappingSourceSchemaProperty',
    'IntegrationRealtimeTaskTaskInfoNode',
    'IntegrationRealtimeTaskTaskInfoNodeConfig',
    'IntegrationRealtimeTaskTaskInfoNodeExtConfig',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMapping',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfig',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchema',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaProperty',
    'IntegrationRealtimeTaskTaskInfoNodeSchema',
    'IntegrationRealtimeTaskTaskInfoNodeSchemaProperty',
    'IntegrationTaskNodeNodeInfo',
    'IntegrationTaskNodeNodeInfoConfig',
    'IntegrationTaskNodeNodeInfoExtConfig',
    'IntegrationTaskNodeNodeInfoNodeMapping',
    'IntegrationTaskNodeNodeInfoNodeMappingExtConfig',
    'IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping',
    'IntegrationTaskNodeNodeInfoNodeMappingSourceSchema',
    'IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaProperty',
    'IntegrationTaskNodeNodeInfoSchema',
    'IntegrationTaskNodeNodeInfoSchemaProperty',
    'LineageAttachmentRelations',
    'LineageAttachmentRelationsProcesses',
    'LineageAttachmentRelationsProcessesProcessProperty',
    'LineageAttachmentRelationsSource',
    'LineageAttachmentRelationsSourceResourceProperty',
    'LineageAttachmentRelationsTarget',
    'LineageAttachmentRelationsTargetResourceProperty',
    'OpsAlarmRuleAlarmGroup',
    'OpsAlarmRuleAlarmGroupNotificationFatigue',
    'OpsAlarmRuleAlarmGroupNotificationFatigueQuietInterval',
    'OpsAlarmRuleAlarmGroupWebHook',
    'OpsAlarmRuleAlarmRuleDetail',
    'OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfo',
    'OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoList',
    'OpsAlarmRuleAlarmRuleDetailReconciliationExtInfo',
    'OpsAlarmRuleAlarmRuleDetailTimeOutExtInfo',
    'ProjectDlcInfo',
    'ProjectProject',
    'SqlScriptScriptConfig',
    'TaskRerunInstanceAsyncRedefineParamList',
    'TaskTaskBaseAttribute',
    'TaskTaskConfiguration',
    'TaskTaskConfigurationTaskExtConfigurationList',
    'TaskTaskConfigurationTaskSchedulingParameterList',
    'TaskTaskSchedulerConfiguration',
    'TaskTaskSchedulerConfigurationEventListenerList',
    'TaskTaskSchedulerConfigurationEventListenerListPropertiesList',
    'TaskTaskSchedulerConfigurationParamTaskInList',
    'TaskTaskSchedulerConfigurationParamTaskOutList',
    'TaskTaskSchedulerConfigurationTaskOutputRegistryList',
    'TaskTaskSchedulerConfigurationUpstreamDependencyConfigList',
    'TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategy',
    'WeDataDataSourceDevFileUpload',
    'WeDataDataSourceListFilterResult',
    'WeDataDataSourceListOrderFieldResult',
    'WeDataDataSourceListRowResult',
    'WeDataDataSourceProdFileUpload',
    'WeDataDataSourcesItemResult',
    'WorkflowWorkflowParam',
    'WorkflowWorkflowSchedulerConfiguration',
    'GetDataBackfillInstancesDataResult',
    'GetDataBackfillInstancesDataItemResult',
    'GetDataBackfillPlanDataResult',
    'GetDataBackfillPlanDataDataBackfillRangeListResult',
    'GetDataBackfillPlanDataRedefineParamListResult',
    'GetDownstreamTaskInstancesDataResult',
    'GetDownstreamTaskInstancesDataItemResult',
    'GetDownstreamTasksDataResult',
    'GetGetTableColumnsDataResult',
    'GetGetTableDataResult',
    'GetGetTableDataBusinessMetadataResult',
    'GetGetTableDataTechnicalMetadataResult',
    'GetListCatalogItemResult',
    'GetListColumnLineageItemResult',
    'GetListColumnLineageItemRelationResult',
    'GetListColumnLineageItemRelationProcessResult',
    'GetListColumnLineageItemRelationProcessProcessPropertyResult',
    'GetListColumnLineageItemResourceResult',
    'GetListColumnLineageItemResourceResourcePropertyResult',
    'GetListDatabaseItemResult',
    'GetListLineageItemResult',
    'GetListLineageItemRelationResult',
    'GetListLineageItemRelationProcessResult',
    'GetListLineageItemRelationProcessProcessPropertyResult',
    'GetListLineageItemResourceResult',
    'GetListLineageItemResourceResourcePropertyResult',
    'GetListProcessLineageItemResult',
    'GetListProcessLineageItemProcessResult',
    'GetListProcessLineageItemProcessProcessPropertyResult',
    'GetListProcessLineageItemSourceResult',
    'GetListProcessLineageItemSourceResourcePropertyResult',
    'GetListProcessLineageItemTargetResult',
    'GetListProcessLineageItemTargetResourcePropertyResult',
    'GetListSchemaItemResult',
    'GetListTableItemResult',
    'GetListTableItemBusinessMetadataResult',
    'GetListTableItemTechnicalMetadataResult',
    'GetOpsAlarmMessageDataResult',
    'GetOpsAlarmMessagesDataResult',
    'GetOpsAlarmMessagesDataItemResult',
    'GetOpsAlarmRulesDataResult',
    'GetOpsAlarmRulesDataItemResult',
    'GetOpsAlarmRulesDataItemAlarmGroupResult',
    'GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueResult',
    'GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueQuietIntervalResult',
    'GetOpsAlarmRulesDataItemAlarmGroupWebHookResult',
    'GetOpsAlarmRulesDataItemAlarmRuleDetailResult',
    'GetOpsAlarmRulesDataItemAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoResult',
    'GetOpsAlarmRulesDataItemAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListResult',
    'GetOpsAlarmRulesDataItemAlarmRuleDetailReconciliationExtInfoResult',
    'GetOpsAlarmRulesDataItemAlarmRuleDetailTimeOutExtInfoResult',
    'GetOpsAsyncJobDataResult',
    'GetOpsDownstreamTasksDataResult',
    'GetOpsDownstreamTasksDataItemResult',
    'GetOpsTaskCodeDataResult',
    'GetOpsTasksDataResult',
    'GetOpsTasksDataItemResult',
    'GetOpsUpstreamTasksDataResult',
    'GetOpsUpstreamTasksDataItemResult',
    'GetOpsWorkflowDataResult',
    'GetOpsWorkflowsDataResult',
    'GetProjectRolesItemResult',
    'GetProjectsItemResult',
    'GetResourceFilesDataResult',
    'GetResourceGroupMetricsDataResult',
    'GetResourceGroupMetricsDataMetricSnapshotResult',
    'GetResourceGroupMetricsDataMetricSnapshotTrendListResult',
    'GetRuleTemplatesDataResult',
    'GetSqlScriptRunsDataResult',
    'GetSqlScriptRunsDataJobExecutionListResult',
    'GetTaskCodeDataResult',
    'GetTaskInstanceDataResult',
    'GetTaskInstanceExecutionsDataResult',
    'GetTaskInstanceExecutionsDataItemResult',
    'GetTaskInstanceExecutionsDataItemExecutionPhaseListResult',
    'GetTaskInstanceLogDataResult',
    'GetTaskInstancesDataResult',
    'GetTaskInstancesDataItemResult',
    'GetTaskVersionDataResult',
    'GetTaskVersionDataTaskResult',
    'GetTaskVersionDataTaskTaskBaseAttributeResult',
    'GetTaskVersionDataTaskTaskConfigurationResult',
    'GetTaskVersionDataTaskTaskConfigurationTaskExtConfigurationListResult',
    'GetTaskVersionDataTaskTaskConfigurationTaskSchedulingParameterListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListDependencyStrategyResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListPropertiesListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskInListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskOutListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationTaskOutputRegistryListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListResult',
    'GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyResult',
    'GetTaskVersionsDataResult',
    'GetTasksDataResult',
    'GetTenantRolesDataResult',
    'GetUpstreamTaskInstancesDataResult',
    'GetUpstreamTaskInstancesDataItemResult',
    'GetUpstreamTasksDataResult',
    'GetWorkflowFoldersDataResult',
    'GetWorkflowsDataResult',
]

@pulumi.output_type
class AddCalcEnginesToProjectOperationDlcInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeResources":
            suggest = "compute_resources"
        elif key == "defaultDatabase":
            suggest = "default_database"
        elif key == "accessAccount":
            suggest = "access_account"
        elif key == "standardModeEnvTag":
            suggest = "standard_mode_env_tag"
        elif key == "subAccountUin":
            suggest = "sub_account_uin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddCalcEnginesToProjectOperationDlcInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddCalcEnginesToProjectOperationDlcInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddCalcEnginesToProjectOperationDlcInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_resources: Sequence[_builtins.str],
                 default_database: _builtins.str,
                 region: _builtins.str,
                 access_account: Optional[_builtins.str] = None,
                 standard_mode_env_tag: Optional[_builtins.str] = None,
                 sub_account_uin: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] compute_resources: DLC resource names (need to add role Uin to DLC, otherwise resources may not be available).
        :param _builtins.str default_database: Specify the default database for the DLC cluster.
        :param _builtins.str region: DLC region.
        :param _builtins.str access_account: Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
               It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failures when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.
               
               Enum values:
               - TASK_RUNNER (Task Runner)
               - OWNER (Main Account Mode)
               - SUB (Sub-Account Mode).
        :param _builtins.str standard_mode_env_tag: Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
               - Prod  (Production environment)
               - Dev  (Development environment).
        :param _builtins.str sub_account_uin: Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        pulumi.set(__self__, "compute_resources", compute_resources)
        pulumi.set(__self__, "default_database", default_database)
        pulumi.set(__self__, "region", region)
        if access_account is not None:
            pulumi.set(__self__, "access_account", access_account)
        if standard_mode_env_tag is not None:
            pulumi.set(__self__, "standard_mode_env_tag", standard_mode_env_tag)
        if sub_account_uin is not None:
            pulumi.set(__self__, "sub_account_uin", sub_account_uin)

    @_builtins.property
    @pulumi.getter(name="computeResources")
    def compute_resources(self) -> Sequence[_builtins.str]:
        """
        DLC resource names (need to add role Uin to DLC, otherwise resources may not be available).
        """
        return pulumi.get(self, "compute_resources")

    @_builtins.property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> _builtins.str:
        """
        Specify the default database for the DLC cluster.
        """
        return pulumi.get(self, "default_database")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        DLC region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessAccount")
    def access_account(self) -> Optional[_builtins.str]:
        """
        Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
        It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failures when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.

        Enum values:
        - TASK_RUNNER (Task Runner)
        - OWNER (Main Account Mode)
        - SUB (Sub-Account Mode).
        """
        return pulumi.get(self, "access_account")

    @_builtins.property
    @pulumi.getter(name="standardModeEnvTag")
    def standard_mode_env_tag(self) -> Optional[_builtins.str]:
        """
        Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
        - Prod  (Production environment)
        - Dev  (Development environment).
        """
        return pulumi.get(self, "standard_mode_env_tag")

    @_builtins.property
    @pulumi.getter(name="subAccountUin")
    def sub_account_uin(self) -> Optional[_builtins.str]:
        """
        Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        return pulumi.get(self, "sub_account_uin")


@pulumi.output_type
class CodeFileCodeFileConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookSessionInfo":
            suggest = "notebook_session_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeFileCodeFileConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeFileCodeFileConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeFileCodeFileConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook_session_info: Optional['outputs.CodeFileCodeFileConfigNotebookSessionInfo'] = None,
                 params: Optional[_builtins.str] = None):
        """
        :param 'CodeFileCodeFileConfigNotebookSessionInfoArgs' notebook_session_info: Notebook kernel session information.
        :param _builtins.str params: Advanced runtime parameters, variable substitution, map-json String,String.
        """
        if notebook_session_info is not None:
            pulumi.set(__self__, "notebook_session_info", notebook_session_info)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter(name="notebookSessionInfo")
    def notebook_session_info(self) -> Optional['outputs.CodeFileCodeFileConfigNotebookSessionInfo']:
        """
        Notebook kernel session information.
        """
        return pulumi.get(self, "notebook_session_info")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[_builtins.str]:
        """
        Advanced runtime parameters, variable substitution, map-json String,String.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class CodeFileCodeFileConfigNotebookSessionInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookSessionId":
            suggest = "notebook_session_id"
        elif key == "notebookSessionName":
            suggest = "notebook_session_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeFileCodeFileConfigNotebookSessionInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeFileCodeFileConfigNotebookSessionInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeFileCodeFileConfigNotebookSessionInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook_session_id: Optional[_builtins.str] = None,
                 notebook_session_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str notebook_session_id: Session ID.
        :param _builtins.str notebook_session_name: Session name.
        """
        if notebook_session_id is not None:
            pulumi.set(__self__, "notebook_session_id", notebook_session_id)
        if notebook_session_name is not None:
            pulumi.set(__self__, "notebook_session_name", notebook_session_name)

    @_builtins.property
    @pulumi.getter(name="notebookSessionId")
    def notebook_session_id(self) -> Optional[_builtins.str]:
        """
        Session ID.
        """
        return pulumi.get(self, "notebook_session_id")

    @_builtins.property
    @pulumi.getter(name="notebookSessionName")
    def notebook_session_name(self) -> Optional[_builtins.str]:
        """
        Session name.
        """
        return pulumi.get(self, "notebook_session_name")


@pulumi.output_type
class DataBackfillPlanOperationDataBackfillRangeList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "executionEndTime":
            suggest = "execution_end_time"
        elif key == "executionStartTime":
            suggest = "execution_start_time"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataBackfillPlanOperationDataBackfillRangeList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataBackfillPlanOperationDataBackfillRangeList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataBackfillPlanOperationDataBackfillRangeList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: Optional[_builtins.str] = None,
                 execution_end_time: Optional[_builtins.str] = None,
                 execution_start_time: Optional[_builtins.str] = None,
                 start_date: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_date: End date in the format yyyy-MM-dd, indicates ending at 23:59:59 of the specified date.
        :param _builtins.str execution_end_time: End time point between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        :param _builtins.str execution_start_time: Start time of each day between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        :param _builtins.str start_date: Start date in yyyy-MM-dd format. indicates the start from 00:00:00 on the specified date.
        """
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[_builtins.str]:
        """
        End date in the format yyyy-MM-dd, indicates ending at 23:59:59 of the specified date.
        """
        return pulumi.get(self, "end_date")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[_builtins.str]:
        """
        End time point between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[_builtins.str]:
        """
        Start time of each day between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[_builtins.str]:
        """
        Start date in yyyy-MM-dd format. indicates the start from 00:00:00 on the specified date.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class DataBackfillPlanOperationRedefineParamList(dict):
    def __init__(__self__, *,
                 k: Optional[_builtins.str] = None,
                 v: Optional[_builtins.str] = None):
        """
        :param _builtins.str k: Key name.
        :param _builtins.str v: The value. do not pass SQL (the request will be deemed as an attack on the api). if needed, transcode the SQL with Base64 and decode it.
        """
        if k is not None:
            pulumi.set(__self__, "k", k)
        if v is not None:
            pulumi.set(__self__, "v", v)

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.str]:
        """
        Key name.
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter
    def v(self) -> Optional[_builtins.str]:
        """
        The value. do not pass SQL (the request will be deemed as an attack on the api). if needed, transcode the SQL with Base64 and decode it.
        """
        return pulumi.get(self, "v")


@pulumi.output_type
class DqRuleCompareRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cycleStep":
            suggest = "cycle_step"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DqRuleCompareRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DqRuleCompareRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DqRuleCompareRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cycle_step: Optional[_builtins.int] = None,
                 items: Optional[Sequence['outputs.DqRuleCompareRuleItem']] = None):
        """
        :param _builtins.int cycle_step: Periodic Indicates the default period of a template, in secondsNote: This field may return null, indicating that a valid value cannot be obtained.
        :param Sequence['DqRuleCompareRuleItemArgs'] items: Comparison condition listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if cycle_step is not None:
            pulumi.set(__self__, "cycle_step", cycle_step)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="cycleStep")
    def cycle_step(self) -> Optional[_builtins.int]:
        """
        Periodic Indicates the default period of a template, in secondsNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "cycle_step")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.DqRuleCompareRuleItem']]:
        """
        Comparison condition listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class DqRuleCompareRuleItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareType":
            suggest = "compare_type"
        elif key == "valueComputeType":
            suggest = "value_compute_type"
        elif key == "valueLists":
            suggest = "value_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DqRuleCompareRuleItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DqRuleCompareRuleItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DqRuleCompareRuleItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compare_type: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 value_compute_type: Optional[_builtins.int] = None,
                 value_lists: Optional[Sequence['outputs.DqRuleCompareRuleItemValueList']] = None):
        """
        :param _builtins.int compare_type: Comparison type 1. Fixed value 2. Fluctuating value 3. Comparison of value range 4. Enumeration range comparison 5. Do not compareNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str operator: Comparison operation type &amp;lt; &amp;lt;= == =&amp;gt; &amp;gt;Note: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int value_compute_type: Quality statistics Type 1. Absolute value 2. Increase 3. Decrease 4. C contains 5. N C does not containNote: This field may return null, indicating that a valid value cannot be obtained.
        :param Sequence['DqRuleCompareRuleItemValueListArgs'] value_lists: Compare the threshold listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if compare_type is not None:
            pulumi.set(__self__, "compare_type", compare_type)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value_compute_type is not None:
            pulumi.set(__self__, "value_compute_type", value_compute_type)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)

    @_builtins.property
    @pulumi.getter(name="compareType")
    def compare_type(self) -> Optional[_builtins.int]:
        """
        Comparison type 1. Fixed value 2. Fluctuating value 3. Comparison of value range 4. Enumeration range comparison 5. Do not compareNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "compare_type")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Comparison operation type &amp;lt; &amp;lt;= == =&amp;gt; &amp;gt;Note: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter(name="valueComputeType")
    def value_compute_type(self) -> Optional[_builtins.int]:
        """
        Quality statistics Type 1. Absolute value 2. Increase 3. Decrease 4. C contains 5. N C does not containNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value_compute_type")

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[Sequence['outputs.DqRuleCompareRuleItemValueList']]:
        """
        Compare the threshold listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value_lists")


@pulumi.output_type
class DqRuleCompareRuleItemValueList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DqRuleCompareRuleItemValueList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DqRuleCompareRuleItemValueList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DqRuleCompareRuleItemValueList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None,
                 value_type: Optional[_builtins.int] = None):
        """
        :param _builtins.str value: Threshold valueNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int value_type: Threshold type 1. Low threshold 2. High threshold 3. Common threshold 4. Enumerated valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Threshold valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.int]:
        """
        Threshold type 1. Low threshold 2. High threshold 3. Common threshold 4. Enumerated valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class DqRuleFieldConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableConfigs":
            suggest = "table_configs"
        elif key == "whereConfigs":
            suggest = "where_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DqRuleFieldConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DqRuleFieldConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DqRuleFieldConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_configs: Optional[Sequence['outputs.DqRuleFieldConfigTableConfig']] = None,
                 where_configs: Optional[Sequence['outputs.DqRuleFieldConfigWhereConfig']] = None):
        """
        :param Sequence['DqRuleFieldConfigTableConfigArgs'] table_configs: Library table variableNote: This field may return null, indicating that a valid value cannot be obtained.
        :param Sequence['DqRuleFieldConfigWhereConfigArgs'] where_configs: Where variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if table_configs is not None:
            pulumi.set(__self__, "table_configs", table_configs)
        if where_configs is not None:
            pulumi.set(__self__, "where_configs", where_configs)

    @_builtins.property
    @pulumi.getter(name="tableConfigs")
    def table_configs(self) -> Optional[Sequence['outputs.DqRuleFieldConfigTableConfig']]:
        """
        Library table variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_configs")

    @_builtins.property
    @pulumi.getter(name="whereConfigs")
    def where_configs(self) -> Optional[Sequence['outputs.DqRuleFieldConfigWhereConfig']]:
        """
        Where variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "where_configs")


@pulumi.output_type
class DqRuleFieldConfigTableConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseId":
            suggest = "database_id"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fieldConfigs":
            suggest = "field_configs"
        elif key == "tableId":
            suggest = "table_id"
        elif key == "tableKey":
            suggest = "table_key"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DqRuleFieldConfigTableConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DqRuleFieldConfigTableConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DqRuleFieldConfigTableConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_id: Optional[_builtins.str] = None,
                 database_name: Optional[_builtins.str] = None,
                 field_configs: Optional[Sequence['outputs.DqRuleFieldConfigTableConfigFieldConfig']] = None,
                 table_id: Optional[_builtins.str] = None,
                 table_key: Optional[_builtins.str] = None,
                 table_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_id: Database idNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str database_name: Database nameNote: This field may return null, indicating that a valid value cannot be obtained.
        :param Sequence['DqRuleFieldConfigTableConfigFieldConfigArgs'] field_configs: Field variableNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str table_id: Table idNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str table_key: Table keyNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str table_name: Table nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if field_configs is not None:
            pulumi.set(__self__, "field_configs", field_configs)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)
        if table_key is not None:
            pulumi.set(__self__, "table_key", table_key)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database idNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        Database nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="fieldConfigs")
    def field_configs(self) -> Optional[Sequence['outputs.DqRuleFieldConfigTableConfigFieldConfig']]:
        """
        Field variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_configs")

    @_builtins.property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[_builtins.str]:
        """
        Table idNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_id")

    @_builtins.property
    @pulumi.getter(name="tableKey")
    def table_key(self) -> Optional[_builtins.str]:
        """
        Table keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_key")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[_builtins.str]:
        """
        Table nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class DqRuleFieldConfigTableConfigFieldConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDataType":
            suggest = "field_data_type"
        elif key == "fieldKey":
            suggest = "field_key"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DqRuleFieldConfigTableConfigFieldConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DqRuleFieldConfigTableConfigFieldConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DqRuleFieldConfigTableConfigFieldConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_data_type: Optional[_builtins.str] = None,
                 field_key: Optional[_builtins.str] = None,
                 field_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str field_data_type: Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str field_key: Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str field_value: Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if field_data_type is not None:
            pulumi.set(__self__, "field_data_type", field_data_type)
        if field_key is not None:
            pulumi.set(__self__, "field_key", field_key)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)

    @_builtins.property
    @pulumi.getter(name="fieldDataType")
    def field_data_type(self) -> Optional[_builtins.str]:
        """
        Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_data_type")

    @_builtins.property
    @pulumi.getter(name="fieldKey")
    def field_key(self) -> Optional[_builtins.str]:
        """
        Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_key")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[_builtins.str]:
        """
        Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_value")


@pulumi.output_type
class DqRuleFieldConfigWhereConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDataType":
            suggest = "field_data_type"
        elif key == "fieldKey":
            suggest = "field_key"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DqRuleFieldConfigWhereConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DqRuleFieldConfigWhereConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DqRuleFieldConfigWhereConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_data_type: Optional[_builtins.str] = None,
                 field_key: Optional[_builtins.str] = None,
                 field_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str field_data_type: Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str field_key: Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str field_value: Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if field_data_type is not None:
            pulumi.set(__self__, "field_data_type", field_data_type)
        if field_key is not None:
            pulumi.set(__self__, "field_key", field_key)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)

    @_builtins.property
    @pulumi.getter(name="fieldDataType")
    def field_data_type(self) -> Optional[_builtins.str]:
        """
        Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_data_type")

    @_builtins.property
    @pulumi.getter(name="fieldKey")
    def field_key(self) -> Optional[_builtins.str]:
        """
        Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_key")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[_builtins.str]:
        """
        Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_value")


@pulumi.output_type
class FunctionResourceList(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 md5: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Resource Name.
        :param _builtins.str path: Resource Path.
        :param _builtins.str id: Resource ID.
        :param _builtins.str md5: Resource MD5 Value.
        :param _builtins.str type: Resource Type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Resource Path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[_builtins.str]:
        """
        Resource MD5 Value.
        """
        return pulumi.get(self, "md5")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Resource Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "creatorUin":
            suggest = "creator_uin"
        elif key == "dataProxyUrls":
            suggest = "data_proxy_urls"
        elif key == "executeContexts":
            suggest = "execute_contexts"
        elif key == "executorGroupName":
            suggest = "executor_group_name"
        elif key == "executorId":
            suggest = "executor_id"
        elif key == "extConfigs":
            suggest = "ext_configs"
        elif key == "hasVersion":
            suggest = "has_version"
        elif key == "inLongManagerUrl":
            suggest = "in_long_manager_url"
        elif key == "inLongManagerVersion":
            suggest = "in_long_manager_version"
        elif key == "inLongStreamId":
            suggest = "in_long_stream_id"
        elif key == "inputDatasourceType":
            suggest = "input_datasource_type"
        elif key == "instanceVersion":
            suggest = "instance_version"
        elif key == "lastRunTime":
            suggest = "last_run_time"
        elif key == "numRecordsIn":
            suggest = "num_records_in"
        elif key == "numRecordsOut":
            suggest = "num_records_out"
        elif key == "numRestarts":
            suggest = "num_restarts"
        elif key == "offlineTaskAddEntity":
            suggest = "offline_task_add_entity"
        elif key == "operatorUin":
            suggest = "operator_uin"
        elif key == "outputDatasourceType":
            suggest = "output_datasource_type"
        elif key == "ownerUin":
            suggest = "owner_uin"
        elif key == "readPhase":
            suggest = "read_phase"
        elif key == "readerDelay":
            suggest = "reader_delay"
        elif key == "runningCu":
            suggest = "running_cu"
        elif key == "scheduleTaskId":
            suggest = "schedule_task_id"
        elif key == "stopTime":
            suggest = "stop_time"
        elif key == "switchResource":
            suggest = "switch_resource"
        elif key == "syncType":
            suggest = "sync_type"
        elif key == "taskAlarmRegularLists":
            suggest = "task_alarm_regular_lists"
        elif key == "taskGroupId":
            suggest = "task_group_id"
        elif key == "taskMode":
            suggest = "task_mode"
        elif key == "updateTime":
            suggest = "update_time"
        elif key == "workflowId":
            suggest = "workflow_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationOfflineTaskTaskInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationOfflineTaskTaskInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationOfflineTaskTaskInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 configs: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoConfig']] = None,
                 create_time: Optional[_builtins.str] = None,
                 creator_uin: Optional[_builtins.str] = None,
                 data_proxy_urls: Optional[Sequence[_builtins.str]] = None,
                 execute_contexts: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoExecuteContext']] = None,
                 executor_group_name: Optional[_builtins.str] = None,
                 executor_id: Optional[_builtins.str] = None,
                 ext_configs: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoExtConfig']] = None,
                 has_version: Optional[_builtins.bool] = None,
                 in_long_manager_url: Optional[_builtins.str] = None,
                 in_long_manager_version: Optional[_builtins.str] = None,
                 in_long_stream_id: Optional[_builtins.str] = None,
                 incharge: Optional[_builtins.str] = None,
                 input_datasource_type: Optional[_builtins.str] = None,
                 instance_version: Optional[_builtins.int] = None,
                 last_run_time: Optional[_builtins.str] = None,
                 locked: Optional[_builtins.bool] = None,
                 locker: Optional[_builtins.str] = None,
                 mappings: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMapping']] = None,
                 num_records_in: Optional[_builtins.int] = None,
                 num_records_out: Optional[_builtins.int] = None,
                 num_restarts: Optional[_builtins.int] = None,
                 offline_task_add_entity: Optional['outputs.IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity'] = None,
                 operator_uin: Optional[_builtins.str] = None,
                 output_datasource_type: Optional[_builtins.str] = None,
                 owner_uin: Optional[_builtins.str] = None,
                 read_phase: Optional[_builtins.int] = None,
                 reader_delay: Optional[_builtins.float] = None,
                 running_cu: Optional[_builtins.float] = None,
                 schedule_task_id: Optional[_builtins.str] = None,
                 status: Optional[_builtins.int] = None,
                 stop_time: Optional[_builtins.str] = None,
                 submit: Optional[_builtins.bool] = None,
                 switch_resource: Optional[_builtins.int] = None,
                 sync_type: Optional[_builtins.int] = None,
                 task_alarm_regular_lists: Optional[Sequence[_builtins.str]] = None,
                 task_group_id: Optional[_builtins.str] = None,
                 task_mode: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None,
                 workflow_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: User App Id.
        :param Sequence['IntegrationOfflineTaskTaskInfoConfigArgs'] configs: Task configuration.
        :param _builtins.str create_time: Create time.
        :param _builtins.str creator_uin: Creator User ID.
        :param Sequence[_builtins.str] data_proxy_urls: Data proxy url.
        :param Sequence['IntegrationOfflineTaskTaskInfoExecuteContextArgs'] execute_contexts: Execute context.
        :param _builtins.str executor_group_name: Executor group name.
        :param _builtins.str executor_id: Executor resource ID.
        :param Sequence['IntegrationOfflineTaskTaskInfoExtConfigArgs'] ext_configs: Node extension configuration information.
        :param _builtins.bool has_version: Whether the task been submitted.
        :param _builtins.str in_long_manager_url: InLong manager url.
        :param _builtins.str in_long_manager_version: InLong manager version.
        :param _builtins.str in_long_stream_id: InLong stream id.
        :param _builtins.str incharge: Incharge user.
        :param _builtins.str input_datasource_type: Input datasource type.
        :param _builtins.int instance_version: Instance version.
        :param _builtins.str last_run_time: The last time the task was run.
        :param _builtins.bool locked: Whether the task been locked.
        :param _builtins.str locker: User locked task.
        :param Sequence['IntegrationOfflineTaskTaskInfoMappingArgs'] mappings: Node mapping.
        :param _builtins.int num_records_in: Number of reads.
        :param _builtins.int num_records_out: Number of writes.
        :param _builtins.int num_restarts: Times of restarts.
        :param 'IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgs' offline_task_add_entity: Offline task scheduling configuration.
        :param _builtins.str operator_uin: Operator User ID.
        :param _builtins.str output_datasource_type: Output datasource type.
        :param _builtins.str owner_uin: Owner User ID.
        :param _builtins.int read_phase: Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        :param _builtins.float reader_delay: Read latency.
        :param _builtins.float running_cu: The amount of resources consumed by real-time task.
        :param _builtins.str schedule_task_id: Task scheduling id (job id such as oceanus or us).
        :param _builtins.int status: Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        :param _builtins.str stop_time: The time the task was stopped.
        :param _builtins.bool submit: Whether the task version has been submitted for operation and maintenance.
        :param _builtins.int switch_resource: Resource tiering status, 0: in progress, 1: successful, 2: failed.
        :param _builtins.int sync_type: Synchronization type: 1. Whole database synchronization, 2. Single table synchronization.
        :param Sequence[_builtins.str] task_alarm_regular_lists: Task alarm regular.
        :param _builtins.str task_group_id: Inlong Task Group ID.
        :param _builtins.str task_mode: Task display mode, 0: canvas mode, 1: form mode.
        :param _builtins.str update_time: Update time.
        :param _builtins.str workflow_id: The workflow id to which the task belongs.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if data_proxy_urls is not None:
            pulumi.set(__self__, "data_proxy_urls", data_proxy_urls)
        if execute_contexts is not None:
            pulumi.set(__self__, "execute_contexts", execute_contexts)
        if executor_group_name is not None:
            pulumi.set(__self__, "executor_group_name", executor_group_name)
        if executor_id is not None:
            pulumi.set(__self__, "executor_id", executor_id)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if has_version is not None:
            pulumi.set(__self__, "has_version", has_version)
        if in_long_manager_url is not None:
            pulumi.set(__self__, "in_long_manager_url", in_long_manager_url)
        if in_long_manager_version is not None:
            pulumi.set(__self__, "in_long_manager_version", in_long_manager_version)
        if in_long_stream_id is not None:
            pulumi.set(__self__, "in_long_stream_id", in_long_stream_id)
        if incharge is not None:
            pulumi.set(__self__, "incharge", incharge)
        if input_datasource_type is not None:
            pulumi.set(__self__, "input_datasource_type", input_datasource_type)
        if instance_version is not None:
            pulumi.set(__self__, "instance_version", instance_version)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if locker is not None:
            pulumi.set(__self__, "locker", locker)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if num_records_in is not None:
            pulumi.set(__self__, "num_records_in", num_records_in)
        if num_records_out is not None:
            pulumi.set(__self__, "num_records_out", num_records_out)
        if num_restarts is not None:
            pulumi.set(__self__, "num_restarts", num_restarts)
        if offline_task_add_entity is not None:
            pulumi.set(__self__, "offline_task_add_entity", offline_task_add_entity)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if output_datasource_type is not None:
            pulumi.set(__self__, "output_datasource_type", output_datasource_type)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if read_phase is not None:
            pulumi.set(__self__, "read_phase", read_phase)
        if reader_delay is not None:
            pulumi.set(__self__, "reader_delay", reader_delay)
        if running_cu is not None:
            pulumi.set(__self__, "running_cu", running_cu)
        if schedule_task_id is not None:
            pulumi.set(__self__, "schedule_task_id", schedule_task_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stop_time is not None:
            pulumi.set(__self__, "stop_time", stop_time)
        if submit is not None:
            pulumi.set(__self__, "submit", submit)
        if switch_resource is not None:
            pulumi.set(__self__, "switch_resource", switch_resource)
        if sync_type is not None:
            pulumi.set(__self__, "sync_type", sync_type)
        if task_alarm_regular_lists is not None:
            pulumi.set(__self__, "task_alarm_regular_lists", task_alarm_regular_lists)
        if task_group_id is not None:
            pulumi.set(__self__, "task_group_id", task_group_id)
        if task_mode is not None:
            pulumi.set(__self__, "task_mode", task_mode)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoConfig']]:
        """
        Task configuration.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[_builtins.str]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @_builtins.property
    @pulumi.getter(name="dataProxyUrls")
    def data_proxy_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Data proxy url.
        """
        return pulumi.get(self, "data_proxy_urls")

    @_builtins.property
    @pulumi.getter(name="executeContexts")
    def execute_contexts(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoExecuteContext']]:
        """
        Execute context.
        """
        return pulumi.get(self, "execute_contexts")

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> Optional[_builtins.str]:
        """
        Executor group name.
        """
        return pulumi.get(self, "executor_group_name")

    @_builtins.property
    @pulumi.getter(name="executorId")
    def executor_id(self) -> Optional[_builtins.str]:
        """
        Executor resource ID.
        """
        return pulumi.get(self, "executor_id")

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter(name="hasVersion")
    def has_version(self) -> Optional[_builtins.bool]:
        """
        Whether the task been submitted.
        """
        return pulumi.get(self, "has_version")

    @_builtins.property
    @pulumi.getter(name="inLongManagerUrl")
    def in_long_manager_url(self) -> Optional[_builtins.str]:
        """
        InLong manager url.
        """
        return pulumi.get(self, "in_long_manager_url")

    @_builtins.property
    @pulumi.getter(name="inLongManagerVersion")
    def in_long_manager_version(self) -> Optional[_builtins.str]:
        """
        InLong manager version.
        """
        return pulumi.get(self, "in_long_manager_version")

    @_builtins.property
    @pulumi.getter(name="inLongStreamId")
    def in_long_stream_id(self) -> Optional[_builtins.str]:
        """
        InLong stream id.
        """
        return pulumi.get(self, "in_long_stream_id")

    @_builtins.property
    @pulumi.getter
    def incharge(self) -> Optional[_builtins.str]:
        """
        Incharge user.
        """
        return pulumi.get(self, "incharge")

    @_builtins.property
    @pulumi.getter(name="inputDatasourceType")
    def input_datasource_type(self) -> Optional[_builtins.str]:
        """
        Input datasource type.
        """
        return pulumi.get(self, "input_datasource_type")

    @_builtins.property
    @pulumi.getter(name="instanceVersion")
    def instance_version(self) -> Optional[_builtins.int]:
        """
        Instance version.
        """
        return pulumi.get(self, "instance_version")

    @_builtins.property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[_builtins.str]:
        """
        The last time the task was run.
        """
        return pulumi.get(self, "last_run_time")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> Optional[_builtins.bool]:
        """
        Whether the task been locked.
        """
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter
    def locker(self) -> Optional[_builtins.str]:
        """
        User locked task.
        """
        return pulumi.get(self, "locker")

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMapping']]:
        """
        Node mapping.
        """
        return pulumi.get(self, "mappings")

    @_builtins.property
    @pulumi.getter(name="numRecordsIn")
    def num_records_in(self) -> Optional[_builtins.int]:
        """
        Number of reads.
        """
        return pulumi.get(self, "num_records_in")

    @_builtins.property
    @pulumi.getter(name="numRecordsOut")
    def num_records_out(self) -> Optional[_builtins.int]:
        """
        Number of writes.
        """
        return pulumi.get(self, "num_records_out")

    @_builtins.property
    @pulumi.getter(name="numRestarts")
    def num_restarts(self) -> Optional[_builtins.int]:
        """
        Times of restarts.
        """
        return pulumi.get(self, "num_restarts")

    @_builtins.property
    @pulumi.getter(name="offlineTaskAddEntity")
    def offline_task_add_entity(self) -> Optional['outputs.IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity']:
        """
        Offline task scheduling configuration.
        """
        return pulumi.get(self, "offline_task_add_entity")

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[_builtins.str]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @_builtins.property
    @pulumi.getter(name="outputDatasourceType")
    def output_datasource_type(self) -> Optional[_builtins.str]:
        """
        Output datasource type.
        """
        return pulumi.get(self, "output_datasource_type")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[_builtins.str]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="readPhase")
    def read_phase(self) -> Optional[_builtins.int]:
        """
        Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        """
        return pulumi.get(self, "read_phase")

    @_builtins.property
    @pulumi.getter(name="readerDelay")
    def reader_delay(self) -> Optional[_builtins.float]:
        """
        Read latency.
        """
        return pulumi.get(self, "reader_delay")

    @_builtins.property
    @pulumi.getter(name="runningCu")
    def running_cu(self) -> Optional[_builtins.float]:
        """
        The amount of resources consumed by real-time task.
        """
        return pulumi.get(self, "running_cu")

    @_builtins.property
    @pulumi.getter(name="scheduleTaskId")
    def schedule_task_id(self) -> Optional[_builtins.str]:
        """
        Task scheduling id (job id such as oceanus or us).
        """
        return pulumi.get(self, "schedule_task_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.int]:
        """
        Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="stopTime")
    def stop_time(self) -> Optional[_builtins.str]:
        """
        The time the task was stopped.
        """
        return pulumi.get(self, "stop_time")

    @_builtins.property
    @pulumi.getter
    def submit(self) -> Optional[_builtins.bool]:
        """
        Whether the task version has been submitted for operation and maintenance.
        """
        return pulumi.get(self, "submit")

    @_builtins.property
    @pulumi.getter(name="switchResource")
    def switch_resource(self) -> Optional[_builtins.int]:
        """
        Resource tiering status, 0: in progress, 1: successful, 2: failed.
        """
        return pulumi.get(self, "switch_resource")

    @_builtins.property
    @pulumi.getter(name="syncType")
    def sync_type(self) -> Optional[_builtins.int]:
        """
        Synchronization type: 1. Whole database synchronization, 2. Single table synchronization.
        """
        return pulumi.get(self, "sync_type")

    @_builtins.property
    @pulumi.getter(name="taskAlarmRegularLists")
    def task_alarm_regular_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Task alarm regular.
        """
        return pulumi.get(self, "task_alarm_regular_lists")

    @_builtins.property
    @pulumi.getter(name="taskGroupId")
    def task_group_id(self) -> Optional[_builtins.str]:
        """
        Inlong Task Group ID.
        """
        return pulumi.get(self, "task_group_id")

    @_builtins.property
    @pulumi.getter(name="taskMode")
    def task_mode(self) -> Optional[_builtins.str]:
        """
        Task display mode, 0: canvas mode, 1: form mode.
        """
        return pulumi.get(self, "task_mode")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[_builtins.str]:
        """
        The workflow id to which the task belongs.
        """
        return pulumi.get(self, "workflow_id")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoExecuteContext(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extConfigs":
            suggest = "ext_configs"
        elif key == "schemaMappings":
            suggest = "schema_mappings"
        elif key == "sinkId":
            suggest = "sink_id"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceSchemas":
            suggest = "source_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationOfflineTaskTaskInfoMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationOfflineTaskTaskInfoMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationOfflineTaskTaskInfoMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ext_configs: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingExtConfig']] = None,
                 schema_mappings: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingSchemaMapping']] = None,
                 sink_id: Optional[_builtins.str] = None,
                 source_id: Optional[_builtins.str] = None,
                 source_schemas: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingSourceSchema']] = None):
        """
        :param Sequence['IntegrationOfflineTaskTaskInfoMappingExtConfigArgs'] ext_configs: Node extension configuration information.
        :param Sequence['IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgs'] schema_mappings: Schema mapping information.
        :param _builtins.str sink_id: Sink node ID.
        :param _builtins.str source_id: Source node ID.
        :param Sequence['IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgs'] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingSchemaMapping']]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[_builtins.str]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[_builtins.str]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingSourceSchema']]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoMappingExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoMappingSchemaMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sinkSchemaId":
            suggest = "sink_schema_id"
        elif key == "sourceSchemaId":
            suggest = "source_schema_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationOfflineTaskTaskInfoMappingSchemaMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationOfflineTaskTaskInfoMappingSchemaMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationOfflineTaskTaskInfoMappingSchemaMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sink_schema_id: _builtins.str,
                 source_schema_id: _builtins.str):
        """
        :param _builtins.str sink_schema_id: Schema ID from sink node.
        :param _builtins.str source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> _builtins.str:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> _builtins.str:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoMappingSourceSchema(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 alias: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 properties: Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingSourceSchemaProperty']] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Schema ID.
        :param _builtins.str name: Schema name.
        :param _builtins.str type: Schema type.
        :param _builtins.str alias: Schema alias.
        :param _builtins.str comment: Schema comment.
        :param Sequence['IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgs'] properties: Schema extended attributes.
        :param _builtins.str value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.IntegrationOfflineTaskTaskInfoMappingSourceSchemaProperty']]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoMappingSourceSchemaProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Attributes name.
        :param _builtins.str value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crontabExpression":
            suggest = "crontab_expression"
        elif key == "cycleType":
            suggest = "cycle_type"
        elif key == "executionEndTime":
            suggest = "execution_end_time"
        elif key == "executionStartTime":
            suggest = "execution_start_time"
        elif key == "retryWait":
            suggest = "retry_wait"
        elif key == "selfDepend":
            suggest = "self_depend"
        elif key == "tryLimit":
            suggest = "try_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crontab_expression: Optional[_builtins.str] = None,
                 cycle_type: Optional[_builtins.int] = None,
                 execution_end_time: Optional[_builtins.str] = None,
                 execution_start_time: Optional[_builtins.str] = None,
                 retriable: Optional[_builtins.int] = None,
                 retry_wait: Optional[_builtins.int] = None,
                 self_depend: Optional[_builtins.int] = None,
                 try_limit: Optional[_builtins.int] = None):
        """
        :param _builtins.str crontab_expression: Crontab expression.
        :param _builtins.int cycle_type: Scheduling type, 0: crontab type, 1: minutes, 2: hours, 3: days, 4: weeks, 5: months, 6: one-time, 7: user-driven, 10: elastic period (week), 11: elastic period (month), 12: year, 13: instant trigger.
        :param _builtins.str execution_end_time: Scheduling execution end time.
        :param _builtins.str execution_start_time: Scheduling execution start time.
        :param _builtins.int retriable: Whether to retry.
        :param _builtins.int retry_wait: Retry waiting time, unit is minutes.
        :param _builtins.int self_depend: Self-dependent rules, 1: Ordered serial one at a time, queued execution, 2: Unordered serial one at a time, not queued execution, 3: Parallel, multiple at once.
        :param _builtins.int try_limit: Number of retries.
        """
        if crontab_expression is not None:
            pulumi.set(__self__, "crontab_expression", crontab_expression)
        if cycle_type is not None:
            pulumi.set(__self__, "cycle_type", cycle_type)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if retriable is not None:
            pulumi.set(__self__, "retriable", retriable)
        if retry_wait is not None:
            pulumi.set(__self__, "retry_wait", retry_wait)
        if self_depend is not None:
            pulumi.set(__self__, "self_depend", self_depend)
        if try_limit is not None:
            pulumi.set(__self__, "try_limit", try_limit)

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> Optional[_builtins.str]:
        """
        Crontab expression.
        """
        return pulumi.get(self, "crontab_expression")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> Optional[_builtins.int]:
        """
        Scheduling type, 0: crontab type, 1: minutes, 2: hours, 3: days, 4: weeks, 5: months, 6: one-time, 7: user-driven, 10: elastic period (week), 11: elastic period (month), 12: year, 13: instant trigger.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[_builtins.str]:
        """
        Scheduling execution end time.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[_builtins.str]:
        """
        Scheduling execution start time.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter
    def retriable(self) -> Optional[_builtins.int]:
        """
        Whether to retry.
        """
        return pulumi.get(self, "retriable")

    @_builtins.property
    @pulumi.getter(name="retryWait")
    def retry_wait(self) -> Optional[_builtins.int]:
        """
        Retry waiting time, unit is minutes.
        """
        return pulumi.get(self, "retry_wait")

    @_builtins.property
    @pulumi.getter(name="selfDepend")
    def self_depend(self) -> Optional[_builtins.int]:
        """
        Self-dependent rules, 1: Ordered serial one at a time, queued execution, 2: Unordered serial one at a time, not queued execution, 3: Parallel, multiple at once.
        """
        return pulumi.get(self, "self_depend")

    @_builtins.property
    @pulumi.getter(name="tryLimit")
    def try_limit(self) -> Optional[_builtins.int]:
        """
        Number of retries.
        """
        return pulumi.get(self, "try_limit")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "creatorUin":
            suggest = "creator_uin"
        elif key == "dataProxyUrls":
            suggest = "data_proxy_urls"
        elif key == "executeContexts":
            suggest = "execute_contexts"
        elif key == "executorGroupName":
            suggest = "executor_group_name"
        elif key == "executorId":
            suggest = "executor_id"
        elif key == "extConfigs":
            suggest = "ext_configs"
        elif key == "hasVersion":
            suggest = "has_version"
        elif key == "inLongManagerUrl":
            suggest = "in_long_manager_url"
        elif key == "inLongManagerVersion":
            suggest = "in_long_manager_version"
        elif key == "inLongStreamId":
            suggest = "in_long_stream_id"
        elif key == "inputDatasourceType":
            suggest = "input_datasource_type"
        elif key == "instanceVersion":
            suggest = "instance_version"
        elif key == "lastRunTime":
            suggest = "last_run_time"
        elif key == "numRecordsIn":
            suggest = "num_records_in"
        elif key == "numRecordsOut":
            suggest = "num_records_out"
        elif key == "numRestarts":
            suggest = "num_restarts"
        elif key == "operatorUin":
            suggest = "operator_uin"
        elif key == "outputDatasourceType":
            suggest = "output_datasource_type"
        elif key == "ownerUin":
            suggest = "owner_uin"
        elif key == "readPhase":
            suggest = "read_phase"
        elif key == "readerDelay":
            suggest = "reader_delay"
        elif key == "runningCu":
            suggest = "running_cu"
        elif key == "scheduleTaskId":
            suggest = "schedule_task_id"
        elif key == "stopTime":
            suggest = "stop_time"
        elif key == "switchResource":
            suggest = "switch_resource"
        elif key == "taskAlarmRegularLists":
            suggest = "task_alarm_regular_lists"
        elif key == "taskGroupId":
            suggest = "task_group_id"
        elif key == "updateTime":
            suggest = "update_time"
        elif key == "workflowId":
            suggest = "workflow_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRealtimeTaskTaskInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRealtimeTaskTaskInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRealtimeTaskTaskInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 configs: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoConfig']] = None,
                 create_time: Optional[_builtins.str] = None,
                 creator_uin: Optional[_builtins.str] = None,
                 data_proxy_urls: Optional[Sequence[_builtins.str]] = None,
                 execute_contexts: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoExecuteContext']] = None,
                 executor_group_name: Optional[_builtins.str] = None,
                 executor_id: Optional[_builtins.str] = None,
                 ext_configs: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoExtConfig']] = None,
                 has_version: Optional[_builtins.bool] = None,
                 in_long_manager_url: Optional[_builtins.str] = None,
                 in_long_manager_version: Optional[_builtins.str] = None,
                 in_long_stream_id: Optional[_builtins.str] = None,
                 incharge: Optional[_builtins.str] = None,
                 input_datasource_type: Optional[_builtins.str] = None,
                 instance_version: Optional[_builtins.int] = None,
                 last_run_time: Optional[_builtins.str] = None,
                 locked: Optional[_builtins.bool] = None,
                 locker: Optional[_builtins.str] = None,
                 mappings: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMapping']] = None,
                 nodes: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNode']] = None,
                 num_records_in: Optional[_builtins.int] = None,
                 num_records_out: Optional[_builtins.int] = None,
                 num_restarts: Optional[_builtins.int] = None,
                 operator_uin: Optional[_builtins.str] = None,
                 output_datasource_type: Optional[_builtins.str] = None,
                 owner_uin: Optional[_builtins.str] = None,
                 read_phase: Optional[_builtins.int] = None,
                 reader_delay: Optional[_builtins.float] = None,
                 running_cu: Optional[_builtins.float] = None,
                 schedule_task_id: Optional[_builtins.str] = None,
                 status: Optional[_builtins.int] = None,
                 stop_time: Optional[_builtins.str] = None,
                 submit: Optional[_builtins.bool] = None,
                 switch_resource: Optional[_builtins.int] = None,
                 task_alarm_regular_lists: Optional[Sequence[_builtins.str]] = None,
                 task_group_id: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None,
                 workflow_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: User App Id.
        :param Sequence['IntegrationRealtimeTaskTaskInfoConfigArgs'] configs: Task configuration.
        :param _builtins.str create_time: Create time.
        :param _builtins.str creator_uin: Creator User ID.
        :param Sequence[_builtins.str] data_proxy_urls: Data proxy url.
        :param Sequence['IntegrationRealtimeTaskTaskInfoExecuteContextArgs'] execute_contexts: Execute context.
        :param _builtins.str executor_group_name: Executor group name.
        :param _builtins.str executor_id: Executor resource ID.
        :param Sequence['IntegrationRealtimeTaskTaskInfoExtConfigArgs'] ext_configs: Node extension configuration information.
        :param _builtins.bool has_version: Whether the task been submitted.
        :param _builtins.str in_long_manager_url: InLong manager url.
        :param _builtins.str in_long_manager_version: InLong manager version.
        :param _builtins.str in_long_stream_id: InLong stream id.
        :param _builtins.str incharge: Incharge user.
        :param _builtins.str input_datasource_type: Input datasource type.
        :param _builtins.int instance_version: Instance version.
        :param _builtins.str last_run_time: The last time the task was run.
        :param _builtins.bool locked: Whether the task been locked.
        :param _builtins.str locker: User locked task.
        :param Sequence['IntegrationRealtimeTaskTaskInfoMappingArgs'] mappings: Node mapping.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeArgs'] nodes: Task Node Information.
        :param _builtins.int num_records_in: Number of reads.
        :param _builtins.int num_records_out: Number of writes.
        :param _builtins.int num_restarts: Times of restarts.
        :param _builtins.str operator_uin: Operator User ID.
        :param _builtins.str output_datasource_type: Output datasource type.
        :param _builtins.str owner_uin: Owner User ID.
        :param _builtins.int read_phase: Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        :param _builtins.float reader_delay: Read latency.
        :param _builtins.float running_cu: The amount of resources consumed by real-time task.
        :param _builtins.str schedule_task_id: Task scheduling id (job id such as oceanus or us).
        :param _builtins.int status: Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        :param _builtins.str stop_time: The time the task was stopped.
        :param _builtins.bool submit: Whether the task version has been submitted for operation and maintenance.
        :param _builtins.int switch_resource: Resource tiering status, 0: in progress, 1: successful, 2: failed.
        :param Sequence[_builtins.str] task_alarm_regular_lists: Task alarm regular.
        :param _builtins.str task_group_id: Inlong Task Group ID.
        :param _builtins.str update_time: Update time.
        :param _builtins.str workflow_id: The workflow id to which the task belongs.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if data_proxy_urls is not None:
            pulumi.set(__self__, "data_proxy_urls", data_proxy_urls)
        if execute_contexts is not None:
            pulumi.set(__self__, "execute_contexts", execute_contexts)
        if executor_group_name is not None:
            pulumi.set(__self__, "executor_group_name", executor_group_name)
        if executor_id is not None:
            pulumi.set(__self__, "executor_id", executor_id)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if has_version is not None:
            pulumi.set(__self__, "has_version", has_version)
        if in_long_manager_url is not None:
            pulumi.set(__self__, "in_long_manager_url", in_long_manager_url)
        if in_long_manager_version is not None:
            pulumi.set(__self__, "in_long_manager_version", in_long_manager_version)
        if in_long_stream_id is not None:
            pulumi.set(__self__, "in_long_stream_id", in_long_stream_id)
        if incharge is not None:
            pulumi.set(__self__, "incharge", incharge)
        if input_datasource_type is not None:
            pulumi.set(__self__, "input_datasource_type", input_datasource_type)
        if instance_version is not None:
            pulumi.set(__self__, "instance_version", instance_version)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if locker is not None:
            pulumi.set(__self__, "locker", locker)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if num_records_in is not None:
            pulumi.set(__self__, "num_records_in", num_records_in)
        if num_records_out is not None:
            pulumi.set(__self__, "num_records_out", num_records_out)
        if num_restarts is not None:
            pulumi.set(__self__, "num_restarts", num_restarts)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if output_datasource_type is not None:
            pulumi.set(__self__, "output_datasource_type", output_datasource_type)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if read_phase is not None:
            pulumi.set(__self__, "read_phase", read_phase)
        if reader_delay is not None:
            pulumi.set(__self__, "reader_delay", reader_delay)
        if running_cu is not None:
            pulumi.set(__self__, "running_cu", running_cu)
        if schedule_task_id is not None:
            pulumi.set(__self__, "schedule_task_id", schedule_task_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stop_time is not None:
            pulumi.set(__self__, "stop_time", stop_time)
        if submit is not None:
            pulumi.set(__self__, "submit", submit)
        if switch_resource is not None:
            pulumi.set(__self__, "switch_resource", switch_resource)
        if task_alarm_regular_lists is not None:
            pulumi.set(__self__, "task_alarm_regular_lists", task_alarm_regular_lists)
        if task_group_id is not None:
            pulumi.set(__self__, "task_group_id", task_group_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoConfig']]:
        """
        Task configuration.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[_builtins.str]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @_builtins.property
    @pulumi.getter(name="dataProxyUrls")
    def data_proxy_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Data proxy url.
        """
        return pulumi.get(self, "data_proxy_urls")

    @_builtins.property
    @pulumi.getter(name="executeContexts")
    def execute_contexts(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoExecuteContext']]:
        """
        Execute context.
        """
        return pulumi.get(self, "execute_contexts")

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> Optional[_builtins.str]:
        """
        Executor group name.
        """
        return pulumi.get(self, "executor_group_name")

    @_builtins.property
    @pulumi.getter(name="executorId")
    def executor_id(self) -> Optional[_builtins.str]:
        """
        Executor resource ID.
        """
        return pulumi.get(self, "executor_id")

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter(name="hasVersion")
    def has_version(self) -> Optional[_builtins.bool]:
        """
        Whether the task been submitted.
        """
        return pulumi.get(self, "has_version")

    @_builtins.property
    @pulumi.getter(name="inLongManagerUrl")
    def in_long_manager_url(self) -> Optional[_builtins.str]:
        """
        InLong manager url.
        """
        return pulumi.get(self, "in_long_manager_url")

    @_builtins.property
    @pulumi.getter(name="inLongManagerVersion")
    def in_long_manager_version(self) -> Optional[_builtins.str]:
        """
        InLong manager version.
        """
        return pulumi.get(self, "in_long_manager_version")

    @_builtins.property
    @pulumi.getter(name="inLongStreamId")
    def in_long_stream_id(self) -> Optional[_builtins.str]:
        """
        InLong stream id.
        """
        return pulumi.get(self, "in_long_stream_id")

    @_builtins.property
    @pulumi.getter
    def incharge(self) -> Optional[_builtins.str]:
        """
        Incharge user.
        """
        return pulumi.get(self, "incharge")

    @_builtins.property
    @pulumi.getter(name="inputDatasourceType")
    def input_datasource_type(self) -> Optional[_builtins.str]:
        """
        Input datasource type.
        """
        return pulumi.get(self, "input_datasource_type")

    @_builtins.property
    @pulumi.getter(name="instanceVersion")
    def instance_version(self) -> Optional[_builtins.int]:
        """
        Instance version.
        """
        return pulumi.get(self, "instance_version")

    @_builtins.property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[_builtins.str]:
        """
        The last time the task was run.
        """
        return pulumi.get(self, "last_run_time")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> Optional[_builtins.bool]:
        """
        Whether the task been locked.
        """
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter
    def locker(self) -> Optional[_builtins.str]:
        """
        User locked task.
        """
        return pulumi.get(self, "locker")

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMapping']]:
        """
        Node mapping.
        """
        return pulumi.get(self, "mappings")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNode']]:
        """
        Task Node Information.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="numRecordsIn")
    def num_records_in(self) -> Optional[_builtins.int]:
        """
        Number of reads.
        """
        return pulumi.get(self, "num_records_in")

    @_builtins.property
    @pulumi.getter(name="numRecordsOut")
    def num_records_out(self) -> Optional[_builtins.int]:
        """
        Number of writes.
        """
        return pulumi.get(self, "num_records_out")

    @_builtins.property
    @pulumi.getter(name="numRestarts")
    def num_restarts(self) -> Optional[_builtins.int]:
        """
        Times of restarts.
        """
        return pulumi.get(self, "num_restarts")

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[_builtins.str]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @_builtins.property
    @pulumi.getter(name="outputDatasourceType")
    def output_datasource_type(self) -> Optional[_builtins.str]:
        """
        Output datasource type.
        """
        return pulumi.get(self, "output_datasource_type")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[_builtins.str]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="readPhase")
    def read_phase(self) -> Optional[_builtins.int]:
        """
        Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        """
        return pulumi.get(self, "read_phase")

    @_builtins.property
    @pulumi.getter(name="readerDelay")
    def reader_delay(self) -> Optional[_builtins.float]:
        """
        Read latency.
        """
        return pulumi.get(self, "reader_delay")

    @_builtins.property
    @pulumi.getter(name="runningCu")
    def running_cu(self) -> Optional[_builtins.float]:
        """
        The amount of resources consumed by real-time task.
        """
        return pulumi.get(self, "running_cu")

    @_builtins.property
    @pulumi.getter(name="scheduleTaskId")
    def schedule_task_id(self) -> Optional[_builtins.str]:
        """
        Task scheduling id (job id such as oceanus or us).
        """
        return pulumi.get(self, "schedule_task_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.int]:
        """
        Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="stopTime")
    def stop_time(self) -> Optional[_builtins.str]:
        """
        The time the task was stopped.
        """
        return pulumi.get(self, "stop_time")

    @_builtins.property
    @pulumi.getter
    def submit(self) -> Optional[_builtins.bool]:
        """
        Whether the task version has been submitted for operation and maintenance.
        """
        return pulumi.get(self, "submit")

    @_builtins.property
    @pulumi.getter(name="switchResource")
    def switch_resource(self) -> Optional[_builtins.int]:
        """
        Resource tiering status, 0: in progress, 1: successful, 2: failed.
        """
        return pulumi.get(self, "switch_resource")

    @_builtins.property
    @pulumi.getter(name="taskAlarmRegularLists")
    def task_alarm_regular_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Task alarm regular.
        """
        return pulumi.get(self, "task_alarm_regular_lists")

    @_builtins.property
    @pulumi.getter(name="taskGroupId")
    def task_group_id(self) -> Optional[_builtins.str]:
        """
        Inlong Task Group ID.
        """
        return pulumi.get(self, "task_group_id")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[_builtins.str]:
        """
        The workflow id to which the task belongs.
        """
        return pulumi.get(self, "workflow_id")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoExecuteContext(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extConfigs":
            suggest = "ext_configs"
        elif key == "schemaMappings":
            suggest = "schema_mappings"
        elif key == "sinkId":
            suggest = "sink_id"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceSchemas":
            suggest = "source_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRealtimeTaskTaskInfoMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRealtimeTaskTaskInfoMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRealtimeTaskTaskInfoMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ext_configs: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingExtConfig']] = None,
                 schema_mappings: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingSchemaMapping']] = None,
                 sink_id: Optional[_builtins.str] = None,
                 source_id: Optional[_builtins.str] = None,
                 source_schemas: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingSourceSchema']] = None):
        """
        :param Sequence['IntegrationRealtimeTaskTaskInfoMappingExtConfigArgs'] ext_configs: Node extension configuration information.
        :param Sequence['IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgs'] schema_mappings: Schema mapping information.
        :param _builtins.str sink_id: Sink node ID.
        :param _builtins.str source_id: Source node ID.
        :param Sequence['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgs'] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingSchemaMapping']]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[_builtins.str]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[_builtins.str]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingSourceSchema']]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoMappingExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoMappingSchemaMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sinkSchemaId":
            suggest = "sink_schema_id"
        elif key == "sourceSchemaId":
            suggest = "source_schema_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRealtimeTaskTaskInfoMappingSchemaMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRealtimeTaskTaskInfoMappingSchemaMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRealtimeTaskTaskInfoMappingSchemaMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sink_schema_id: _builtins.str,
                 source_schema_id: _builtins.str):
        """
        :param _builtins.str sink_schema_id: Schema ID from sink node.
        :param _builtins.str source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> _builtins.str:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> _builtins.str:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoMappingSourceSchema(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 alias: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 properties: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingSourceSchemaProperty']] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Schema ID.
        :param _builtins.str name: Schema name.
        :param _builtins.str type: Schema type.
        :param _builtins.str alias: Schema alias.
        :param _builtins.str comment: Schema comment.
        :param Sequence['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgs'] properties: Schema extended attributes.
        :param _builtins.str value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoMappingSourceSchemaProperty']]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoMappingSourceSchemaProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Attributes name.
        :param _builtins.str value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "creatorUin":
            suggest = "creator_uin"
        elif key == "dataSourceType":
            suggest = "data_source_type"
        elif key == "datasourceId":
            suggest = "datasource_id"
        elif key == "extConfigs":
            suggest = "ext_configs"
        elif key == "nodeMapping":
            suggest = "node_mapping"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "operatorUin":
            suggest = "operator_uin"
        elif key == "ownerUin":
            suggest = "owner_uin"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "taskId":
            suggest = "task_id"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRealtimeTaskTaskInfoNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRealtimeTaskTaskInfoNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRealtimeTaskTaskInfoNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 configs: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeConfig']] = None,
                 create_time: Optional[_builtins.str] = None,
                 creator_uin: Optional[_builtins.str] = None,
                 data_source_type: Optional[_builtins.str] = None,
                 datasource_id: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 ext_configs: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeExtConfig']] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 node_mapping: Optional['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMapping'] = None,
                 node_type: Optional[_builtins.str] = None,
                 operator_uin: Optional[_builtins.str] = None,
                 owner_uin: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 schemas: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeSchema']] = None,
                 task_id: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: User App Id.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeConfigArgs'] configs: Node configuration information.
        :param _builtins.str create_time: Create time.
        :param _builtins.str creator_uin: Creator User ID.
        :param _builtins.str data_source_type: Data source type: MYSQL, POSTGRE, ORACLE, SQLSERVER, FTP, HIVE, HDFS, ICEBERG, KAFKA, HBASE, SPARK, TBASE, DB2, DM, GAUSSDB, GBASE, IMPALA, ES, S3_DATAINSIGHT, GREENPLUM, PHOENIX, SAP_HANA, SFTP, OCEANBASE, CLICKHOUSE, KUDU, VERTICA, REDIS, COS, DLC, DORIS, CKAFKA, DTS_KAFKA, S3, CDW, TDSQLC, TDSQL, MONGODB, SYBASE, REST_API, StarRocks, TCHOUSE_X.
        :param _builtins.str datasource_id: Datasource ID.
        :param _builtins.str description: Node Description.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeExtConfigArgs'] ext_configs: Node extension configuration information.
        :param _builtins.str id: Schema ID.
        :param _builtins.str name: Schema name.
        :param 'IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgs' node_mapping: Node mapping.
        :param _builtins.str node_type: Node type: INPUT,OUTPUT,JOIN,FILTER,TRANSFORM.
        :param _builtins.str operator_uin: Operator User ID.
        :param _builtins.str owner_uin: Owner User ID.
        :param _builtins.str project_id: Project ID.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeSchemaArgs'] schemas: Schema information.
        :param _builtins.str task_id: The task id to which the node belongs.
        :param _builtins.str update_time: Update time.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if datasource_id is not None:
            pulumi.set(__self__, "datasource_id", datasource_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_mapping is not None:
            pulumi.set(__self__, "node_mapping", node_mapping)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if task_id is not None:
            pulumi.set(__self__, "task_id", task_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeConfig']]:
        """
        Node configuration information.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[_builtins.str]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[_builtins.str]:
        """
        Data source type: MYSQL, POSTGRE, ORACLE, SQLSERVER, FTP, HIVE, HDFS, ICEBERG, KAFKA, HBASE, SPARK, TBASE, DB2, DM, GAUSSDB, GBASE, IMPALA, ES, S3_DATAINSIGHT, GREENPLUM, PHOENIX, SAP_HANA, SFTP, OCEANBASE, CLICKHOUSE, KUDU, VERTICA, REDIS, COS, DLC, DORIS, CKAFKA, DTS_KAFKA, S3, CDW, TDSQLC, TDSQL, MONGODB, SYBASE, REST_API, StarRocks, TCHOUSE_X.
        """
        return pulumi.get(self, "data_source_type")

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> Optional[_builtins.str]:
        """
        Datasource ID.
        """
        return pulumi.get(self, "datasource_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Node Description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeMapping")
    def node_mapping(self) -> Optional['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMapping']:
        """
        Node mapping.
        """
        return pulumi.get(self, "node_mapping")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[_builtins.str]:
        """
        Node type: INPUT,OUTPUT,JOIN,FILTER,TRANSFORM.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[_builtins.str]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[_builtins.str]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeSchema']]:
        """
        Schema information.
        """
        return pulumi.get(self, "schemas")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[_builtins.str]:
        """
        The task id to which the node belongs.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extConfigs":
            suggest = "ext_configs"
        elif key == "schemaMappings":
            suggest = "schema_mappings"
        elif key == "sinkId":
            suggest = "sink_id"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceSchemas":
            suggest = "source_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRealtimeTaskTaskInfoNodeNodeMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRealtimeTaskTaskInfoNodeNodeMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRealtimeTaskTaskInfoNodeNodeMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ext_configs: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfig']] = None,
                 schema_mappings: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping']] = None,
                 sink_id: Optional[_builtins.str] = None,
                 source_id: Optional[_builtins.str] = None,
                 source_schemas: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchema']] = None):
        """
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgs'] ext_configs: Node extension configuration information.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgs'] schema_mappings: Schema mapping information.
        :param _builtins.str sink_id: Sink node ID.
        :param _builtins.str source_id: Source node ID.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgs'] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping']]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[_builtins.str]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[_builtins.str]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchema']]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sinkSchemaId":
            suggest = "sink_schema_id"
        elif key == "sourceSchemaId":
            suggest = "source_schema_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sink_schema_id: _builtins.str,
                 source_schema_id: _builtins.str):
        """
        :param _builtins.str sink_schema_id: Schema ID from sink node.
        :param _builtins.str source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> _builtins.str:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> _builtins.str:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchema(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 alias: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 properties: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaProperty']] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Schema ID.
        :param _builtins.str name: Schema name.
        :param _builtins.str type: Schema type.
        :param _builtins.str alias: Schema alias.
        :param _builtins.str comment: Schema comment.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgs'] properties: Schema extended attributes.
        :param _builtins.str value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaProperty']]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Attributes name.
        :param _builtins.str value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeSchema(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 alias: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 properties: Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeSchemaProperty']] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Schema ID.
        :param _builtins.str name: Schema name.
        :param _builtins.str type: Schema type.
        :param _builtins.str alias: Schema alias.
        :param _builtins.str comment: Schema comment.
        :param Sequence['IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgs'] properties: Schema extended attributes.
        :param _builtins.str value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.IntegrationRealtimeTaskTaskInfoNodeSchemaProperty']]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationRealtimeTaskTaskInfoNodeSchemaProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Attributes name.
        :param _builtins.str value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationTaskNodeNodeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "creatorUin":
            suggest = "creator_uin"
        elif key == "datasourceId":
            suggest = "datasource_id"
        elif key == "extConfigs":
            suggest = "ext_configs"
        elif key == "nodeMapping":
            suggest = "node_mapping"
        elif key == "operatorUin":
            suggest = "operator_uin"
        elif key == "ownerUin":
            suggest = "owner_uin"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationTaskNodeNodeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationTaskNodeNodeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationTaskNodeNodeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 configs: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoConfig']] = None,
                 create_time: Optional[_builtins.str] = None,
                 creator_uin: Optional[_builtins.str] = None,
                 datasource_id: Optional[_builtins.str] = None,
                 ext_configs: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoExtConfig']] = None,
                 node_mapping: Optional['outputs.IntegrationTaskNodeNodeInfoNodeMapping'] = None,
                 operator_uin: Optional[_builtins.str] = None,
                 owner_uin: Optional[_builtins.str] = None,
                 schemas: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoSchema']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: User App Id.
        :param Sequence['IntegrationTaskNodeNodeInfoConfigArgs'] configs: Node configuration information.
        :param _builtins.str create_time: Create time.
        :param _builtins.str creator_uin: Creator User ID.
        :param _builtins.str datasource_id: Datasource ID.
        :param Sequence['IntegrationTaskNodeNodeInfoExtConfigArgs'] ext_configs: Node extension configuration information.
        :param 'IntegrationTaskNodeNodeInfoNodeMappingArgs' node_mapping: Node mapping.
        :param _builtins.str operator_uin: Operator User ID.
        :param _builtins.str owner_uin: Owner User ID.
        :param Sequence['IntegrationTaskNodeNodeInfoSchemaArgs'] schemas: Schema information.
        :param _builtins.str update_time: Update time.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if datasource_id is not None:
            pulumi.set(__self__, "datasource_id", datasource_id)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if node_mapping is not None:
            pulumi.set(__self__, "node_mapping", node_mapping)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoConfig']]:
        """
        Node configuration information.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[_builtins.str]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> Optional[_builtins.str]:
        """
        Datasource ID.
        """
        return pulumi.get(self, "datasource_id")

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter(name="nodeMapping")
    def node_mapping(self) -> Optional['outputs.IntegrationTaskNodeNodeInfoNodeMapping']:
        """
        Node mapping.
        """
        return pulumi.get(self, "node_mapping")

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[_builtins.str]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[_builtins.str]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoSchema']]:
        """
        Schema information.
        """
        return pulumi.get(self, "schemas")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoNodeMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extConfigs":
            suggest = "ext_configs"
        elif key == "schemaMappings":
            suggest = "schema_mappings"
        elif key == "sinkId":
            suggest = "sink_id"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceSchemas":
            suggest = "source_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationTaskNodeNodeInfoNodeMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationTaskNodeNodeInfoNodeMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationTaskNodeNodeInfoNodeMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ext_configs: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingExtConfig']] = None,
                 schema_mappings: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping']] = None,
                 sink_id: Optional[_builtins.str] = None,
                 source_id: Optional[_builtins.str] = None,
                 source_schemas: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingSourceSchema']] = None):
        """
        :param Sequence['IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgs'] ext_configs: Node extension configuration information.
        :param Sequence['IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgs'] schema_mappings: Schema mapping information.
        :param _builtins.str sink_id: Sink node ID.
        :param _builtins.str source_id: Source node ID.
        :param Sequence['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgs'] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingExtConfig']]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping']]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[_builtins.str]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[_builtins.str]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingSourceSchema']]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoNodeMappingExtConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Configuration name.
        :param _builtins.str value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sinkSchemaId":
            suggest = "sink_schema_id"
        elif key == "sourceSchemaId":
            suggest = "source_schema_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sink_schema_id: _builtins.str,
                 source_schema_id: _builtins.str):
        """
        :param _builtins.str sink_schema_id: Schema ID from sink node.
        :param _builtins.str source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> _builtins.str:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> _builtins.str:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoNodeMappingSourceSchema(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 alias: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 properties: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaProperty']] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Schema ID.
        :param _builtins.str name: Schema name.
        :param _builtins.str type: Schema type.
        :param _builtins.str alias: Schema alias.
        :param _builtins.str comment: Schema comment.
        :param Sequence['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgs'] properties: Schema extended attributes.
        :param _builtins.str value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaProperty']]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Attributes name.
        :param _builtins.str value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoSchema(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 alias: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 properties: Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoSchemaProperty']] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Schema ID.
        :param _builtins.str name: Schema name.
        :param _builtins.str type: Schema type.
        :param _builtins.str alias: Schema alias.
        :param _builtins.str comment: Schema comment.
        :param Sequence['IntegrationTaskNodeNodeInfoSchemaPropertyArgs'] properties: Schema extended attributes.
        :param _builtins.str value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.IntegrationTaskNodeNodeInfoSchemaProperty']]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationTaskNodeNodeInfoSchemaProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Attributes name.
        :param _builtins.str value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LineageAttachmentRelations(dict):
    def __init__(__self__, *,
                 processes: 'outputs.LineageAttachmentRelationsProcesses',
                 source: 'outputs.LineageAttachmentRelationsSource',
                 target: 'outputs.LineageAttachmentRelationsTarget'):
        """
        :param 'LineageAttachmentRelationsProcessesArgs' processes: Lineage processing process.
        :param 'LineageAttachmentRelationsSourceArgs' source: Source.
        :param 'LineageAttachmentRelationsTargetArgs' target: Target.
        """
        pulumi.set(__self__, "processes", processes)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def processes(self) -> 'outputs.LineageAttachmentRelationsProcesses':
        """
        Lineage processing process.
        """
        return pulumi.get(self, "processes")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.LineageAttachmentRelationsSource':
        """
        Source.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> 'outputs.LineageAttachmentRelationsTarget':
        """
        Target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class LineageAttachmentRelationsProcesses(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processId":
            suggest = "process_id"
        elif key == "processType":
            suggest = "process_type"
        elif key == "lineageNodeId":
            suggest = "lineage_node_id"
        elif key == "processProperties":
            suggest = "process_properties"
        elif key == "processSubType":
            suggest = "process_sub_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LineageAttachmentRelationsProcesses. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LineageAttachmentRelationsProcesses.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LineageAttachmentRelationsProcesses.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 platform: _builtins.str,
                 process_id: _builtins.str,
                 process_type: _builtins.str,
                 lineage_node_id: Optional[_builtins.str] = None,
                 process_properties: Optional[Sequence['outputs.LineageAttachmentRelationsProcessesProcessProperty']] = None,
                 process_sub_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str platform: WEDATA, THIRD.
        :param _builtins.str process_id: Original unique ID.
        :param _builtins.str process_type: Task type.
               //Scheduled task
               SCHEDULE_TASK,
               //Integration task
               INTEGRATION_TASK,
               //Third-party reporting
               THIRD_REPORT,
               //Data modeling
               TABLE_MODEL,
               //Model creates metric
               MODEL_METRIC,
               //Atomic metric creates derived metric
               METRIC_METRIC,
               //Data service
               DATA_SERVICE.
        :param _builtins.str lineage_node_id: Lineage task unique node ID.
        :param Sequence['LineageAttachmentRelationsProcessesProcessPropertyArgs'] process_properties: Additional extension parameters.
        :param _builtins.str process_sub_type: Task subtype.
               SQL_TASK,
               //Integrated real-time task lineage
               INTEGRATED_STREAM,
               //Integrated offline task lineage
               INTEGRATED_OFFLINE.
        """
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "process_id", process_id)
        pulumi.set(__self__, "process_type", process_type)
        if lineage_node_id is not None:
            pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        if process_properties is not None:
            pulumi.set(__self__, "process_properties", process_properties)
        if process_sub_type is not None:
            pulumi.set(__self__, "process_sub_type", process_sub_type)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        WEDATA, THIRD.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="processId")
    def process_id(self) -> _builtins.str:
        """
        Original unique ID.
        """
        return pulumi.get(self, "process_id")

    @_builtins.property
    @pulumi.getter(name="processType")
    def process_type(self) -> _builtins.str:
        """
        Task type.
        //Scheduled task
        SCHEDULE_TASK,
        //Integration task
        INTEGRATION_TASK,
        //Third-party reporting
        THIRD_REPORT,
        //Data modeling
        TABLE_MODEL,
        //Model creates metric
        MODEL_METRIC,
        //Atomic metric creates derived metric
        METRIC_METRIC,
        //Data service
        DATA_SERVICE.
        """
        return pulumi.get(self, "process_type")

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> Optional[_builtins.str]:
        """
        Lineage task unique node ID.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter(name="processProperties")
    def process_properties(self) -> Optional[Sequence['outputs.LineageAttachmentRelationsProcessesProcessProperty']]:
        """
        Additional extension parameters.
        """
        return pulumi.get(self, "process_properties")

    @_builtins.property
    @pulumi.getter(name="processSubType")
    def process_sub_type(self) -> Optional[_builtins.str]:
        """
        Task subtype.
        SQL_TASK,
        //Integrated real-time task lineage
        INTEGRATED_STREAM,
        //Integrated offline task lineage
        INTEGRATED_OFFLINE.
        """
        return pulumi.get(self, "process_sub_type")


@pulumi.output_type
class LineageAttachmentRelationsProcessesProcessProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LineageAttachmentRelationsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "resourceUniqueId":
            suggest = "resource_unique_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "lineageNodeId":
            suggest = "lineage_node_id"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "resourceProperties":
            suggest = "resource_properties"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LineageAttachmentRelationsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LineageAttachmentRelationsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LineageAttachmentRelationsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 platform: _builtins.str,
                 resource_type: _builtins.str,
                 resource_unique_id: _builtins.str,
                 create_time: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 lineage_node_id: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None,
                 resource_properties: Optional[Sequence['outputs.LineageAttachmentRelationsSourceResourceProperty']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str platform: Source: WEDATA|THIRD.
               Default is wedata.
        :param _builtins.str resource_type: Entity type.
               TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param _builtins.str resource_unique_id: Entity original unique ID.\\n
               Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        :param _builtins.str create_time: Creation time.
        :param _builtins.str description: Description: table type | metric description | model description | field description.
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str resource_name: Business name: database.table | metric name | model name | field name.
        :param Sequence['LineageAttachmentRelationsSourceResourcePropertyArgs'] resource_properties: Resource additional extension parameters.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if lineage_node_id is not None:
            pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD.
        Default is wedata.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> _builtins.str:
        """
        Entity original unique ID.\\n
        Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        """
        return pulumi.get(self, "resource_unique_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description: table type | metric description | model description | field description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> Optional[_builtins.str]:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        Business name: database.table | metric name | model name | field name.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional[Sequence['outputs.LineageAttachmentRelationsSourceResourceProperty']]:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class LineageAttachmentRelationsSourceResourceProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LineageAttachmentRelationsTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "resourceUniqueId":
            suggest = "resource_unique_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "lineageNodeId":
            suggest = "lineage_node_id"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "resourceProperties":
            suggest = "resource_properties"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LineageAttachmentRelationsTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LineageAttachmentRelationsTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LineageAttachmentRelationsTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 platform: _builtins.str,
                 resource_type: _builtins.str,
                 resource_unique_id: _builtins.str,
                 create_time: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 lineage_node_id: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None,
                 resource_properties: Optional[Sequence['outputs.LineageAttachmentRelationsTargetResourceProperty']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str platform: Source: WEDATA|THIRD.
               Default is wedata.
        :param _builtins.str resource_type: Entity type.
               TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param _builtins.str resource_unique_id: Entity original unique ID.\\n
               Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        :param _builtins.str create_time: Creation time.
        :param _builtins.str description: Description: table type | metric description | model description | field description.
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str resource_name: Business name: database.table | metric name | model name | field name.
        :param Sequence['LineageAttachmentRelationsTargetResourcePropertyArgs'] resource_properties: Resource additional extension parameters.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if lineage_node_id is not None:
            pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD.
        Default is wedata.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> _builtins.str:
        """
        Entity original unique ID.\\n
        Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        """
        return pulumi.get(self, "resource_unique_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description: table type | metric description | model description | field description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> Optional[_builtins.str]:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        Business name: database.table | metric name | model name | field name.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional[Sequence['outputs.LineageAttachmentRelationsTargetResourceProperty']]:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class LineageAttachmentRelationsTargetResourceProperty(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OpsAlarmRuleAlarmGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmEscalationInterval":
            suggest = "alarm_escalation_interval"
        elif key == "alarmEscalationRecipientIds":
            suggest = "alarm_escalation_recipient_ids"
        elif key == "alarmRecipientIds":
            suggest = "alarm_recipient_ids"
        elif key == "alarmRecipientType":
            suggest = "alarm_recipient_type"
        elif key == "alarmWays":
            suggest = "alarm_ways"
        elif key == "notificationFatigue":
            suggest = "notification_fatigue"
        elif key == "webHooks":
            suggest = "web_hooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_escalation_interval: Optional[_builtins.int] = None,
                 alarm_escalation_recipient_ids: Optional[Sequence[_builtins.str]] = None,
                 alarm_recipient_ids: Optional[Sequence[_builtins.str]] = None,
                 alarm_recipient_type: Optional[_builtins.int] = None,
                 alarm_ways: Optional[Sequence[_builtins.str]] = None,
                 notification_fatigue: Optional['outputs.OpsAlarmRuleAlarmGroupNotificationFatigue'] = None,
                 web_hooks: Optional[Sequence['outputs.OpsAlarmRuleAlarmGroupWebHook']] = None):
        """
        :param _builtins.int alarm_escalation_interval: Alarm escalation interval.
        :param Sequence[_builtins.str] alarm_escalation_recipient_ids: Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.
        :param Sequence[_builtins.str] alarm_recipient_ids: Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.
        :param _builtins.int alarm_recipient_type: Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).
        :param Sequence[_builtins.str] alarm_ways: Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.
        :param 'OpsAlarmRuleAlarmGroupNotificationFatigueArgs' notification_fatigue: Alarm notification fatigue configuration.
        :param Sequence['OpsAlarmRuleAlarmGroupWebHookArgs'] web_hooks: List of webhook addresses for the alarm group.
        """
        if alarm_escalation_interval is not None:
            pulumi.set(__self__, "alarm_escalation_interval", alarm_escalation_interval)
        if alarm_escalation_recipient_ids is not None:
            pulumi.set(__self__, "alarm_escalation_recipient_ids", alarm_escalation_recipient_ids)
        if alarm_recipient_ids is not None:
            pulumi.set(__self__, "alarm_recipient_ids", alarm_recipient_ids)
        if alarm_recipient_type is not None:
            pulumi.set(__self__, "alarm_recipient_type", alarm_recipient_type)
        if alarm_ways is not None:
            pulumi.set(__self__, "alarm_ways", alarm_ways)
        if notification_fatigue is not None:
            pulumi.set(__self__, "notification_fatigue", notification_fatigue)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @_builtins.property
    @pulumi.getter(name="alarmEscalationInterval")
    def alarm_escalation_interval(self) -> Optional[_builtins.int]:
        """
        Alarm escalation interval.
        """
        return pulumi.get(self, "alarm_escalation_interval")

    @_builtins.property
    @pulumi.getter(name="alarmEscalationRecipientIds")
    def alarm_escalation_recipient_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.
        """
        return pulumi.get(self, "alarm_escalation_recipient_ids")

    @_builtins.property
    @pulumi.getter(name="alarmRecipientIds")
    def alarm_recipient_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.
        """
        return pulumi.get(self, "alarm_recipient_ids")

    @_builtins.property
    @pulumi.getter(name="alarmRecipientType")
    def alarm_recipient_type(self) -> Optional[_builtins.int]:
        """
        Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).
        """
        return pulumi.get(self, "alarm_recipient_type")

    @_builtins.property
    @pulumi.getter(name="alarmWays")
    def alarm_ways(self) -> Optional[Sequence[_builtins.str]]:
        """
        Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.
        """
        return pulumi.get(self, "alarm_ways")

    @_builtins.property
    @pulumi.getter(name="notificationFatigue")
    def notification_fatigue(self) -> Optional['outputs.OpsAlarmRuleAlarmGroupNotificationFatigue']:
        """
        Alarm notification fatigue configuration.
        """
        return pulumi.get(self, "notification_fatigue")

    @_builtins.property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[Sequence['outputs.OpsAlarmRuleAlarmGroupWebHook']]:
        """
        List of webhook addresses for the alarm group.
        """
        return pulumi.get(self, "web_hooks")


@pulumi.output_type
class OpsAlarmRuleAlarmGroupNotificationFatigue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyCount":
            suggest = "notify_count"
        elif key == "notifyInterval":
            suggest = "notify_interval"
        elif key == "quietIntervals":
            suggest = "quiet_intervals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmGroupNotificationFatigue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmGroupNotificationFatigue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmGroupNotificationFatigue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_count: Optional[_builtins.int] = None,
                 notify_interval: Optional[_builtins.int] = None,
                 quiet_intervals: Optional[Sequence['outputs.OpsAlarmRuleAlarmGroupNotificationFatigueQuietInterval']] = None):
        """
        :param _builtins.int notify_count: Number of alarms.
        :param _builtins.int notify_interval: Alarm interval, in minutes.
        :param Sequence['OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgs'] quiet_intervals: Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: "00:00:00", EndTime: "09:00:00"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.
        """
        if notify_count is not None:
            pulumi.set(__self__, "notify_count", notify_count)
        if notify_interval is not None:
            pulumi.set(__self__, "notify_interval", notify_interval)
        if quiet_intervals is not None:
            pulumi.set(__self__, "quiet_intervals", quiet_intervals)

    @_builtins.property
    @pulumi.getter(name="notifyCount")
    def notify_count(self) -> Optional[_builtins.int]:
        """
        Number of alarms.
        """
        return pulumi.get(self, "notify_count")

    @_builtins.property
    @pulumi.getter(name="notifyInterval")
    def notify_interval(self) -> Optional[_builtins.int]:
        """
        Alarm interval, in minutes.
        """
        return pulumi.get(self, "notify_interval")

    @_builtins.property
    @pulumi.getter(name="quietIntervals")
    def quiet_intervals(self) -> Optional[Sequence['outputs.OpsAlarmRuleAlarmGroupNotificationFatigueQuietInterval']]:
        """
        Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: "00:00:00", EndTime: "09:00:00"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.
        """
        return pulumi.get(self, "quiet_intervals")


@pulumi.output_type
class OpsAlarmRuleAlarmGroupNotificationFatigueQuietInterval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmGroupNotificationFatigueQuietInterval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmGroupNotificationFatigueQuietInterval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmGroupNotificationFatigueQuietInterval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.int] days_of_weeks: According to the ISO standard, 1 represents Monday and 7 represents Sunday.
        :param _builtins.str end_time: End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        :param _builtins.str start_time: Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[_builtins.int]]:
        """
        According to the ISO standard, 1 represents Monday and 7 represents Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class OpsAlarmRuleAlarmGroupWebHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmWay":
            suggest = "alarm_way"
        elif key == "webHooks":
            suggest = "web_hooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmGroupWebHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmGroupWebHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmGroupWebHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_way: Optional[_builtins.str] = None,
                 web_hooks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str alarm_way: Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.
        :param Sequence[_builtins.str] web_hooks: List of webhook addresses for the alarm group.
        """
        if alarm_way is not None:
            pulumi.set(__self__, "alarm_way", alarm_way)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @_builtins.property
    @pulumi.getter(name="alarmWay")
    def alarm_way(self) -> Optional[_builtins.str]:
        """
        Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.
        """
        return pulumi.get(self, "alarm_way")

    @_builtins.property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of webhook addresses for the alarm group.
        """
        return pulumi.get(self, "web_hooks")


@pulumi.output_type
class OpsAlarmRuleAlarmRuleDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataBackfillOrRerunTimeOutExtInfos":
            suggest = "data_backfill_or_rerun_time_out_ext_infos"
        elif key == "dataBackfillOrRerunTrigger":
            suggest = "data_backfill_or_rerun_trigger"
        elif key == "projectInstanceStatisticsAlarmInfoLists":
            suggest = "project_instance_statistics_alarm_info_lists"
        elif key == "reconciliationExtInfos":
            suggest = "reconciliation_ext_infos"
        elif key == "timeOutExtInfos":
            suggest = "time_out_ext_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmRuleDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmRuleDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmRuleDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_backfill_or_rerun_time_out_ext_infos: Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfo']] = None,
                 data_backfill_or_rerun_trigger: Optional[_builtins.int] = None,
                 project_instance_statistics_alarm_info_lists: Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoList']] = None,
                 reconciliation_ext_infos: Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailReconciliationExtInfo']] = None,
                 time_out_ext_infos: Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailTimeOutExtInfo']] = None,
                 trigger: Optional[_builtins.int] = None):
        """
        :param Sequence['OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs'] data_backfill_or_rerun_time_out_ext_infos: Detailed configuration of re-running and re-recording instance timeout.
        :param _builtins.int data_backfill_or_rerun_trigger: Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.
        :param Sequence['OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs'] project_instance_statistics_alarm_info_lists: Project fluctuation alarm configuration details.
        :param Sequence['OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgs'] reconciliation_ext_infos: Offline integrated reconciliation alarm configuration information.
        :param Sequence['OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgs'] time_out_ext_infos: Periodic instance timeout configuration details.
        :param _builtins.int trigger: Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).
        """
        if data_backfill_or_rerun_time_out_ext_infos is not None:
            pulumi.set(__self__, "data_backfill_or_rerun_time_out_ext_infos", data_backfill_or_rerun_time_out_ext_infos)
        if data_backfill_or_rerun_trigger is not None:
            pulumi.set(__self__, "data_backfill_or_rerun_trigger", data_backfill_or_rerun_trigger)
        if project_instance_statistics_alarm_info_lists is not None:
            pulumi.set(__self__, "project_instance_statistics_alarm_info_lists", project_instance_statistics_alarm_info_lists)
        if reconciliation_ext_infos is not None:
            pulumi.set(__self__, "reconciliation_ext_infos", reconciliation_ext_infos)
        if time_out_ext_infos is not None:
            pulumi.set(__self__, "time_out_ext_infos", time_out_ext_infos)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter(name="dataBackfillOrRerunTimeOutExtInfos")
    def data_backfill_or_rerun_time_out_ext_infos(self) -> Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfo']]:
        """
        Detailed configuration of re-running and re-recording instance timeout.
        """
        return pulumi.get(self, "data_backfill_or_rerun_time_out_ext_infos")

    @_builtins.property
    @pulumi.getter(name="dataBackfillOrRerunTrigger")
    def data_backfill_or_rerun_trigger(self) -> Optional[_builtins.int]:
        """
        Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.
        """
        return pulumi.get(self, "data_backfill_or_rerun_trigger")

    @_builtins.property
    @pulumi.getter(name="projectInstanceStatisticsAlarmInfoLists")
    def project_instance_statistics_alarm_info_lists(self) -> Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoList']]:
        """
        Project fluctuation alarm configuration details.
        """
        return pulumi.get(self, "project_instance_statistics_alarm_info_lists")

    @_builtins.property
    @pulumi.getter(name="reconciliationExtInfos")
    def reconciliation_ext_infos(self) -> Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailReconciliationExtInfo']]:
        """
        Offline integrated reconciliation alarm configuration information.
        """
        return pulumi.get(self, "reconciliation_ext_infos")

    @_builtins.property
    @pulumi.getter(name="timeOutExtInfos")
    def time_out_ext_infos(self) -> Optional[Sequence['outputs.OpsAlarmRuleAlarmRuleDetailTimeOutExtInfo']]:
        """
        Periodic instance timeout configuration details.
        """
        return pulumi.get(self, "time_out_ext_infos")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional[_builtins.int]:
        """
        Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "scheduleTimeZone":
            suggest = "schedule_time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hour: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 rule_type: Optional[_builtins.int] = None,
                 schedule_time_zone: Optional[_builtins.str] = None,
                 type: Optional[_builtins.int] = None):
        """
        :param _builtins.int hour: Specify the timeout value in hours. The default value is 0.
        :param _builtins.int min: The timeout value is specified in minutes. The default value is 1.
        :param _builtins.int rule_type: Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        :param _builtins.str schedule_time_zone: The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        :param _builtins.int type: Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Specify the timeout value in hours. The default value is 0.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.int]:
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.int]:
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmType":
            suggest = "alarm_type"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceThresholdCount":
            suggest = "instance_threshold_count"
        elif key == "instanceThresholdCountPercent":
            suggest = "instance_threshold_count_percent"
        elif key == "isCumulant":
            suggest = "is_cumulant"
        elif key == "stabilizeStatisticsCycle":
            suggest = "stabilize_statistics_cycle"
        elif key == "stabilizeThreshold":
            suggest = "stabilize_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_type: _builtins.str,
                 instance_count: Optional[_builtins.int] = None,
                 instance_threshold_count: Optional[_builtins.int] = None,
                 instance_threshold_count_percent: Optional[_builtins.int] = None,
                 is_cumulant: Optional[_builtins.bool] = None,
                 stabilize_statistics_cycle: Optional[_builtins.int] = None,
                 stabilize_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str alarm_type: Alarm type: projectFailureInstanceUpwardFluctuationAlarm: Failure instance upward fluctuation alarm; projectSuccessInstanceDownwardFluctuationAlarm: Success instance downward fluctuation alarm.
        :param _builtins.int instance_count: The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.
        :param _builtins.int instance_threshold_count: The cumulative instance number fluctuation threshold.
        :param _builtins.int instance_threshold_count_percent: The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.
        :param _builtins.bool is_cumulant: Whether to calculate cumulatively, false: continuous, true: cumulative.
        :param _builtins.int stabilize_statistics_cycle: Stability statistics period (number of anti-shake configuration statistics periods).
        :param _builtins.int stabilize_threshold: Stability threshold (number of statistical cycles for anti-shake configuration).
        """
        pulumi.set(__self__, "alarm_type", alarm_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_threshold_count is not None:
            pulumi.set(__self__, "instance_threshold_count", instance_threshold_count)
        if instance_threshold_count_percent is not None:
            pulumi.set(__self__, "instance_threshold_count_percent", instance_threshold_count_percent)
        if is_cumulant is not None:
            pulumi.set(__self__, "is_cumulant", is_cumulant)
        if stabilize_statistics_cycle is not None:
            pulumi.set(__self__, "stabilize_statistics_cycle", stabilize_statistics_cycle)
        if stabilize_threshold is not None:
            pulumi.set(__self__, "stabilize_threshold", stabilize_threshold)

    @_builtins.property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> _builtins.str:
        """
        Alarm type: projectFailureInstanceUpwardFluctuationAlarm: Failure instance upward fluctuation alarm; projectSuccessInstanceDownwardFluctuationAlarm: Success instance downward fluctuation alarm.
        """
        return pulumi.get(self, "alarm_type")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceThresholdCount")
    def instance_threshold_count(self) -> Optional[_builtins.int]:
        """
        The cumulative instance number fluctuation threshold.
        """
        return pulumi.get(self, "instance_threshold_count")

    @_builtins.property
    @pulumi.getter(name="instanceThresholdCountPercent")
    def instance_threshold_count_percent(self) -> Optional[_builtins.int]:
        """
        The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.
        """
        return pulumi.get(self, "instance_threshold_count_percent")

    @_builtins.property
    @pulumi.getter(name="isCumulant")
    def is_cumulant(self) -> Optional[_builtins.bool]:
        """
        Whether to calculate cumulatively, false: continuous, true: cumulative.
        """
        return pulumi.get(self, "is_cumulant")

    @_builtins.property
    @pulumi.getter(name="stabilizeStatisticsCycle")
    def stabilize_statistics_cycle(self) -> Optional[_builtins.int]:
        """
        Stability statistics period (number of anti-shake configuration statistics periods).
        """
        return pulumi.get(self, "stabilize_statistics_cycle")

    @_builtins.property
    @pulumi.getter(name="stabilizeThreshold")
    def stabilize_threshold(self) -> Optional[_builtins.int]:
        """
        Stability threshold (number of statistical cycles for anti-shake configuration).
        """
        return pulumi.get(self, "stabilize_threshold")


@pulumi.output_type
class OpsAlarmRuleAlarmRuleDetailReconciliationExtInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mismatchCount":
            suggest = "mismatch_count"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmRuleDetailReconciliationExtInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmRuleDetailReconciliationExtInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmRuleDetailReconciliationExtInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hour: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 mismatch_count: Optional[_builtins.int] = None,
                 rule_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int hour: Reconciliation task timeout threshold: hours, default is 0.
        :param _builtins.int min: Reconciliation task timeout threshold: minutes, default is 1.
        :param _builtins.int mismatch_count: Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.
        :param _builtins.str rule_type: Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if mismatch_count is not None:
            pulumi.set(__self__, "mismatch_count", mismatch_count)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Reconciliation task timeout threshold: hours, default is 0.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Reconciliation task timeout threshold: minutes, default is 1.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="mismatchCount")
    def mismatch_count(self) -> Optional[_builtins.int]:
        """
        Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.
        """
        return pulumi.get(self, "mismatch_count")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.str]:
        """
        Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class OpsAlarmRuleAlarmRuleDetailTimeOutExtInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "scheduleTimeZone":
            suggest = "schedule_time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpsAlarmRuleAlarmRuleDetailTimeOutExtInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpsAlarmRuleAlarmRuleDetailTimeOutExtInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpsAlarmRuleAlarmRuleDetailTimeOutExtInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hour: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 rule_type: Optional[_builtins.int] = None,
                 schedule_time_zone: Optional[_builtins.str] = None,
                 type: Optional[_builtins.int] = None):
        """
        :param _builtins.int hour: Specify the timeout value in hours. The default value is 0.
        :param _builtins.int min: The timeout value is specified in minutes. The default value is 1.
        :param _builtins.int rule_type: Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        :param _builtins.str schedule_time_zone: The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        :param _builtins.int type: Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Specify the timeout value in hours. The default value is 0.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.int]:
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.int]:
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectDlcInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeResources":
            suggest = "compute_resources"
        elif key == "defaultDatabase":
            suggest = "default_database"
        elif key == "accessAccount":
            suggest = "access_account"
        elif key == "standardModeEnvTag":
            suggest = "standard_mode_env_tag"
        elif key == "subAccountUin":
            suggest = "sub_account_uin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectDlcInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectDlcInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectDlcInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_resources: Sequence[_builtins.str],
                 default_database: _builtins.str,
                 region: _builtins.str,
                 access_account: Optional[_builtins.str] = None,
                 standard_mode_env_tag: Optional[_builtins.str] = None,
                 sub_account_uin: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] compute_resources: DLC resource name (need to add role Uin to DLC, otherwise may not be able to obtain resources).
        :param _builtins.str default_database: Specify the default database for DLC cluster.
        :param _builtins.str region: DLC region.
        :param _builtins.str access_account: Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
               It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failure when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.
               
               Enum values:
               - TASK_RUNNER (Task Runner)
               - OWNER (Main Account Mode)
               - SUB (Sub Account Mode).
        :param _builtins.str standard_mode_env_tag: Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
               - Prod  (Production environment)
               - Dev  (Development environment).
        :param _builtins.str sub_account_uin: Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        pulumi.set(__self__, "compute_resources", compute_resources)
        pulumi.set(__self__, "default_database", default_database)
        pulumi.set(__self__, "region", region)
        if access_account is not None:
            pulumi.set(__self__, "access_account", access_account)
        if standard_mode_env_tag is not None:
            pulumi.set(__self__, "standard_mode_env_tag", standard_mode_env_tag)
        if sub_account_uin is not None:
            pulumi.set(__self__, "sub_account_uin", sub_account_uin)

    @_builtins.property
    @pulumi.getter(name="computeResources")
    def compute_resources(self) -> Sequence[_builtins.str]:
        """
        DLC resource name (need to add role Uin to DLC, otherwise may not be able to obtain resources).
        """
        return pulumi.get(self, "compute_resources")

    @_builtins.property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> _builtins.str:
        """
        Specify the default database for DLC cluster.
        """
        return pulumi.get(self, "default_database")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        DLC region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessAccount")
    def access_account(self) -> Optional[_builtins.str]:
        """
        Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
        It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failure when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.

        Enum values:
        - TASK_RUNNER (Task Runner)
        - OWNER (Main Account Mode)
        - SUB (Sub Account Mode).
        """
        return pulumi.get(self, "access_account")

    @_builtins.property
    @pulumi.getter(name="standardModeEnvTag")
    def standard_mode_env_tag(self) -> Optional[_builtins.str]:
        """
        Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
        - Prod  (Production environment)
        - Dev  (Development environment).
        """
        return pulumi.get(self, "standard_mode_env_tag")

    @_builtins.property
    @pulumi.getter(name="subAccountUin")
    def sub_account_uin(self) -> Optional[_builtins.str]:
        """
        Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        return pulumi.get(self, "sub_account_uin")


@pulumi.output_type
class ProjectProject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "projectModel":
            suggest = "project_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectProject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectProject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectProject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: _builtins.str,
                 project_name: _builtins.str,
                 project_model: Optional[_builtins.str] = None):
        """
        :param _builtins.str display_name: Project display name, can be Chinese name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        :param _builtins.str project_name: Project identifier, English name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        :param _builtins.str project_model: Project mode, SIMPLE (default): Simple mode STANDARD: Standard mode.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "project_name", project_name)
        if project_model is not None:
            pulumi.set(__self__, "project_model", project_model)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Project display name, can be Chinese name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> _builtins.str:
        """
        Project identifier, English name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter(name="projectModel")
    def project_model(self) -> Optional[_builtins.str]:
        """
        Project mode, SIMPLE (default): Simple mode STANDARD: Standard mode.
        """
        return pulumi.get(self, "project_model")


@pulumi.output_type
class SqlScriptScriptConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advanceConfig":
            suggest = "advance_config"
        elif key == "computeResource":
            suggest = "compute_resource"
        elif key == "datasourceEnv":
            suggest = "datasource_env"
        elif key == "datasourceId":
            suggest = "datasource_id"
        elif key == "executorGroupId":
            suggest = "executor_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlScriptScriptConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlScriptScriptConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlScriptScriptConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advance_config: Optional[_builtins.str] = None,
                 compute_resource: Optional[_builtins.str] = None,
                 datasource_env: Optional[_builtins.str] = None,
                 datasource_id: Optional[_builtins.str] = None,
                 executor_group_id: Optional[_builtins.str] = None,
                 params: Optional[_builtins.str] = None):
        """
        :param _builtins.str advance_config: Advanced settings, execution configuration parameters, map-json String,String. Encoded in Base64.
        :param _builtins.str compute_resource: Computing resource.
        :param _builtins.str datasource_env: Data source environment.
        :param _builtins.str datasource_id: Data source ID.
        :param _builtins.str executor_group_id: Execution resource group.
        :param _builtins.str params: Advanced runtime parameters, variable substitution, map-json String,String.
        """
        if advance_config is not None:
            pulumi.set(__self__, "advance_config", advance_config)
        if compute_resource is not None:
            pulumi.set(__self__, "compute_resource", compute_resource)
        if datasource_env is not None:
            pulumi.set(__self__, "datasource_env", datasource_env)
        if datasource_id is not None:
            pulumi.set(__self__, "datasource_id", datasource_id)
        if executor_group_id is not None:
            pulumi.set(__self__, "executor_group_id", executor_group_id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter(name="advanceConfig")
    def advance_config(self) -> Optional[_builtins.str]:
        """
        Advanced settings, execution configuration parameters, map-json String,String. Encoded in Base64.
        """
        return pulumi.get(self, "advance_config")

    @_builtins.property
    @pulumi.getter(name="computeResource")
    def compute_resource(self) -> Optional[_builtins.str]:
        """
        Computing resource.
        """
        return pulumi.get(self, "compute_resource")

    @_builtins.property
    @pulumi.getter(name="datasourceEnv")
    def datasource_env(self) -> Optional[_builtins.str]:
        """
        Data source environment.
        """
        return pulumi.get(self, "datasource_env")

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> Optional[_builtins.str]:
        """
        Data source ID.
        """
        return pulumi.get(self, "datasource_id")

    @_builtins.property
    @pulumi.getter(name="executorGroupId")
    def executor_group_id(self) -> Optional[_builtins.str]:
        """
        Execution resource group.
        """
        return pulumi.get(self, "executor_group_id")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[_builtins.str]:
        """
        Advanced runtime parameters, variable substitution, map-json String,String.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class TaskRerunInstanceAsyncRedefineParamList(dict):
    def __init__(__self__, *,
                 k: Optional[_builtins.str] = None,
                 v: Optional[_builtins.str] = None):
        """
        :param _builtins.str k: Key.
        :param _builtins.str v: Value.
        """
        if k is not None:
            pulumi.set(__self__, "k", k)
        if v is not None:
            pulumi.set(__self__, "v", v)

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter
    def v(self) -> Optional[_builtins.str]:
        """
        Value.
        """
        return pulumi.get(self, "v")


@pulumi.output_type
class TaskTaskBaseAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskName":
            suggest = "task_name"
        elif key == "taskTypeId":
            suggest = "task_type_id"
        elif key == "workflowId":
            suggest = "workflow_id"
        elif key == "ownerUin":
            suggest = "owner_uin"
        elif key == "taskDescription":
            suggest = "task_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskBaseAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskBaseAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskBaseAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_name: _builtins.str,
                 task_type_id: _builtins.str,
                 workflow_id: _builtins.str,
                 owner_uin: Optional[_builtins.str] = None,
                 task_description: Optional[_builtins.str] = None):
        """
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type_id: Task type ID:
               
               * 21:JDBC SQL
               * 23:TDSQL-PostgreSQL
               * 26:OfflineSynchronization
               * 30:Python
               * 31:PySpark
               * 32:DLC SQL
               * 33:Impala
               * 34:Hive SQL
               * 35:Shell
               * 36:Spark SQL
               * 38:Shell Form Mode
               * 39:Spark
               * 40:TCHouse-P
               * 41:Kettle
               * 42:Tchouse-X
               * 43:TCHouse-X SQL
               * 46:DLC Spark
               * 47:TiOne
               * 48:Trino
               * 50:DLC PySpark
               * 92:MapReduce
               * 130:Branch Node
               * 131:Merged Node
               * 132:Notebook
               * 133:SSH
               * 134:StarRocks
               * 137:For-each
               * 138:Setats SQL.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str owner_uin: Task owner ID, defaults to current user.
        :param _builtins.str task_description: Task description.
        """
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if task_description is not None:
            pulumi.set(__self__, "task_description", task_description)

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.str:
        """
        Task type ID:

        * 21:JDBC SQL
        * 23:TDSQL-PostgreSQL
        * 26:OfflineSynchronization
        * 30:Python
        * 31:PySpark
        * 32:DLC SQL
        * 33:Impala
        * 34:Hive SQL
        * 35:Shell
        * 36:Spark SQL
        * 38:Shell Form Mode
        * 39:Spark
        * 40:TCHouse-P
        * 41:Kettle
        * 42:Tchouse-X
        * 43:TCHouse-X SQL
        * 46:DLC Spark
        * 47:TiOne
        * 48:Trino
        * 50:DLC PySpark
        * 92:MapReduce
        * 130:Branch Node
        * 131:Merged Node
        * 132:Notebook
        * 133:SSH
        * 134:StarRocks
        * 137:For-each
        * 138:Setats SQL.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[_builtins.str]:
        """
        Task owner ID, defaults to current user.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="taskDescription")
    def task_description(self) -> Optional[_builtins.str]:
        """
        Task description.
        """
        return pulumi.get(self, "task_description")


@pulumi.output_type
class TaskTaskConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerIp":
            suggest = "broker_ip"
        elif key == "bundleId":
            suggest = "bundle_id"
        elif key == "bundleInfo":
            suggest = "bundle_info"
        elif key == "codeContent":
            suggest = "code_content"
        elif key == "dataCluster":
            suggest = "data_cluster"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "sourceServiceId":
            suggest = "source_service_id"
        elif key == "targetServiceId":
            suggest = "target_service_id"
        elif key == "taskExtConfigurationLists":
            suggest = "task_ext_configuration_lists"
        elif key == "taskSchedulingParameterLists":
            suggest = "task_scheduling_parameter_lists"
        elif key == "yarnQueue":
            suggest = "yarn_queue"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_ip: Optional[_builtins.str] = None,
                 bundle_id: Optional[_builtins.str] = None,
                 bundle_info: Optional[_builtins.str] = None,
                 code_content: Optional[_builtins.str] = None,
                 data_cluster: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 source_service_id: Optional[_builtins.str] = None,
                 target_service_id: Optional[_builtins.str] = None,
                 task_ext_configuration_lists: Optional[Sequence['outputs.TaskTaskConfigurationTaskExtConfigurationList']] = None,
                 task_scheduling_parameter_lists: Optional[Sequence['outputs.TaskTaskConfigurationTaskSchedulingParameterList']] = None,
                 yarn_queue: Optional[_builtins.str] = None):
        """
        :param _builtins.str broker_ip: Specified running node.
        :param _builtins.str bundle_id: ID used by Bundle.
        :param _builtins.str bundle_info: Bundle information.
        :param _builtins.str code_content: Base64 encoded code content.
        :param _builtins.str data_cluster: Cluster ID.
        :param _builtins.str resource_group: Resource group ID: Need to obtain ExecutorGroupId via DescribeNormalSchedulerExecutorGroups.
        :param _builtins.str source_service_id: Source data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        :param _builtins.str target_service_id: Target data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        :param Sequence['TaskTaskConfigurationTaskExtConfigurationListArgs'] task_ext_configuration_lists: Task extended attribute configuration list.
        :param Sequence['TaskTaskConfigurationTaskSchedulingParameterListArgs'] task_scheduling_parameter_lists: Scheduling parameters.
        :param _builtins.str yarn_queue: Resource pool queue name, need to obtain via DescribeProjectClusterQueues.
        """
        if broker_ip is not None:
            pulumi.set(__self__, "broker_ip", broker_ip)
        if bundle_id is not None:
            pulumi.set(__self__, "bundle_id", bundle_id)
        if bundle_info is not None:
            pulumi.set(__self__, "bundle_info", bundle_info)
        if code_content is not None:
            pulumi.set(__self__, "code_content", code_content)
        if data_cluster is not None:
            pulumi.set(__self__, "data_cluster", data_cluster)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if source_service_id is not None:
            pulumi.set(__self__, "source_service_id", source_service_id)
        if target_service_id is not None:
            pulumi.set(__self__, "target_service_id", target_service_id)
        if task_ext_configuration_lists is not None:
            pulumi.set(__self__, "task_ext_configuration_lists", task_ext_configuration_lists)
        if task_scheduling_parameter_lists is not None:
            pulumi.set(__self__, "task_scheduling_parameter_lists", task_scheduling_parameter_lists)
        if yarn_queue is not None:
            pulumi.set(__self__, "yarn_queue", yarn_queue)

    @_builtins.property
    @pulumi.getter(name="brokerIp")
    def broker_ip(self) -> Optional[_builtins.str]:
        """
        Specified running node.
        """
        return pulumi.get(self, "broker_ip")

    @_builtins.property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> Optional[_builtins.str]:
        """
        ID used by Bundle.
        """
        return pulumi.get(self, "bundle_id")

    @_builtins.property
    @pulumi.getter(name="bundleInfo")
    def bundle_info(self) -> Optional[_builtins.str]:
        """
        Bundle information.
        """
        return pulumi.get(self, "bundle_info")

    @_builtins.property
    @pulumi.getter(name="codeContent")
    def code_content(self) -> Optional[_builtins.str]:
        """
        Base64 encoded code content.
        """
        return pulumi.get(self, "code_content")

    @_builtins.property
    @pulumi.getter(name="dataCluster")
    def data_cluster(self) -> Optional[_builtins.str]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "data_cluster")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        Resource group ID: Need to obtain ExecutorGroupId via DescribeNormalSchedulerExecutorGroups.
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="sourceServiceId")
    def source_service_id(self) -> Optional[_builtins.str]:
        """
        Source data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        """
        return pulumi.get(self, "source_service_id")

    @_builtins.property
    @pulumi.getter(name="targetServiceId")
    def target_service_id(self) -> Optional[_builtins.str]:
        """
        Target data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        """
        return pulumi.get(self, "target_service_id")

    @_builtins.property
    @pulumi.getter(name="taskExtConfigurationLists")
    def task_ext_configuration_lists(self) -> Optional[Sequence['outputs.TaskTaskConfigurationTaskExtConfigurationList']]:
        """
        Task extended attribute configuration list.
        """
        return pulumi.get(self, "task_ext_configuration_lists")

    @_builtins.property
    @pulumi.getter(name="taskSchedulingParameterLists")
    def task_scheduling_parameter_lists(self) -> Optional[Sequence['outputs.TaskTaskConfigurationTaskSchedulingParameterList']]:
        """
        Scheduling parameters.
        """
        return pulumi.get(self, "task_scheduling_parameter_lists")

    @_builtins.property
    @pulumi.getter(name="yarnQueue")
    def yarn_queue(self) -> Optional[_builtins.str]:
        """
        Resource pool queue name, need to obtain via DescribeProjectClusterQueues.
        """
        return pulumi.get(self, "yarn_queue")


@pulumi.output_type
class TaskTaskConfigurationTaskExtConfigurationList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramKey":
            suggest = "param_key"
        elif key == "paramValue":
            suggest = "param_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskConfigurationTaskExtConfigurationList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskConfigurationTaskExtConfigurationList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskConfigurationTaskExtConfigurationList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class TaskTaskConfigurationTaskSchedulingParameterList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramKey":
            suggest = "param_key"
        elif key == "paramValue":
            suggest = "param_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskConfigurationTaskSchedulingParameterList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskConfigurationTaskSchedulingParameterList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskConfigurationTaskSchedulingParameterList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class TaskTaskSchedulerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRedoType":
            suggest = "allow_redo_type"
        elif key == "calendarId":
            suggest = "calendar_id"
        elif key == "calendarOpen":
            suggest = "calendar_open"
        elif key == "crontabExpression":
            suggest = "crontab_expression"
        elif key == "cycleType":
            suggest = "cycle_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "eventListenerLists":
            suggest = "event_listener_lists"
        elif key == "executionEndTime":
            suggest = "execution_end_time"
        elif key == "executionStartTime":
            suggest = "execution_start_time"
        elif key == "executionTtl":
            suggest = "execution_ttl"
        elif key == "initStrategy":
            suggest = "init_strategy"
        elif key == "maxRetryAttempts":
            suggest = "max_retry_attempts"
        elif key == "paramTaskInLists":
            suggest = "param_task_in_lists"
        elif key == "paramTaskOutLists":
            suggest = "param_task_out_lists"
        elif key == "retryWait":
            suggest = "retry_wait"
        elif key == "runPriority":
            suggest = "run_priority"
        elif key == "scheduleRunType":
            suggest = "schedule_run_type"
        elif key == "scheduleTimeZone":
            suggest = "schedule_time_zone"
        elif key == "selfDepend":
            suggest = "self_depend"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "taskOutputRegistryLists":
            suggest = "task_output_registry_lists"
        elif key == "upstreamDependencyConfigLists":
            suggest = "upstream_dependency_config_lists"
        elif key == "waitExecutionTotalTtl":
            suggest = "wait_execution_total_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_redo_type: Optional[_builtins.str] = None,
                 calendar_id: Optional[_builtins.str] = None,
                 calendar_open: Optional[_builtins.str] = None,
                 crontab_expression: Optional[_builtins.str] = None,
                 cycle_type: Optional[_builtins.str] = None,
                 end_time: Optional[_builtins.str] = None,
                 event_listener_lists: Optional[Sequence['outputs.TaskTaskSchedulerConfigurationEventListenerList']] = None,
                 execution_end_time: Optional[_builtins.str] = None,
                 execution_start_time: Optional[_builtins.str] = None,
                 execution_ttl: Optional[_builtins.str] = None,
                 init_strategy: Optional[_builtins.str] = None,
                 max_retry_attempts: Optional[_builtins.str] = None,
                 param_task_in_lists: Optional[Sequence['outputs.TaskTaskSchedulerConfigurationParamTaskInList']] = None,
                 param_task_out_lists: Optional[Sequence['outputs.TaskTaskSchedulerConfigurationParamTaskOutList']] = None,
                 retry_wait: Optional[_builtins.str] = None,
                 run_priority: Optional[_builtins.str] = None,
                 schedule_run_type: Optional[_builtins.str] = None,
                 schedule_time_zone: Optional[_builtins.str] = None,
                 self_depend: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 task_output_registry_lists: Optional[Sequence['outputs.TaskTaskSchedulerConfigurationTaskOutputRegistryList']] = None,
                 upstream_dependency_config_lists: Optional[Sequence['outputs.TaskTaskSchedulerConfigurationUpstreamDependencyConfigList']] = None,
                 wait_execution_total_ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_redo_type: Rerun & backfill configuration, defaults to ALL; ALL: can rerun or backfill after success or failure; FAILURE: cannot rerun or backfill after success, can rerun or backfill after failure; NONE: cannot rerun or backfill after success or failure.
        :param _builtins.str calendar_id: Calendar scheduling calendar ID.
        :param _builtins.str calendar_open: Calendar scheduling: Values are 0 and 1, 1 for enabled, 0 for disabled, defaults to 0.
        :param _builtins.str crontab_expression: Cron expression, defaults to 0 0 0 * * `?` *.
        :param _builtins.str cycle_type: Cycle type: Defaults to DAY_CYCLE.
               
               Supported types are
               
               * ONEOFF_CYCLE: One-time
               * YEAR_CYCLE: Yearly
               * MONTH_CYCLE: Monthly
               * WEEK_CYCLE: Weekly
               * DAY_CYCLE: Daily
               * HOUR_CYCLE: Hourly
               * MINUTE_CYCLE: Minutely
               * CRONTAB_CYCLE: Crontab expression type.
        :param _builtins.str end_time: End date, defaults to 2099-12-31 23:59:59.
        :param Sequence['TaskTaskSchedulerConfigurationEventListenerListArgs'] event_listener_lists: Event array.
        :param _builtins.str execution_end_time: Execution time right-closed interval, default 23:59.
        :param _builtins.str execution_start_time: Execution time left-closed interval, default 00:00.
        :param _builtins.str execution_ttl: Timeout handling strategy - running time timeout (unit: minutes) defaults to -1.
        :param _builtins.str init_strategy: **Instance generation strategy**
               * T_PLUS_0: T+0 generation, default strategy
               * T_PLUS_1: T+1 generation.
        :param _builtins.str max_retry_attempts: Retry strategy - maximum number of attempts, default: 4.
        :param Sequence['TaskTaskSchedulerConfigurationParamTaskInListArgs'] param_task_in_lists: Input parameter array.
        :param Sequence['TaskTaskSchedulerConfigurationParamTaskOutListArgs'] param_task_out_lists: Output parameter array.
        :param _builtins.str retry_wait: Retry strategy - retry waiting time, unit: minutes: default: 5.
        :param _builtins.str run_priority: Task scheduling priority: 4 for high, 5 for medium, 6 for low, default: 6.
        :param _builtins.str schedule_run_type: Scheduling type: 0 Normal scheduling 1 Empty run scheduling, defaults to 0.
        :param _builtins.str schedule_time_zone: Time zone, defaults to UTC+8.
        :param _builtins.str self_depend: Self-dependency, default value serial, values: parallel, serial, orderly.
        :param _builtins.str start_time: Effective date, defaults to 00:00:00 of current date.
        :param Sequence['TaskTaskSchedulerConfigurationTaskOutputRegistryListArgs'] task_output_registry_lists: Output registration.
        :param Sequence['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs'] upstream_dependency_config_lists: Upstream dependency array.
        :param _builtins.str wait_execution_total_ttl: Timeout handling strategy - total waiting time timeout (unit: minutes) defaults to -1.
        """
        if allow_redo_type is not None:
            pulumi.set(__self__, "allow_redo_type", allow_redo_type)
        if calendar_id is not None:
            pulumi.set(__self__, "calendar_id", calendar_id)
        if calendar_open is not None:
            pulumi.set(__self__, "calendar_open", calendar_open)
        if crontab_expression is not None:
            pulumi.set(__self__, "crontab_expression", crontab_expression)
        if cycle_type is not None:
            pulumi.set(__self__, "cycle_type", cycle_type)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if event_listener_lists is not None:
            pulumi.set(__self__, "event_listener_lists", event_listener_lists)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if execution_ttl is not None:
            pulumi.set(__self__, "execution_ttl", execution_ttl)
        if init_strategy is not None:
            pulumi.set(__self__, "init_strategy", init_strategy)
        if max_retry_attempts is not None:
            pulumi.set(__self__, "max_retry_attempts", max_retry_attempts)
        if param_task_in_lists is not None:
            pulumi.set(__self__, "param_task_in_lists", param_task_in_lists)
        if param_task_out_lists is not None:
            pulumi.set(__self__, "param_task_out_lists", param_task_out_lists)
        if retry_wait is not None:
            pulumi.set(__self__, "retry_wait", retry_wait)
        if run_priority is not None:
            pulumi.set(__self__, "run_priority", run_priority)
        if schedule_run_type is not None:
            pulumi.set(__self__, "schedule_run_type", schedule_run_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if self_depend is not None:
            pulumi.set(__self__, "self_depend", self_depend)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if task_output_registry_lists is not None:
            pulumi.set(__self__, "task_output_registry_lists", task_output_registry_lists)
        if upstream_dependency_config_lists is not None:
            pulumi.set(__self__, "upstream_dependency_config_lists", upstream_dependency_config_lists)
        if wait_execution_total_ttl is not None:
            pulumi.set(__self__, "wait_execution_total_ttl", wait_execution_total_ttl)

    @_builtins.property
    @pulumi.getter(name="allowRedoType")
    def allow_redo_type(self) -> Optional[_builtins.str]:
        """
        Rerun & backfill configuration, defaults to ALL; ALL: can rerun or backfill after success or failure; FAILURE: cannot rerun or backfill after success, can rerun or backfill after failure; NONE: cannot rerun or backfill after success or failure.
        """
        return pulumi.get(self, "allow_redo_type")

    @_builtins.property
    @pulumi.getter(name="calendarId")
    def calendar_id(self) -> Optional[_builtins.str]:
        """
        Calendar scheduling calendar ID.
        """
        return pulumi.get(self, "calendar_id")

    @_builtins.property
    @pulumi.getter(name="calendarOpen")
    def calendar_open(self) -> Optional[_builtins.str]:
        """
        Calendar scheduling: Values are 0 and 1, 1 for enabled, 0 for disabled, defaults to 0.
        """
        return pulumi.get(self, "calendar_open")

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> Optional[_builtins.str]:
        """
        Cron expression, defaults to 0 0 0 * * `?` *.
        """
        return pulumi.get(self, "crontab_expression")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> Optional[_builtins.str]:
        """
        Cycle type: Defaults to DAY_CYCLE.

        Supported types are

        * ONEOFF_CYCLE: One-time
        * YEAR_CYCLE: Yearly
        * MONTH_CYCLE: Monthly
        * WEEK_CYCLE: Weekly
        * DAY_CYCLE: Daily
        * HOUR_CYCLE: Hourly
        * MINUTE_CYCLE: Minutely
        * CRONTAB_CYCLE: Crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End date, defaults to 2099-12-31 23:59:59.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="eventListenerLists")
    def event_listener_lists(self) -> Optional[Sequence['outputs.TaskTaskSchedulerConfigurationEventListenerList']]:
        """
        Event array.
        """
        return pulumi.get(self, "event_listener_lists")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[_builtins.str]:
        """
        Execution time right-closed interval, default 23:59.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[_builtins.str]:
        """
        Execution time left-closed interval, default 00:00.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter(name="executionTtl")
    def execution_ttl(self) -> Optional[_builtins.str]:
        """
        Timeout handling strategy - running time timeout (unit: minutes) defaults to -1.
        """
        return pulumi.get(self, "execution_ttl")

    @_builtins.property
    @pulumi.getter(name="initStrategy")
    def init_strategy(self) -> Optional[_builtins.str]:
        """
        **Instance generation strategy**
        * T_PLUS_0: T+0 generation, default strategy
        * T_PLUS_1: T+1 generation.
        """
        return pulumi.get(self, "init_strategy")

    @_builtins.property
    @pulumi.getter(name="maxRetryAttempts")
    def max_retry_attempts(self) -> Optional[_builtins.str]:
        """
        Retry strategy - maximum number of attempts, default: 4.
        """
        return pulumi.get(self, "max_retry_attempts")

    @_builtins.property
    @pulumi.getter(name="paramTaskInLists")
    def param_task_in_lists(self) -> Optional[Sequence['outputs.TaskTaskSchedulerConfigurationParamTaskInList']]:
        """
        Input parameter array.
        """
        return pulumi.get(self, "param_task_in_lists")

    @_builtins.property
    @pulumi.getter(name="paramTaskOutLists")
    def param_task_out_lists(self) -> Optional[Sequence['outputs.TaskTaskSchedulerConfigurationParamTaskOutList']]:
        """
        Output parameter array.
        """
        return pulumi.get(self, "param_task_out_lists")

    @_builtins.property
    @pulumi.getter(name="retryWait")
    def retry_wait(self) -> Optional[_builtins.str]:
        """
        Retry strategy - retry waiting time, unit: minutes: default: 5.
        """
        return pulumi.get(self, "retry_wait")

    @_builtins.property
    @pulumi.getter(name="runPriority")
    def run_priority(self) -> Optional[_builtins.str]:
        """
        Task scheduling priority: 4 for high, 5 for medium, 6 for low, default: 6.
        """
        return pulumi.get(self, "run_priority")

    @_builtins.property
    @pulumi.getter(name="scheduleRunType")
    def schedule_run_type(self) -> Optional[_builtins.str]:
        """
        Scheduling type: 0 Normal scheduling 1 Empty run scheduling, defaults to 0.
        """
        return pulumi.get(self, "schedule_run_type")

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[_builtins.str]:
        """
        Time zone, defaults to UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @_builtins.property
    @pulumi.getter(name="selfDepend")
    def self_depend(self) -> Optional[_builtins.str]:
        """
        Self-dependency, default value serial, values: parallel, serial, orderly.
        """
        return pulumi.get(self, "self_depend")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Effective date, defaults to 00:00:00 of current date.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="taskOutputRegistryLists")
    def task_output_registry_lists(self) -> Optional[Sequence['outputs.TaskTaskSchedulerConfigurationTaskOutputRegistryList']]:
        """
        Output registration.
        """
        return pulumi.get(self, "task_output_registry_lists")

    @_builtins.property
    @pulumi.getter(name="upstreamDependencyConfigLists")
    def upstream_dependency_config_lists(self) -> Optional[Sequence['outputs.TaskTaskSchedulerConfigurationUpstreamDependencyConfigList']]:
        """
        Upstream dependency array.
        """
        return pulumi.get(self, "upstream_dependency_config_lists")

    @_builtins.property
    @pulumi.getter(name="waitExecutionTotalTtl")
    def wait_execution_total_ttl(self) -> Optional[_builtins.str]:
        """
        Timeout handling strategy - total waiting time timeout (unit: minutes) defaults to -1.
        """
        return pulumi.get(self, "wait_execution_total_ttl")


@pulumi.output_type
class TaskTaskSchedulerConfigurationEventListenerList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventBroadcastType":
            suggest = "event_broadcast_type"
        elif key == "eventName":
            suggest = "event_name"
        elif key == "eventSubType":
            suggest = "event_sub_type"
        elif key == "propertiesLists":
            suggest = "properties_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfigurationEventListenerList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfigurationEventListenerList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfigurationEventListenerList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_broadcast_type: _builtins.str,
                 event_name: _builtins.str,
                 event_sub_type: _builtins.str,
                 properties_lists: Optional[Sequence['outputs.TaskTaskSchedulerConfigurationEventListenerListPropertiesList']] = None):
        """
        :param _builtins.str event_broadcast_type: Event broadcast type: SINGLE, BROADCAST.
        :param _builtins.str event_name: Event name.
        :param _builtins.str event_sub_type: Event cycle: SECOND, MIN, HOUR, DAY.
        :param Sequence['TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs'] properties_lists: Extended information.
        """
        pulumi.set(__self__, "event_broadcast_type", event_broadcast_type)
        pulumi.set(__self__, "event_name", event_name)
        pulumi.set(__self__, "event_sub_type", event_sub_type)
        if properties_lists is not None:
            pulumi.set(__self__, "properties_lists", properties_lists)

    @_builtins.property
    @pulumi.getter(name="eventBroadcastType")
    def event_broadcast_type(self) -> _builtins.str:
        """
        Event broadcast type: SINGLE, BROADCAST.
        """
        return pulumi.get(self, "event_broadcast_type")

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> _builtins.str:
        """
        Event name.
        """
        return pulumi.get(self, "event_name")

    @_builtins.property
    @pulumi.getter(name="eventSubType")
    def event_sub_type(self) -> _builtins.str:
        """
        Event cycle: SECOND, MIN, HOUR, DAY.
        """
        return pulumi.get(self, "event_sub_type")

    @_builtins.property
    @pulumi.getter(name="propertiesLists")
    def properties_lists(self) -> Optional[Sequence['outputs.TaskTaskSchedulerConfigurationEventListenerListPropertiesList']]:
        """
        Extended information.
        """
        return pulumi.get(self, "properties_lists")


@pulumi.output_type
class TaskTaskSchedulerConfigurationEventListenerListPropertiesList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramKey":
            suggest = "param_key"
        elif key == "paramValue":
            suggest = "param_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfigurationEventListenerListPropertiesList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfigurationEventListenerListPropertiesList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfigurationEventListenerListPropertiesList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class TaskTaskSchedulerConfigurationParamTaskInList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromParamKey":
            suggest = "from_param_key"
        elif key == "fromTaskId":
            suggest = "from_task_id"
        elif key == "paramDesc":
            suggest = "param_desc"
        elif key == "paramKey":
            suggest = "param_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfigurationParamTaskInList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfigurationParamTaskInList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfigurationParamTaskInList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_param_key: _builtins.str,
                 from_task_id: _builtins.str,
                 param_desc: _builtins.str,
                 param_key: _builtins.str):
        """
        :param _builtins.str from_param_key: Parent task parameter key.
        :param _builtins.str from_task_id: Parent task ID.
        :param _builtins.str param_desc: Parameter description: format is project_identifier.task_name.parameter_name; example: project_wedata_1.sh_250820_104107.pp_out.
        :param _builtins.str param_key: Parameter name.
        """
        pulumi.set(__self__, "from_param_key", from_param_key)
        pulumi.set(__self__, "from_task_id", from_task_id)
        pulumi.set(__self__, "param_desc", param_desc)
        pulumi.set(__self__, "param_key", param_key)

    @_builtins.property
    @pulumi.getter(name="fromParamKey")
    def from_param_key(self) -> _builtins.str:
        """
        Parent task parameter key.
        """
        return pulumi.get(self, "from_param_key")

    @_builtins.property
    @pulumi.getter(name="fromTaskId")
    def from_task_id(self) -> _builtins.str:
        """
        Parent task ID.
        """
        return pulumi.get(self, "from_task_id")

    @_builtins.property
    @pulumi.getter(name="paramDesc")
    def param_desc(self) -> _builtins.str:
        """
        Parameter description: format is project_identifier.task_name.parameter_name; example: project_wedata_1.sh_250820_104107.pp_out.
        """
        return pulumi.get(self, "param_desc")

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")


@pulumi.output_type
class TaskTaskSchedulerConfigurationParamTaskOutList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramKey":
            suggest = "param_key"
        elif key == "paramValue":
            suggest = "param_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfigurationParamTaskOutList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfigurationParamTaskOutList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfigurationParamTaskOutList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter definition.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter definition.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class TaskTaskSchedulerConfigurationTaskOutputRegistryList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataFlowType":
            suggest = "data_flow_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "datasourceId":
            suggest = "datasource_id"
        elif key == "partitionName":
            suggest = "partition_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "tablePhysicalId":
            suggest = "table_physical_id"
        elif key == "dbGuid":
            suggest = "db_guid"
        elif key == "tableGuid":
            suggest = "table_guid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfigurationTaskOutputRegistryList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfigurationTaskOutputRegistryList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfigurationTaskOutputRegistryList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_flow_type: _builtins.str,
                 database_name: _builtins.str,
                 datasource_id: _builtins.str,
                 partition_name: _builtins.str,
                 table_name: _builtins.str,
                 table_physical_id: _builtins.str,
                 db_guid: Optional[_builtins.str] = None,
                 table_guid: Optional[_builtins.str] = None):
        """
        :param _builtins.str data_flow_type: Input/output table type
               Input stream
               UPSTREAM,
               Output stream
               DOWNSTREAM.
        :param _builtins.str database_name: Database name.
        :param _builtins.str datasource_id: Data source ID.
        :param _builtins.str partition_name: Partition name.
        :param _builtins.str table_name: Table name.
        :param _builtins.str table_physical_id: Table physical unique ID.
        :param _builtins.str db_guid: Database unique identifier.
        :param _builtins.str table_guid: Table unique identifier.
        """
        pulumi.set(__self__, "data_flow_type", data_flow_type)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "datasource_id", datasource_id)
        pulumi.set(__self__, "partition_name", partition_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "table_physical_id", table_physical_id)
        if db_guid is not None:
            pulumi.set(__self__, "db_guid", db_guid)
        if table_guid is not None:
            pulumi.set(__self__, "table_guid", table_guid)

    @_builtins.property
    @pulumi.getter(name="dataFlowType")
    def data_flow_type(self) -> _builtins.str:
        """
        Input/output table type
        Input stream
        UPSTREAM,
        Output stream
        DOWNSTREAM.
        """
        return pulumi.get(self, "data_flow_type")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> _builtins.str:
        """
        Data source ID.
        """
        return pulumi.get(self, "datasource_id")

    @_builtins.property
    @pulumi.getter(name="partitionName")
    def partition_name(self) -> _builtins.str:
        """
        Partition name.
        """
        return pulumi.get(self, "partition_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="tablePhysicalId")
    def table_physical_id(self) -> _builtins.str:
        """
        Table physical unique ID.
        """
        return pulumi.get(self, "table_physical_id")

    @_builtins.property
    @pulumi.getter(name="dbGuid")
    def db_guid(self) -> Optional[_builtins.str]:
        """
        Database unique identifier.
        """
        return pulumi.get(self, "db_guid")

    @_builtins.property
    @pulumi.getter(name="tableGuid")
    def table_guid(self) -> Optional[_builtins.str]:
        """
        Table unique identifier.
        """
        return pulumi.get(self, "table_guid")


@pulumi.output_type
class TaskTaskSchedulerConfigurationUpstreamDependencyConfigList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mainCyclicConfig":
            suggest = "main_cyclic_config"
        elif key == "taskId":
            suggest = "task_id"
        elif key == "dependencyStrategy":
            suggest = "dependency_strategy"
        elif key == "subordinateCyclicConfig":
            suggest = "subordinate_cyclic_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfigurationUpstreamDependencyConfigList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfigurationUpstreamDependencyConfigList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfigurationUpstreamDependencyConfigList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 main_cyclic_config: _builtins.str,
                 task_id: _builtins.str,
                 dependency_strategy: Optional['outputs.TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategy'] = None,
                 offset: Optional[_builtins.str] = None,
                 subordinate_cyclic_config: Optional[_builtins.str] = None):
        """
        :param _builtins.str main_cyclic_config: Main dependency configuration, values:
               
               * CRONTAB
               * DAY
               * HOUR
               * LIST_DAY
               * LIST_HOUR
               * LIST_MINUTE
               * MINUTE
               * MONTH
               * RANGE_DAY
               * RANGE_HOUR
               * RANGE_MINUTE
               * WEEK
               * YEAR.
        :param _builtins.str task_id: Task ID.
        :param 'TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs' dependency_strategy: Dependency execution strategy.
        :param _builtins.str offset: Offset in interval and list modes.
        :param _builtins.str subordinate_cyclic_config: Secondary dependency configuration, values:
               * ALL_DAY_OF_YEAR
               * ALL_MONTH_OF_YEAR
               * CURRENT
               * CURRENT_DAY
               * CURRENT_HOUR
               * CURRENT_MINUTE
               * CURRENT_MONTH
               * CURRENT_WEEK
               * CURRENT_YEAR
               * PREVIOUS_BEGIN_OF_MONTH
               * PREVIOUS_DAY
               * PREVIOUS_DAY_LATER_OFFSET_HOUR
               * PREVIOUS_DAY_LATER_OFFSET_MINUTE
               * PREVIOUS_END_OF_MONTH
               * PREVIOUS_FRIDAY
               * PREVIOUS_HOUR
               * PREVIOUS_HOUR_CYCLE
               * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
               * PREVIOUS_MINUTE_CYCLE
               * PREVIOUS_MONTH
               * PREVIOUS_WEEK
               * PREVIOUS_WEEKEND
               * RECENT_DATE.
        """
        pulumi.set(__self__, "main_cyclic_config", main_cyclic_config)
        pulumi.set(__self__, "task_id", task_id)
        if dependency_strategy is not None:
            pulumi.set(__self__, "dependency_strategy", dependency_strategy)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if subordinate_cyclic_config is not None:
            pulumi.set(__self__, "subordinate_cyclic_config", subordinate_cyclic_config)

    @_builtins.property
    @pulumi.getter(name="mainCyclicConfig")
    def main_cyclic_config(self) -> _builtins.str:
        """
        Main dependency configuration, values:

        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR.
        """
        return pulumi.get(self, "main_cyclic_config")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="dependencyStrategy")
    def dependency_strategy(self) -> Optional['outputs.TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategy']:
        """
        Dependency execution strategy.
        """
        return pulumi.get(self, "dependency_strategy")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.str]:
        """
        Offset in interval and list modes.
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter(name="subordinateCyclicConfig")
    def subordinate_cyclic_config(self) -> Optional[_builtins.str]:
        """
        Secondary dependency configuration, values:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE.
        """
        return pulumi.get(self, "subordinate_cyclic_config")


@pulumi.output_type
class TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pollingNullStrategy":
            suggest = "polling_null_strategy"
        elif key == "taskDependencyExecutingStrategies":
            suggest = "task_dependency_executing_strategies"
        elif key == "taskDependencyExecutingTimeoutValue":
            suggest = "task_dependency_executing_timeout_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 polling_null_strategy: Optional[_builtins.str] = None,
                 task_dependency_executing_strategies: Optional[Sequence[_builtins.str]] = None,
                 task_dependency_executing_timeout_value: Optional[_builtins.int] = None):
        """
        :param _builtins.str polling_null_strategy: Strategy for waiting for upstream task instances: EXECUTING; WAITING.
        :param Sequence[_builtins.str] task_dependency_executing_strategies: This field is required only when PollingNullStrategy is EXECUTING, List type: NOT_EXIST (default, when minute depends on minute/hour depends on hour, parent instance is not within the downstream instance scheduling time range); PARENT_EXPIRED (parent instance failed); PARENT_TIMEOUT (parent instance timed out). If any of the above scenarios is met, the parent task instance dependency judgment can be passed; otherwise, it is necessary to wait for the parent instance.
        :param _builtins.int task_dependency_executing_timeout_value: This field is required only when TaskDependencyExecutingStrategies contains PARENT_TIMEOUT, the timeout time for downstream tasks depending on parent instance execution, unit: minutes.
        """
        if polling_null_strategy is not None:
            pulumi.set(__self__, "polling_null_strategy", polling_null_strategy)
        if task_dependency_executing_strategies is not None:
            pulumi.set(__self__, "task_dependency_executing_strategies", task_dependency_executing_strategies)
        if task_dependency_executing_timeout_value is not None:
            pulumi.set(__self__, "task_dependency_executing_timeout_value", task_dependency_executing_timeout_value)

    @_builtins.property
    @pulumi.getter(name="pollingNullStrategy")
    def polling_null_strategy(self) -> Optional[_builtins.str]:
        """
        Strategy for waiting for upstream task instances: EXECUTING; WAITING.
        """
        return pulumi.get(self, "polling_null_strategy")

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingStrategies")
    def task_dependency_executing_strategies(self) -> Optional[Sequence[_builtins.str]]:
        """
        This field is required only when PollingNullStrategy is EXECUTING, List type: NOT_EXIST (default, when minute depends on minute/hour depends on hour, parent instance is not within the downstream instance scheduling time range); PARENT_EXPIRED (parent instance failed); PARENT_TIMEOUT (parent instance timed out). If any of the above scenarios is met, the parent task instance dependency judgment can be passed; otherwise, it is necessary to wait for the parent instance.
        """
        return pulumi.get(self, "task_dependency_executing_strategies")

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingTimeoutValue")
    def task_dependency_executing_timeout_value(self) -> Optional[_builtins.int]:
        """
        This field is required only when TaskDependencyExecutingStrategies contains PARENT_TIMEOUT, the timeout time for downstream tasks depending on parent instance execution, unit: minutes.
        """
        return pulumi.get(self, "task_dependency_executing_timeout_value")


@pulumi.output_type
class WeDataDataSourceDevFileUpload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreSite":
            suggest = "core_site"
        elif key == "hbaseSite":
            suggest = "hbase_site"
        elif key == "hdfsSite":
            suggest = "hdfs_site"
        elif key == "hiveSite":
            suggest = "hive_site"
        elif key == "keyStore":
            suggest = "key_store"
        elif key == "keyTab":
            suggest = "key_tab"
        elif key == "krb5Conf":
            suggest = "krb5_conf"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "trustStore":
            suggest = "trust_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeDataDataSourceDevFileUpload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeDataDataSourceDevFileUpload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeDataDataSourceDevFileUpload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_site: Optional[_builtins.str] = None,
                 hbase_site: Optional[_builtins.str] = None,
                 hdfs_site: Optional[_builtins.str] = None,
                 hive_site: Optional[_builtins.str] = None,
                 key_store: Optional[_builtins.str] = None,
                 key_tab: Optional[_builtins.str] = None,
                 krb5_conf: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None,
                 public_key: Optional[_builtins.str] = None,
                 trust_store: Optional[_builtins.str] = None):
        """
        :param _builtins.str core_site: core-site.xml file.
        :param _builtins.str hbase_site: hbase-site file.
        :param _builtins.str hdfs_site: hdfs-site.xml file.
        :param _builtins.str hive_site: hive-site.xml file.
        :param _builtins.str key_store: Keystore authentication file, default filename keystore.jks.
        :param _builtins.str key_tab: keytab file, default filename [data source name].keytab.
        :param _builtins.str krb5_conf: krb5.conf file.
        :param _builtins.str private_key: Private key, default filename private_key.pem.
        :param _builtins.str public_key: Public key, default filename public_key.pem.
        :param _builtins.str trust_store: Truststore authentication file, default filename truststore.jks.
        """
        if core_site is not None:
            pulumi.set(__self__, "core_site", core_site)
        if hbase_site is not None:
            pulumi.set(__self__, "hbase_site", hbase_site)
        if hdfs_site is not None:
            pulumi.set(__self__, "hdfs_site", hdfs_site)
        if hive_site is not None:
            pulumi.set(__self__, "hive_site", hive_site)
        if key_store is not None:
            pulumi.set(__self__, "key_store", key_store)
        if key_tab is not None:
            pulumi.set(__self__, "key_tab", key_tab)
        if krb5_conf is not None:
            pulumi.set(__self__, "krb5_conf", krb5_conf)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if trust_store is not None:
            pulumi.set(__self__, "trust_store", trust_store)

    @_builtins.property
    @pulumi.getter(name="coreSite")
    def core_site(self) -> Optional[_builtins.str]:
        """
        core-site.xml file.
        """
        return pulumi.get(self, "core_site")

    @_builtins.property
    @pulumi.getter(name="hbaseSite")
    def hbase_site(self) -> Optional[_builtins.str]:
        """
        hbase-site file.
        """
        return pulumi.get(self, "hbase_site")

    @_builtins.property
    @pulumi.getter(name="hdfsSite")
    def hdfs_site(self) -> Optional[_builtins.str]:
        """
        hdfs-site.xml file.
        """
        return pulumi.get(self, "hdfs_site")

    @_builtins.property
    @pulumi.getter(name="hiveSite")
    def hive_site(self) -> Optional[_builtins.str]:
        """
        hive-site.xml file.
        """
        return pulumi.get(self, "hive_site")

    @_builtins.property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> Optional[_builtins.str]:
        """
        Keystore authentication file, default filename keystore.jks.
        """
        return pulumi.get(self, "key_store")

    @_builtins.property
    @pulumi.getter(name="keyTab")
    def key_tab(self) -> Optional[_builtins.str]:
        """
        keytab file, default filename [data source name].keytab.
        """
        return pulumi.get(self, "key_tab")

    @_builtins.property
    @pulumi.getter(name="krb5Conf")
    def krb5_conf(self) -> Optional[_builtins.str]:
        """
        krb5.conf file.
        """
        return pulumi.get(self, "krb5_conf")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        Private key, default filename private_key.pem.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[_builtins.str]:
        """
        Public key, default filename public_key.pem.
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="trustStore")
    def trust_store(self) -> Optional[_builtins.str]:
        """
        Truststore authentication file, default filename truststore.jks.
        """
        return pulumi.get(self, "trust_store")


@pulumi.output_type
class WeDataDataSourceListFilterResult(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Filter name.
        :param Sequence[_builtins.str] values: Filter value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Filter name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter value.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class WeDataDataSourceListOrderFieldResult(dict):
    def __init__(__self__, *,
                 direction: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str direction: OrderFields rule.
        :param _builtins.str name: OrderFields name.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        OrderFields rule.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        OrderFields name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WeDataDataSourceListRowResult(dict):
    def __init__(__self__, *,
                 app_id: _builtins.int,
                 author: _builtins.bool,
                 authority_project_name: _builtins.str,
                 authority_user_name: _builtins.str,
                 biz_params: _builtins.str,
                 biz_params_string: _builtins.str,
                 category: _builtins.str,
                 cluster_id: _builtins.str,
                 cluster_name: _builtins.str,
                 create_time: _builtins.int,
                 data_source_status: _builtins.str,
                 database_name: _builtins.str,
                 deliver: _builtins.bool,
                 description: _builtins.str,
                 display: _builtins.str,
                 edit: _builtins.bool,
                 id: _builtins.int,
                 instance: _builtins.str,
                 modified_time: _builtins.int,
                 name: _builtins.str,
                 owner_account: _builtins.str,
                 owner_account_name: _builtins.str,
                 owner_project_id: _builtins.str,
                 owner_project_ident: _builtins.str,
                 owner_project_name: _builtins.str,
                 params: _builtins.str,
                 params_string: _builtins.str,
                 region: _builtins.str,
                 show_type: _builtins.str,
                 status: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int app_id: Appid.
        :param _builtins.bool author: Has Author.
        :param _builtins.str authority_project_name: Datasource AuthorityProjectName.
        :param _builtins.str authority_user_name: Datasource AuthorityUserName.
        :param _builtins.str biz_params: Biz params.
        :param _builtins.str biz_params_string: Biz params json string.
        :param _builtins.str category: Datasource category.
        :param _builtins.str cluster_id: Datasource cluster id.
        :param _builtins.str cluster_name: Datasource cluster name.
        :param _builtins.int create_time: CreateTime.
        :param _builtins.str data_source_status: DatasourceDataSourceStatus.
        :param _builtins.str database_name: DatabaseName.
        :param _builtins.bool deliver: Can Deliver.
        :param _builtins.str description: Description.
        :param _builtins.str display: Datasource display name.
        :param _builtins.bool edit: Datasource can Edit.
        :param _builtins.int id: ID.
        :param _builtins.str instance: Instance.
        :param _builtins.int modified_time: Datasource ModifiedTime.
        :param _builtins.str name: Datasource name.
        :param _builtins.str owner_account: Datasource owner account.
        :param _builtins.str owner_account_name: Datasource owner account name.
        :param _builtins.str owner_project_id: Datasource owner project id.
        :param _builtins.str owner_project_ident: Datasource OwnerProjectIdent.
        :param _builtins.str owner_project_name: Datasource OwnerProjectName.
        :param _builtins.str params: Datasource params.
        :param _builtins.str params_string: Params json string.
        :param _builtins.str region: Datasource engin cluster region.
        :param _builtins.str show_type: Datasource show type.
        :param _builtins.int status: Datasource status.
        :param _builtins.str type: Datasource type.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "author", author)
        pulumi.set(__self__, "authority_project_name", authority_project_name)
        pulumi.set(__self__, "authority_user_name", authority_user_name)
        pulumi.set(__self__, "biz_params", biz_params)
        pulumi.set(__self__, "biz_params_string", biz_params_string)
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_source_status", data_source_status)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "deliver", deliver)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display", display)
        pulumi.set(__self__, "edit", edit)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner_account", owner_account)
        pulumi.set(__self__, "owner_account_name", owner_account_name)
        pulumi.set(__self__, "owner_project_id", owner_project_id)
        pulumi.set(__self__, "owner_project_ident", owner_project_ident)
        pulumi.set(__self__, "owner_project_name", owner_project_name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "params_string", params_string)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "show_type", show_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.int:
        """
        Appid.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter
    def author(self) -> _builtins.bool:
        """
        Has Author.
        """
        return pulumi.get(self, "author")

    @_builtins.property
    @pulumi.getter(name="authorityProjectName")
    def authority_project_name(self) -> _builtins.str:
        """
        Datasource AuthorityProjectName.
        """
        return pulumi.get(self, "authority_project_name")

    @_builtins.property
    @pulumi.getter(name="authorityUserName")
    def authority_user_name(self) -> _builtins.str:
        """
        Datasource AuthorityUserName.
        """
        return pulumi.get(self, "authority_user_name")

    @_builtins.property
    @pulumi.getter(name="bizParams")
    def biz_params(self) -> _builtins.str:
        """
        Biz params.
        """
        return pulumi.get(self, "biz_params")

    @_builtins.property
    @pulumi.getter(name="bizParamsString")
    def biz_params_string(self) -> _builtins.str:
        """
        Biz params json string.
        """
        return pulumi.get(self, "biz_params_string")

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Datasource category.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        Datasource cluster id.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        Datasource cluster name.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.int:
        """
        CreateTime.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dataSourceStatus")
    def data_source_status(self) -> _builtins.str:
        """
        DatasourceDataSourceStatus.
        """
        return pulumi.get(self, "data_source_status")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        DatabaseName.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def deliver(self) -> _builtins.bool:
        """
        Can Deliver.
        """
        return pulumi.get(self, "deliver")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def display(self) -> _builtins.str:
        """
        Datasource display name.
        """
        return pulumi.get(self, "display")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> _builtins.bool:
        """
        Datasource can Edit.
        """
        return pulumi.get(self, "edit")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> _builtins.str:
        """
        Instance.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.int:
        """
        Datasource ModifiedTime.
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Datasource name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ownerAccount")
    def owner_account(self) -> _builtins.str:
        """
        Datasource owner account.
        """
        return pulumi.get(self, "owner_account")

    @_builtins.property
    @pulumi.getter(name="ownerAccountName")
    def owner_account_name(self) -> _builtins.str:
        """
        Datasource owner account name.
        """
        return pulumi.get(self, "owner_account_name")

    @_builtins.property
    @pulumi.getter(name="ownerProjectId")
    def owner_project_id(self) -> _builtins.str:
        """
        Datasource owner project id.
        """
        return pulumi.get(self, "owner_project_id")

    @_builtins.property
    @pulumi.getter(name="ownerProjectIdent")
    def owner_project_ident(self) -> _builtins.str:
        """
        Datasource OwnerProjectIdent.
        """
        return pulumi.get(self, "owner_project_ident")

    @_builtins.property
    @pulumi.getter(name="ownerProjectName")
    def owner_project_name(self) -> _builtins.str:
        """
        Datasource OwnerProjectName.
        """
        return pulumi.get(self, "owner_project_name")

    @_builtins.property
    @pulumi.getter
    def params(self) -> _builtins.str:
        """
        Datasource params.
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter(name="paramsString")
    def params_string(self) -> _builtins.str:
        """
        Params json string.
        """
        return pulumi.get(self, "params_string")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Datasource engin cluster region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="showType")
    def show_type(self) -> _builtins.str:
        """
        Datasource show type.
        """
        return pulumi.get(self, "show_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Datasource status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Datasource type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WeDataDataSourceProdFileUpload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreSite":
            suggest = "core_site"
        elif key == "hbaseSite":
            suggest = "hbase_site"
        elif key == "hdfsSite":
            suggest = "hdfs_site"
        elif key == "hiveSite":
            suggest = "hive_site"
        elif key == "keyStore":
            suggest = "key_store"
        elif key == "keyTab":
            suggest = "key_tab"
        elif key == "krb5Conf":
            suggest = "krb5_conf"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "trustStore":
            suggest = "trust_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeDataDataSourceProdFileUpload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeDataDataSourceProdFileUpload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeDataDataSourceProdFileUpload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_site: Optional[_builtins.str] = None,
                 hbase_site: Optional[_builtins.str] = None,
                 hdfs_site: Optional[_builtins.str] = None,
                 hive_site: Optional[_builtins.str] = None,
                 key_store: Optional[_builtins.str] = None,
                 key_tab: Optional[_builtins.str] = None,
                 krb5_conf: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None,
                 public_key: Optional[_builtins.str] = None,
                 trust_store: Optional[_builtins.str] = None):
        """
        :param _builtins.str core_site: core-site.xml file.
        :param _builtins.str hbase_site: hbase-site file.
        :param _builtins.str hdfs_site: hdfs-site.xml file.
        :param _builtins.str hive_site: hive-site.xml file.
        :param _builtins.str key_store: Keystore authentication file, default filename keystore.jks.
        :param _builtins.str key_tab: keytab file, default filename [data source name].keytab.
        :param _builtins.str krb5_conf: krb5.conf file.
        :param _builtins.str private_key: Private key, default filename private_key.pem.
        :param _builtins.str public_key: Public key, default filename public_key.pem.
        :param _builtins.str trust_store: Truststore authentication file, default filename truststore.jks.
        """
        if core_site is not None:
            pulumi.set(__self__, "core_site", core_site)
        if hbase_site is not None:
            pulumi.set(__self__, "hbase_site", hbase_site)
        if hdfs_site is not None:
            pulumi.set(__self__, "hdfs_site", hdfs_site)
        if hive_site is not None:
            pulumi.set(__self__, "hive_site", hive_site)
        if key_store is not None:
            pulumi.set(__self__, "key_store", key_store)
        if key_tab is not None:
            pulumi.set(__self__, "key_tab", key_tab)
        if krb5_conf is not None:
            pulumi.set(__self__, "krb5_conf", krb5_conf)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if trust_store is not None:
            pulumi.set(__self__, "trust_store", trust_store)

    @_builtins.property
    @pulumi.getter(name="coreSite")
    def core_site(self) -> Optional[_builtins.str]:
        """
        core-site.xml file.
        """
        return pulumi.get(self, "core_site")

    @_builtins.property
    @pulumi.getter(name="hbaseSite")
    def hbase_site(self) -> Optional[_builtins.str]:
        """
        hbase-site file.
        """
        return pulumi.get(self, "hbase_site")

    @_builtins.property
    @pulumi.getter(name="hdfsSite")
    def hdfs_site(self) -> Optional[_builtins.str]:
        """
        hdfs-site.xml file.
        """
        return pulumi.get(self, "hdfs_site")

    @_builtins.property
    @pulumi.getter(name="hiveSite")
    def hive_site(self) -> Optional[_builtins.str]:
        """
        hive-site.xml file.
        """
        return pulumi.get(self, "hive_site")

    @_builtins.property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> Optional[_builtins.str]:
        """
        Keystore authentication file, default filename keystore.jks.
        """
        return pulumi.get(self, "key_store")

    @_builtins.property
    @pulumi.getter(name="keyTab")
    def key_tab(self) -> Optional[_builtins.str]:
        """
        keytab file, default filename [data source name].keytab.
        """
        return pulumi.get(self, "key_tab")

    @_builtins.property
    @pulumi.getter(name="krb5Conf")
    def krb5_conf(self) -> Optional[_builtins.str]:
        """
        krb5.conf file.
        """
        return pulumi.get(self, "krb5_conf")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        Private key, default filename private_key.pem.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[_builtins.str]:
        """
        Public key, default filename public_key.pem.
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="trustStore")
    def trust_store(self) -> Optional[_builtins.str]:
        """
        Truststore authentication file, default filename truststore.jks.
        """
        return pulumi.get(self, "trust_store")


@pulumi.output_type
class WeDataDataSourcesItemResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 create_time: _builtins.str,
                 create_user: _builtins.str,
                 description: _builtins.str,
                 dev_con_properties: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.int,
                 modify_time: _builtins.str,
                 modify_user: _builtins.str,
                 name: _builtins.str,
                 prod_con_properties: _builtins.str,
                 project_id: _builtins.str,
                 project_name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str category: Data source category:
        :param _builtins.str create_time: Time.
        :param _builtins.str create_user: Data source creator.
        :param _builtins.str description: Data source description information.
        :param _builtins.str dev_con_properties: Same as params, contains data for development data source.
        :param _builtins.str display_name: Data source display name.
        :param _builtins.int id: Data source ID.
        :param _builtins.str modify_time: Modification time.
        :param _builtins.str modify_user: Modifier.
        :param _builtins.str name: Data source name.
        :param _builtins.str prod_con_properties: Data source configuration information, stored in JSON KV format, varies by data source type.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str project_name: Belonging project name.
        :param _builtins.str type: Data source type: enumeration values.
               
               - MYSQL
               - TENCENT_MYSQL
               - POSTGRE
               - ORACLE
               - SQLSERVER
               - FTP
               - HIVE
               - HUDI
               - HDFS
               - ICEBERG
               - KAFKA
               - HBASE
               - SPARK
               - VIRTUAL
               - TBASE
               - DB2
               - DM
               - GAUSSDB
               - GBASE
               - IMPALA
               - ES
               - TENCENT_ES
               - GREENPLUM
               - PHOENIX
               - SAP_HANA
               - SFTP
               - OCEANBASE
               - CLICKHOUSE
               - KUDU
               - VERTICA
               - REDIS
               - COS
               - DLC
               - DORIS
               - CKAFKA
               - S3
               - TDSQL
               - TDSQL_MYSQL
               - MONGODB
               - TENCENT_MONGODB
               - REST_API
               - SuperSQL
               - PRESTO
               - TiDB
               - StarRocks
               - Trino
               - Kyuubi
               - TCHOUSE_X
               - TCHOUSE_P
               - TCHOUSE_C
               - TCHOUSE_D
               - INFLUXDB
               - BIG_QUERY
               - SSH
               - BLOB.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "create_user", create_user)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dev_con_properties", dev_con_properties)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "modify_user", modify_user)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prod_con_properties", prod_con_properties)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Data source category:
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUser")
    def create_user(self) -> _builtins.str:
        """
        Data source creator.
        """
        return pulumi.get(self, "create_user")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Data source description information.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="devConProperties")
    def dev_con_properties(self) -> _builtins.str:
        """
        Same as params, contains data for development data source.
        """
        return pulumi.get(self, "dev_con_properties")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Data source display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        Data source ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        Modification time.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter(name="modifyUser")
    def modify_user(self) -> _builtins.str:
        """
        Modifier.
        """
        return pulumi.get(self, "modify_user")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Data source name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="prodConProperties")
    def prod_con_properties(self) -> _builtins.str:
        """
        Data source configuration information, stored in JSON KV format, varies by data source type.
        """
        return pulumi.get(self, "prod_con_properties")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> _builtins.str:
        """
        Belonging project name.
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Data source type: enumeration values.

        - MYSQL
        - TENCENT_MYSQL
        - POSTGRE
        - ORACLE
        - SQLSERVER
        - FTP
        - HIVE
        - HUDI
        - HDFS
        - ICEBERG
        - KAFKA
        - HBASE
        - SPARK
        - VIRTUAL
        - TBASE
        - DB2
        - DM
        - GAUSSDB
        - GBASE
        - IMPALA
        - ES
        - TENCENT_ES
        - GREENPLUM
        - PHOENIX
        - SAP_HANA
        - SFTP
        - OCEANBASE
        - CLICKHOUSE
        - KUDU
        - VERTICA
        - REDIS
        - COS
        - DLC
        - DORIS
        - CKAFKA
        - S3
        - TDSQL
        - TDSQL_MYSQL
        - MONGODB
        - TENCENT_MONGODB
        - REST_API
        - SuperSQL
        - PRESTO
        - TiDB
        - StarRocks
        - Trino
        - Kyuubi
        - TCHOUSE_X
        - TCHOUSE_P
        - TCHOUSE_C
        - TCHOUSE_D
        - INFLUXDB
        - BIG_QUERY
        - SSH
        - BLOB.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WorkflowWorkflowParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramKey":
            suggest = "param_key"
        elif key == "paramValue":
            suggest = "param_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowWorkflowParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowWorkflowParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowWorkflowParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class WorkflowWorkflowSchedulerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crontabExpression":
            suggest = "crontab_expression"
        elif key == "cycleType":
            suggest = "cycle_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "scheduleTimeZone":
            suggest = "schedule_time_zone"
        elif key == "selfDepend":
            suggest = "self_depend"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "calendarId":
            suggest = "calendar_id"
        elif key == "calendarOpen":
            suggest = "calendar_open"
        elif key == "clearLink":
            suggest = "clear_link"
        elif key == "dependencyWorkflow":
            suggest = "dependency_workflow"
        elif key == "executionEndTime":
            suggest = "execution_end_time"
        elif key == "executionStartTime":
            suggest = "execution_start_time"
        elif key == "mainCyclicConfig":
            suggest = "main_cyclic_config"
        elif key == "modifyCycleValue":
            suggest = "modify_cycle_value"
        elif key == "subordinateCyclicConfig":
            suggest = "subordinate_cyclic_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowWorkflowSchedulerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowWorkflowSchedulerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowWorkflowSchedulerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crontab_expression: _builtins.str,
                 cycle_type: _builtins.str,
                 end_time: _builtins.str,
                 schedule_time_zone: _builtins.str,
                 self_depend: _builtins.str,
                 start_time: _builtins.str,
                 calendar_id: Optional[_builtins.str] = None,
                 calendar_open: Optional[_builtins.str] = None,
                 clear_link: Optional[_builtins.bool] = None,
                 dependency_workflow: Optional[_builtins.str] = None,
                 execution_end_time: Optional[_builtins.str] = None,
                 execution_start_time: Optional[_builtins.str] = None,
                 main_cyclic_config: Optional[_builtins.str] = None,
                 modify_cycle_value: Optional[_builtins.str] = None,
                 subordinate_cyclic_config: Optional[_builtins.str] = None):
        """
        :param _builtins.str crontab_expression: Crontab expression.
        :param _builtins.str cycle_type: Cycle type: Supported types are
               ONEOFF_CYCLE: One-time
               YEAR_CYCLE: Year
               MONTH_CYCLE: Month
               WEEK_CYCLE: Week
               DAY_CYCLE: Day
               HOUR_CYCLE: Hour
               MINUTE_CYCLE: Minute
               CRONTAB_CYCLE: crontab expression type.
        :param _builtins.str end_time: End time.
        :param _builtins.str schedule_time_zone: time zone.
        :param _builtins.str self_depend: Self-dependence, default value serial, values are: parallel, serial, orderly.
        :param _builtins.str start_time: Start time.
        :param _builtins.str calendar_id: calendar id.
        :param _builtins.str calendar_open: Do you want to turn on calendar scheduling 1 on 0 off.
        :param _builtins.bool clear_link: Workflows have cross-workflow dependencies and are scheduled using cron expressions. If you save unified scheduling, unsupported dependencies will be broken.
        :param _builtins.str dependency_workflow: Workflow dependence, yes or no.
        :param _builtins.str execution_end_time: Execution time right-closed interval, example: 23:59, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        :param _builtins.str execution_start_time: Execution time left-closed interval, example: 00:00, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        :param _builtins.str main_cyclic_config: Effective when ModifyCycleValue is 1, indicating the default modified upstream dependence-time dimension. The value is: 
               * CRONTAB
               * DAY
               * HOUR
               * LIST_DAY
               * LIST_HOUR
               * LIST_MINUTE
               * MONTH
               * RANGE_DAY
               * RANGE_HOUR
               * RANGE_MINUTE
               * WEEK
               * YEAR
               
               https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        :param _builtins.str modify_cycle_value: 0: Do not modify 1: Change the upstream dependency configuration of the task to the default value.
        :param _builtins.str subordinate_cyclic_config: Effective when ModifyCycleValue is 1, which means that the default modified upstream dependency-instance range
               value is:
               * ALL_DAY_OF_YEAR
               * ALL_MONTH_OF_YEAR
               * CURRENT
               * CURRENT_DAY
               * CURRENT_HOUR
               * CURRENT_MINUTE
               * CURRENT_MONTH
               * CURRENT_WEEK
               * CURRENT_YEAR
               * PREVIOUS_BEGIN_OF_MONTH
               * PREVIOUS_DAY
               * PREVIOUS_DAY_LATER_OFFSET_HOUR
               * PREVIOUS_DAY_LATER_OFFSET_MINUTE
               * PREVIOUS_END_OF_MONTH
               * PREVIOUS_FRIDAY
               * PREVIOUS_HOUR
               * PREVIOUS_HOUR_CYCLE
               * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
               * PREVIOUS_MINUTE_CYCLE
               * PREVIOUS_MONTH
               * PREVIOUS_WEEK
               * PREVIOUS_WEEKEND
               * RECENT_DATE
               
               https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
        pulumi.set(__self__, "crontab_expression", crontab_expression)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        pulumi.set(__self__, "self_depend", self_depend)
        pulumi.set(__self__, "start_time", start_time)
        if calendar_id is not None:
            pulumi.set(__self__, "calendar_id", calendar_id)
        if calendar_open is not None:
            pulumi.set(__self__, "calendar_open", calendar_open)
        if clear_link is not None:
            pulumi.set(__self__, "clear_link", clear_link)
        if dependency_workflow is not None:
            pulumi.set(__self__, "dependency_workflow", dependency_workflow)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if main_cyclic_config is not None:
            pulumi.set(__self__, "main_cyclic_config", main_cyclic_config)
        if modify_cycle_value is not None:
            pulumi.set(__self__, "modify_cycle_value", modify_cycle_value)
        if subordinate_cyclic_config is not None:
            pulumi.set(__self__, "subordinate_cyclic_config", subordinate_cyclic_config)

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> _builtins.str:
        """
        Crontab expression.
        """
        return pulumi.get(self, "crontab_expression")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Cycle type: Supported types are
        ONEOFF_CYCLE: One-time
        YEAR_CYCLE: Year
        MONTH_CYCLE: Month
        WEEK_CYCLE: Week
        DAY_CYCLE: Day
        HOUR_CYCLE: Hour
        MINUTE_CYCLE: Minute
        CRONTAB_CYCLE: crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> _builtins.str:
        """
        time zone.
        """
        return pulumi.get(self, "schedule_time_zone")

    @_builtins.property
    @pulumi.getter(name="selfDepend")
    def self_depend(self) -> _builtins.str:
        """
        Self-dependence, default value serial, values are: parallel, serial, orderly.
        """
        return pulumi.get(self, "self_depend")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="calendarId")
    def calendar_id(self) -> Optional[_builtins.str]:
        """
        calendar id.
        """
        return pulumi.get(self, "calendar_id")

    @_builtins.property
    @pulumi.getter(name="calendarOpen")
    def calendar_open(self) -> Optional[_builtins.str]:
        """
        Do you want to turn on calendar scheduling 1 on 0 off.
        """
        return pulumi.get(self, "calendar_open")

    @_builtins.property
    @pulumi.getter(name="clearLink")
    def clear_link(self) -> Optional[_builtins.bool]:
        """
        Workflows have cross-workflow dependencies and are scheduled using cron expressions. If you save unified scheduling, unsupported dependencies will be broken.
        """
        return pulumi.get(self, "clear_link")

    @_builtins.property
    @pulumi.getter(name="dependencyWorkflow")
    def dependency_workflow(self) -> Optional[_builtins.str]:
        """
        Workflow dependence, yes or no.
        """
        return pulumi.get(self, "dependency_workflow")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[_builtins.str]:
        """
        Execution time right-closed interval, example: 23:59, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[_builtins.str]:
        """
        Execution time left-closed interval, example: 00:00, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter(name="mainCyclicConfig")
    def main_cyclic_config(self) -> Optional[_builtins.str]:
        """
        Effective when ModifyCycleValue is 1, indicating the default modified upstream dependence-time dimension. The value is: 
        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR

        https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
        return pulumi.get(self, "main_cyclic_config")

    @_builtins.property
    @pulumi.getter(name="modifyCycleValue")
    def modify_cycle_value(self) -> Optional[_builtins.str]:
        """
        0: Do not modify 1: Change the upstream dependency configuration of the task to the default value.
        """
        return pulumi.get(self, "modify_cycle_value")

    @_builtins.property
    @pulumi.getter(name="subordinateCyclicConfig")
    def subordinate_cyclic_config(self) -> Optional[_builtins.str]:
        """
        Effective when ModifyCycleValue is 1, which means that the default modified upstream dependency-instance range
        value is:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE

        https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
        return pulumi.get(self, "subordinate_cyclic_config")


@pulumi.output_type
class GetDataBackfillInstancesDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDataBackfillInstancesDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetDataBackfillInstancesDataItemArgs'] items: Specifies the backfill instance list.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Pagination size.
        :param _builtins.int total_count: Total number of records.
        :param _builtins.int total_page_number: Total pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDataBackfillInstancesDataItemResult']:
        """
        Specifies the backfill instance list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Pagination size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total number of records.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetDataBackfillInstancesDataItemResult(dict):
    def __init__(__self__, *,
                 cost_time: _builtins.str,
                 cur_run_date: _builtins.str,
                 end_time: _builtins.str,
                 start_time: _builtins.str,
                 state: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str):
        """
        :param _builtins.str cost_time: Execution duration.
        :param _builtins.str cur_run_date: Specifies the instance data time.
        :param _builtins.str end_time: End time.
        :param _builtins.str start_time: Start time.
        :param _builtins.str state: Execution status.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        """
        pulumi.set(__self__, "cost_time", cost_time)
        pulumi.set(__self__, "cur_run_date", cur_run_date)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)

    @_builtins.property
    @pulumi.getter(name="costTime")
    def cost_time(self) -> _builtins.str:
        """
        Execution duration.
        """
        return pulumi.get(self, "cost_time")

    @_builtins.property
    @pulumi.getter(name="curRunDate")
    def cur_run_date(self) -> _builtins.str:
        """
        Specifies the instance data time.
        """
        return pulumi.get(self, "cur_run_date")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Execution status.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")


@pulumi.output_type
class GetDataBackfillPlanDataResult(dict):
    def __init__(__self__, *,
                 check_parent_type: _builtins.str,
                 complete_percent: _builtins.int,
                 create_user_uin: _builtins.str,
                 data_backfill_plan_id: _builtins.str,
                 data_backfill_plan_name: _builtins.str,
                 data_backfill_range_lists: Sequence['outputs.GetDataBackfillPlanDataDataBackfillRangeListResult'],
                 data_time_order: _builtins.str,
                 end_time: _builtins.str,
                 integration_resource_group_id: _builtins.str,
                 project_id: _builtins.str,
                 redefine_cycle_type: _builtins.str,
                 redefine_parallel_num: _builtins.int,
                 redefine_param_lists: Sequence['outputs.GetDataBackfillPlanDataRedefineParamListResult'],
                 redefine_self_workflow_dependency: _builtins.str,
                 scheduler_resource_group_id: _builtins.str,
                 skip_event_listening: _builtins.bool,
                 start_time: _builtins.str,
                 success_percent: _builtins.int,
                 task_ids: Sequence[_builtins.str]):
        """
        :param _builtins.str check_parent_type: Parent task check type, valid values: - NONE - Do not check all - ALL - Check all upstream parent tasks - MAKE_SCOPE - Only check within the tasks selected in (the current backfill plan).
        :param _builtins.int complete_percent: Backfill plan instance completion percentage.
        :param _builtins.str create_user_uin: Creator user ID.
        :param _builtins.str data_backfill_plan_id: Backfill Plan ID.
        :param _builtins.str data_backfill_plan_name: Data Backfill Plan Name.
        :param Sequence['GetDataBackfillPlanDataDataBackfillRangeListArgs'] data_backfill_range_lists: List of data configuration for backfill tasks.
        :param _builtins.str data_time_order: Data time order of backfill instances. Effective only if two conditions are met: 1. Must be same-cycle tasks. 2. Prioritize execution based on dependencies; if no dependency impact, execute according to the configured order. Valid values: - NORMAL: Not set - ORDER: Sequential - REVERSE: Reverse order. Default is NORMAL if not set.
        :param _builtins.str end_time: Execution end time of the backfill task.
        :param _builtins.str integration_resource_group_id: Integration resource group ID.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str redefine_cycle_type: Backfill custom generation cycle.
        :param _builtins.int redefine_parallel_num: Custom instance run concurrency, returns null or not returned indicates the task's original self-dependency.
        :param Sequence['GetDataBackfillPlanDataRedefineParamListArgs'] redefine_param_lists: Custom parameters.
        :param _builtins.str redefine_self_workflow_dependency: Custom workflow self-dependency, yes or no; if not configured, the workflow's original self-dependency is used.
        :param _builtins.str scheduler_resource_group_id: Scheduler resource group ID.
        :param _builtins.bool skip_event_listening: Whether the backfill ignores event dependencies.
        :param _builtins.str start_time: Execution start time of the backfill task.
        :param _builtins.int success_percent: Backfill plan instance success percentage.
        :param Sequence[_builtins.str] task_ids: Set of backfill tasks.
        """
        pulumi.set(__self__, "check_parent_type", check_parent_type)
        pulumi.set(__self__, "complete_percent", complete_percent)
        pulumi.set(__self__, "create_user_uin", create_user_uin)
        pulumi.set(__self__, "data_backfill_plan_id", data_backfill_plan_id)
        pulumi.set(__self__, "data_backfill_plan_name", data_backfill_plan_name)
        pulumi.set(__self__, "data_backfill_range_lists", data_backfill_range_lists)
        pulumi.set(__self__, "data_time_order", data_time_order)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "integration_resource_group_id", integration_resource_group_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "redefine_cycle_type", redefine_cycle_type)
        pulumi.set(__self__, "redefine_parallel_num", redefine_parallel_num)
        pulumi.set(__self__, "redefine_param_lists", redefine_param_lists)
        pulumi.set(__self__, "redefine_self_workflow_dependency", redefine_self_workflow_dependency)
        pulumi.set(__self__, "scheduler_resource_group_id", scheduler_resource_group_id)
        pulumi.set(__self__, "skip_event_listening", skip_event_listening)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "success_percent", success_percent)
        pulumi.set(__self__, "task_ids", task_ids)

    @_builtins.property
    @pulumi.getter(name="checkParentType")
    def check_parent_type(self) -> _builtins.str:
        """
        Parent task check type, valid values: - NONE - Do not check all - ALL - Check all upstream parent tasks - MAKE_SCOPE - Only check within the tasks selected in (the current backfill plan).
        """
        return pulumi.get(self, "check_parent_type")

    @_builtins.property
    @pulumi.getter(name="completePercent")
    def complete_percent(self) -> _builtins.int:
        """
        Backfill plan instance completion percentage.
        """
        return pulumi.get(self, "complete_percent")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> _builtins.str:
        """
        Creator user ID.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter(name="dataBackfillPlanId")
    def data_backfill_plan_id(self) -> _builtins.str:
        """
        Backfill Plan ID.
        """
        return pulumi.get(self, "data_backfill_plan_id")

    @_builtins.property
    @pulumi.getter(name="dataBackfillPlanName")
    def data_backfill_plan_name(self) -> _builtins.str:
        """
        Data Backfill Plan Name.
        """
        return pulumi.get(self, "data_backfill_plan_name")

    @_builtins.property
    @pulumi.getter(name="dataBackfillRangeLists")
    def data_backfill_range_lists(self) -> Sequence['outputs.GetDataBackfillPlanDataDataBackfillRangeListResult']:
        """
        List of data configuration for backfill tasks.
        """
        return pulumi.get(self, "data_backfill_range_lists")

    @_builtins.property
    @pulumi.getter(name="dataTimeOrder")
    def data_time_order(self) -> _builtins.str:
        """
        Data time order of backfill instances. Effective only if two conditions are met: 1. Must be same-cycle tasks. 2. Prioritize execution based on dependencies; if no dependency impact, execute according to the configured order. Valid values: - NORMAL: Not set - ORDER: Sequential - REVERSE: Reverse order. Default is NORMAL if not set.
        """
        return pulumi.get(self, "data_time_order")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Execution end time of the backfill task.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="integrationResourceGroupId")
    def integration_resource_group_id(self) -> _builtins.str:
        """
        Integration resource group ID.
        """
        return pulumi.get(self, "integration_resource_group_id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="redefineCycleType")
    def redefine_cycle_type(self) -> _builtins.str:
        """
        Backfill custom generation cycle.
        """
        return pulumi.get(self, "redefine_cycle_type")

    @_builtins.property
    @pulumi.getter(name="redefineParallelNum")
    def redefine_parallel_num(self) -> _builtins.int:
        """
        Custom instance run concurrency, returns null or not returned indicates the task's original self-dependency.
        """
        return pulumi.get(self, "redefine_parallel_num")

    @_builtins.property
    @pulumi.getter(name="redefineParamLists")
    def redefine_param_lists(self) -> Sequence['outputs.GetDataBackfillPlanDataRedefineParamListResult']:
        """
        Custom parameters.
        """
        return pulumi.get(self, "redefine_param_lists")

    @_builtins.property
    @pulumi.getter(name="redefineSelfWorkflowDependency")
    def redefine_self_workflow_dependency(self) -> _builtins.str:
        """
        Custom workflow self-dependency, yes or no; if not configured, the workflow's original self-dependency is used.
        """
        return pulumi.get(self, "redefine_self_workflow_dependency")

    @_builtins.property
    @pulumi.getter(name="schedulerResourceGroupId")
    def scheduler_resource_group_id(self) -> _builtins.str:
        """
        Scheduler resource group ID.
        """
        return pulumi.get(self, "scheduler_resource_group_id")

    @_builtins.property
    @pulumi.getter(name="skipEventListening")
    def skip_event_listening(self) -> _builtins.bool:
        """
        Whether the backfill ignores event dependencies.
        """
        return pulumi.get(self, "skip_event_listening")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Execution start time of the backfill task.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="successPercent")
    def success_percent(self) -> _builtins.int:
        """
        Backfill plan instance success percentage.
        """
        return pulumi.get(self, "success_percent")

    @_builtins.property
    @pulumi.getter(name="taskIds")
    def task_ids(self) -> Sequence[_builtins.str]:
        """
        Set of backfill tasks.
        """
        return pulumi.get(self, "task_ids")


@pulumi.output_type
class GetDataBackfillPlanDataDataBackfillRangeListResult(dict):
    def __init__(__self__, *,
                 end_date: Optional[_builtins.str] = None,
                 execution_end_time: Optional[_builtins.str] = None,
                 execution_start_time: Optional[_builtins.str] = None,
                 start_date: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_date: End date, format yyyy-MM-dd, indicating end at 23:59:59 of the specified date.
        :param _builtins.str execution_end_time: Daily end time point within [StartDate, EndDate], format HH:mm, only effective for tasks with hour or sub-hour cycles.
        :param _builtins.str execution_start_time: Daily start time point within [StartDate, EndDate], format HH:mm, only effective for tasks with hour or sub-hour cycles.
        :param _builtins.str start_date: Start date, format yyyy-MM-dd, indicating start from 00:00:00 of the specified date.
        """
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[_builtins.str]:
        """
        End date, format yyyy-MM-dd, indicating end at 23:59:59 of the specified date.
        """
        return pulumi.get(self, "end_date")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[_builtins.str]:
        """
        Daily end time point within [StartDate, EndDate], format HH:mm, only effective for tasks with hour or sub-hour cycles.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[_builtins.str]:
        """
        Daily start time point within [StartDate, EndDate], format HH:mm, only effective for tasks with hour or sub-hour cycles.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[_builtins.str]:
        """
        Start date, format yyyy-MM-dd, indicating start from 00:00:00 of the specified date.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class GetDataBackfillPlanDataRedefineParamListResult(dict):
    def __init__(__self__, *,
                 k: Optional[_builtins.str] = None,
                 v: Optional[_builtins.str] = None):
        """
        :param _builtins.str k: Key name.
        :param _builtins.str v: Value, do not pass SQL (request will be treated as an attack interface). If necessary, Base64 encode and decode the SQL.
        """
        if k is not None:
            pulumi.set(__self__, "k", k)
        if v is not None:
            pulumi.set(__self__, "v", v)

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.str]:
        """
        Key name.
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter
    def v(self) -> Optional[_builtins.str]:
        """
        Value, do not pass SQL (request will be treated as an attack interface). If necessary, Base64 encode and decode the SQL.
        """
        return pulumi.get(self, "v")


@pulumi.output_type
class GetDownstreamTaskInstancesDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDownstreamTaskInstancesDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetDownstreamTaskInstancesDataItemArgs'] items: Data list.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Page size.
        :param _builtins.int total_count: Total count.
        :param _builtins.int total_page_number: Total page number.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDownstreamTaskInstancesDataItemResult']:
        """
        Data list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Page size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total page number.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetDownstreamTaskInstancesDataItemResult(dict):
    def __init__(__self__, *,
                 cost_time: _builtins.int,
                 cur_run_date: _builtins.str,
                 cycle_type: _builtins.str,
                 end_time: _builtins.str,
                 executor_group_id: _builtins.str,
                 executor_group_name: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 instance_key: _builtins.str,
                 instance_state: _builtins.str,
                 instance_type: _builtins.int,
                 last_update_time: _builtins.str,
                 owner_uin_lists: Sequence[_builtins.str],
                 project_id: _builtins.str,
                 scheduler_time: _builtins.str,
                 start_time: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type: _builtins.str,
                 task_type_id: _builtins.int,
                 total_run_num: _builtins.int,
                 tries: _builtins.int,
                 try_limit: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.int cost_time: Cost time, in milliseconds.
        :param _builtins.str cur_run_date: Instance data time.
        :param _builtins.str cycle_type: Task cycle type. Supports filtering multiple conditions, and the relationship between conditions is OR. O: ONEOFF_CYCLE, Y: YEAR_CYCLE, M: MONTH_CYCLE, W: WEEK_CYCLE, D: DAY_CYCLE, H: HOUR_CYCLE, I: MINUTE_CYCLE, C: CRONTAB_CYCLE.
        :param _builtins.str end_time: Run end time.
        :param _builtins.str executor_group_id: Executor resource group ID.
        :param _builtins.str executor_group_name: Resource group name.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str folder_name: Folder name.
        :param _builtins.str instance_key: Instance unique identifier.
        :param _builtins.str instance_state: Instance state: WAIT_EVENT: Waiting for event, WAIT_UPSTREAM: Waiting for upstream, WAIT_RUN: Waiting to run, RUNNING: Running, SKIP_RUNNING: Skip running, FAILED_RETRY: Failed and retrying, EXPIRED: Failed, COMPLETED: Completed.
        :param _builtins.int instance_type: Instance type: 0: Backfill instance, 1: Periodic instance, 2: Non-periodic instance.
        :param _builtins.str last_update_time: Instance last update time, format: yyyy-MM-dd HH:mm:ss.
        :param Sequence[_builtins.str] owner_uin_lists: List of owners.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str scheduler_time: Scheduled time
        :param _builtins.str start_time: Run start time.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type: Task type description.
        :param _builtins.int task_type_id: Task type ID.
        :param _builtins.int total_run_num: Total run count.
        :param _builtins.int tries: Failure retry count. When triggered again by manual rerun or backfill instance, it will be reset to 0 and recounted.
        :param _builtins.int try_limit: Retry limit after each run failure.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "cost_time", cost_time)
        pulumi.set(__self__, "cur_run_date", cur_run_date)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "executor_group_id", executor_group_id)
        pulumi.set(__self__, "executor_group_name", executor_group_name)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "instance_key", instance_key)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "last_update_time", last_update_time)
        pulumi.set(__self__, "owner_uin_lists", owner_uin_lists)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "scheduler_time", scheduler_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "total_run_num", total_run_num)
        pulumi.set(__self__, "tries", tries)
        pulumi.set(__self__, "try_limit", try_limit)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="costTime")
    def cost_time(self) -> _builtins.int:
        """
        Cost time, in milliseconds.
        """
        return pulumi.get(self, "cost_time")

    @_builtins.property
    @pulumi.getter(name="curRunDate")
    def cur_run_date(self) -> _builtins.str:
        """
        Instance data time.
        """
        return pulumi.get(self, "cur_run_date")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Task cycle type. Supports filtering multiple conditions, and the relationship between conditions is OR. O: ONEOFF_CYCLE, Y: YEAR_CYCLE, M: MONTH_CYCLE, W: WEEK_CYCLE, D: DAY_CYCLE, H: HOUR_CYCLE, I: MINUTE_CYCLE, C: CRONTAB_CYCLE.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Run end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="executorGroupId")
    def executor_group_id(self) -> _builtins.str:
        """
        Executor resource group ID.
        """
        return pulumi.get(self, "executor_group_id")

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> _builtins.str:
        """
        Resource group name.
        """
        return pulumi.get(self, "executor_group_name")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        Folder name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="instanceKey")
    def instance_key(self) -> _builtins.str:
        """
        Instance unique identifier.
        """
        return pulumi.get(self, "instance_key")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        Instance state: WAIT_EVENT: Waiting for event, WAIT_UPSTREAM: Waiting for upstream, WAIT_RUN: Waiting to run, RUNNING: Running, SKIP_RUNNING: Skip running, FAILED_RETRY: Failed and retrying, EXPIRED: Failed, COMPLETED: Completed.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.int:
        """
        Instance type: 0: Backfill instance, 1: Periodic instance, 2: Non-periodic instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> _builtins.str:
        """
        Instance last update time, format: yyyy-MM-dd HH:mm:ss.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="ownerUinLists")
    def owner_uin_lists(self) -> Sequence[_builtins.str]:
        """
        List of owners.
        """
        return pulumi.get(self, "owner_uin_lists")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="schedulerTime")
    def scheduler_time(self) -> _builtins.str:
        """
        Scheduled time
        """
        return pulumi.get(self, "scheduler_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Run start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Task type description.
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type ID.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="totalRunNum")
    def total_run_num(self) -> _builtins.int:
        """
        Total run count.
        """
        return pulumi.get(self, "total_run_num")

    @_builtins.property
    @pulumi.getter
    def tries(self) -> _builtins.int:
        """
        Failure retry count. When triggered again by manual rerun or backfill instance, it will be reset to 0 and recounted.
        """
        return pulumi.get(self, "tries")

    @_builtins.property
    @pulumi.getter(name="tryLimit")
    def try_limit(self) -> _builtins.int:
        """
        Retry limit after each run failure.
        """
        return pulumi.get(self, "try_limit")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetDownstreamTasksDataResult(dict):
    def __init__(__self__, *,
                 crontab_expression: _builtins.str,
                 cycle_type: _builtins.str,
                 delay_time: _builtins.int,
                 end_time: _builtins.str,
                 init_strategy: _builtins.str,
                 owner_uin: _builtins.str,
                 project_id: _builtins.str,
                 schedule_desc: _builtins.str,
                 start_time: _builtins.str,
                 status: _builtins.str,
                 task_action: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type_desc: _builtins.str,
                 task_type_id: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.str crontab_expression: crontab expression.
        :param _builtins.str cycle_type: Cycle Type, Default: D
               Supported types:
               * O: One-time
               
               * Y: Yearly
               
               * M: Monthly
               
               * W: Weekly
               
               * D: Daily
               
               * H: Hourly
               
               * I: Minute
               
               * C: Crontab expression type.
        :param _builtins.int delay_time: Delay time.
        :param _builtins.str end_time: Task end time.
        :param _builtins.str init_strategy: Initialization strategy for scheduling.
        :param _builtins.str owner_uin: Owner ID.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str schedule_desc: Specifies scheduling plan display description information.
        :param _builtins.str start_time: Task start time.
        :param _builtins.str status: Task Status:
               
               * N: New
               
               * Y: Scheduling
               
               * F: Offline
               
               * O: Paused
               
               * T: Offlining (in the process of being taken offline)
               
               I* NVALID: Invalid.
        :param _builtins.str task_action: Elastic cycle configuration.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type_desc: Task type description.
               -20: universal data synchronization.
                - 25:  ETLTaskType
                - 26:  ETLTaskType
                - 30:  python
                - 31:  pyspark
                - 34:  hivesql
                - 35:  shell
                - 36:  sparksql
                - 21:  jdbcsql
                - 32:  dlc
                - 33:  ImpalaTaskType
                - 40:  CDWTaskType
                - 41:  kettle
                - 42:  TCHouse-X
                - 43:  TCHouse-X SQL
                - 46:  dlcsparkTaskType
                - 47:  TiOneMachineLearningTaskType
                - 48:  Trino
                - 50:  DLCPyspark
                - 23:  TencentDistributedSQL
                - 39:  spark
                - 92:  MRTaskType
                - 38:  ShellScript
                - 70:  HiveSQLScrip
               -130: branch.
               -131: merge.
               -132: Notebook 
               -133: SSH node.
                - 134:  StarRocks
                - 137:  For-each
               -10000: custom business common.
        :param _builtins.int task_type_id: Task type id.
        :param _builtins.str workflow_id: Workflow id.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "crontab_expression", crontab_expression)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "delay_time", delay_time)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "init_strategy", init_strategy)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "schedule_desc", schedule_desc)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_action", task_action)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type_desc", task_type_desc)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> _builtins.str:
        """
        crontab expression.
        """
        return pulumi.get(self, "crontab_expression")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Cycle Type, Default: D
        Supported types:
        * O: One-time

        * Y: Yearly

        * M: Monthly

        * W: Weekly

        * D: Daily

        * H: Hourly

        * I: Minute

        * C: Crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="delayTime")
    def delay_time(self) -> _builtins.int:
        """
        Delay time.
        """
        return pulumi.get(self, "delay_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Task end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="initStrategy")
    def init_strategy(self) -> _builtins.str:
        """
        Initialization strategy for scheduling.
        """
        return pulumi.get(self, "init_strategy")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Owner ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="scheduleDesc")
    def schedule_desc(self) -> _builtins.str:
        """
        Specifies scheduling plan display description information.
        """
        return pulumi.get(self, "schedule_desc")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Task start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Task Status:

        * N: New

        * Y: Scheduling

        * F: Offline

        * O: Paused

        * T: Offlining (in the process of being taken offline)

        I* NVALID: Invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskAction")
    def task_action(self) -> _builtins.str:
        """
        Elastic cycle configuration.
        """
        return pulumi.get(self, "task_action")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskTypeDesc")
    def task_type_desc(self) -> _builtins.str:
        """
        Task type description.
        -20: universal data synchronization.
         - 25:  ETLTaskType
         - 26:  ETLTaskType
         - 30:  python
         - 31:  pyspark
         - 34:  hivesql
         - 35:  shell
         - 36:  sparksql
         - 21:  jdbcsql
         - 32:  dlc
         - 33:  ImpalaTaskType
         - 40:  CDWTaskType
         - 41:  kettle
         - 42:  TCHouse-X
         - 43:  TCHouse-X SQL
         - 46:  dlcsparkTaskType
         - 47:  TiOneMachineLearningTaskType
         - 48:  Trino
         - 50:  DLCPyspark
         - 23:  TencentDistributedSQL
         - 39:  spark
         - 92:  MRTaskType
         - 38:  ShellScript
         - 70:  HiveSQLScrip
        -130: branch.
        -131: merge.
        -132: Notebook 
        -133: SSH node.
         - 134:  StarRocks
         - 137:  For-each
        -10000: custom business common.
        """
        return pulumi.get(self, "task_type_desc")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type id.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow id.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetGetTableColumnsDataResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 is_partition: _builtins.bool,
                 length: _builtins.int,
                 name: _builtins.str,
                 position: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str description: Field description.
        :param _builtins.bool is_partition: Whether it is a partition field.
        :param _builtins.int length: Field length.
        :param _builtins.str name: Field name.
        :param _builtins.int position: Field position.
        :param _builtins.str type: Field type.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "is_partition", is_partition)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Field description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="isPartition")
    def is_partition(self) -> _builtins.bool:
        """
        Whether it is a partition field.
        """
        return pulumi.get(self, "is_partition")

    @_builtins.property
    @pulumi.getter
    def length(self) -> _builtins.int:
        """
        Field length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.int:
        """
        Field position.
        """
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Field type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGetTableDataResult(dict):
    def __init__(__self__, *,
                 business_metadatas: Sequence['outputs.GetGetTableDataBusinessMetadataResult'],
                 create_time: _builtins.str,
                 database_name: _builtins.str,
                 description: _builtins.str,
                 guid: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str,
                 table_type: _builtins.str,
                 technical_metadatas: Sequence['outputs.GetGetTableDataTechnicalMetadataResult'],
                 update_time: _builtins.str):
        """
        :param Sequence['GetGetTableDataBusinessMetadataArgs'] business_metadatas: Business metadata of the table.
        :param _builtins.str create_time: Creation time.
        :param _builtins.str database_name: Database name.
        :param _builtins.str description: Data table description.
        :param _builtins.str guid: Data table GUID.
        :param _builtins.str name: Data table name.
        :param _builtins.str schema_name: Database schema name.
        :param _builtins.str table_type: Table type.
        :param Sequence['GetGetTableDataTechnicalMetadataArgs'] technical_metadatas: Technical metadata of the table.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "business_metadatas", business_metadatas)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "guid", guid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "table_type", table_type)
        pulumi.set(__self__, "technical_metadatas", technical_metadatas)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="businessMetadatas")
    def business_metadatas(self) -> Sequence['outputs.GetGetTableDataBusinessMetadataResult']:
        """
        Business metadata of the table.
        """
        return pulumi.get(self, "business_metadatas")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Data table description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def guid(self) -> _builtins.str:
        """
        Data table GUID.
        """
        return pulumi.get(self, "guid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Data table name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        """
        Database schema name.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableType")
    def table_type(self) -> _builtins.str:
        """
        Table type.
        """
        return pulumi.get(self, "table_type")

    @_builtins.property
    @pulumi.getter(name="technicalMetadatas")
    def technical_metadatas(self) -> Sequence['outputs.GetGetTableDataTechnicalMetadataResult']:
        """
        Technical metadata of the table.
        """
        return pulumi.get(self, "technical_metadatas")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetGetTableDataBusinessMetadataResult(dict):
    def __init__(__self__, *,
                 tag_names: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] tag_names: Tag names.
        """
        pulumi.set(__self__, "tag_names", tag_names)

    @_builtins.property
    @pulumi.getter(name="tagNames")
    def tag_names(self) -> Sequence[_builtins.str]:
        """
        Tag names.
        """
        return pulumi.get(self, "tag_names")


@pulumi.output_type
class GetGetTableDataTechnicalMetadataResult(dict):
    def __init__(__self__, *,
                 location: _builtins.str,
                 owner: _builtins.str,
                 storage_size: _builtins.int):
        """
        :param _builtins.str location: Data table location.
        :param _builtins.str owner: Responsible person.
        :param _builtins.int storage_size: Storage size.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "storage_size", storage_size)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Data table location.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        Responsible person.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> _builtins.int:
        """
        Storage size.
        """
        return pulumi.get(self, "storage_size")


@pulumi.output_type
class GetListCatalogItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Catalog name.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Catalog name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetListColumnLineageItemResult(dict):
    def __init__(__self__, *,
                 relations: Sequence['outputs.GetListColumnLineageItemRelationResult'],
                 resources: Sequence['outputs.GetListColumnLineageItemResourceResult']):
        """
        :param Sequence['GetListColumnLineageItemRelationArgs'] relations: Relation.
        :param Sequence['GetListColumnLineageItemResourceArgs'] resources: Current resource.
        """
        pulumi.set(__self__, "relations", relations)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def relations(self) -> Sequence['outputs.GetListColumnLineageItemRelationResult']:
        """
        Relation.
        """
        return pulumi.get(self, "relations")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetListColumnLineageItemResourceResult']:
        """
        Current resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetListColumnLineageItemRelationResult(dict):
    def __init__(__self__, *,
                 processes: Sequence['outputs.GetListColumnLineageItemRelationProcessResult'],
                 relation_id: _builtins.str,
                 source_unique_id: _builtins.str,
                 target_unique_id: _builtins.str):
        """
        :param Sequence['GetListColumnLineageItemRelationProcessArgs'] processes: Lineage processing process.
        :param _builtins.str relation_id: Relation ID.
        :param _builtins.str source_unique_id: Source unique lineage ID.
        :param _builtins.str target_unique_id: Target unique lineage ID.
        """
        pulumi.set(__self__, "processes", processes)
        pulumi.set(__self__, "relation_id", relation_id)
        pulumi.set(__self__, "source_unique_id", source_unique_id)
        pulumi.set(__self__, "target_unique_id", target_unique_id)

    @_builtins.property
    @pulumi.getter
    def processes(self) -> Sequence['outputs.GetListColumnLineageItemRelationProcessResult']:
        """
        Lineage processing process.
        """
        return pulumi.get(self, "processes")

    @_builtins.property
    @pulumi.getter(name="relationId")
    def relation_id(self) -> _builtins.str:
        """
        Relation ID.
        """
        return pulumi.get(self, "relation_id")

    @_builtins.property
    @pulumi.getter(name="sourceUniqueId")
    def source_unique_id(self) -> _builtins.str:
        """
        Source unique lineage ID.
        """
        return pulumi.get(self, "source_unique_id")

    @_builtins.property
    @pulumi.getter(name="targetUniqueId")
    def target_unique_id(self) -> _builtins.str:
        """
        Target unique lineage ID.
        """
        return pulumi.get(self, "target_unique_id")


@pulumi.output_type
class GetListColumnLineageItemRelationProcessResult(dict):
    def __init__(__self__, *,
                 lineage_node_id: _builtins.str,
                 platform: _builtins.str,
                 process_id: _builtins.str,
                 process_properties: Sequence['outputs.GetListColumnLineageItemRelationProcessProcessPropertyResult'],
                 process_sub_type: _builtins.str,
                 process_type: _builtins.str):
        """
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str platform: Source: WEDATA|THIRD, default WEDATA.
        :param _builtins.str process_id: Original unique ID.
        :param Sequence['GetListColumnLineageItemRelationProcessProcessPropertyArgs'] process_properties: Additional extension parameters.
        :param _builtins.str process_sub_type: Task subtype
               SQL_TASK,
               //Integration real-time task lineage
               INTEGRATED_STREAM,
               //Integration offline task lineage
               INTEGRATED_OFFLINE.
        :param _builtins.str process_type: Task type
               //Scheduling task
               SCHEDULE_TASK,
               //Integration task
               INTEGRATION_TASK,
               //Third-party reporting
               THIRD_REPORT,
               //Data modeling
               TABLE_MODEL,
               //Model creates metrics
               MODEL_METRIC,
               //Atomic metric creates derived metric
               METRIC_METRIC,
               //Data service
               DATA_SERVICE.
        """
        pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "process_id", process_id)
        pulumi.set(__self__, "process_properties", process_properties)
        pulumi.set(__self__, "process_sub_type", process_sub_type)
        pulumi.set(__self__, "process_type", process_type)

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> _builtins.str:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD, default WEDATA.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="processId")
    def process_id(self) -> _builtins.str:
        """
        Original unique ID.
        """
        return pulumi.get(self, "process_id")

    @_builtins.property
    @pulumi.getter(name="processProperties")
    def process_properties(self) -> Sequence['outputs.GetListColumnLineageItemRelationProcessProcessPropertyResult']:
        """
        Additional extension parameters.
        """
        return pulumi.get(self, "process_properties")

    @_builtins.property
    @pulumi.getter(name="processSubType")
    def process_sub_type(self) -> _builtins.str:
        """
        Task subtype
        SQL_TASK,
        //Integration real-time task lineage
        INTEGRATED_STREAM,
        //Integration offline task lineage
        INTEGRATED_OFFLINE.
        """
        return pulumi.get(self, "process_sub_type")

    @_builtins.property
    @pulumi.getter(name="processType")
    def process_type(self) -> _builtins.str:
        """
        Task type
        //Scheduling task
        SCHEDULE_TASK,
        //Integration task
        INTEGRATION_TASK,
        //Third-party reporting
        THIRD_REPORT,
        //Data modeling
        TABLE_MODEL,
        //Model creates metrics
        MODEL_METRIC,
        //Atomic metric creates derived metric
        METRIC_METRIC,
        //Data service
        DATA_SERVICE.
        """
        return pulumi.get(self, "process_type")


@pulumi.output_type
class GetListColumnLineageItemRelationProcessProcessPropertyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetListColumnLineageItemResourceResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 lineage_node_id: _builtins.str,
                 platform: _builtins.str,
                 resource_name: _builtins.str,
                 resource_properties: Sequence['outputs.GetListColumnLineageItemResourceResourcePropertyResult'],
                 resource_type: _builtins.str,
                 resource_unique_id: _builtins.str,
                 update_time: _builtins.str):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str description: Description: table type|metric description|model description|field description.
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str platform: Source: WEDATA|THIRD, default WEDATA.
        :param _builtins.str resource_name: Business name: database.table|metric name|model name|field name.
        :param Sequence['GetListColumnLineageItemResourceResourcePropertyArgs'] resource_properties: Resource additional extension parameters.
        :param _builtins.str resource_type: Entity type
               TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param _builtins.str resource_unique_id: Entity original unique ID.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "resource_properties", resource_properties)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description: table type|metric description|model description|field description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> _builtins.str:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD, default WEDATA.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> _builtins.str:
        """
        Business name: database.table|metric name|model name|field name.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Sequence['outputs.GetListColumnLineageItemResourceResourcePropertyResult']:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Entity type
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> _builtins.str:
        """
        Entity original unique ID.
        """
        return pulumi.get(self, "resource_unique_id")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetListColumnLineageItemResourceResourcePropertyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetListDatabaseItemResult(dict):
    def __init__(__self__, *,
                 catalog_name: _builtins.str,
                 description: _builtins.str,
                 guid: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 storage_size: _builtins.int):
        """
        :param _builtins.str catalog_name: Catalog name.
        :param _builtins.str description: Database description.
        :param _builtins.str guid: Database GUID.
        :param _builtins.str location: Database location.
        :param _builtins.str name: Database name.
        :param _builtins.int storage_size: Database storage size.
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "guid", guid)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_size", storage_size)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> _builtins.str:
        """
        Catalog name.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Database description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def guid(self) -> _builtins.str:
        """
        Database GUID.
        """
        return pulumi.get(self, "guid")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Database location.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> _builtins.int:
        """
        Database storage size.
        """
        return pulumi.get(self, "storage_size")


@pulumi.output_type
class GetListLineageItemResult(dict):
    def __init__(__self__, *,
                 relations: Sequence['outputs.GetListLineageItemRelationResult'],
                 resources: Sequence['outputs.GetListLineageItemResourceResult']):
        """
        :param Sequence['GetListLineageItemRelationArgs'] relations: Relation.
        :param Sequence['GetListLineageItemResourceArgs'] resources: Current resource.
        """
        pulumi.set(__self__, "relations", relations)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def relations(self) -> Sequence['outputs.GetListLineageItemRelationResult']:
        """
        Relation.
        """
        return pulumi.get(self, "relations")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetListLineageItemResourceResult']:
        """
        Current resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetListLineageItemRelationResult(dict):
    def __init__(__self__, *,
                 processes: Sequence['outputs.GetListLineageItemRelationProcessResult'],
                 relation_id: _builtins.str,
                 source_unique_id: _builtins.str,
                 target_unique_id: _builtins.str):
        """
        :param Sequence['GetListLineageItemRelationProcessArgs'] processes: Lineage processing process.
        :param _builtins.str relation_id: Association ID.
        :param _builtins.str source_unique_id: Source unique lineage ID.
        :param _builtins.str target_unique_id: Target unique lineage ID.
        """
        pulumi.set(__self__, "processes", processes)
        pulumi.set(__self__, "relation_id", relation_id)
        pulumi.set(__self__, "source_unique_id", source_unique_id)
        pulumi.set(__self__, "target_unique_id", target_unique_id)

    @_builtins.property
    @pulumi.getter
    def processes(self) -> Sequence['outputs.GetListLineageItemRelationProcessResult']:
        """
        Lineage processing process.
        """
        return pulumi.get(self, "processes")

    @_builtins.property
    @pulumi.getter(name="relationId")
    def relation_id(self) -> _builtins.str:
        """
        Association ID.
        """
        return pulumi.get(self, "relation_id")

    @_builtins.property
    @pulumi.getter(name="sourceUniqueId")
    def source_unique_id(self) -> _builtins.str:
        """
        Source unique lineage ID.
        """
        return pulumi.get(self, "source_unique_id")

    @_builtins.property
    @pulumi.getter(name="targetUniqueId")
    def target_unique_id(self) -> _builtins.str:
        """
        Target unique lineage ID.
        """
        return pulumi.get(self, "target_unique_id")


@pulumi.output_type
class GetListLineageItemRelationProcessResult(dict):
    def __init__(__self__, *,
                 lineage_node_id: _builtins.str,
                 platform: _builtins.str,
                 process_id: _builtins.str,
                 process_properties: Sequence['outputs.GetListLineageItemRelationProcessProcessPropertyResult'],
                 process_sub_type: _builtins.str,
                 process_type: _builtins.str):
        """
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str platform: Source: WEDATA|THIRD, default is WEDATA.
        :param _builtins.str process_id: Original unique ID.
        :param Sequence['GetListLineageItemRelationProcessProcessPropertyArgs'] process_properties: Additional extension parameters.
        :param _builtins.str process_sub_type: Task subtype: SQL_TASK, INTEGRATED_STREAM, INTEGRATED_OFFLINE.
        :param _builtins.str process_type: Task type: SCHEDULE_TASK, INTEGRATION_TASK, THIRD_REPORT, TABLE_MODEL, MODEL_METRIC, METRIC_METRIC, DATA_SERVICE.
        """
        pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "process_id", process_id)
        pulumi.set(__self__, "process_properties", process_properties)
        pulumi.set(__self__, "process_sub_type", process_sub_type)
        pulumi.set(__self__, "process_type", process_type)

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> _builtins.str:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD, default is WEDATA.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="processId")
    def process_id(self) -> _builtins.str:
        """
        Original unique ID.
        """
        return pulumi.get(self, "process_id")

    @_builtins.property
    @pulumi.getter(name="processProperties")
    def process_properties(self) -> Sequence['outputs.GetListLineageItemRelationProcessProcessPropertyResult']:
        """
        Additional extension parameters.
        """
        return pulumi.get(self, "process_properties")

    @_builtins.property
    @pulumi.getter(name="processSubType")
    def process_sub_type(self) -> _builtins.str:
        """
        Task subtype: SQL_TASK, INTEGRATED_STREAM, INTEGRATED_OFFLINE.
        """
        return pulumi.get(self, "process_sub_type")

    @_builtins.property
    @pulumi.getter(name="processType")
    def process_type(self) -> _builtins.str:
        """
        Task type: SCHEDULE_TASK, INTEGRATION_TASK, THIRD_REPORT, TABLE_MODEL, MODEL_METRIC, METRIC_METRIC, DATA_SERVICE.
        """
        return pulumi.get(self, "process_type")


@pulumi.output_type
class GetListLineageItemRelationProcessProcessPropertyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetListLineageItemResourceResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 lineage_node_id: _builtins.str,
                 platform: _builtins.str,
                 resource_name: _builtins.str,
                 resource_properties: Sequence['outputs.GetListLineageItemResourceResourcePropertyResult'],
                 resource_type: _builtins.str,
                 resource_unique_id: _builtins.str,
                 update_time: _builtins.str):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str description: Description: table type|metric description|model description|field description.
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str platform: Source: WEDATA|THIRD, default is WEDATA.
        :param _builtins.str resource_name: Business name: database.table|metric name|model name|field name.
        :param Sequence['GetListLineageItemResourceResourcePropertyArgs'] resource_properties: Resource additional extension parameters.
        :param _builtins.str resource_type: Entity type: TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param _builtins.str resource_unique_id: Entity unique ID.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "resource_properties", resource_properties)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description: table type|metric description|model description|field description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> _builtins.str:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD, default is WEDATA.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> _builtins.str:
        """
        Business name: database.table|metric name|model name|field name.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Sequence['outputs.GetListLineageItemResourceResourcePropertyResult']:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Entity type: TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> _builtins.str:
        """
        Entity unique ID.
        """
        return pulumi.get(self, "resource_unique_id")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetListLineageItemResourceResourcePropertyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetListProcessLineageItemResult(dict):
    def __init__(__self__, *,
                 processes: Sequence['outputs.GetListProcessLineageItemProcessResult'],
                 sources: Sequence['outputs.GetListProcessLineageItemSourceResult'],
                 targets: Sequence['outputs.GetListProcessLineageItemTargetResult']):
        """
        :param Sequence['GetListProcessLineageItemProcessArgs'] processes: Lineage processing procedures.
        :param Sequence['GetListProcessLineageItemSourceArgs'] sources: Source.
        :param Sequence['GetListProcessLineageItemTargetArgs'] targets: Target.
        """
        pulumi.set(__self__, "processes", processes)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def processes(self) -> Sequence['outputs.GetListProcessLineageItemProcessResult']:
        """
        Lineage processing procedures.
        """
        return pulumi.get(self, "processes")

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetListProcessLineageItemSourceResult']:
        """
        Source.
        """
        return pulumi.get(self, "sources")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetListProcessLineageItemTargetResult']:
        """
        Target.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetListProcessLineageItemProcessResult(dict):
    def __init__(__self__, *,
                 lineage_node_id: _builtins.str,
                 platform: _builtins.str,
                 process_id: _builtins.str,
                 process_properties: Sequence['outputs.GetListProcessLineageItemProcessProcessPropertyResult'],
                 process_sub_type: _builtins.str,
                 process_type: _builtins.str):
        """
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str platform: Source: WEDATA|THIRD, default WEDATA.
        :param _builtins.str process_id: Task unique ID.
        :param Sequence['GetListProcessLineageItemProcessProcessPropertyArgs'] process_properties: Additional extension parameters.
        :param _builtins.str process_sub_type: Task subtype.
               SQL_TASK,
               INTEGRATED_STREAM,
               INTEGRATED_OFFLINE.
        :param _builtins.str process_type: Task type: SCHEDULE_TASK, INTEGRATION_TASK, THIRD_REPORT, TABLE_MODEL, MODEL_METRIC, METRIC_METRIC, DATA_SERVICE.
        """
        pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "process_id", process_id)
        pulumi.set(__self__, "process_properties", process_properties)
        pulumi.set(__self__, "process_sub_type", process_sub_type)
        pulumi.set(__self__, "process_type", process_type)

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> _builtins.str:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD, default WEDATA.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="processId")
    def process_id(self) -> _builtins.str:
        """
        Task unique ID.
        """
        return pulumi.get(self, "process_id")

    @_builtins.property
    @pulumi.getter(name="processProperties")
    def process_properties(self) -> Sequence['outputs.GetListProcessLineageItemProcessProcessPropertyResult']:
        """
        Additional extension parameters.
        """
        return pulumi.get(self, "process_properties")

    @_builtins.property
    @pulumi.getter(name="processSubType")
    def process_sub_type(self) -> _builtins.str:
        """
        Task subtype.
        SQL_TASK,
        INTEGRATED_STREAM,
        INTEGRATED_OFFLINE.
        """
        return pulumi.get(self, "process_sub_type")

    @_builtins.property
    @pulumi.getter(name="processType")
    def process_type(self) -> _builtins.str:
        """
        Task type: SCHEDULE_TASK, INTEGRATION_TASK, THIRD_REPORT, TABLE_MODEL, MODEL_METRIC, METRIC_METRIC, DATA_SERVICE.
        """
        return pulumi.get(self, "process_type")


@pulumi.output_type
class GetListProcessLineageItemProcessProcessPropertyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetListProcessLineageItemSourceResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 lineage_node_id: _builtins.str,
                 platform: _builtins.str,
                 resource_name: _builtins.str,
                 resource_properties: Sequence['outputs.GetListProcessLineageItemSourceResourcePropertyResult'],
                 resource_type: _builtins.str,
                 resource_unique_id: _builtins.str,
                 update_time: _builtins.str):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str description: Description: table type|metric description|model description|field description.
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str platform: Source: WEDATA|THIRD, default WEDATA.
        :param _builtins.str resource_name: Business name: database.table|metric name|model name|field name.
        :param Sequence['GetListProcessLineageItemSourceResourcePropertyArgs'] resource_properties: Resource additional extension parameters.
        :param _builtins.str resource_type: Entity type.
               TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param _builtins.str resource_unique_id: Entity original unique ID.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "resource_properties", resource_properties)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description: table type|metric description|model description|field description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> _builtins.str:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD, default WEDATA.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> _builtins.str:
        """
        Business name: database.table|metric name|model name|field name.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Sequence['outputs.GetListProcessLineageItemSourceResourcePropertyResult']:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> _builtins.str:
        """
        Entity original unique ID.
        """
        return pulumi.get(self, "resource_unique_id")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetListProcessLineageItemSourceResourcePropertyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetListProcessLineageItemTargetResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 lineage_node_id: _builtins.str,
                 platform: _builtins.str,
                 resource_name: _builtins.str,
                 resource_properties: Sequence['outputs.GetListProcessLineageItemTargetResourcePropertyResult'],
                 resource_type: _builtins.str,
                 resource_unique_id: _builtins.str,
                 update_time: _builtins.str):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str description: Description: table type|metric description|model description|field description.
        :param _builtins.str lineage_node_id: Lineage node unique identifier.
        :param _builtins.str platform: Source: WEDATA|THIRD, default WEDATA.
        :param _builtins.str resource_name: Business name: database.table|metric name|model name|field name.
        :param Sequence['GetListProcessLineageItemTargetResourcePropertyArgs'] resource_properties: Resource additional extension parameters.
        :param _builtins.str resource_type: Entity type.
               TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param _builtins.str resource_unique_id: Entity original unique ID.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "resource_properties", resource_properties)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description: table type|metric description|model description|field description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> _builtins.str:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        Source: WEDATA|THIRD, default WEDATA.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> _builtins.str:
        """
        Business name: database.table|metric name|model name|field name.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Sequence['outputs.GetListProcessLineageItemTargetResourcePropertyResult']:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> _builtins.str:
        """
        Entity original unique ID.
        """
        return pulumi.get(self, "resource_unique_id")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetListProcessLineageItemTargetResourcePropertyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Property name.
        :param _builtins.str value: Property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetListSchemaItemResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 guid: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str database_name: Database name.
        :param _builtins.str guid: Schema GUID.
        :param _builtins.str name: Schema name.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "guid", guid)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def guid(self) -> _builtins.str:
        """
        Schema GUID.
        """
        return pulumi.get(self, "guid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetListTableItemResult(dict):
    def __init__(__self__, *,
                 business_metadatas: Sequence['outputs.GetListTableItemBusinessMetadataResult'],
                 create_time: _builtins.str,
                 database_name: _builtins.str,
                 description: _builtins.str,
                 guid: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str,
                 table_type: _builtins.str,
                 technical_metadatas: Sequence['outputs.GetListTableItemTechnicalMetadataResult'],
                 update_time: _builtins.str):
        """
        :param Sequence['GetListTableItemBusinessMetadataArgs'] business_metadatas: Business metadata of the table.
        :param _builtins.str create_time: Creation time.
        :param _builtins.str database_name: Database name.
        :param _builtins.str description: Data table description.
        :param _builtins.str guid: Data table GUID.
        :param _builtins.str name: Data table name.
        :param _builtins.str schema_name: Database schema name.
        :param _builtins.str table_type: Table type.
        :param Sequence['GetListTableItemTechnicalMetadataArgs'] technical_metadatas: Technical metadata of the table.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "business_metadatas", business_metadatas)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "guid", guid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "table_type", table_type)
        pulumi.set(__self__, "technical_metadatas", technical_metadatas)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="businessMetadatas")
    def business_metadatas(self) -> Sequence['outputs.GetListTableItemBusinessMetadataResult']:
        """
        Business metadata of the table.
        """
        return pulumi.get(self, "business_metadatas")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Data table description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def guid(self) -> _builtins.str:
        """
        Data table GUID.
        """
        return pulumi.get(self, "guid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Data table name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        """
        Database schema name.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableType")
    def table_type(self) -> _builtins.str:
        """
        Table type.
        """
        return pulumi.get(self, "table_type")

    @_builtins.property
    @pulumi.getter(name="technicalMetadatas")
    def technical_metadatas(self) -> Sequence['outputs.GetListTableItemTechnicalMetadataResult']:
        """
        Technical metadata of the table.
        """
        return pulumi.get(self, "technical_metadatas")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetListTableItemBusinessMetadataResult(dict):
    def __init__(__self__, *,
                 tag_names: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] tag_names: Tag names.
        """
        pulumi.set(__self__, "tag_names", tag_names)

    @_builtins.property
    @pulumi.getter(name="tagNames")
    def tag_names(self) -> Sequence[_builtins.str]:
        """
        Tag names.
        """
        return pulumi.get(self, "tag_names")


@pulumi.output_type
class GetListTableItemTechnicalMetadataResult(dict):
    def __init__(__self__, *,
                 location: _builtins.str,
                 owner: _builtins.str,
                 storage_size: _builtins.int):
        """
        :param _builtins.str location: Data table location.
        :param _builtins.str owner: Owner.
        :param _builtins.int storage_size: Storage size.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "storage_size", storage_size)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Data table location.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        Owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> _builtins.int:
        """
        Storage size.
        """
        return pulumi.get(self, "storage_size")


@pulumi.output_type
class GetOpsAlarmMessageDataResult(dict):
    def __init__(__self__, *,
                 alarm_level: _builtins.int,
                 alarm_message_id: _builtins.int,
                 alarm_reason: _builtins.str,
                 alarm_recipients: Sequence[_builtins.str],
                 alarm_rule_id: _builtins.str,
                 alarm_time: _builtins.str,
                 alarm_ways: Sequence[_builtins.str],
                 cur_run_date: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str):
        """
        :param _builtins.int alarm_level: Alarm level. 1. ordinary, 2. important, 3. critical.
        :param _builtins.int alarm_message_id: Alarm message Id.
        :param _builtins.str alarm_reason: Indicates the Alarm cause.
        :param Sequence[_builtins.str] alarm_recipients: Alarm recipient.
        :param _builtins.str alarm_rule_id: Specifies the Id of the Alarm rule.
        :param _builtins.str alarm_time: Alarm time. the same Alarm may be sent multiple times, only the latest Alarm time is displayed.
        :param Sequence[_builtins.str] alarm_ways: Alarm channel specifies the notification methods: 1. mail, 2. sms, 3. wechat, 4. voice, 5. wecom, 6. Http, 7. wecom group, 8. lark group, 9. dingtalk group, 10. Slack group, 11. Teams group (default: 1. mail).
        :param _builtins.str cur_run_date: Instance data time of the task.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        """
        pulumi.set(__self__, "alarm_level", alarm_level)
        pulumi.set(__self__, "alarm_message_id", alarm_message_id)
        pulumi.set(__self__, "alarm_reason", alarm_reason)
        pulumi.set(__self__, "alarm_recipients", alarm_recipients)
        pulumi.set(__self__, "alarm_rule_id", alarm_rule_id)
        pulumi.set(__self__, "alarm_time", alarm_time)
        pulumi.set(__self__, "alarm_ways", alarm_ways)
        pulumi.set(__self__, "cur_run_date", cur_run_date)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> _builtins.int:
        """
        Alarm level. 1. ordinary, 2. important, 3. critical.
        """
        return pulumi.get(self, "alarm_level")

    @_builtins.property
    @pulumi.getter(name="alarmMessageId")
    def alarm_message_id(self) -> _builtins.int:
        """
        Alarm message Id.
        """
        return pulumi.get(self, "alarm_message_id")

    @_builtins.property
    @pulumi.getter(name="alarmReason")
    def alarm_reason(self) -> _builtins.str:
        """
        Indicates the Alarm cause.
        """
        return pulumi.get(self, "alarm_reason")

    @_builtins.property
    @pulumi.getter(name="alarmRecipients")
    def alarm_recipients(self) -> Sequence[_builtins.str]:
        """
        Alarm recipient.
        """
        return pulumi.get(self, "alarm_recipients")

    @_builtins.property
    @pulumi.getter(name="alarmRuleId")
    def alarm_rule_id(self) -> _builtins.str:
        """
        Specifies the Id of the Alarm rule.
        """
        return pulumi.get(self, "alarm_rule_id")

    @_builtins.property
    @pulumi.getter(name="alarmTime")
    def alarm_time(self) -> _builtins.str:
        """
        Alarm time. the same Alarm may be sent multiple times, only the latest Alarm time is displayed.
        """
        return pulumi.get(self, "alarm_time")

    @_builtins.property
    @pulumi.getter(name="alarmWays")
    def alarm_ways(self) -> Sequence[_builtins.str]:
        """
        Alarm channel specifies the notification methods: 1. mail, 2. sms, 3. wechat, 4. voice, 5. wecom, 6. Http, 7. wecom group, 8. lark group, 9. dingtalk group, 10. Slack group, 11. Teams group (default: 1. mail).
        """
        return pulumi.get(self, "alarm_ways")

    @_builtins.property
    @pulumi.getter(name="curRunDate")
    def cur_run_date(self) -> _builtins.str:
        """
        Instance data time of the task.
        """
        return pulumi.get(self, "cur_run_date")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")


@pulumi.output_type
class GetOpsAlarmMessagesDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOpsAlarmMessagesDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetOpsAlarmMessagesDataItemArgs'] items: Alarm information list.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Pagination size.
        :param _builtins.int total_count: Total number of entries.
        :param _builtins.int total_page_number: Total pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOpsAlarmMessagesDataItemResult']:
        """
        Alarm information list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Pagination size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total number of entries.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetOpsAlarmMessagesDataItemResult(dict):
    def __init__(__self__, *,
                 alarm_level: _builtins.int,
                 alarm_message_id: _builtins.int,
                 alarm_reason: _builtins.str,
                 alarm_recipients: Sequence[_builtins.str],
                 alarm_rule_id: _builtins.str,
                 alarm_time: _builtins.str,
                 alarm_ways: Sequence[_builtins.str],
                 cur_run_date: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str):
        """
        :param _builtins.int alarm_level: Alarm level.
        :param _builtins.int alarm_message_id: Alarm message Id.
        :param _builtins.str alarm_reason: Indicates the Alarm cause.
        :param Sequence[_builtins.str] alarm_recipients: Alarm recipient.
        :param _builtins.str alarm_rule_id: Specifies the Id of the Alarm rule.
        :param _builtins.str alarm_time: Alarm time. the same Alarm may be sent multiple times, only the latest Alarm time is displayed.
        :param Sequence[_builtins.str] alarm_ways: Alarm channel specifies the notification methods: 1. mail, 2. sms, 3. wechat, 4. voice, 5. wecom, 6. Http, 7. wecom group, 8. lark group, 9. dingtalk group, 10. Slack group, 11. Teams group (default: 1. mail).
        :param _builtins.str cur_run_date: Instance data time of the task.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        """
        pulumi.set(__self__, "alarm_level", alarm_level)
        pulumi.set(__self__, "alarm_message_id", alarm_message_id)
        pulumi.set(__self__, "alarm_reason", alarm_reason)
        pulumi.set(__self__, "alarm_recipients", alarm_recipients)
        pulumi.set(__self__, "alarm_rule_id", alarm_rule_id)
        pulumi.set(__self__, "alarm_time", alarm_time)
        pulumi.set(__self__, "alarm_ways", alarm_ways)
        pulumi.set(__self__, "cur_run_date", cur_run_date)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> _builtins.int:
        """
        Alarm level.
        """
        return pulumi.get(self, "alarm_level")

    @_builtins.property
    @pulumi.getter(name="alarmMessageId")
    def alarm_message_id(self) -> _builtins.int:
        """
        Alarm message Id.
        """
        return pulumi.get(self, "alarm_message_id")

    @_builtins.property
    @pulumi.getter(name="alarmReason")
    def alarm_reason(self) -> _builtins.str:
        """
        Indicates the Alarm cause.
        """
        return pulumi.get(self, "alarm_reason")

    @_builtins.property
    @pulumi.getter(name="alarmRecipients")
    def alarm_recipients(self) -> Sequence[_builtins.str]:
        """
        Alarm recipient.
        """
        return pulumi.get(self, "alarm_recipients")

    @_builtins.property
    @pulumi.getter(name="alarmRuleId")
    def alarm_rule_id(self) -> _builtins.str:
        """
        Specifies the Id of the Alarm rule.
        """
        return pulumi.get(self, "alarm_rule_id")

    @_builtins.property
    @pulumi.getter(name="alarmTime")
    def alarm_time(self) -> _builtins.str:
        """
        Alarm time. the same Alarm may be sent multiple times, only the latest Alarm time is displayed.
        """
        return pulumi.get(self, "alarm_time")

    @_builtins.property
    @pulumi.getter(name="alarmWays")
    def alarm_ways(self) -> Sequence[_builtins.str]:
        """
        Alarm channel specifies the notification methods: 1. mail, 2. sms, 3. wechat, 4. voice, 5. wecom, 6. Http, 7. wecom group, 8. lark group, 9. dingtalk group, 10. Slack group, 11. Teams group (default: 1. mail).
        """
        return pulumi.get(self, "alarm_ways")

    @_builtins.property
    @pulumi.getter(name="curRunDate")
    def cur_run_date(self) -> _builtins.str:
        """
        Instance data time of the task.
        """
        return pulumi.get(self, "cur_run_date")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")


@pulumi.output_type
class GetOpsAlarmRulesDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOpsAlarmRulesDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetOpsAlarmRulesDataItemArgs'] items: Alarm rule information list.
        :param _builtins.int page_number: The number of pages in the pagination, the current page number.
        :param _builtins.int page_size: Number of items displayed per page.
        :param _builtins.int total_count: The total number of alarm rules.
        :param _builtins.int total_page_number: Total number of pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOpsAlarmRulesDataItemResult']:
        """
        Alarm rule information list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        The number of pages in the pagination, the current page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Number of items displayed per page.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        The total number of alarm rules.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total number of pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetOpsAlarmRulesDataItemResult(dict):
    def __init__(__self__, *,
                 alarm_groups: Sequence['outputs.GetOpsAlarmRulesDataItemAlarmGroupResult'],
                 alarm_level: _builtins.int,
                 alarm_rule_detail: 'outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailResult',
                 alarm_rule_id: _builtins.str,
                 alarm_rule_name: _builtins.str,
                 alarm_types: Sequence[_builtins.str],
                 bundle_id: _builtins.str,
                 bundle_info: _builtins.str,
                 description: _builtins.str,
                 monitor_object_ids: Sequence[_builtins.str],
                 monitor_object_type: _builtins.int,
                 owner_uin: _builtins.str,
                 status: _builtins.int):
        """
        :param Sequence['GetOpsAlarmRulesDataItemAlarmGroupArgs'] alarm_groups: Alarm recipient configuration list.
        :param _builtins.int alarm_level: Alarm level: 1. Normal, 2. Major, 3. Urgent.
        :param 'GetOpsAlarmRulesDataItemAlarmRuleDetailArgs' alarm_rule_detail: Alarm rule configuration information: Success alarms do not require configuration. Failure alarms can be configured as either first-failure alarms or all retry failure alarms. Timeout configuration requires the timeout type and timeout threshold. Project fluctuation alarms require the fluctuation rate and anti-shake period.
        :param _builtins.str alarm_rule_id: Alarm rule ID.
        :param _builtins.str alarm_rule_name: Alarm rule name.
        :param Sequence[_builtins.str] alarm_types: Alarm Rule Monitoring Types: failure: failure alarm; overtime: timeout alarm; success: success alarm; backTrackingOrRerunSuccess: backTrackingOrRerunSuccess: backTrackingOrRerunFailure: backTrackingOrRerunFailure. Project Fluctuation Alarms: projectFailureInstanceUpwardFluctuationAlarm: alarm if the upward fluctuation rate of failed instances exceeds the threshold. projectSuccessInstanceDownwardFluctuationAlarm: alarm if the downward fluctuation rate of successful instances exceeds the threshold. Offline Integration Task Reconciliation Alarms: reconciliationFailure: offline reconciliation task failure alarm; reconciliationOvertime: offline reconciliation task timeout alarm; reconciliationMismatch: alarm if the number of inconsistent entries in a data reconciliation task exceeds the threshold.
        :param _builtins.str bundle_id: Alarm rules bound to the bundle client: If it is empty, it is a normal alarm rule; if it is not empty, it corresponds to the rule bound to the bundle client.
        :param _builtins.str bundle_info: If bundleId is not empty, it indicates the name of the bound bundle client.
        :param _builtins.str description: Alarm rule description.
        :param Sequence[_builtins.str] monitor_object_ids: A list of monitored object business IDs. Different business IDs are passed in based on the MonitorType setting. For example, 1 (Task) - MonitorObjectIds is a list of task IDs; 2 (Workflow) - MonitorObjectIds is a list of workflow IDs (workflow IDs can be obtained from the ListWorkflows interface); 3 (Project) - MonitorObjectIds is a list of project IDs.
        :param _builtins.int monitor_object_type: Monitoring object type, Task dimension monitoring: can be configured according to task/workflow/project: 1.Task, 2.Workflow, 3.Project (default is 1.Task) Project dimension monitoring: Project overall task fluctuation alarm, 7: Project fluctuation monitoring alarm.
        :param _builtins.str owner_uin: Alarm rule creator uid.
        :param _builtins.int status: Whether the alarm rule is enabled: 0-disable, 1-enable.
        """
        pulumi.set(__self__, "alarm_groups", alarm_groups)
        pulumi.set(__self__, "alarm_level", alarm_level)
        pulumi.set(__self__, "alarm_rule_detail", alarm_rule_detail)
        pulumi.set(__self__, "alarm_rule_id", alarm_rule_id)
        pulumi.set(__self__, "alarm_rule_name", alarm_rule_name)
        pulumi.set(__self__, "alarm_types", alarm_types)
        pulumi.set(__self__, "bundle_id", bundle_id)
        pulumi.set(__self__, "bundle_info", bundle_info)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "monitor_object_ids", monitor_object_ids)
        pulumi.set(__self__, "monitor_object_type", monitor_object_type)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="alarmGroups")
    def alarm_groups(self) -> Sequence['outputs.GetOpsAlarmRulesDataItemAlarmGroupResult']:
        """
        Alarm recipient configuration list.
        """
        return pulumi.get(self, "alarm_groups")

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> _builtins.int:
        """
        Alarm level: 1. Normal, 2. Major, 3. Urgent.
        """
        return pulumi.get(self, "alarm_level")

    @_builtins.property
    @pulumi.getter(name="alarmRuleDetail")
    def alarm_rule_detail(self) -> 'outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailResult':
        """
        Alarm rule configuration information: Success alarms do not require configuration. Failure alarms can be configured as either first-failure alarms or all retry failure alarms. Timeout configuration requires the timeout type and timeout threshold. Project fluctuation alarms require the fluctuation rate and anti-shake period.
        """
        return pulumi.get(self, "alarm_rule_detail")

    @_builtins.property
    @pulumi.getter(name="alarmRuleId")
    def alarm_rule_id(self) -> _builtins.str:
        """
        Alarm rule ID.
        """
        return pulumi.get(self, "alarm_rule_id")

    @_builtins.property
    @pulumi.getter(name="alarmRuleName")
    def alarm_rule_name(self) -> _builtins.str:
        """
        Alarm rule name.
        """
        return pulumi.get(self, "alarm_rule_name")

    @_builtins.property
    @pulumi.getter(name="alarmTypes")
    def alarm_types(self) -> Sequence[_builtins.str]:
        """
        Alarm Rule Monitoring Types: failure: failure alarm; overtime: timeout alarm; success: success alarm; backTrackingOrRerunSuccess: backTrackingOrRerunSuccess: backTrackingOrRerunFailure: backTrackingOrRerunFailure. Project Fluctuation Alarms: projectFailureInstanceUpwardFluctuationAlarm: alarm if the upward fluctuation rate of failed instances exceeds the threshold. projectSuccessInstanceDownwardFluctuationAlarm: alarm if the downward fluctuation rate of successful instances exceeds the threshold. Offline Integration Task Reconciliation Alarms: reconciliationFailure: offline reconciliation task failure alarm; reconciliationOvertime: offline reconciliation task timeout alarm; reconciliationMismatch: alarm if the number of inconsistent entries in a data reconciliation task exceeds the threshold.
        """
        return pulumi.get(self, "alarm_types")

    @_builtins.property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> _builtins.str:
        """
        Alarm rules bound to the bundle client: If it is empty, it is a normal alarm rule; if it is not empty, it corresponds to the rule bound to the bundle client.
        """
        return pulumi.get(self, "bundle_id")

    @_builtins.property
    @pulumi.getter(name="bundleInfo")
    def bundle_info(self) -> _builtins.str:
        """
        If bundleId is not empty, it indicates the name of the bound bundle client.
        """
        return pulumi.get(self, "bundle_info")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Alarm rule description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="monitorObjectIds")
    def monitor_object_ids(self) -> Sequence[_builtins.str]:
        """
        A list of monitored object business IDs. Different business IDs are passed in based on the MonitorType setting. For example, 1 (Task) - MonitorObjectIds is a list of task IDs; 2 (Workflow) - MonitorObjectIds is a list of workflow IDs (workflow IDs can be obtained from the ListWorkflows interface); 3 (Project) - MonitorObjectIds is a list of project IDs.
        """
        return pulumi.get(self, "monitor_object_ids")

    @_builtins.property
    @pulumi.getter(name="monitorObjectType")
    def monitor_object_type(self) -> _builtins.int:
        """
        Monitoring object type, Task dimension monitoring: can be configured according to task/workflow/project: 1.Task, 2.Workflow, 3.Project (default is 1.Task) Project dimension monitoring: Project overall task fluctuation alarm, 7: Project fluctuation monitoring alarm.
        """
        return pulumi.get(self, "monitor_object_type")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Alarm rule creator uid.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Whether the alarm rule is enabled: 0-disable, 1-enable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmGroupResult(dict):
    def __init__(__self__, *,
                 alarm_escalation_interval: Optional[_builtins.int] = None,
                 alarm_escalation_recipient_ids: Optional[Sequence[_builtins.str]] = None,
                 alarm_recipient_ids: Optional[Sequence[_builtins.str]] = None,
                 alarm_recipient_type: Optional[_builtins.int] = None,
                 alarm_ways: Optional[Sequence[_builtins.str]] = None,
                 notification_fatigue: Optional['outputs.GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueResult'] = None,
                 web_hooks: Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmGroupWebHookResult']] = None):
        """
        :param _builtins.int alarm_escalation_interval: Alarm escalation interval.
        :param Sequence[_builtins.str] alarm_escalation_recipient_ids: Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.
        :param Sequence[_builtins.str] alarm_recipient_ids: Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.
        :param _builtins.int alarm_recipient_type: Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).
        :param Sequence[_builtins.str] alarm_ways: Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.
        :param 'GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueArgs' notification_fatigue: Alarm notification fatigue configuration.
        :param Sequence['GetOpsAlarmRulesDataItemAlarmGroupWebHookArgs'] web_hooks: List of webhook addresses for corporate WeChat groups, Feishu groups, DingTalk groups, Slack groups, and Teams groups.
        """
        if alarm_escalation_interval is not None:
            pulumi.set(__self__, "alarm_escalation_interval", alarm_escalation_interval)
        if alarm_escalation_recipient_ids is not None:
            pulumi.set(__self__, "alarm_escalation_recipient_ids", alarm_escalation_recipient_ids)
        if alarm_recipient_ids is not None:
            pulumi.set(__self__, "alarm_recipient_ids", alarm_recipient_ids)
        if alarm_recipient_type is not None:
            pulumi.set(__self__, "alarm_recipient_type", alarm_recipient_type)
        if alarm_ways is not None:
            pulumi.set(__self__, "alarm_ways", alarm_ways)
        if notification_fatigue is not None:
            pulumi.set(__self__, "notification_fatigue", notification_fatigue)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @_builtins.property
    @pulumi.getter(name="alarmEscalationInterval")
    def alarm_escalation_interval(self) -> Optional[_builtins.int]:
        """
        Alarm escalation interval.
        """
        return pulumi.get(self, "alarm_escalation_interval")

    @_builtins.property
    @pulumi.getter(name="alarmEscalationRecipientIds")
    def alarm_escalation_recipient_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.
        """
        return pulumi.get(self, "alarm_escalation_recipient_ids")

    @_builtins.property
    @pulumi.getter(name="alarmRecipientIds")
    def alarm_recipient_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.
        """
        return pulumi.get(self, "alarm_recipient_ids")

    @_builtins.property
    @pulumi.getter(name="alarmRecipientType")
    def alarm_recipient_type(self) -> Optional[_builtins.int]:
        """
        Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).
        """
        return pulumi.get(self, "alarm_recipient_type")

    @_builtins.property
    @pulumi.getter(name="alarmWays")
    def alarm_ways(self) -> Optional[Sequence[_builtins.str]]:
        """
        Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.
        """
        return pulumi.get(self, "alarm_ways")

    @_builtins.property
    @pulumi.getter(name="notificationFatigue")
    def notification_fatigue(self) -> Optional['outputs.GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueResult']:
        """
        Alarm notification fatigue configuration.
        """
        return pulumi.get(self, "notification_fatigue")

    @_builtins.property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmGroupWebHookResult']]:
        """
        List of webhook addresses for corporate WeChat groups, Feishu groups, DingTalk groups, Slack groups, and Teams groups.
        """
        return pulumi.get(self, "web_hooks")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueResult(dict):
    def __init__(__self__, *,
                 notify_count: Optional[_builtins.int] = None,
                 notify_interval: Optional[_builtins.int] = None,
                 quiet_intervals: Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueQuietIntervalResult']] = None):
        """
        :param _builtins.int notify_count: Number of alarms.
        :param _builtins.int notify_interval: Alarm interval, in minutes.
        :param Sequence['GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueQuietIntervalArgs'] quiet_intervals: Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: "00:00:00", EndTime: "09:00:00"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.
        """
        if notify_count is not None:
            pulumi.set(__self__, "notify_count", notify_count)
        if notify_interval is not None:
            pulumi.set(__self__, "notify_interval", notify_interval)
        if quiet_intervals is not None:
            pulumi.set(__self__, "quiet_intervals", quiet_intervals)

    @_builtins.property
    @pulumi.getter(name="notifyCount")
    def notify_count(self) -> Optional[_builtins.int]:
        """
        Number of alarms.
        """
        return pulumi.get(self, "notify_count")

    @_builtins.property
    @pulumi.getter(name="notifyInterval")
    def notify_interval(self) -> Optional[_builtins.int]:
        """
        Alarm interval, in minutes.
        """
        return pulumi.get(self, "notify_interval")

    @_builtins.property
    @pulumi.getter(name="quietIntervals")
    def quiet_intervals(self) -> Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueQuietIntervalResult']]:
        """
        Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: "00:00:00", EndTime: "09:00:00"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.
        """
        return pulumi.get(self, "quiet_intervals")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmGroupNotificationFatigueQuietIntervalResult(dict):
    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.int] days_of_weeks: According to the ISO standard, 1 represents Monday and 7 represents Sunday.
        :param _builtins.str end_time: End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        :param _builtins.str start_time: Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[_builtins.int]]:
        """
        According to the ISO standard, 1 represents Monday and 7 represents Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmGroupWebHookResult(dict):
    def __init__(__self__, *,
                 alarm_way: Optional[_builtins.str] = None,
                 web_hooks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str alarm_way: Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.
        :param Sequence[_builtins.str] web_hooks: List of webhook addresses for the alarm group.
        """
        if alarm_way is not None:
            pulumi.set(__self__, "alarm_way", alarm_way)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @_builtins.property
    @pulumi.getter(name="alarmWay")
    def alarm_way(self) -> Optional[_builtins.str]:
        """
        Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.
        """
        return pulumi.get(self, "alarm_way")

    @_builtins.property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of webhook addresses for the alarm group.
        """
        return pulumi.get(self, "web_hooks")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmRuleDetailResult(dict):
    def __init__(__self__, *,
                 data_backfill_or_rerun_time_out_ext_infos: Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoResult']] = None,
                 data_backfill_or_rerun_trigger: Optional[_builtins.int] = None,
                 project_instance_statistics_alarm_info_lists: Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListResult']] = None,
                 reconciliation_ext_infos: Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailReconciliationExtInfoResult']] = None,
                 time_out_ext_infos: Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailTimeOutExtInfoResult']] = None,
                 trigger: Optional[_builtins.int] = None):
        """
        :param Sequence['GetOpsAlarmRulesDataItemAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs'] data_backfill_or_rerun_time_out_ext_infos: Detailed configuration of re-running and re-recording instance timeout.
        :param _builtins.int data_backfill_or_rerun_trigger: Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.
        :param Sequence['GetOpsAlarmRulesDataItemAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs'] project_instance_statistics_alarm_info_lists: Project fluctuation alarm configuration details.
        :param Sequence['GetOpsAlarmRulesDataItemAlarmRuleDetailReconciliationExtInfoArgs'] reconciliation_ext_infos: Offline integrated reconciliation alarm configuration information.
        :param Sequence['GetOpsAlarmRulesDataItemAlarmRuleDetailTimeOutExtInfoArgs'] time_out_ext_infos: Periodic instance timeout configuration details.
        :param _builtins.int trigger: Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).
        """
        if data_backfill_or_rerun_time_out_ext_infos is not None:
            pulumi.set(__self__, "data_backfill_or_rerun_time_out_ext_infos", data_backfill_or_rerun_time_out_ext_infos)
        if data_backfill_or_rerun_trigger is not None:
            pulumi.set(__self__, "data_backfill_or_rerun_trigger", data_backfill_or_rerun_trigger)
        if project_instance_statistics_alarm_info_lists is not None:
            pulumi.set(__self__, "project_instance_statistics_alarm_info_lists", project_instance_statistics_alarm_info_lists)
        if reconciliation_ext_infos is not None:
            pulumi.set(__self__, "reconciliation_ext_infos", reconciliation_ext_infos)
        if time_out_ext_infos is not None:
            pulumi.set(__self__, "time_out_ext_infos", time_out_ext_infos)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter(name="dataBackfillOrRerunTimeOutExtInfos")
    def data_backfill_or_rerun_time_out_ext_infos(self) -> Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoResult']]:
        """
        Detailed configuration of re-running and re-recording instance timeout.
        """
        return pulumi.get(self, "data_backfill_or_rerun_time_out_ext_infos")

    @_builtins.property
    @pulumi.getter(name="dataBackfillOrRerunTrigger")
    def data_backfill_or_rerun_trigger(self) -> Optional[_builtins.int]:
        """
        Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.
        """
        return pulumi.get(self, "data_backfill_or_rerun_trigger")

    @_builtins.property
    @pulumi.getter(name="projectInstanceStatisticsAlarmInfoLists")
    def project_instance_statistics_alarm_info_lists(self) -> Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListResult']]:
        """
        Project fluctuation alarm configuration details.
        """
        return pulumi.get(self, "project_instance_statistics_alarm_info_lists")

    @_builtins.property
    @pulumi.getter(name="reconciliationExtInfos")
    def reconciliation_ext_infos(self) -> Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailReconciliationExtInfoResult']]:
        """
        Offline integrated reconciliation alarm configuration information.
        """
        return pulumi.get(self, "reconciliation_ext_infos")

    @_builtins.property
    @pulumi.getter(name="timeOutExtInfos")
    def time_out_ext_infos(self) -> Optional[Sequence['outputs.GetOpsAlarmRulesDataItemAlarmRuleDetailTimeOutExtInfoResult']]:
        """
        Periodic instance timeout configuration details.
        """
        return pulumi.get(self, "time_out_ext_infos")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional[_builtins.int]:
        """
        Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoResult(dict):
    def __init__(__self__, *,
                 hour: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 rule_type: Optional[_builtins.int] = None,
                 schedule_time_zone: Optional[_builtins.str] = None,
                 type: Optional[_builtins.int] = None):
        """
        :param _builtins.int hour: Specify the timeout value in hours. The default value is 0.
        :param _builtins.int min: The timeout value is specified in minutes. The default value is 1.
        :param _builtins.int rule_type: Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        :param _builtins.str schedule_time_zone: The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        :param _builtins.int type: Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Specify the timeout value in hours. The default value is 0.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.int]:
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.int]:
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListResult(dict):
    def __init__(__self__, *,
                 alarm_type: _builtins.str,
                 instance_count: Optional[_builtins.int] = None,
                 instance_threshold_count: Optional[_builtins.int] = None,
                 instance_threshold_count_percent: Optional[_builtins.int] = None,
                 is_cumulant: Optional[_builtins.bool] = None,
                 stabilize_statistics_cycle: Optional[_builtins.int] = None,
                 stabilize_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str alarm_type: Alarm Rule Monitoring Types: failure: failure alarm; overtime: timeout alarm; success: success alarm; backTrackingOrRerunSuccess: backTrackingOrRerunSuccess: backTrackingOrRerunFailure: backTrackingOrRerunFailure. Project Fluctuation Alarms: projectFailureInstanceUpwardFluctuationAlarm: alarm if the upward fluctuation rate of failed instances exceeds the threshold. projectSuccessInstanceDownwardFluctuationAlarm: alarm if the downward fluctuation rate of successful instances exceeds the threshold. Offline Integration Task Reconciliation Alarms: reconciliationFailure: offline reconciliation task failure alarm; reconciliationOvertime: offline reconciliation task timeout alarm; reconciliationMismatch: alarm if the number of inconsistent entries in a data reconciliation task exceeds the threshold. Example value: ["failure"].
        :param _builtins.int instance_count: The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.
        :param _builtins.int instance_threshold_count: The cumulative instance number fluctuation threshold.
        :param _builtins.int instance_threshold_count_percent: The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.
        :param _builtins.bool is_cumulant: Whether to calculate cumulatively, false: continuous, true: cumulative.
        :param _builtins.int stabilize_statistics_cycle: Stability statistics period (number of anti-shake configuration statistics periods).
        :param _builtins.int stabilize_threshold: Stability threshold (number of statistical cycles for anti-shake configuration).
        """
        pulumi.set(__self__, "alarm_type", alarm_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_threshold_count is not None:
            pulumi.set(__self__, "instance_threshold_count", instance_threshold_count)
        if instance_threshold_count_percent is not None:
            pulumi.set(__self__, "instance_threshold_count_percent", instance_threshold_count_percent)
        if is_cumulant is not None:
            pulumi.set(__self__, "is_cumulant", is_cumulant)
        if stabilize_statistics_cycle is not None:
            pulumi.set(__self__, "stabilize_statistics_cycle", stabilize_statistics_cycle)
        if stabilize_threshold is not None:
            pulumi.set(__self__, "stabilize_threshold", stabilize_threshold)

    @_builtins.property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> _builtins.str:
        """
        Alarm Rule Monitoring Types: failure: failure alarm; overtime: timeout alarm; success: success alarm; backTrackingOrRerunSuccess: backTrackingOrRerunSuccess: backTrackingOrRerunFailure: backTrackingOrRerunFailure. Project Fluctuation Alarms: projectFailureInstanceUpwardFluctuationAlarm: alarm if the upward fluctuation rate of failed instances exceeds the threshold. projectSuccessInstanceDownwardFluctuationAlarm: alarm if the downward fluctuation rate of successful instances exceeds the threshold. Offline Integration Task Reconciliation Alarms: reconciliationFailure: offline reconciliation task failure alarm; reconciliationOvertime: offline reconciliation task timeout alarm; reconciliationMismatch: alarm if the number of inconsistent entries in a data reconciliation task exceeds the threshold. Example value: ["failure"].
        """
        return pulumi.get(self, "alarm_type")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceThresholdCount")
    def instance_threshold_count(self) -> Optional[_builtins.int]:
        """
        The cumulative instance number fluctuation threshold.
        """
        return pulumi.get(self, "instance_threshold_count")

    @_builtins.property
    @pulumi.getter(name="instanceThresholdCountPercent")
    def instance_threshold_count_percent(self) -> Optional[_builtins.int]:
        """
        The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.
        """
        return pulumi.get(self, "instance_threshold_count_percent")

    @_builtins.property
    @pulumi.getter(name="isCumulant")
    def is_cumulant(self) -> Optional[_builtins.bool]:
        """
        Whether to calculate cumulatively, false: continuous, true: cumulative.
        """
        return pulumi.get(self, "is_cumulant")

    @_builtins.property
    @pulumi.getter(name="stabilizeStatisticsCycle")
    def stabilize_statistics_cycle(self) -> Optional[_builtins.int]:
        """
        Stability statistics period (number of anti-shake configuration statistics periods).
        """
        return pulumi.get(self, "stabilize_statistics_cycle")

    @_builtins.property
    @pulumi.getter(name="stabilizeThreshold")
    def stabilize_threshold(self) -> Optional[_builtins.int]:
        """
        Stability threshold (number of statistical cycles for anti-shake configuration).
        """
        return pulumi.get(self, "stabilize_threshold")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmRuleDetailReconciliationExtInfoResult(dict):
    def __init__(__self__, *,
                 hour: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 mismatch_count: Optional[_builtins.int] = None,
                 rule_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int hour: Reconciliation task timeout threshold: hours, default is 0.
        :param _builtins.int min: Reconciliation task timeout threshold: minutes, default is 1.
        :param _builtins.int mismatch_count: Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.
        :param _builtins.str rule_type: Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if mismatch_count is not None:
            pulumi.set(__self__, "mismatch_count", mismatch_count)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Reconciliation task timeout threshold: hours, default is 0.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Reconciliation task timeout threshold: minutes, default is 1.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="mismatchCount")
    def mismatch_count(self) -> Optional[_builtins.int]:
        """
        Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.
        """
        return pulumi.get(self, "mismatch_count")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.str]:
        """
        Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class GetOpsAlarmRulesDataItemAlarmRuleDetailTimeOutExtInfoResult(dict):
    def __init__(__self__, *,
                 hour: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 rule_type: Optional[_builtins.int] = None,
                 schedule_time_zone: Optional[_builtins.str] = None,
                 type: Optional[_builtins.int] = None):
        """
        :param _builtins.int hour: Specify the timeout value in hours. The default value is 0.
        :param _builtins.int min: The timeout value is specified in minutes. The default value is 1.
        :param _builtins.int rule_type: Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        :param _builtins.str schedule_time_zone: The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        :param _builtins.int type: Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Specify the timeout value in hours. The default value is 0.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[_builtins.int]:
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.int]:
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOpsAsyncJobDataResult(dict):
    def __init__(__self__, *,
                 async_id: Optional[_builtins.str] = None,
                 async_type: Optional[_builtins.str] = None,
                 create_time: Optional[_builtins.str] = None,
                 create_user_uin: Optional[_builtins.str] = None,
                 error_desc: Optional[_builtins.str] = None,
                 finished_sub_process_count: Optional[_builtins.int] = None,
                 project_id: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 success_sub_process_count: Optional[_builtins.int] = None,
                 total_sub_process_count: Optional[_builtins.int] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str async_id: Operation ID.
        :param _builtins.str async_type: Asynchronous operation type.
        :param _builtins.str create_time: Operation creation time.
        :param _builtins.str create_user_uin: Operator ID.
        :param _builtins.str error_desc: Error message.
        :param _builtins.int finished_sub_process_count: Number of completed sub-operations.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str status: Asynchronous operation status: Initial state: INIT; Running: RUNNING; Success: SUCCESS; Failure: FAIL; Partial success: PART_SUCCESS.
        :param _builtins.int success_sub_process_count: Number of successful sub-operations.
        :param _builtins.int total_sub_process_count: Total number of sub-operations.
        :param _builtins.str update_time: Update time.
        """
        if async_id is not None:
            pulumi.set(__self__, "async_id", async_id)
        if async_type is not None:
            pulumi.set(__self__, "async_type", async_type)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if create_user_uin is not None:
            pulumi.set(__self__, "create_user_uin", create_user_uin)
        if error_desc is not None:
            pulumi.set(__self__, "error_desc", error_desc)
        if finished_sub_process_count is not None:
            pulumi.set(__self__, "finished_sub_process_count", finished_sub_process_count)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if success_sub_process_count is not None:
            pulumi.set(__self__, "success_sub_process_count", success_sub_process_count)
        if total_sub_process_count is not None:
            pulumi.set(__self__, "total_sub_process_count", total_sub_process_count)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="asyncId")
    def async_id(self) -> Optional[_builtins.str]:
        """
        Operation ID.
        """
        return pulumi.get(self, "async_id")

    @_builtins.property
    @pulumi.getter(name="asyncType")
    def async_type(self) -> Optional[_builtins.str]:
        """
        Asynchronous operation type.
        """
        return pulumi.get(self, "async_type")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Operation creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> Optional[_builtins.str]:
        """
        Operator ID.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter(name="errorDesc")
    def error_desc(self) -> Optional[_builtins.str]:
        """
        Error message.
        """
        return pulumi.get(self, "error_desc")

    @_builtins.property
    @pulumi.getter(name="finishedSubProcessCount")
    def finished_sub_process_count(self) -> Optional[_builtins.int]:
        """
        Number of completed sub-operations.
        """
        return pulumi.get(self, "finished_sub_process_count")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Asynchronous operation status: Initial state: INIT; Running: RUNNING; Success: SUCCESS; Failure: FAIL; Partial success: PART_SUCCESS.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="successSubProcessCount")
    def success_sub_process_count(self) -> Optional[_builtins.int]:
        """
        Number of successful sub-operations.
        """
        return pulumi.get(self, "success_sub_process_count")

    @_builtins.property
    @pulumi.getter(name="totalSubProcessCount")
    def total_sub_process_count(self) -> Optional[_builtins.int]:
        """
        Total number of sub-operations.
        """
        return pulumi.get(self, "total_sub_process_count")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetOpsDownstreamTasksDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOpsDownstreamTasksDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetOpsDownstreamTasksDataItemArgs'] items: Paging data.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Pagination size.
        :param _builtins.int total_count: Total number of results.
        :param _builtins.int total_page_number: Total pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOpsDownstreamTasksDataItemResult']:
        """
        Paging data.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Pagination size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total number of results.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetOpsDownstreamTasksDataItemResult(dict):
    def __init__(__self__, *,
                 cycle_type: _builtins.str,
                 execution_end_time: _builtins.str,
                 execution_start_time: _builtins.str,
                 first_run_time: _builtins.str,
                 first_submit_time: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 owner_uin: _builtins.str,
                 project_id: _builtins.str,
                 project_name: _builtins.str,
                 schedule_desc: _builtins.str,
                 status: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type_desc: _builtins.str,
                 task_type_id: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.str cycle_type: Task Cycle Type: ONEOFF_CYCLE: One-time, YEAR_CYCLE: Yearly, MONTH_CYCLE: Monthly, WEEK_CYCLE: Weekly, DAY_CYCLE: Daily, HOUR_CYCLE: Hourly, MINUTE_CYCLE: Minute-level, CRONTAB_CYCLE: Crontab expression-based.
        :param _builtins.str execution_end_time: Execution end time. format: HH:mm, for example 23:59.
        :param _builtins.str execution_start_time: Execution start time. format: HH:mm, for example 00:00.
        :param _builtins.str first_run_time: First running time.
        :param _builtins.str first_submit_time: Latest submission time.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str folder_name: Folder name.
        :param _builtins.str owner_uin: Specifies the person in charge.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str project_name: Project name.
        :param _builtins.str schedule_desc: Describes the scheduling plan display description information.
        :param _builtins.str status: Task Status: -N: New, -Y: Scheduling, -F: Offline, -O: Paused, -T: Offlining, -INVALID: Invalid.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type_desc: Task type description. -20 : universal data synchronization, - 25 :  ETLTaskType, - 26 :  ETLTaskType, - 30 :  python, - 31 :  pyspark, - 34 :  hivesql, - 35 :  shell, - 36 :  sparksql, - 21 :  jdbcsql, - 32 :  dlc, - 33 :  ImpalaTaskType, - 40 :  CDWTaskType, - 41 :  kettle, - 42 :  TCHouse-X, - 43 :  TCHouse-X SQL, - 46 :  dlcsparkTaskType, - 47 :  TiOneMachineLearningTaskType, - 48 :  Trino, - 50 :  DLCPyspark, - 23 :  TencentDistributedSQL, - 39 :  spark, - 92 :  MRTaskType, - 38 :  ShellScript, - 70 :  HiveSQLScrip, -130: specifies the branch, -131: specifies the merge, -132: specifies the Notebook explore, -133: specifies the SSH node, - 134 :  StarRocks, - 137 :  For-each, -10000: common custom business. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int task_type_id: Task type Id. 21:JDBC SQL, 23:TDSQL-PostgreSQL, 26:OfflineSynchronization, 30:Python, 31:PySpark, 33:Impala, 34:Hive SQL, 35:Shell, 36:Spark SQL, 38:Shell Form Mode, 39:Spark, 40:TCHouse-P, 41:Kettle, 42:Tchouse-X, 43:TCHouse-X SQL, 46:DLC Spark, 47:TiOne, 48:Trino, 50:DLC PySpark, 92:MapReduce, 130:Branch Node, 131:Merged Node, 132:Notebook, 133:SSH, 134:StarRocks, 137:For-each, 138:Setats SQL. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str workflow_id: Workflow id.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "execution_end_time", execution_end_time)
        pulumi.set(__self__, "execution_start_time", execution_start_time)
        pulumi.set(__self__, "first_run_time", first_run_time)
        pulumi.set(__self__, "first_submit_time", first_submit_time)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "schedule_desc", schedule_desc)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type_desc", task_type_desc)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Task Cycle Type: ONEOFF_CYCLE: One-time, YEAR_CYCLE: Yearly, MONTH_CYCLE: Monthly, WEEK_CYCLE: Weekly, DAY_CYCLE: Daily, HOUR_CYCLE: Hourly, MINUTE_CYCLE: Minute-level, CRONTAB_CYCLE: Crontab expression-based.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> _builtins.str:
        """
        Execution end time. format: HH:mm, for example 23:59.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> _builtins.str:
        """
        Execution start time. format: HH:mm, for example 00:00.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter(name="firstRunTime")
    def first_run_time(self) -> _builtins.str:
        """
        First running time.
        """
        return pulumi.get(self, "first_run_time")

    @_builtins.property
    @pulumi.getter(name="firstSubmitTime")
    def first_submit_time(self) -> _builtins.str:
        """
        Latest submission time.
        """
        return pulumi.get(self, "first_submit_time")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        Folder name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Specifies the person in charge.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> _builtins.str:
        """
        Project name.
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter(name="scheduleDesc")
    def schedule_desc(self) -> _builtins.str:
        """
        Describes the scheduling plan display description information.
        """
        return pulumi.get(self, "schedule_desc")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Task Status: -N: New, -Y: Scheduling, -F: Offline, -O: Paused, -T: Offlining, -INVALID: Invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskTypeDesc")
    def task_type_desc(self) -> _builtins.str:
        """
        Task type description. -20 : universal data synchronization, - 25 :  ETLTaskType, - 26 :  ETLTaskType, - 30 :  python, - 31 :  pyspark, - 34 :  hivesql, - 35 :  shell, - 36 :  sparksql, - 21 :  jdbcsql, - 32 :  dlc, - 33 :  ImpalaTaskType, - 40 :  CDWTaskType, - 41 :  kettle, - 42 :  TCHouse-X, - 43 :  TCHouse-X SQL, - 46 :  dlcsparkTaskType, - 47 :  TiOneMachineLearningTaskType, - 48 :  Trino, - 50 :  DLCPyspark, - 23 :  TencentDistributedSQL, - 39 :  spark, - 92 :  MRTaskType, - 38 :  ShellScript, - 70 :  HiveSQLScrip, -130: specifies the branch, -131: specifies the merge, -132: specifies the Notebook explore, -133: specifies the SSH node, - 134 :  StarRocks, - 137 :  For-each, -10000: common custom business. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "task_type_desc")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type Id. 21:JDBC SQL, 23:TDSQL-PostgreSQL, 26:OfflineSynchronization, 30:Python, 31:PySpark, 33:Impala, 34:Hive SQL, 35:Shell, 36:Spark SQL, 38:Shell Form Mode, 39:Spark, 40:TCHouse-P, 41:Kettle, 42:Tchouse-X, 43:TCHouse-X SQL, 46:DLC Spark, 47:TiOne, 48:Trino, 50:DLC PySpark, 92:MapReduce, 130:Branch Node, 131:Merged Node, 132:Notebook, 133:SSH, 134:StarRocks, 137:For-each, 138:Setats SQL. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow id.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetOpsTaskCodeDataResult(dict):
    def __init__(__self__, *,
                 code_content: _builtins.str,
                 code_file_size: _builtins.int):
        """
        :param _builtins.str code_content: Specifies the code content.
        :param _builtins.int code_file_size: Specifies the size of the code file in bytes.
        """
        pulumi.set(__self__, "code_content", code_content)
        pulumi.set(__self__, "code_file_size", code_file_size)

    @_builtins.property
    @pulumi.getter(name="codeContent")
    def code_content(self) -> _builtins.str:
        """
        Specifies the code content.
        """
        return pulumi.get(self, "code_content")

    @_builtins.property
    @pulumi.getter(name="codeFileSize")
    def code_file_size(self) -> _builtins.int:
        """
        Specifies the size of the code file in bytes.
        """
        return pulumi.get(self, "code_file_size")


@pulumi.output_type
class GetOpsTasksDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOpsTasksDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetOpsTasksDataItemArgs'] items: Record list.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Pagination size.
        :param _builtins.int total_count: Total number of results.
        :param _builtins.int total_page_number: Total pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOpsTasksDataItemResult']:
        """
        Record list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Pagination size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total number of results.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetOpsTasksDataItemResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 cycle_type: _builtins.str,
                 executor_group_id: _builtins.str,
                 executor_group_name: _builtins.str,
                 first_run_time: _builtins.str,
                 first_submit_time: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 last_scheduler_commit_time: _builtins.str,
                 last_update_time: _builtins.str,
                 owner_uin: _builtins.str,
                 project_id: _builtins.str,
                 project_name: _builtins.str,
                 schedule_desc: _builtins.str,
                 status: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type_desc: _builtins.str,
                 task_type_id: _builtins.int,
                 update_user_uin: _builtins.str,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str cycle_type: Task Cycle Type: ONEOFF_CYCLE: One-time, YEAR_CYCLE: Yearly, MONTH_CYCLE: Monthly, WEEK_CYCLE: Weekly, DAY_CYCLE: Daily, HOUR_CYCLE: Hourly, MINUTE_CYCLE: Minute-level, CRONTAB_CYCLE: Crontab expression-based.
        :param _builtins.str executor_group_id: Executor Group ID.
        :param _builtins.str executor_group_name: Resource group name.
        :param _builtins.str first_run_time: First execution time.
        :param _builtins.str first_submit_time: Most recent submission time.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str folder_name: Folder name.
        :param _builtins.str last_scheduler_commit_time: Latest scheduling submission time.
        :param _builtins.str last_update_time: Latest update time.
        :param _builtins.str owner_uin: Owner id.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str project_name: Project name.
        :param _builtins.str schedule_desc: Scheduling description.
        :param _builtins.str status: Task Status: -Y: Running, -F: Stopped, -O: Frozen, -T: Stopping, -INVALID: Invalid.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type_desc: Task type description. -Universal data synchronization, - ETLTaskType, - ETLTaskType, - python, - pyspark, - HiveSQLTaskType, - shell, - SparkSQLTaskType, - JDBCSQLTaskType, - DLCTaskType, - ImpalaTaskType, - CDWTaskType, - kettle, - DLCSparkTaskType, -TiOne machine learning, - TrinoTaskType, - DLCPyspark, - spark, - mr, -Specifies the shell script, -hivesql script, -Specifies common custom business.
        :param _builtins.int task_type_id: Task type Id. -20: common data sync, - 25:ETLTaskType, - 26:ETLTaskType, - 30:python, - 31:pyspark, - 34:HiveSQLTaskType, - 35:shell, - 36:SparkSQLTaskType, - 21:JDBCSQLTaskType, - 32:DLCTaskType, - 33:ImpalaTaskType, - 40:CDWTaskType, - 41:kettle, - 46:DLCSparkTaskType, -47: TiOne machine learning, - 48:TrinoTaskType, - 50:DLCPyspark39:spark, - 92:mr, -38: shell script, -70: hivesql script, -1000: common custom business.
        :param _builtins.str update_user_uin: Specifies the name of the updater.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "executor_group_id", executor_group_id)
        pulumi.set(__self__, "executor_group_name", executor_group_name)
        pulumi.set(__self__, "first_run_time", first_run_time)
        pulumi.set(__self__, "first_submit_time", first_submit_time)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "last_scheduler_commit_time", last_scheduler_commit_time)
        pulumi.set(__self__, "last_update_time", last_update_time)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "schedule_desc", schedule_desc)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type_desc", task_type_desc)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "update_user_uin", update_user_uin)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Task Cycle Type: ONEOFF_CYCLE: One-time, YEAR_CYCLE: Yearly, MONTH_CYCLE: Monthly, WEEK_CYCLE: Weekly, DAY_CYCLE: Daily, HOUR_CYCLE: Hourly, MINUTE_CYCLE: Minute-level, CRONTAB_CYCLE: Crontab expression-based.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="executorGroupId")
    def executor_group_id(self) -> _builtins.str:
        """
        Executor Group ID.
        """
        return pulumi.get(self, "executor_group_id")

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> _builtins.str:
        """
        Resource group name.
        """
        return pulumi.get(self, "executor_group_name")

    @_builtins.property
    @pulumi.getter(name="firstRunTime")
    def first_run_time(self) -> _builtins.str:
        """
        First execution time.
        """
        return pulumi.get(self, "first_run_time")

    @_builtins.property
    @pulumi.getter(name="firstSubmitTime")
    def first_submit_time(self) -> _builtins.str:
        """
        Most recent submission time.
        """
        return pulumi.get(self, "first_submit_time")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        Folder name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="lastSchedulerCommitTime")
    def last_scheduler_commit_time(self) -> _builtins.str:
        """
        Latest scheduling submission time.
        """
        return pulumi.get(self, "last_scheduler_commit_time")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> _builtins.str:
        """
        Latest update time.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Owner id.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> _builtins.str:
        """
        Project name.
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter(name="scheduleDesc")
    def schedule_desc(self) -> _builtins.str:
        """
        Scheduling description.
        """
        return pulumi.get(self, "schedule_desc")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Task Status: -Y: Running, -F: Stopped, -O: Frozen, -T: Stopping, -INVALID: Invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskTypeDesc")
    def task_type_desc(self) -> _builtins.str:
        """
        Task type description. -Universal data synchronization, - ETLTaskType, - ETLTaskType, - python, - pyspark, - HiveSQLTaskType, - shell, - SparkSQLTaskType, - JDBCSQLTaskType, - DLCTaskType, - ImpalaTaskType, - CDWTaskType, - kettle, - DLCSparkTaskType, -TiOne machine learning, - TrinoTaskType, - DLCPyspark, - spark, - mr, -Specifies the shell script, -hivesql script, -Specifies common custom business.
        """
        return pulumi.get(self, "task_type_desc")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type Id. -20: common data sync, - 25:ETLTaskType, - 26:ETLTaskType, - 30:python, - 31:pyspark, - 34:HiveSQLTaskType, - 35:shell, - 36:SparkSQLTaskType, - 21:JDBCSQLTaskType, - 32:DLCTaskType, - 33:ImpalaTaskType, - 40:CDWTaskType, - 41:kettle, - 46:DLCSparkTaskType, -47: TiOne machine learning, - 48:TrinoTaskType, - 50:DLCPyspark39:spark, - 92:mr, -38: shell script, -70: hivesql script, -1000: common custom business.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="updateUserUin")
    def update_user_uin(self) -> _builtins.str:
        """
        Specifies the name of the updater.
        """
        return pulumi.get(self, "update_user_uin")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetOpsUpstreamTasksDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOpsUpstreamTasksDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetOpsUpstreamTasksDataItemArgs'] items: Paging data.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Pagination size.
        :param _builtins.int total_count: Total number of results.
        :param _builtins.int total_page_number: Total pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOpsUpstreamTasksDataItemResult']:
        """
        Paging data.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Pagination size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total number of results.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetOpsUpstreamTasksDataItemResult(dict):
    def __init__(__self__, *,
                 cycle_type: _builtins.str,
                 execution_end_time: _builtins.str,
                 execution_start_time: _builtins.str,
                 first_run_time: _builtins.str,
                 first_submit_time: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 owner_uin: _builtins.str,
                 project_id: _builtins.str,
                 project_name: _builtins.str,
                 schedule_desc: _builtins.str,
                 status: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type_desc: _builtins.str,
                 task_type_id: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.str cycle_type: Task Cycle Type: ONEOFF_CYCLE: One-time, YEAR_CYCLE: Yearly, MONTH_CYCLE: Monthly, WEEK_CYCLE: Weekly, DAY_CYCLE: Daily, HOUR_CYCLE: Hourly, MINUTE_CYCLE: Minute-level, CRONTAB_CYCLE: Crontab expression-based.
        :param _builtins.str execution_end_time: Execution end time. format: HH:mm, for example 23:59.
        :param _builtins.str execution_start_time: Execution start time. format: HH:mm, for example 00:00.
        :param _builtins.str first_run_time: First running time.
        :param _builtins.str first_submit_time: Latest submission time.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str folder_name: Folder name.
        :param _builtins.str owner_uin: Specifies the person in charge.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str project_name: Project name.
        :param _builtins.str schedule_desc: Describes the scheduling plan display description information.
        :param _builtins.str status: Task Status: -N: New, -Y: Scheduling, -F: Offline, -O: Paused, -T: Offlining, -INVALID: Invalid.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type_desc: Task type description. -20 : universal data synchronization, - 25 :  ETLTaskType, - 26 :  ETLTaskType, - 30 :  python, - 31 :  pyspark, - 34 :  hivesql, - 35 :  shell, - 36 :  sparksql, - 21 :  jdbcsql, - 32 :  dlc, - 33 :  ImpalaTaskType, - 40 :  CDWTaskType, - 41 :  kettle, - 42 :  TCHouse-X, - 43 :  TCHouse-X SQL, - 46 :  dlcsparkTaskType, - 47 :  TiOneMachineLearningTaskType, - 48 :  Trino, - 50 :  DLCPyspark, - 23 :  TencentDistributedSQL, - 39 :  spark, - 92 :  MRTaskType, - 38 :  ShellScript, - 70 :  HiveSQLScrip, -130: specifies the branch, -131: specifies the merge, -132: specifies the Notebook explore, -133: specifies the SSH node, - 134 :  StarRocks, - 137 :  For-each, -10000: common custom business. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int task_type_id: Task type Id. 21:JDBC SQL, 23:TDSQL-PostgreSQL, 26:OfflineSynchronization, 30:Python, 31:PySpark, 33:Impala, 34:Hive SQL, 35:Shell, 36:Spark SQL, 38:Shell Form Mode, 39:Spark, 40:TCHouse-P, 41:Kettle, 42:Tchouse-X, 43:TCHouse-X SQL, 46:DLC Spark, 47:TiOne, 48:Trino, 50:DLC PySpark, 92:MapReduce, 130:Branch Node, 131:Merged Node, 132:Notebook, 133:SSH, 134:StarRocks, 137:For-each, 138:Setats SQL. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str workflow_id: Workflow id.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "execution_end_time", execution_end_time)
        pulumi.set(__self__, "execution_start_time", execution_start_time)
        pulumi.set(__self__, "first_run_time", first_run_time)
        pulumi.set(__self__, "first_submit_time", first_submit_time)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "schedule_desc", schedule_desc)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type_desc", task_type_desc)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Task Cycle Type: ONEOFF_CYCLE: One-time, YEAR_CYCLE: Yearly, MONTH_CYCLE: Monthly, WEEK_CYCLE: Weekly, DAY_CYCLE: Daily, HOUR_CYCLE: Hourly, MINUTE_CYCLE: Minute-level, CRONTAB_CYCLE: Crontab expression-based.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> _builtins.str:
        """
        Execution end time. format: HH:mm, for example 23:59.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> _builtins.str:
        """
        Execution start time. format: HH:mm, for example 00:00.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter(name="firstRunTime")
    def first_run_time(self) -> _builtins.str:
        """
        First running time.
        """
        return pulumi.get(self, "first_run_time")

    @_builtins.property
    @pulumi.getter(name="firstSubmitTime")
    def first_submit_time(self) -> _builtins.str:
        """
        Latest submission time.
        """
        return pulumi.get(self, "first_submit_time")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        Folder name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Specifies the person in charge.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> _builtins.str:
        """
        Project name.
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter(name="scheduleDesc")
    def schedule_desc(self) -> _builtins.str:
        """
        Describes the scheduling plan display description information.
        """
        return pulumi.get(self, "schedule_desc")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Task Status: -N: New, -Y: Scheduling, -F: Offline, -O: Paused, -T: Offlining, -INVALID: Invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskTypeDesc")
    def task_type_desc(self) -> _builtins.str:
        """
        Task type description. -20 : universal data synchronization, - 25 :  ETLTaskType, - 26 :  ETLTaskType, - 30 :  python, - 31 :  pyspark, - 34 :  hivesql, - 35 :  shell, - 36 :  sparksql, - 21 :  jdbcsql, - 32 :  dlc, - 33 :  ImpalaTaskType, - 40 :  CDWTaskType, - 41 :  kettle, - 42 :  TCHouse-X, - 43 :  TCHouse-X SQL, - 46 :  dlcsparkTaskType, - 47 :  TiOneMachineLearningTaskType, - 48 :  Trino, - 50 :  DLCPyspark, - 23 :  TencentDistributedSQL, - 39 :  spark, - 92 :  MRTaskType, - 38 :  ShellScript, - 70 :  HiveSQLScrip, -130: specifies the branch, -131: specifies the merge, -132: specifies the Notebook explore, -133: specifies the SSH node, - 134 :  StarRocks, - 137 :  For-each, -10000: common custom business. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "task_type_desc")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type Id. 21:JDBC SQL, 23:TDSQL-PostgreSQL, 26:OfflineSynchronization, 30:Python, 31:PySpark, 33:Impala, 34:Hive SQL, 35:Shell, 36:Spark SQL, 38:Shell Form Mode, 39:Spark, 40:TCHouse-P, 41:Kettle, 42:Tchouse-X, 43:TCHouse-X SQL, 46:DLC Spark, 47:TiOne, 48:Trino, 50:DLC PySpark, 92:MapReduce, 130:Branch Node, 131:Merged Node, 132:Notebook, 133:SSH, 134:StarRocks, 137:For-each, 138:Setats SQL. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow id.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetOpsWorkflowDataResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 create_user_uin: _builtins.str,
                 cycle_type: _builtins.str,
                 end_time: _builtins.str,
                 first_submit_time: _builtins.str,
                 folder_id: _builtins.str,
                 instance_init_strategy: _builtins.str,
                 latest_submit_time: _builtins.str,
                 owner_uin: _builtins.str,
                 scheduler_desc: _builtins.str,
                 start_time: _builtins.str,
                 startup_time: _builtins.int,
                 status: _builtins.str,
                 update_time: _builtins.str,
                 workflow_desc: _builtins.str,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str,
                 workflow_type: _builtins.str):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str create_user_uin: Creator.
        :param _builtins.str cycle_type: Task cycle type. `ONEOFF_CYCLE`: One-time; `YEAR_CYCLE`: Year; `MONTH_CYCLE`: Month; `WEEK_CYCLE`: Week; `DAY_CYCLE`: Day; `HOUR_CYCLE`: Hour; `MINUTE_CYCLE`: Minute; `CRONTAB_CYCLE`: Crontab expression type.
        :param _builtins.str end_time: Configuration end date - end date.
        :param _builtins.str first_submit_time: Workflow first submission time.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str instance_init_strategy: Task instance initialization strategy: 
                - T_PLUS_1 (T+1): Initialize after one day delay;
                - T_PLUS_0 (T+0): Initialize on the same day;
                - T_MINUS_1 (T-1): Initialize one day in advance.
        :param _builtins.str latest_submit_time: Workflow latest submission time.
        :param _builtins.str owner_uin: Responsible persons, multiple separated by ';'.
        :param _builtins.str scheduler_desc: Scheduling plan description.
        :param _builtins.str start_time: Configuration effective date - start date.
        :param _builtins.int startup_time: Delayed execution time, unit=minute.
        :param _builtins.str status: Workflow status: `ALL_RUNNING`: All scheduled; `ALL_FREEZED`: All paused; `ALL_STOPPTED`: All offline; `PART_RUNNING`: Partially scheduled; `ALL_NO_RUNNING`: All unscheduled; `ALL_INVALID`: All invalid.
        :param _builtins.str update_time: Modification time.
        :param _builtins.str workflow_desc: Workflow description.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        :param _builtins.str workflow_type: Workflow type:
                - cycle: Periodic;
                - manual: Manual.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "create_user_uin", create_user_uin)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "first_submit_time", first_submit_time)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "instance_init_strategy", instance_init_strategy)
        pulumi.set(__self__, "latest_submit_time", latest_submit_time)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "scheduler_desc", scheduler_desc)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "startup_time", startup_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "workflow_desc", workflow_desc)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)
        pulumi.set(__self__, "workflow_type", workflow_type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> _builtins.str:
        """
        Creator.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Task cycle type. `ONEOFF_CYCLE`: One-time; `YEAR_CYCLE`: Year; `MONTH_CYCLE`: Month; `WEEK_CYCLE`: Week; `DAY_CYCLE`: Day; `HOUR_CYCLE`: Hour; `MINUTE_CYCLE`: Minute; `CRONTAB_CYCLE`: Crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Configuration end date - end date.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="firstSubmitTime")
    def first_submit_time(self) -> _builtins.str:
        """
        Workflow first submission time.
        """
        return pulumi.get(self, "first_submit_time")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="instanceInitStrategy")
    def instance_init_strategy(self) -> _builtins.str:
        """
        Task instance initialization strategy: 
         - T_PLUS_1 (T+1): Initialize after one day delay;
         - T_PLUS_0 (T+0): Initialize on the same day;
         - T_MINUS_1 (T-1): Initialize one day in advance.
        """
        return pulumi.get(self, "instance_init_strategy")

    @_builtins.property
    @pulumi.getter(name="latestSubmitTime")
    def latest_submit_time(self) -> _builtins.str:
        """
        Workflow latest submission time.
        """
        return pulumi.get(self, "latest_submit_time")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Responsible persons, multiple separated by ';'.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="schedulerDesc")
    def scheduler_desc(self) -> _builtins.str:
        """
        Scheduling plan description.
        """
        return pulumi.get(self, "scheduler_desc")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Configuration effective date - start date.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="startupTime")
    def startup_time(self) -> _builtins.int:
        """
        Delayed execution time, unit=minute.
        """
        return pulumi.get(self, "startup_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Workflow status: `ALL_RUNNING`: All scheduled; `ALL_FREEZED`: All paused; `ALL_STOPPTED`: All offline; `PART_RUNNING`: Partially scheduled; `ALL_NO_RUNNING`: All unscheduled; `ALL_INVALID`: All invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Modification time.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="workflowDesc")
    def workflow_desc(self) -> _builtins.str:
        """
        Workflow description.
        """
        return pulumi.get(self, "workflow_desc")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")

    @_builtins.property
    @pulumi.getter(name="workflowType")
    def workflow_type(self) -> _builtins.str:
        """
        Workflow type:
         - cycle: Periodic;
         - manual: Manual.
        """
        return pulumi.get(self, "workflow_type")


@pulumi.output_type
class GetOpsWorkflowsDataResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 owner_uin: _builtins.str,
                 project_id: _builtins.str,
                 project_name: _builtins.str,
                 status: _builtins.str,
                 task_count: _builtins.int,
                 update_time: _builtins.str,
                 update_user_uin: _builtins.str,
                 workflow_desc: _builtins.str,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str,
                 workflow_type: _builtins.str):
        """
        :param _builtins.str create_time: Creation time, format yyyy-MM-dd HH:mm:ss.
        :param _builtins.str folder_id: File ID.
        :param _builtins.str folder_name: File name.
        :param _builtins.str owner_uin: Responsible person ID.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str project_name: Project name.
        :param _builtins.str status: Workflow status filter: `ALL_RUNNING`: All scheduled, `ALL_FREEZED`: All paused, `ALL_STOPPTED`: All offline, `PART_RUNNING`: Partially scheduled, `ALL_NO_RUNNING`: All unscheduled, `ALL_INVALID`: All invalid.
        :param _builtins.int task_count: Task count.
        :param _builtins.str update_time: Last update time, including development and production changes.
        :param _builtins.str update_user_uin: Last updated by, including development and production changes.
        :param _builtins.str workflow_desc: Workflow description.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        :param _builtins.str workflow_type: Workflow type filter, supported values: `Cycle` or `Manual`. By default, only `Cycle` is queried.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_count", task_count)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "update_user_uin", update_user_uin)
        pulumi.set(__self__, "workflow_desc", workflow_desc)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)
        pulumi.set(__self__, "workflow_type", workflow_type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time, format yyyy-MM-dd HH:mm:ss.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        File ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        File name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Responsible person ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> _builtins.str:
        """
        Project name.
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Workflow status filter: `ALL_RUNNING`: All scheduled, `ALL_FREEZED`: All paused, `ALL_STOPPTED`: All offline, `PART_RUNNING`: Partially scheduled, `ALL_NO_RUNNING`: All unscheduled, `ALL_INVALID`: All invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> _builtins.int:
        """
        Task count.
        """
        return pulumi.get(self, "task_count")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Last update time, including development and production changes.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="updateUserUin")
    def update_user_uin(self) -> _builtins.str:
        """
        Last updated by, including development and production changes.
        """
        return pulumi.get(self, "update_user_uin")

    @_builtins.property
    @pulumi.getter(name="workflowDesc")
    def workflow_desc(self) -> _builtins.str:
        """
        Workflow description.
        """
        return pulumi.get(self, "workflow_desc")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")

    @_builtins.property
    @pulumi.getter(name="workflowType")
    def workflow_type(self) -> _builtins.str:
        """
        Workflow type filter, supported values: `Cycle` or `Manual`. By default, only `Cycle` is queried.
        """
        return pulumi.get(self, "workflow_type")


@pulumi.output_type
class GetProjectRolesItemResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 role_display_name: _builtins.str,
                 role_id: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str description: Description.
        :param _builtins.str role_display_name: Role Chinese display name fuzzy search, can only pass one value.
        :param _builtins.str role_id: Role ID.
        :param _builtins.str role_name: Role name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "role_display_name", role_display_name)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="roleDisplayName")
    def role_display_name(self) -> _builtins.str:
        """
        Role Chinese display name fuzzy search, can only pass one value.
        """
        return pulumi.get(self, "role_display_name")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Role ID.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        Role name.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetProjectsItemResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 creator_uin: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 project_id: _builtins.str,
                 project_model: _builtins.str,
                 project_name: _builtins.str,
                 project_owner_uin: _builtins.str,
                 status: _builtins.int):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str creator_uin: Project creator ID.
        :param _builtins.str description: Remarks.
        :param _builtins.str display_name: Project display name, can be Chinese name.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str project_model: Project model, optional values: SIMPLE, STANDARD.
        :param _builtins.str project_name: Project name or unique identifier name, supports fuzzy search.
        :param _builtins.str project_owner_uin: Project owner ID.
        :param _builtins.int status: Project status, optional values: 0 (disabled), 1 (normal).
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator_uin", creator_uin)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_model", project_model)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "project_owner_uin", project_owner_uin)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> _builtins.str:
        """
        Project creator ID.
        """
        return pulumi.get(self, "creator_uin")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Remarks.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Project display name, can be Chinese name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectModel")
    def project_model(self) -> _builtins.str:
        """
        Project model, optional values: SIMPLE, STANDARD.
        """
        return pulumi.get(self, "project_model")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> _builtins.str:
        """
        Project name or unique identifier name, supports fuzzy search.
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter(name="projectOwnerUin")
    def project_owner_uin(self) -> _builtins.str:
        """
        Project owner ID.
        """
        return pulumi.get(self, "project_owner_uin")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Project status, optional values: 0 (disabled), 1 (normal).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetResourceFilesDataResult(dict):
    def __init__(__self__, *,
                 file_extension_type: _builtins.str,
                 local_path: _builtins.str,
                 resource_id: _builtins.str,
                 resource_name: _builtins.str):
        """
        :param _builtins.str file_extension_type: Specifies the resource file type.
        :param _builtins.str local_path: Resource path.
        :param _builtins.str resource_id: Resource file ID.
        :param _builtins.str resource_name: Resource file name (fuzzy search keyword).
        """
        pulumi.set(__self__, "file_extension_type", file_extension_type)
        pulumi.set(__self__, "local_path", local_path)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_name", resource_name)

    @_builtins.property
    @pulumi.getter(name="fileExtensionType")
    def file_extension_type(self) -> _builtins.str:
        """
        Specifies the resource file type.
        """
        return pulumi.get(self, "file_extension_type")

    @_builtins.property
    @pulumi.getter(name="localPath")
    def local_path(self) -> _builtins.str:
        """
        Resource path.
        """
        return pulumi.get(self, "local_path")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource file ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> _builtins.str:
        """
        Resource file name (fuzzy search keyword).
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class GetResourceGroupMetricsDataResult(dict):
    def __init__(__self__, *,
                 cpu_num: _builtins.int,
                 disk_volume: _builtins.int,
                 life_cycle: _builtins.int,
                 maximum_concurrency: _builtins.int,
                 mem_size: _builtins.int,
                 metric_snapshots: Sequence['outputs.GetResourceGroupMetricsDataMetricSnapshotResult'],
                 status: _builtins.int):
        """
        :param _builtins.int cpu_num: Resource group specification related: CPU count.
        :param _builtins.int disk_volume: Resource group specification related: disk specification.
        :param _builtins.int life_cycle: Resource group lifecycle, unit: days.
        :param _builtins.int maximum_concurrency: Resource group specification related: maximum concurrency.
        :param _builtins.int mem_size: Resource group specification related: memory size, unit: G.
        :param Sequence['GetResourceGroupMetricsDataMetricSnapshotArgs'] metric_snapshots: Metric details.
        :param _builtins.int status: Resource group status.
        """
        pulumi.set(__self__, "cpu_num", cpu_num)
        pulumi.set(__self__, "disk_volume", disk_volume)
        pulumi.set(__self__, "life_cycle", life_cycle)
        pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)
        pulumi.set(__self__, "mem_size", mem_size)
        pulumi.set(__self__, "metric_snapshots", metric_snapshots)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="cpuNum")
    def cpu_num(self) -> _builtins.int:
        """
        Resource group specification related: CPU count.
        """
        return pulumi.get(self, "cpu_num")

    @_builtins.property
    @pulumi.getter(name="diskVolume")
    def disk_volume(self) -> _builtins.int:
        """
        Resource group specification related: disk specification.
        """
        return pulumi.get(self, "disk_volume")

    @_builtins.property
    @pulumi.getter(name="lifeCycle")
    def life_cycle(self) -> _builtins.int:
        """
        Resource group lifecycle, unit: days.
        """
        return pulumi.get(self, "life_cycle")

    @_builtins.property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> _builtins.int:
        """
        Resource group specification related: maximum concurrency.
        """
        return pulumi.get(self, "maximum_concurrency")

    @_builtins.property
    @pulumi.getter(name="memSize")
    def mem_size(self) -> _builtins.int:
        """
        Resource group specification related: memory size, unit: G.
        """
        return pulumi.get(self, "mem_size")

    @_builtins.property
    @pulumi.getter(name="metricSnapshots")
    def metric_snapshots(self) -> Sequence['outputs.GetResourceGroupMetricsDataMetricSnapshotResult']:
        """
        Metric details.
        """
        return pulumi.get(self, "metric_snapshots")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Resource group status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetResourceGroupMetricsDataMetricSnapshotResult(dict):
    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 snapshot_value: _builtins.int,
                 trend_lists: Sequence['outputs.GetResourceGroupMetricsDataMetricSnapshotTrendListResult']):
        """
        :param _builtins.str metric_name: Metric name.
        :param _builtins.int snapshot_value: Current value.
        :param Sequence['GetResourceGroupMetricsDataMetricSnapshotTrendListArgs'] trend_lists: Metric trend.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "snapshot_value", snapshot_value)
        pulumi.set(__self__, "trend_lists", trend_lists)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="snapshotValue")
    def snapshot_value(self) -> _builtins.int:
        """
        Current value.
        """
        return pulumi.get(self, "snapshot_value")

    @_builtins.property
    @pulumi.getter(name="trendLists")
    def trend_lists(self) -> Sequence['outputs.GetResourceGroupMetricsDataMetricSnapshotTrendListResult']:
        """
        Metric trend.
        """
        return pulumi.get(self, "trend_lists")


@pulumi.output_type
class GetResourceGroupMetricsDataMetricSnapshotTrendListResult(dict):
    def __init__(__self__, *,
                 timestamp: _builtins.int,
                 value: _builtins.int):
        """
        :param _builtins.int timestamp: Timestamp.
        :param _builtins.int value: Metric value.
        """
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.int:
        """
        Timestamp.
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Metric value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRuleTemplatesDataResult(dict):
    def __init__(__self__, *,
                 citation_count: _builtins.int,
                 compare_type: _builtins.int,
                 description: _builtins.str,
                 multi_source_flag: _builtins.bool,
                 name: _builtins.str,
                 quality_dim: _builtins.int,
                 rule_template_id: _builtins.int,
                 source_content: _builtins.str,
                 source_engine_types: Sequence[_builtins.int],
                 source_object_data_type: _builtins.int,
                 source_object_type: _builtins.int,
                 sql_expression: _builtins.str,
                 sub_quality_dim: _builtins.int,
                 type: _builtins.int,
                 update_time: _builtins.str,
                 user_id: _builtins.int,
                 user_name: _builtins.str,
                 where_flag: _builtins.bool):
        """
        :param _builtins.int citation_count: Citations.
        :param _builtins.int compare_type: The type of comparison method supported by the rule (1: fixed value comparison, greater than, less than, greater than or equal to, etc. 2: fluctuating value comparison, absolute value, rise, fall).
        :param _builtins.str description: Description of rule template.
        :param _builtins.bool multi_source_flag: Whether to associate other library tables.
        :param _builtins.str name: Name of rule template.
        :param _builtins.int quality_dim: Quality inspection dimensions. `1`: Accuracy, `2`: Uniqueness, `3`: Completeness, `4`: Consistency, `5`: Timeliness, `6`: Effectiveness.
        :param _builtins.int rule_template_id: ID of rule template.
        :param _builtins.str source_content: Content of rule template.
        :param Sequence[_builtins.int] source_engine_types: Applicable type of source data.
        :param _builtins.int source_object_data_type: Source data object type. `1`: value, `2`: string.
        :param _builtins.int source_object_type: Source data object type. `1`: Constant, `2`: Offline table level, `3`: Offline field level.
        :param _builtins.str sql_expression: Sql Expression.
        :param _builtins.int sub_quality_dim: Sub Quality inspection dimensions. `1`: Accuracy, `2`: Uniqueness, `3`: Completeness, `4`: Consistency, `5`: Timeliness, `6`: Effectiveness.
        :param _builtins.int type: Template type. `1` means System template, `2` means Custom template.
        :param _builtins.str update_time: update time, like: yyyy-MM-dd HH:mm:ss.
        :param _builtins.int user_id: user id.
        :param _builtins.str user_name: user name.
        :param _builtins.bool where_flag: If add where.
        """
        pulumi.set(__self__, "citation_count", citation_count)
        pulumi.set(__self__, "compare_type", compare_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "multi_source_flag", multi_source_flag)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "quality_dim", quality_dim)
        pulumi.set(__self__, "rule_template_id", rule_template_id)
        pulumi.set(__self__, "source_content", source_content)
        pulumi.set(__self__, "source_engine_types", source_engine_types)
        pulumi.set(__self__, "source_object_data_type", source_object_data_type)
        pulumi.set(__self__, "source_object_type", source_object_type)
        pulumi.set(__self__, "sql_expression", sql_expression)
        pulumi.set(__self__, "sub_quality_dim", sub_quality_dim)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "where_flag", where_flag)

    @_builtins.property
    @pulumi.getter(name="citationCount")
    def citation_count(self) -> _builtins.int:
        """
        Citations.
        """
        return pulumi.get(self, "citation_count")

    @_builtins.property
    @pulumi.getter(name="compareType")
    def compare_type(self) -> _builtins.int:
        """
        The type of comparison method supported by the rule (1: fixed value comparison, greater than, less than, greater than or equal to, etc. 2: fluctuating value comparison, absolute value, rise, fall).
        """
        return pulumi.get(self, "compare_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of rule template.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="multiSourceFlag")
    def multi_source_flag(self) -> _builtins.bool:
        """
        Whether to associate other library tables.
        """
        return pulumi.get(self, "multi_source_flag")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of rule template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="qualityDim")
    def quality_dim(self) -> _builtins.int:
        """
        Quality inspection dimensions. `1`: Accuracy, `2`: Uniqueness, `3`: Completeness, `4`: Consistency, `5`: Timeliness, `6`: Effectiveness.
        """
        return pulumi.get(self, "quality_dim")

    @_builtins.property
    @pulumi.getter(name="ruleTemplateId")
    def rule_template_id(self) -> _builtins.int:
        """
        ID of rule template.
        """
        return pulumi.get(self, "rule_template_id")

    @_builtins.property
    @pulumi.getter(name="sourceContent")
    def source_content(self) -> _builtins.str:
        """
        Content of rule template.
        """
        return pulumi.get(self, "source_content")

    @_builtins.property
    @pulumi.getter(name="sourceEngineTypes")
    def source_engine_types(self) -> Sequence[_builtins.int]:
        """
        Applicable type of source data.
        """
        return pulumi.get(self, "source_engine_types")

    @_builtins.property
    @pulumi.getter(name="sourceObjectDataType")
    def source_object_data_type(self) -> _builtins.int:
        """
        Source data object type. `1`: value, `2`: string.
        """
        return pulumi.get(self, "source_object_data_type")

    @_builtins.property
    @pulumi.getter(name="sourceObjectType")
    def source_object_type(self) -> _builtins.int:
        """
        Source data object type. `1`: Constant, `2`: Offline table level, `3`: Offline field level.
        """
        return pulumi.get(self, "source_object_type")

    @_builtins.property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> _builtins.str:
        """
        Sql Expression.
        """
        return pulumi.get(self, "sql_expression")

    @_builtins.property
    @pulumi.getter(name="subQualityDim")
    def sub_quality_dim(self) -> _builtins.int:
        """
        Sub Quality inspection dimensions. `1`: Accuracy, `2`: Uniqueness, `3`: Completeness, `4`: Consistency, `5`: Timeliness, `6`: Effectiveness.
        """
        return pulumi.get(self, "sub_quality_dim")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.int:
        """
        Template type. `1` means System template, `2` means Custom template.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        update time, like: yyyy-MM-dd HH:mm:ss.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.int:
        """
        user id.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        user name.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter(name="whereFlag")
    def where_flag(self) -> _builtins.bool:
        """
        If add where.
        """
        return pulumi.get(self, "where_flag")


@pulumi.output_type
class GetSqlScriptRunsDataResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 end_time: _builtins.str,
                 job_execution_lists: Sequence['outputs.GetSqlScriptRunsDataJobExecutionListResult'],
                 job_id: _builtins.str,
                 job_name: _builtins.str,
                 job_type: _builtins.str,
                 owner_uin: _builtins.str,
                 script_content: _builtins.str,
                 script_content_truncate: _builtins.bool,
                 script_id: _builtins.str,
                 status: _builtins.str,
                 time_cost: _builtins.int,
                 update_time: _builtins.str,
                 user_uin: _builtins.str):
        """
        :param _builtins.str create_time: Create time.
        :param _builtins.str end_time: End time.
        :param Sequence['GetSqlScriptRunsDataJobExecutionListArgs'] job_execution_lists: Subtask list.
        :param _builtins.str job_id: Job ID.
        :param _builtins.str job_name: Data exploration task name.
        :param _builtins.str job_type: Job type.
        :param _builtins.str owner_uin: Cloud owner account UIN.
        :param _builtins.str script_content: Script content.
        :param _builtins.bool script_content_truncate: Whether the script content is truncated.
        :param _builtins.str script_id: Script ID.
        :param _builtins.str status: Task status.
        :param _builtins.int time_cost: Time consumed.
        :param _builtins.str update_time: Update time.
        :param _builtins.str user_uin: Account UIN.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "job_execution_lists", job_execution_lists)
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "job_name", job_name)
        pulumi.set(__self__, "job_type", job_type)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "script_content", script_content)
        pulumi.set(__self__, "script_content_truncate", script_content_truncate)
        pulumi.set(__self__, "script_id", script_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "time_cost", time_cost)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "user_uin", user_uin)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="jobExecutionLists")
    def job_execution_lists(self) -> Sequence['outputs.GetSqlScriptRunsDataJobExecutionListResult']:
        """
        Subtask list.
        """
        return pulumi.get(self, "job_execution_lists")

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.str:
        """
        Job ID.
        """
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> _builtins.str:
        """
        Data exploration task name.
        """
        return pulumi.get(self, "job_name")

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> _builtins.str:
        """
        Job type.
        """
        return pulumi.get(self, "job_type")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Cloud owner account UIN.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="scriptContent")
    def script_content(self) -> _builtins.str:
        """
        Script content.
        """
        return pulumi.get(self, "script_content")

    @_builtins.property
    @pulumi.getter(name="scriptContentTruncate")
    def script_content_truncate(self) -> _builtins.bool:
        """
        Whether the script content is truncated.
        """
        return pulumi.get(self, "script_content_truncate")

    @_builtins.property
    @pulumi.getter(name="scriptId")
    def script_id(self) -> _builtins.str:
        """
        Script ID.
        """
        return pulumi.get(self, "script_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Task status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="timeCost")
    def time_cost(self) -> _builtins.int:
        """
        Time consumed.
        """
        return pulumi.get(self, "time_cost")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="userUin")
    def user_uin(self) -> _builtins.str:
        """
        Account UIN.
        """
        return pulumi.get(self, "user_uin")


@pulumi.output_type
class GetSqlScriptRunsDataJobExecutionListResult(dict):
    def __init__(__self__, *,
                 collecting_total_result: _builtins.bool,
                 context_script_contents: Sequence[_builtins.str],
                 create_time: _builtins.str,
                 end_time: _builtins.str,
                 execute_stage_info: _builtins.str,
                 job_execution_id: _builtins.str,
                 job_execution_name: _builtins.str,
                 job_id: _builtins.str,
                 log_file_path: _builtins.str,
                 result_effect_count: _builtins.int,
                 result_file_path: _builtins.str,
                 result_preview_count: _builtins.int,
                 result_preview_file_path: _builtins.str,
                 result_total_count: _builtins.int,
                 script_content: _builtins.str,
                 script_content_truncate: _builtins.bool,
                 status: _builtins.str,
                 time_cost: _builtins.int,
                 update_time: _builtins.str):
        """
        :param _builtins.bool collecting_total_result: Whether collecting full results: default false, true means collecting full results, used for frontend polling.
        :param Sequence[_builtins.str] context_script_contents: Context SQL content.
        :param _builtins.str create_time: Create time.
        :param _builtins.str end_time: End time.
        :param _builtins.str execute_stage_info: Execution phase.
        :param _builtins.str job_execution_id: Subquery task ID.
        :param _builtins.str job_execution_name: Subquery name.
        :param _builtins.str job_id: Job ID.
        :param _builtins.str log_file_path: Log file path.
        :param _builtins.int result_effect_count: Number of rows affected by the task execution result.
        :param _builtins.str result_file_path: Result file path.
        :param _builtins.int result_preview_count: Number of rows for previewing the task execution results.
        :param _builtins.str result_preview_file_path: Preview result file path.
        :param _builtins.int result_total_count: Total number of rows in the task execution result.
        :param _builtins.str script_content: Script content.
        :param _builtins.bool script_content_truncate: Whether the script content is truncated.
        :param _builtins.str status: Task status.
        :param _builtins.int time_cost: Time consumed.
        :param _builtins.str update_time: Update time.
        """
        pulumi.set(__self__, "collecting_total_result", collecting_total_result)
        pulumi.set(__self__, "context_script_contents", context_script_contents)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "execute_stage_info", execute_stage_info)
        pulumi.set(__self__, "job_execution_id", job_execution_id)
        pulumi.set(__self__, "job_execution_name", job_execution_name)
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "log_file_path", log_file_path)
        pulumi.set(__self__, "result_effect_count", result_effect_count)
        pulumi.set(__self__, "result_file_path", result_file_path)
        pulumi.set(__self__, "result_preview_count", result_preview_count)
        pulumi.set(__self__, "result_preview_file_path", result_preview_file_path)
        pulumi.set(__self__, "result_total_count", result_total_count)
        pulumi.set(__self__, "script_content", script_content)
        pulumi.set(__self__, "script_content_truncate", script_content_truncate)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "time_cost", time_cost)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="collectingTotalResult")
    def collecting_total_result(self) -> _builtins.bool:
        """
        Whether collecting full results: default false, true means collecting full results, used for frontend polling.
        """
        return pulumi.get(self, "collecting_total_result")

    @_builtins.property
    @pulumi.getter(name="contextScriptContents")
    def context_script_contents(self) -> Sequence[_builtins.str]:
        """
        Context SQL content.
        """
        return pulumi.get(self, "context_script_contents")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="executeStageInfo")
    def execute_stage_info(self) -> _builtins.str:
        """
        Execution phase.
        """
        return pulumi.get(self, "execute_stage_info")

    @_builtins.property
    @pulumi.getter(name="jobExecutionId")
    def job_execution_id(self) -> _builtins.str:
        """
        Subquery task ID.
        """
        return pulumi.get(self, "job_execution_id")

    @_builtins.property
    @pulumi.getter(name="jobExecutionName")
    def job_execution_name(self) -> _builtins.str:
        """
        Subquery name.
        """
        return pulumi.get(self, "job_execution_name")

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.str:
        """
        Job ID.
        """
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="logFilePath")
    def log_file_path(self) -> _builtins.str:
        """
        Log file path.
        """
        return pulumi.get(self, "log_file_path")

    @_builtins.property
    @pulumi.getter(name="resultEffectCount")
    def result_effect_count(self) -> _builtins.int:
        """
        Number of rows affected by the task execution result.
        """
        return pulumi.get(self, "result_effect_count")

    @_builtins.property
    @pulumi.getter(name="resultFilePath")
    def result_file_path(self) -> _builtins.str:
        """
        Result file path.
        """
        return pulumi.get(self, "result_file_path")

    @_builtins.property
    @pulumi.getter(name="resultPreviewCount")
    def result_preview_count(self) -> _builtins.int:
        """
        Number of rows for previewing the task execution results.
        """
        return pulumi.get(self, "result_preview_count")

    @_builtins.property
    @pulumi.getter(name="resultPreviewFilePath")
    def result_preview_file_path(self) -> _builtins.str:
        """
        Preview result file path.
        """
        return pulumi.get(self, "result_preview_file_path")

    @_builtins.property
    @pulumi.getter(name="resultTotalCount")
    def result_total_count(self) -> _builtins.int:
        """
        Total number of rows in the task execution result.
        """
        return pulumi.get(self, "result_total_count")

    @_builtins.property
    @pulumi.getter(name="scriptContent")
    def script_content(self) -> _builtins.str:
        """
        Script content.
        """
        return pulumi.get(self, "script_content")

    @_builtins.property
    @pulumi.getter(name="scriptContentTruncate")
    def script_content_truncate(self) -> _builtins.bool:
        """
        Whether the script content is truncated.
        """
        return pulumi.get(self, "script_content_truncate")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Task status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="timeCost")
    def time_cost(self) -> _builtins.int:
        """
        Time consumed.
        """
        return pulumi.get(self, "time_cost")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetTaskCodeDataResult(dict):
    def __init__(__self__, *,
                 code_file_size: _builtins.str,
                 code_info: _builtins.str):
        """
        :param _builtins.str code_file_size: Code file size. unit: KB.
        :param _builtins.str code_info: Code content.
        """
        pulumi.set(__self__, "code_file_size", code_file_size)
        pulumi.set(__self__, "code_info", code_info)

    @_builtins.property
    @pulumi.getter(name="codeFileSize")
    def code_file_size(self) -> _builtins.str:
        """
        Code file size. unit: KB.
        """
        return pulumi.get(self, "code_file_size")

    @_builtins.property
    @pulumi.getter(name="codeInfo")
    def code_info(self) -> _builtins.str:
        """
        Code content.
        """
        return pulumi.get(self, "code_info")


@pulumi.output_type
class GetTaskInstanceDataResult(dict):
    def __init__(__self__, *,
                 cost_time: _builtins.int,
                 cur_run_date: _builtins.str,
                 cycle_type: _builtins.str,
                 end_time: _builtins.str,
                 executor_group_id: _builtins.str,
                 executor_group_name: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 instance_key: _builtins.str,
                 instance_state: _builtins.str,
                 instance_type: _builtins.int,
                 job_error_msg: _builtins.str,
                 last_update_time: _builtins.str,
                 owner_uin_lists: Sequence[_builtins.str],
                 project_id: _builtins.str,
                 scheduler_time: _builtins.str,
                 start_time: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type: _builtins.str,
                 task_type_id: _builtins.int,
                 total_run_num: _builtins.int,
                 tries: _builtins.int,
                 try_limit: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.int cost_time: Execution duration, in ms.
        :param _builtins.str cur_run_date: Instance data time.
        :param _builtins.str cycle_type: **Task cycle type**.
               * ONEOFF_CYCLE: One-time
               * YEAR_CYCLE: Year
               * MONTH_CYCLE: Month
               * WEEK_CYCLE: Week
               * DAY_CYCLE: Day
               * HOUR_CYCLE: Hour
               * MINUTE_CYCLE: Minute
               * CRONTAB_CYCLE: Crontab expression type.
        :param _builtins.str end_time: Execution end time.
        :param _builtins.str executor_group_id: Executor resource group ID.
        :param _builtins.str executor_group_name: Resource group name.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str folder_name: Folder name.
        :param _builtins.str instance_key: Unique instance identifier, can be obtained via ListInstances.
        :param _builtins.str instance_state: **Instance status**.
               - WAIT_EVENT: Waiting for event
               - WAIT_UPSTREAM: Waiting for upstream
               - WAIT_RUN: Waiting to run
               - RUNNING: Running
               - SKIP_RUNNING: Skipped running
               - FAILED_RETRY: Failed retry
               - EXPIRED: Failed
               - COMPLETED: Success.
        :param _builtins.int instance_type: Instance type.
               
               - 0: Backfill type
               - 1: Periodic instance
               - 2: Non-periodic instance.
        :param _builtins.str job_error_msg: Brief task failure message.
        :param _builtins.str last_update_time: Last update time, format yyyy-MM-dd HH:mm:ss.
        :param Sequence[_builtins.str] owner_uin_lists: Owner list.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str scheduler_time: Scheduled time.
        :param _builtins.str start_time: Execution start time.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type: Task type.
        :param _builtins.int task_type_id: ID corresponding to taskType.
        :param _builtins.int total_run_num: Total run count.
        :param _builtins.int tries: Failed retry count.
               Reset to 0 when manually rerun or backfilled.
        :param _builtins.int try_limit: Retry limit per run failure.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "cost_time", cost_time)
        pulumi.set(__self__, "cur_run_date", cur_run_date)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "executor_group_id", executor_group_id)
        pulumi.set(__self__, "executor_group_name", executor_group_name)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "instance_key", instance_key)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "job_error_msg", job_error_msg)
        pulumi.set(__self__, "last_update_time", last_update_time)
        pulumi.set(__self__, "owner_uin_lists", owner_uin_lists)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "scheduler_time", scheduler_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "total_run_num", total_run_num)
        pulumi.set(__self__, "tries", tries)
        pulumi.set(__self__, "try_limit", try_limit)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="costTime")
    def cost_time(self) -> _builtins.int:
        """
        Execution duration, in ms.
        """
        return pulumi.get(self, "cost_time")

    @_builtins.property
    @pulumi.getter(name="curRunDate")
    def cur_run_date(self) -> _builtins.str:
        """
        Instance data time.
        """
        return pulumi.get(self, "cur_run_date")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        **Task cycle type**.
        * ONEOFF_CYCLE: One-time
        * YEAR_CYCLE: Year
        * MONTH_CYCLE: Month
        * WEEK_CYCLE: Week
        * DAY_CYCLE: Day
        * HOUR_CYCLE: Hour
        * MINUTE_CYCLE: Minute
        * CRONTAB_CYCLE: Crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Execution end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="executorGroupId")
    def executor_group_id(self) -> _builtins.str:
        """
        Executor resource group ID.
        """
        return pulumi.get(self, "executor_group_id")

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> _builtins.str:
        """
        Resource group name.
        """
        return pulumi.get(self, "executor_group_name")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        Folder name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="instanceKey")
    def instance_key(self) -> _builtins.str:
        """
        Unique instance identifier, can be obtained via ListInstances.
        """
        return pulumi.get(self, "instance_key")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        **Instance status**.
        - WAIT_EVENT: Waiting for event
        - WAIT_UPSTREAM: Waiting for upstream
        - WAIT_RUN: Waiting to run
        - RUNNING: Running
        - SKIP_RUNNING: Skipped running
        - FAILED_RETRY: Failed retry
        - EXPIRED: Failed
        - COMPLETED: Success.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.int:
        """
        Instance type.

        - 0: Backfill type
        - 1: Periodic instance
        - 2: Non-periodic instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="jobErrorMsg")
    def job_error_msg(self) -> _builtins.str:
        """
        Brief task failure message.
        """
        return pulumi.get(self, "job_error_msg")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> _builtins.str:
        """
        Last update time, format yyyy-MM-dd HH:mm:ss.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="ownerUinLists")
    def owner_uin_lists(self) -> Sequence[_builtins.str]:
        """
        Owner list.
        """
        return pulumi.get(self, "owner_uin_lists")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="schedulerTime")
    def scheduler_time(self) -> _builtins.str:
        """
        Scheduled time.
        """
        return pulumi.get(self, "scheduler_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Execution start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Task type.
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        ID corresponding to taskType.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="totalRunNum")
    def total_run_num(self) -> _builtins.int:
        """
        Total run count.
        """
        return pulumi.get(self, "total_run_num")

    @_builtins.property
    @pulumi.getter
    def tries(self) -> _builtins.int:
        """
        Failed retry count.
        Reset to 0 when manually rerun or backfilled.
        """
        return pulumi.get(self, "tries")

    @_builtins.property
    @pulumi.getter(name="tryLimit")
    def try_limit(self) -> _builtins.int:
        """
        Retry limit per run failure.
        """
        return pulumi.get(self, "try_limit")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetTaskInstanceExecutionsDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetTaskInstanceExecutionsDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetTaskInstanceExecutionsDataItemArgs'] items: Record list.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Page size.
        :param _builtins.int total_count: Total count of results.
        :param _builtins.int total_page_number: Total number of pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetTaskInstanceExecutionsDataItemResult']:
        """
        Record list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Page size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total count of results.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total number of pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetTaskInstanceExecutionsDataItemResult(dict):
    def __init__(__self__, *,
                 cost_time: _builtins.int,
                 execution_phase_lists: Sequence['outputs.GetTaskInstanceExecutionsDataItemExecutionPhaseListResult'],
                 instance_key: _builtins.str,
                 instance_state: _builtins.str,
                 life_round_num: _builtins.int,
                 run_type: _builtins.str,
                 tries: _builtins.int):
        """
        :param _builtins.int cost_time: Cost time, in milliseconds.
        :param Sequence['GetTaskInstanceExecutionsDataItemExecutionPhaseListArgs'] execution_phase_lists: Instance execution lifecycle list.
        :param _builtins.str instance_key: Instance unique identifier, can be obtained via ListInstances.
        :param _builtins.str instance_state: Instance state, - WAIT_EVENT: Waiting for event, - WAIT_UPSTREAM: Waiting for upstream, - WAIT_RUN: Waiting to run, - RUNNING: Running, - SKIP_RUNNING: Skip running, - FAILED_RETRY: Failed and retrying, - EXPIRED: Failed, - COMPLETED: Completed.
        :param _builtins.int life_round_num: Instance lifecycle round number, identifying a specific execution of the instance. For example: The first run of a periodic instance has a round number of 0; if the user reruns the instance later, the second execution will have a round number of 1.
        :param _builtins.str run_type: Instance run trigger type, - RERUN: Rerun, - ADDITION: Backfill, - PERIODIC: Periodic, - APERIODIC: Non-periodic, - RERUN_SKIP_RUN: Rerun - Skip run, - ADDITION_SKIP_RUN: Backfill - Skip run, - PERIODIC_SKIP_RUN: Periodic - Skip run, - APERIODIC_SKIP_RUN: Non-periodic - Skip run, - MANUAL_TRIGGER: Manual trigger, - RERUN_MANUAL_TRIGGER: Manual trigger - Rerun.
        :param _builtins.int tries: Failure retry count.
        """
        pulumi.set(__self__, "cost_time", cost_time)
        pulumi.set(__self__, "execution_phase_lists", execution_phase_lists)
        pulumi.set(__self__, "instance_key", instance_key)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "life_round_num", life_round_num)
        pulumi.set(__self__, "run_type", run_type)
        pulumi.set(__self__, "tries", tries)

    @_builtins.property
    @pulumi.getter(name="costTime")
    def cost_time(self) -> _builtins.int:
        """
        Cost time, in milliseconds.
        """
        return pulumi.get(self, "cost_time")

    @_builtins.property
    @pulumi.getter(name="executionPhaseLists")
    def execution_phase_lists(self) -> Sequence['outputs.GetTaskInstanceExecutionsDataItemExecutionPhaseListResult']:
        """
        Instance execution lifecycle list.
        """
        return pulumi.get(self, "execution_phase_lists")

    @_builtins.property
    @pulumi.getter(name="instanceKey")
    def instance_key(self) -> _builtins.str:
        """
        Instance unique identifier, can be obtained via ListInstances.
        """
        return pulumi.get(self, "instance_key")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        Instance state, - WAIT_EVENT: Waiting for event, - WAIT_UPSTREAM: Waiting for upstream, - WAIT_RUN: Waiting to run, - RUNNING: Running, - SKIP_RUNNING: Skip running, - FAILED_RETRY: Failed and retrying, - EXPIRED: Failed, - COMPLETED: Completed.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="lifeRoundNum")
    def life_round_num(self) -> _builtins.int:
        """
        Instance lifecycle round number, identifying a specific execution of the instance. For example: The first run of a periodic instance has a round number of 0; if the user reruns the instance later, the second execution will have a round number of 1.
        """
        return pulumi.get(self, "life_round_num")

    @_builtins.property
    @pulumi.getter(name="runType")
    def run_type(self) -> _builtins.str:
        """
        Instance run trigger type, - RERUN: Rerun, - ADDITION: Backfill, - PERIODIC: Periodic, - APERIODIC: Non-periodic, - RERUN_SKIP_RUN: Rerun - Skip run, - ADDITION_SKIP_RUN: Backfill - Skip run, - PERIODIC_SKIP_RUN: Periodic - Skip run, - APERIODIC_SKIP_RUN: Non-periodic - Skip run, - MANUAL_TRIGGER: Manual trigger, - RERUN_MANUAL_TRIGGER: Manual trigger - Rerun.
        """
        return pulumi.get(self, "run_type")

    @_builtins.property
    @pulumi.getter
    def tries(self) -> _builtins.int:
        """
        Failure retry count.
        """
        return pulumi.get(self, "tries")


@pulumi.output_type
class GetTaskInstanceExecutionsDataItemExecutionPhaseListResult(dict):
    def __init__(__self__, *,
                 detail_state: Optional[_builtins.str] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str detail_state: Instance lifecycle phase state, - WAIT_UPSTREAM: Waiting for event/upstream, - WAIT_RUN: Waiting to run, - RUNNING: Running, - COMPLETE: Final state - Completed, - FAILED: Final state - Failed and retrying, - EXPIRED: Final state - Failed, - SKIP_RUNNING: Final state - Branch skipped by upstream branch node, - HISTORY: For compatibility with historical instances before 2024-03-30, instances after that date do not need to pay attention to this enum type.
        :param _builtins.str end_time: End time of this state.
        :param _builtins.str start_time: Start time of this state.
        """
        if detail_state is not None:
            pulumi.set(__self__, "detail_state", detail_state)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="detailState")
    def detail_state(self) -> Optional[_builtins.str]:
        """
        Instance lifecycle phase state, - WAIT_UPSTREAM: Waiting for event/upstream, - WAIT_RUN: Waiting to run, - RUNNING: Running, - COMPLETE: Final state - Completed, - FAILED: Final state - Failed and retrying, - EXPIRED: Final state - Failed, - SKIP_RUNNING: Final state - Branch skipped by upstream branch node, - HISTORY: For compatibility with historical instances before 2024-03-30, instances after that date do not need to pay attention to this enum type.
        """
        return pulumi.get(self, "detail_state")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time of this state.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time of this state.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetTaskInstanceLogDataResult(dict):
    def __init__(__self__, *,
                 code_content: _builtins.str,
                 instance_key: _builtins.str,
                 log_info: _builtins.str,
                 next_cursor: _builtins.str,
                 project_id: _builtins.str):
        """
        :param _builtins.str code_content: Execution code content.
        :param _builtins.str instance_key: Unique instance identifier.
        :param _builtins.str log_info: Log content.
        :param _builtins.str next_cursor: Pagination cursor for log queries, no business meaning. First query uses null, subsequent queries use NextCursor from previous response.
        :param _builtins.str project_id: Project ID.
        """
        pulumi.set(__self__, "code_content", code_content)
        pulumi.set(__self__, "instance_key", instance_key)
        pulumi.set(__self__, "log_info", log_info)
        pulumi.set(__self__, "next_cursor", next_cursor)
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="codeContent")
    def code_content(self) -> _builtins.str:
        """
        Execution code content.
        """
        return pulumi.get(self, "code_content")

    @_builtins.property
    @pulumi.getter(name="instanceKey")
    def instance_key(self) -> _builtins.str:
        """
        Unique instance identifier.
        """
        return pulumi.get(self, "instance_key")

    @_builtins.property
    @pulumi.getter(name="logInfo")
    def log_info(self) -> _builtins.str:
        """
        Log content.
        """
        return pulumi.get(self, "log_info")

    @_builtins.property
    @pulumi.getter(name="nextCursor")
    def next_cursor(self) -> _builtins.str:
        """
        Pagination cursor for log queries, no business meaning. First query uses null, subsequent queries use NextCursor from previous response.
        """
        return pulumi.get(self, "next_cursor")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetTaskInstancesDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetTaskInstancesDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetTaskInstancesDataItemArgs'] items: Data list.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Page size.
        :param _builtins.int total_count: Total count.
        :param _builtins.int total_page_number: Total pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetTaskInstancesDataItemResult']:
        """
        Data list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Page size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetTaskInstancesDataItemResult(dict):
    def __init__(__self__, *,
                 cost_time: _builtins.int,
                 cur_run_date: _builtins.str,
                 cycle_type: _builtins.str,
                 end_time: _builtins.str,
                 executor_group_id: _builtins.str,
                 executor_group_name: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 instance_key: _builtins.str,
                 instance_state: _builtins.str,
                 instance_type: _builtins.int,
                 last_update_time: _builtins.str,
                 owner_uin_lists: Sequence[_builtins.str],
                 project_id: _builtins.str,
                 scheduler_time: _builtins.str,
                 start_time: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type: _builtins.str,
                 task_type_id: _builtins.int,
                 total_run_num: _builtins.int,
                 tries: _builtins.int,
                 try_limit: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.int cost_time: Execution duration, in ms.
        :param _builtins.str cur_run_date: Instance data time.
        :param _builtins.str cycle_type: Task cycle type * ONEOFF_CYCLE: One-time * YEAR_CYCLE: Year * MONTH_CYCLE: Month * WEEK_CYCLE: Week * DAY_CYCLE: Day * HOUR_CYCLE: Hour * MINUTE_CYCLE: Minute * CRONTAB_CYCLE: Crontab expression type.
        :param _builtins.str end_time: Execution end time.
        :param _builtins.str executor_group_id: Executor resource group ID.
        :param _builtins.str executor_group_name: Resource group name.
        :param _builtins.str folder_id: Task folder ID.
        :param _builtins.str folder_name: Folder name.
        :param _builtins.str instance_key: Unique instance identifier.
        :param _builtins.str instance_state: Instance status - WAIT_EVENT: Waiting for event - WAIT_UPSTREAM: Waiting for upstream - WAIT_RUN: Waiting to run - RUNNING: Running - SKIP_RUNNING: Skipped running - FAILED_RETRY: Failed retry - EXPIRED: Failed - COMPLETED: Success.
        :param _builtins.int instance_type: Instance type - 0: Backfill type - 1: Periodic instance - 2: Non-periodic instance.
        :param _builtins.str last_update_time: Last update time, format yyyy-MM-dd HH:mm:ss.
        :param Sequence[_builtins.str] owner_uin_lists: Owner list.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str scheduler_time: Scheduled time.
        :param _builtins.str start_time: Execution start time.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type: Task type description.
        :param _builtins.int task_type_id: Task type ID.
        :param _builtins.int total_run_num: Total run count.
        :param _builtins.int tries: Failed retry count. Reset to 0 when manually rerun or backfilled.
        :param _builtins.int try_limit: Retry limit per run failure.
        :param _builtins.str workflow_id: Task workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "cost_time", cost_time)
        pulumi.set(__self__, "cur_run_date", cur_run_date)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "executor_group_id", executor_group_id)
        pulumi.set(__self__, "executor_group_name", executor_group_name)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "instance_key", instance_key)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "last_update_time", last_update_time)
        pulumi.set(__self__, "owner_uin_lists", owner_uin_lists)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "scheduler_time", scheduler_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "total_run_num", total_run_num)
        pulumi.set(__self__, "tries", tries)
        pulumi.set(__self__, "try_limit", try_limit)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="costTime")
    def cost_time(self) -> _builtins.int:
        """
        Execution duration, in ms.
        """
        return pulumi.get(self, "cost_time")

    @_builtins.property
    @pulumi.getter(name="curRunDate")
    def cur_run_date(self) -> _builtins.str:
        """
        Instance data time.
        """
        return pulumi.get(self, "cur_run_date")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Task cycle type * ONEOFF_CYCLE: One-time * YEAR_CYCLE: Year * MONTH_CYCLE: Month * WEEK_CYCLE: Week * DAY_CYCLE: Day * HOUR_CYCLE: Hour * MINUTE_CYCLE: Minute * CRONTAB_CYCLE: Crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Execution end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="executorGroupId")
    def executor_group_id(self) -> _builtins.str:
        """
        Executor resource group ID.
        """
        return pulumi.get(self, "executor_group_id")

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> _builtins.str:
        """
        Resource group name.
        """
        return pulumi.get(self, "executor_group_name")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Task folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        Folder name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="instanceKey")
    def instance_key(self) -> _builtins.str:
        """
        Unique instance identifier.
        """
        return pulumi.get(self, "instance_key")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        Instance status - WAIT_EVENT: Waiting for event - WAIT_UPSTREAM: Waiting for upstream - WAIT_RUN: Waiting to run - RUNNING: Running - SKIP_RUNNING: Skipped running - FAILED_RETRY: Failed retry - EXPIRED: Failed - COMPLETED: Success.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.int:
        """
        Instance type - 0: Backfill type - 1: Periodic instance - 2: Non-periodic instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> _builtins.str:
        """
        Last update time, format yyyy-MM-dd HH:mm:ss.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="ownerUinLists")
    def owner_uin_lists(self) -> Sequence[_builtins.str]:
        """
        Owner list.
        """
        return pulumi.get(self, "owner_uin_lists")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="schedulerTime")
    def scheduler_time(self) -> _builtins.str:
        """
        Scheduled time.
        """
        return pulumi.get(self, "scheduler_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Execution start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Task type description.
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type ID.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="totalRunNum")
    def total_run_num(self) -> _builtins.int:
        """
        Total run count.
        """
        return pulumi.get(self, "total_run_num")

    @_builtins.property
    @pulumi.getter
    def tries(self) -> _builtins.int:
        """
        Failed retry count. Reset to 0 when manually rerun or backfilled.
        """
        return pulumi.get(self, "tries")

    @_builtins.property
    @pulumi.getter(name="tryLimit")
    def try_limit(self) -> _builtins.int:
        """
        Retry limit per run failure.
        """
        return pulumi.get(self, "try_limit")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Task workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetTaskVersionDataResult(dict):
    def __init__(__self__, *,
                 approve_status: _builtins.str,
                 approve_time: _builtins.str,
                 approve_user_uin: _builtins.str,
                 create_time: _builtins.str,
                 create_user_uin: _builtins.str,
                 task: 'outputs.GetTaskVersionDataTaskResult',
                 version_id: _builtins.str,
                 version_num: _builtins.str,
                 version_remark: _builtins.str):
        """
        :param _builtins.str approve_status: Approval status (only for submit version).
        :param _builtins.str approve_time: Production status  (only for submit version).
        :param _builtins.str approve_user_uin: Approver Id.
        :param _builtins.str create_time: Creation time.
        :param _builtins.str create_user_uin: Specifies the version creator.
        :param 'GetTaskVersionDataTaskArgs' task: Describes the task detail of the version.
        :param _builtins.str version_id: Submit version ID. If not specified, the latest submit version will be used by default.
        :param _builtins.str version_num: Version number.
        :param _builtins.str version_remark: Version description.
        """
        pulumi.set(__self__, "approve_status", approve_status)
        pulumi.set(__self__, "approve_time", approve_time)
        pulumi.set(__self__, "approve_user_uin", approve_user_uin)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "create_user_uin", create_user_uin)
        pulumi.set(__self__, "task", task)
        pulumi.set(__self__, "version_id", version_id)
        pulumi.set(__self__, "version_num", version_num)
        pulumi.set(__self__, "version_remark", version_remark)

    @_builtins.property
    @pulumi.getter(name="approveStatus")
    def approve_status(self) -> _builtins.str:
        """
        Approval status (only for submit version).
        """
        return pulumi.get(self, "approve_status")

    @_builtins.property
    @pulumi.getter(name="approveTime")
    def approve_time(self) -> _builtins.str:
        """
        Production status  (only for submit version).
        """
        return pulumi.get(self, "approve_time")

    @_builtins.property
    @pulumi.getter(name="approveUserUin")
    def approve_user_uin(self) -> _builtins.str:
        """
        Approver Id.
        """
        return pulumi.get(self, "approve_user_uin")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> _builtins.str:
        """
        Specifies the version creator.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter
    def task(self) -> 'outputs.GetTaskVersionDataTaskResult':
        """
        Describes the task detail of the version.
        """
        return pulumi.get(self, "task")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.str:
        """
        Submit version ID. If not specified, the latest submit version will be used by default.
        """
        return pulumi.get(self, "version_id")

    @_builtins.property
    @pulumi.getter(name="versionNum")
    def version_num(self) -> _builtins.str:
        """
        Version number.
        """
        return pulumi.get(self, "version_num")

    @_builtins.property
    @pulumi.getter(name="versionRemark")
    def version_remark(self) -> _builtins.str:
        """
        Version description.
        """
        return pulumi.get(self, "version_remark")


@pulumi.output_type
class GetTaskVersionDataTaskResult(dict):
    def __init__(__self__, *,
                 task_base_attribute: 'outputs.GetTaskVersionDataTaskTaskBaseAttributeResult',
                 task_configuration: 'outputs.GetTaskVersionDataTaskTaskConfigurationResult',
                 task_scheduler_configuration: 'outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationResult'):
        """
        :param 'GetTaskVersionDataTaskTaskBaseAttributeArgs' task_base_attribute: Describes the basic attributes of the task.
        :param 'GetTaskVersionDataTaskTaskConfigurationArgs' task_configuration: Task configurations.
        :param 'GetTaskVersionDataTaskTaskSchedulerConfigurationArgs' task_scheduler_configuration: Specifies task scheduling configuration.
        """
        pulumi.set(__self__, "task_base_attribute", task_base_attribute)
        pulumi.set(__self__, "task_configuration", task_configuration)
        pulumi.set(__self__, "task_scheduler_configuration", task_scheduler_configuration)

    @_builtins.property
    @pulumi.getter(name="taskBaseAttribute")
    def task_base_attribute(self) -> 'outputs.GetTaskVersionDataTaskTaskBaseAttributeResult':
        """
        Describes the basic attributes of the task.
        """
        return pulumi.get(self, "task_base_attribute")

    @_builtins.property
    @pulumi.getter(name="taskConfiguration")
    def task_configuration(self) -> 'outputs.GetTaskVersionDataTaskTaskConfigurationResult':
        """
        Task configurations.
        """
        return pulumi.get(self, "task_configuration")

    @_builtins.property
    @pulumi.getter(name="taskSchedulerConfiguration")
    def task_scheduler_configuration(self) -> 'outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationResult':
        """
        Specifies task scheduling configuration.
        """
        return pulumi.get(self, "task_scheduler_configuration")


@pulumi.output_type
class GetTaskVersionDataTaskTaskBaseAttributeResult(dict):
    def __init__(__self__, *,
                 task_id: _builtins.str,
                 task_type_id: _builtins.int,
                 workflow_id: _builtins.str,
                 create_time: Optional[_builtins.str] = None,
                 create_user_uin: Optional[_builtins.str] = None,
                 last_ops_time: Optional[_builtins.str] = None,
                 last_ops_user_name: Optional[_builtins.str] = None,
                 last_update_time: Optional[_builtins.str] = None,
                 last_update_user_name: Optional[_builtins.str] = None,
                 owner_uin: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 submit: Optional[_builtins.bool] = None,
                 task_description: Optional[_builtins.str] = None,
                 task_latest_submit_version_no: Optional[_builtins.str] = None,
                 task_latest_version_no: Optional[_builtins.str] = None,
                 task_name: Optional[_builtins.str] = None,
                 update_user_uin: Optional[_builtins.str] = None,
                 workflow_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str task_id: Task ID.
        :param _builtins.int task_type_id: Specifies the task type ID.
               
               * 21:JDBC SQL
               * 23:TDSQL-PostgreSQL
               * 26:OfflineSynchronization
               * 30:Python
               * 31:PySpark
               * 33:Impala
               * 34:Hive SQL
               * 35:Shell
               * 36:Spark SQL
               * 38:Shell Form Mode
               * 39:Spark
               * 40:TCHouse-P
               * 41:Kettle
               * 42:Tchouse-X
               * 43:TCHouse-X SQL
               * 46:DLC Spark
               * 47:TiOne
               * 48:Trino
               * 50:DLC PySpark
               * 92:MapReduce
               * 130:Branch Node
               * 131:Merged Node
               * 132:Notebook
               * 133:SSH
               * 134:StarRocks
               * 137:For-each
               * 138:Setats SQL.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str create_time: Task creation time. example: 2022-02-12 11:13:41.
        :param _builtins.str create_user_uin: Created By User ID.
        :param _builtins.str last_ops_time: Last operation time.
        :param _builtins.str last_ops_user_name: Last operator name.
        :param _builtins.str last_update_time: Last update time. example: 2025-08-13 16:34:06.
        :param _builtins.str last_update_user_name: Last Updated By (Name).
        :param _builtins.str owner_uin: Task owner ID.
        :param _builtins.str status: Task Status:
               
               * N: New
               * Y: Scheduling
               * F: Offline
               * O: Paused
               * T: Offlining (in the process of being taken offline)
               * INVALID: Invalid.
        :param _builtins.bool submit: Latest submission status of the task. Specifies whether it has been submitted: true/false.
        :param _builtins.str task_description: Task description.
        :param _builtins.str task_latest_submit_version_no: Last submit version number.
        :param _builtins.str task_latest_version_no: Last save version number.
        :param _builtins.str task_name: Task name.
        :param _builtins.str update_user_uin: Last Updated User ID.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if create_user_uin is not None:
            pulumi.set(__self__, "create_user_uin", create_user_uin)
        if last_ops_time is not None:
            pulumi.set(__self__, "last_ops_time", last_ops_time)
        if last_ops_user_name is not None:
            pulumi.set(__self__, "last_ops_user_name", last_ops_user_name)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if last_update_user_name is not None:
            pulumi.set(__self__, "last_update_user_name", last_update_user_name)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if submit is not None:
            pulumi.set(__self__, "submit", submit)
        if task_description is not None:
            pulumi.set(__self__, "task_description", task_description)
        if task_latest_submit_version_no is not None:
            pulumi.set(__self__, "task_latest_submit_version_no", task_latest_submit_version_no)
        if task_latest_version_no is not None:
            pulumi.set(__self__, "task_latest_version_no", task_latest_version_no)
        if task_name is not None:
            pulumi.set(__self__, "task_name", task_name)
        if update_user_uin is not None:
            pulumi.set(__self__, "update_user_uin", update_user_uin)
        if workflow_name is not None:
            pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Specifies the task type ID.

        * 21:JDBC SQL
        * 23:TDSQL-PostgreSQL
        * 26:OfflineSynchronization
        * 30:Python
        * 31:PySpark
        * 33:Impala
        * 34:Hive SQL
        * 35:Shell
        * 36:Spark SQL
        * 38:Shell Form Mode
        * 39:Spark
        * 40:TCHouse-P
        * 41:Kettle
        * 42:Tchouse-X
        * 43:TCHouse-X SQL
        * 46:DLC Spark
        * 47:TiOne
        * 48:Trino
        * 50:DLC PySpark
        * 92:MapReduce
        * 130:Branch Node
        * 131:Merged Node
        * 132:Notebook
        * 133:SSH
        * 134:StarRocks
        * 137:For-each
        * 138:Setats SQL.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Task creation time. example: 2022-02-12 11:13:41.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> Optional[_builtins.str]:
        """
        Created By User ID.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter(name="lastOpsTime")
    def last_ops_time(self) -> Optional[_builtins.str]:
        """
        Last operation time.
        """
        return pulumi.get(self, "last_ops_time")

    @_builtins.property
    @pulumi.getter(name="lastOpsUserName")
    def last_ops_user_name(self) -> Optional[_builtins.str]:
        """
        Last operator name.
        """
        return pulumi.get(self, "last_ops_user_name")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[_builtins.str]:
        """
        Last update time. example: 2025-08-13 16:34:06.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="lastUpdateUserName")
    def last_update_user_name(self) -> Optional[_builtins.str]:
        """
        Last Updated By (Name).
        """
        return pulumi.get(self, "last_update_user_name")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[_builtins.str]:
        """
        Task owner ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Task Status:

        * N: New
        * Y: Scheduling
        * F: Offline
        * O: Paused
        * T: Offlining (in the process of being taken offline)
        * INVALID: Invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def submit(self) -> Optional[_builtins.bool]:
        """
        Latest submission status of the task. Specifies whether it has been submitted: true/false.
        """
        return pulumi.get(self, "submit")

    @_builtins.property
    @pulumi.getter(name="taskDescription")
    def task_description(self) -> Optional[_builtins.str]:
        """
        Task description.
        """
        return pulumi.get(self, "task_description")

    @_builtins.property
    @pulumi.getter(name="taskLatestSubmitVersionNo")
    def task_latest_submit_version_no(self) -> Optional[_builtins.str]:
        """
        Last submit version number.
        """
        return pulumi.get(self, "task_latest_submit_version_no")

    @_builtins.property
    @pulumi.getter(name="taskLatestVersionNo")
    def task_latest_version_no(self) -> Optional[_builtins.str]:
        """
        Last save version number.
        """
        return pulumi.get(self, "task_latest_version_no")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> Optional[_builtins.str]:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="updateUserUin")
    def update_user_uin(self) -> Optional[_builtins.str]:
        """
        Last Updated User ID.
        """
        return pulumi.get(self, "update_user_uin")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> Optional[_builtins.str]:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetTaskVersionDataTaskTaskConfigurationResult(dict):
    def __init__(__self__, *,
                 broker_ip: Optional[_builtins.str] = None,
                 bundle_id: Optional[_builtins.str] = None,
                 bundle_info: Optional[_builtins.str] = None,
                 code_content: Optional[_builtins.str] = None,
                 data_cluster: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 resource_group_name: Optional[_builtins.str] = None,
                 source_service_id: Optional[_builtins.str] = None,
                 source_service_name: Optional[_builtins.str] = None,
                 source_service_type: Optional[_builtins.str] = None,
                 target_service_id: Optional[_builtins.str] = None,
                 target_service_name: Optional[_builtins.str] = None,
                 target_service_type: Optional[_builtins.str] = None,
                 task_ext_configuration_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskConfigurationTaskExtConfigurationListResult']] = None,
                 task_scheduling_parameter_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskConfigurationTaskSchedulingParameterListResult']] = None,
                 yarn_queue: Optional[_builtins.str] = None):
        """
        :param _builtins.str broker_ip: Specifies the specified running node.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str bundle_id: ID used by the Bundle.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str bundle_info: Bundle info.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str code_content: Base64 encoding of the code content.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str data_cluster: Cluster ID
               
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str resource_group: Resource group ID: need to pass through DescribeNormalSchedulerExecutorGroups to obtain ExecutorGroupId.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str resource_group_name: Resource group name: need to pass through DescribeNormalSchedulerExecutorGroups to obtain ExecutorGroupName.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str source_service_id: Source data source ID, separated by;, obtained through DescribeDataSourceWithoutInfo.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str source_service_name: Data source name. use semicolons to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str source_service_type: Data source type. use semicolon to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str target_service_id: TargetTarget data source ID, separated by semicolons. need to pass through DescribeDataSourceWithoutInfo to obtain.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str target_service_name: Target data source name. use semicolon to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str target_service_type: Target data source type. uses ; for separation. needs to pass through DescribeDataSourceWithoutInfo for retrieval.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetTaskVersionDataTaskTaskConfigurationTaskExtConfigurationListArgs'] task_ext_configuration_lists: Extended attribute configuration list of the task.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetTaskVersionDataTaskTaskConfigurationTaskSchedulingParameterListArgs'] task_scheduling_parameter_lists: Specifies the scheduling parameter.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str yarn_queue: Resource pool queue name. need to pass through DescribeProjectClusterQueues to obtain.
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        if broker_ip is not None:
            pulumi.set(__self__, "broker_ip", broker_ip)
        if bundle_id is not None:
            pulumi.set(__self__, "bundle_id", bundle_id)
        if bundle_info is not None:
            pulumi.set(__self__, "bundle_info", bundle_info)
        if code_content is not None:
            pulumi.set(__self__, "code_content", code_content)
        if data_cluster is not None:
            pulumi.set(__self__, "data_cluster", data_cluster)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if source_service_id is not None:
            pulumi.set(__self__, "source_service_id", source_service_id)
        if source_service_name is not None:
            pulumi.set(__self__, "source_service_name", source_service_name)
        if source_service_type is not None:
            pulumi.set(__self__, "source_service_type", source_service_type)
        if target_service_id is not None:
            pulumi.set(__self__, "target_service_id", target_service_id)
        if target_service_name is not None:
            pulumi.set(__self__, "target_service_name", target_service_name)
        if target_service_type is not None:
            pulumi.set(__self__, "target_service_type", target_service_type)
        if task_ext_configuration_lists is not None:
            pulumi.set(__self__, "task_ext_configuration_lists", task_ext_configuration_lists)
        if task_scheduling_parameter_lists is not None:
            pulumi.set(__self__, "task_scheduling_parameter_lists", task_scheduling_parameter_lists)
        if yarn_queue is not None:
            pulumi.set(__self__, "yarn_queue", yarn_queue)

    @_builtins.property
    @pulumi.getter(name="brokerIp")
    def broker_ip(self) -> Optional[_builtins.str]:
        """
        Specifies the specified running node.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "broker_ip")

    @_builtins.property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> Optional[_builtins.str]:
        """
        ID used by the Bundle.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "bundle_id")

    @_builtins.property
    @pulumi.getter(name="bundleInfo")
    def bundle_info(self) -> Optional[_builtins.str]:
        """
        Bundle info.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "bundle_info")

    @_builtins.property
    @pulumi.getter(name="codeContent")
    def code_content(self) -> Optional[_builtins.str]:
        """
        Base64 encoding of the code content.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "code_content")

    @_builtins.property
    @pulumi.getter(name="dataCluster")
    def data_cluster(self) -> Optional[_builtins.str]:
        """
        Cluster ID

        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "data_cluster")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        Resource group ID: need to pass through DescribeNormalSchedulerExecutorGroups to obtain ExecutorGroupId.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[_builtins.str]:
        """
        Resource group name: need to pass through DescribeNormalSchedulerExecutorGroups to obtain ExecutorGroupName.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter(name="sourceServiceId")
    def source_service_id(self) -> Optional[_builtins.str]:
        """
        Source data source ID, separated by;, obtained through DescribeDataSourceWithoutInfo.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "source_service_id")

    @_builtins.property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> Optional[_builtins.str]:
        """
        Data source name. use semicolons to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "source_service_name")

    @_builtins.property
    @pulumi.getter(name="sourceServiceType")
    def source_service_type(self) -> Optional[_builtins.str]:
        """
        Data source type. use semicolon to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "source_service_type")

    @_builtins.property
    @pulumi.getter(name="targetServiceId")
    def target_service_id(self) -> Optional[_builtins.str]:
        """
        TargetTarget data source ID, separated by semicolons. need to pass through DescribeDataSourceWithoutInfo to obtain.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "target_service_id")

    @_builtins.property
    @pulumi.getter(name="targetServiceName")
    def target_service_name(self) -> Optional[_builtins.str]:
        """
        Target data source name. use semicolon to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "target_service_name")

    @_builtins.property
    @pulumi.getter(name="targetServiceType")
    def target_service_type(self) -> Optional[_builtins.str]:
        """
        Target data source type. uses ; for separation. needs to pass through DescribeDataSourceWithoutInfo for retrieval.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "target_service_type")

    @_builtins.property
    @pulumi.getter(name="taskExtConfigurationLists")
    def task_ext_configuration_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskConfigurationTaskExtConfigurationListResult']]:
        """
        Extended attribute configuration list of the task.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "task_ext_configuration_lists")

    @_builtins.property
    @pulumi.getter(name="taskSchedulingParameterLists")
    def task_scheduling_parameter_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskConfigurationTaskSchedulingParameterListResult']]:
        """
        Specifies the scheduling parameter.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "task_scheduling_parameter_lists")

    @_builtins.property
    @pulumi.getter(name="yarnQueue")
    def yarn_queue(self) -> Optional[_builtins.str]:
        """
        Resource pool queue name. need to pass through DescribeProjectClusterQueues to obtain.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "yarn_queue")


@pulumi.output_type
class GetTaskVersionDataTaskTaskConfigurationTaskExtConfigurationListResult(dict):
    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class GetTaskVersionDataTaskTaskConfigurationTaskSchedulingParameterListResult(dict):
    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationResult(dict):
    def __init__(__self__, *,
                 allow_redo_type: Optional[_builtins.str] = None,
                 calendar_id: Optional[_builtins.str] = None,
                 calendar_name: Optional[_builtins.str] = None,
                 calendar_open: Optional[_builtins.str] = None,
                 crontab_expression: Optional[_builtins.str] = None,
                 cycle_type: Optional[_builtins.str] = None,
                 down_stream_dependency_config_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListResult']] = None,
                 end_time: Optional[_builtins.str] = None,
                 event_listener_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListResult']] = None,
                 execution_end_time: Optional[_builtins.str] = None,
                 execution_start_time: Optional[_builtins.str] = None,
                 execution_ttl: Optional[_builtins.int] = None,
                 init_strategy: Optional[_builtins.str] = None,
                 max_retry_attempts: Optional[_builtins.int] = None,
                 param_task_in_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskInListResult']] = None,
                 param_task_out_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskOutListResult']] = None,
                 retry_wait: Optional[_builtins.int] = None,
                 run_priority: Optional[_builtins.int] = None,
                 schedule_run_type: Optional[_builtins.int] = None,
                 schedule_time_zone: Optional[_builtins.str] = None,
                 self_depend: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 task_output_registry_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationTaskOutputRegistryListResult']] = None,
                 upstream_dependency_config_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListResult']] = None,
                 wait_execution_total_ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_redo_type: Rerun & Refill Configuration: Default: ALL;
               
               * ALL: Rerun or refill is allowed regardless of whether the task succeeds or fails.
               
               * FAILURE: Rerun or refill is allowed only if the task fails; not allowed if the task succeeds.
               
               * NONE: Rerun or refill is not allowed regardless of success or failure.
        :param _builtins.str calendar_id: Calendar id.
        :param _builtins.str calendar_name: Calendar name, which needs to be obtained from DescribeScheduleCalendarPageList API.
        :param _builtins.str calendar_open: Whether calendar scheduling is enabled. Valid values: 1 (enabled), 0 (disabled).
        :param _builtins.str crontab_expression: 0 2 3 1,L,2 * ?
        :param _builtins.str cycle_type: Period type. Supported types:
               
               ONEOFF_CYCLE: specifies a one-time cycle.
               YEAR_CYCLE: specifies the year cycle.
               MONTH_CYCLE: specifies the monthly cycle.
               WEEK_CYCLE: specifies the week cycle.
               DAY_CYCLE: specifies the day cycle.
               HOUR_CYCLE: specifies the hour cycle.
               MINUTE_CYCLE: specifies the minute cycle.
               CRONTAB_CYCLE: specifies the crontab expression type.
        :param Sequence['GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListArgs'] down_stream_dependency_config_lists: SpecSpecifies the downstream dependency array.
        :param _builtins.str end_time: End date
        :param Sequence['GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListArgs'] event_listener_lists: Array of Events
        :param _builtins.str execution_end_time: Execution time. right closed interval.
        :param _builtins.str execution_start_time: Execution time. the left-closed interval.
        :param _builtins.int execution_ttl: Timeout Handling Policy: Execution Timeout (in minutes), default: -1
        :param _builtins.str init_strategy: **Instance generation policy**.
               T_PLUS_0: specifies t+0 generation. default policy.
               T_PLUS_1: specifies t+1 generation.
        :param _builtins.int max_retry_attempts: Specifies the maximum attempts of the retry policy. default: 4.
        :param Sequence['GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskInListArgs'] param_task_in_lists: Input parameter list.
        :param Sequence['GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskOutListArgs'] param_task_out_lists: Output parameter list.
        :param _builtins.int retry_wait: Retry policy. retry wait time in minutes. default: 5.
        :param _builtins.int run_priority: Task scheduling priority. valid values: 4 (high), 5 (medium), 6 (low). default: 6.
        :param _builtins.int schedule_run_type: Scheduling type: 0 for normal scheduling, 1 for dry-run scheduling.
        :param _builtins.str schedule_time_zone: Time zone.
        :param _builtins.str self_depend: Self-Dependent. Valid values: parallel, serial, orderly. Default value: serial.
        :param _builtins.str start_time: Effective date.
        :param Sequence['GetTaskVersionDataTaskTaskSchedulerConfigurationTaskOutputRegistryListArgs'] task_output_registry_lists: Output registration.
        :param Sequence['GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs'] upstream_dependency_config_lists: Specifies the upstream dependency array.
        :param _builtins.str wait_execution_total_ttl: Timeout Handling Policy: Wait Duration Timeout  (in minutes), default: -1
        """
        if allow_redo_type is not None:
            pulumi.set(__self__, "allow_redo_type", allow_redo_type)
        if calendar_id is not None:
            pulumi.set(__self__, "calendar_id", calendar_id)
        if calendar_name is not None:
            pulumi.set(__self__, "calendar_name", calendar_name)
        if calendar_open is not None:
            pulumi.set(__self__, "calendar_open", calendar_open)
        if crontab_expression is not None:
            pulumi.set(__self__, "crontab_expression", crontab_expression)
        if cycle_type is not None:
            pulumi.set(__self__, "cycle_type", cycle_type)
        if down_stream_dependency_config_lists is not None:
            pulumi.set(__self__, "down_stream_dependency_config_lists", down_stream_dependency_config_lists)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if event_listener_lists is not None:
            pulumi.set(__self__, "event_listener_lists", event_listener_lists)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if execution_ttl is not None:
            pulumi.set(__self__, "execution_ttl", execution_ttl)
        if init_strategy is not None:
            pulumi.set(__self__, "init_strategy", init_strategy)
        if max_retry_attempts is not None:
            pulumi.set(__self__, "max_retry_attempts", max_retry_attempts)
        if param_task_in_lists is not None:
            pulumi.set(__self__, "param_task_in_lists", param_task_in_lists)
        if param_task_out_lists is not None:
            pulumi.set(__self__, "param_task_out_lists", param_task_out_lists)
        if retry_wait is not None:
            pulumi.set(__self__, "retry_wait", retry_wait)
        if run_priority is not None:
            pulumi.set(__self__, "run_priority", run_priority)
        if schedule_run_type is not None:
            pulumi.set(__self__, "schedule_run_type", schedule_run_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if self_depend is not None:
            pulumi.set(__self__, "self_depend", self_depend)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if task_output_registry_lists is not None:
            pulumi.set(__self__, "task_output_registry_lists", task_output_registry_lists)
        if upstream_dependency_config_lists is not None:
            pulumi.set(__self__, "upstream_dependency_config_lists", upstream_dependency_config_lists)
        if wait_execution_total_ttl is not None:
            pulumi.set(__self__, "wait_execution_total_ttl", wait_execution_total_ttl)

    @_builtins.property
    @pulumi.getter(name="allowRedoType")
    def allow_redo_type(self) -> Optional[_builtins.str]:
        """
        Rerun & Refill Configuration: Default: ALL;

        * ALL: Rerun or refill is allowed regardless of whether the task succeeds or fails.

        * FAILURE: Rerun or refill is allowed only if the task fails; not allowed if the task succeeds.

        * NONE: Rerun or refill is not allowed regardless of success or failure.
        """
        return pulumi.get(self, "allow_redo_type")

    @_builtins.property
    @pulumi.getter(name="calendarId")
    def calendar_id(self) -> Optional[_builtins.str]:
        """
        Calendar id.
        """
        return pulumi.get(self, "calendar_id")

    @_builtins.property
    @pulumi.getter(name="calendarName")
    def calendar_name(self) -> Optional[_builtins.str]:
        """
        Calendar name, which needs to be obtained from DescribeScheduleCalendarPageList API.
        """
        return pulumi.get(self, "calendar_name")

    @_builtins.property
    @pulumi.getter(name="calendarOpen")
    def calendar_open(self) -> Optional[_builtins.str]:
        """
        Whether calendar scheduling is enabled. Valid values: 1 (enabled), 0 (disabled).
        """
        return pulumi.get(self, "calendar_open")

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> Optional[_builtins.str]:
        """
        0 2 3 1,L,2 * ?
        """
        return pulumi.get(self, "crontab_expression")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> Optional[_builtins.str]:
        """
        Period type. Supported types:

        ONEOFF_CYCLE: specifies a one-time cycle.
        YEAR_CYCLE: specifies the year cycle.
        MONTH_CYCLE: specifies the monthly cycle.
        WEEK_CYCLE: specifies the week cycle.
        DAY_CYCLE: specifies the day cycle.
        HOUR_CYCLE: specifies the hour cycle.
        MINUTE_CYCLE: specifies the minute cycle.
        CRONTAB_CYCLE: specifies the crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="downStreamDependencyConfigLists")
    def down_stream_dependency_config_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListResult']]:
        """
        SpecSpecifies the downstream dependency array.
        """
        return pulumi.get(self, "down_stream_dependency_config_lists")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End date
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="eventListenerLists")
    def event_listener_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListResult']]:
        """
        Array of Events
        """
        return pulumi.get(self, "event_listener_lists")

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[_builtins.str]:
        """
        Execution time. right closed interval.
        """
        return pulumi.get(self, "execution_end_time")

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[_builtins.str]:
        """
        Execution time. the left-closed interval.
        """
        return pulumi.get(self, "execution_start_time")

    @_builtins.property
    @pulumi.getter(name="executionTtl")
    def execution_ttl(self) -> Optional[_builtins.int]:
        """
        Timeout Handling Policy: Execution Timeout (in minutes), default: -1
        """
        return pulumi.get(self, "execution_ttl")

    @_builtins.property
    @pulumi.getter(name="initStrategy")
    def init_strategy(self) -> Optional[_builtins.str]:
        """
        **Instance generation policy**.
        T_PLUS_0: specifies t+0 generation. default policy.
        T_PLUS_1: specifies t+1 generation.
        """
        return pulumi.get(self, "init_strategy")

    @_builtins.property
    @pulumi.getter(name="maxRetryAttempts")
    def max_retry_attempts(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum attempts of the retry policy. default: 4.
        """
        return pulumi.get(self, "max_retry_attempts")

    @_builtins.property
    @pulumi.getter(name="paramTaskInLists")
    def param_task_in_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskInListResult']]:
        """
        Input parameter list.
        """
        return pulumi.get(self, "param_task_in_lists")

    @_builtins.property
    @pulumi.getter(name="paramTaskOutLists")
    def param_task_out_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskOutListResult']]:
        """
        Output parameter list.
        """
        return pulumi.get(self, "param_task_out_lists")

    @_builtins.property
    @pulumi.getter(name="retryWait")
    def retry_wait(self) -> Optional[_builtins.int]:
        """
        Retry policy. retry wait time in minutes. default: 5.
        """
        return pulumi.get(self, "retry_wait")

    @_builtins.property
    @pulumi.getter(name="runPriority")
    def run_priority(self) -> Optional[_builtins.int]:
        """
        Task scheduling priority. valid values: 4 (high), 5 (medium), 6 (low). default: 6.
        """
        return pulumi.get(self, "run_priority")

    @_builtins.property
    @pulumi.getter(name="scheduleRunType")
    def schedule_run_type(self) -> Optional[_builtins.int]:
        """
        Scheduling type: 0 for normal scheduling, 1 for dry-run scheduling.
        """
        return pulumi.get(self, "schedule_run_type")

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[_builtins.str]:
        """
        Time zone.
        """
        return pulumi.get(self, "schedule_time_zone")

    @_builtins.property
    @pulumi.getter(name="selfDepend")
    def self_depend(self) -> Optional[_builtins.str]:
        """
        Self-Dependent. Valid values: parallel, serial, orderly. Default value: serial.
        """
        return pulumi.get(self, "self_depend")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Effective date.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="taskOutputRegistryLists")
    def task_output_registry_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationTaskOutputRegistryListResult']]:
        """
        Output registration.
        """
        return pulumi.get(self, "task_output_registry_lists")

    @_builtins.property
    @pulumi.getter(name="upstreamDependencyConfigLists")
    def upstream_dependency_config_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListResult']]:
        """
        Specifies the upstream dependency array.
        """
        return pulumi.get(self, "upstream_dependency_config_lists")

    @_builtins.property
    @pulumi.getter(name="waitExecutionTotalTtl")
    def wait_execution_total_ttl(self) -> Optional[_builtins.str]:
        """
        Timeout Handling Policy: Wait Duration Timeout  (in minutes), default: -1
        """
        return pulumi.get(self, "wait_execution_total_ttl")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListResult(dict):
    def __init__(__self__, *,
                 main_cyclic_config: _builtins.str,
                 task_id: _builtins.str,
                 dependency_strategy: Optional['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListDependencyStrategyResult'] = None,
                 offset: Optional[_builtins.str] = None,
                 subordinate_cyclic_config: Optional[_builtins.str] = None):
        """
        :param _builtins.str main_cyclic_config: Main dependency configuration. Valid values:
               
               * CRONTAB
               * DAY
               * HOUR
               * LIST_DAY
               * LIST_HOUR
               * LIST_MINUTE
               * MINUTE
               * MONTH
               * RANGE_DAY
               * RANGE_HOUR
               * RANGE_MINUTE
               * WEEK
               * YEAR
        :param _builtins.str task_id: Task ID.
        :param 'GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListDependencyStrategyArgs' dependency_strategy: Dependency Execution Policy
        :param _builtins.str offset: Offset in Range/List Mode
        :param _builtins.str subordinate_cyclic_config: Configures secondary dependencies.  Valid values:
               * ALL_DAY_OF_YEAR
               * ALL_MONTH_OF_YEAR
               * CURRENT
               * CURRENT_DAY
               * CURRENT_HOUR
               * CURRENT_MINUTE
               * CURRENT_MONTH
               * CURRENT_WEEK
               * CURRENT_YEAR
               * PREVIOUS_BEGIN_OF_MONTH
               * PREVIOUS_DAY
               * PREVIOUS_DAY_LATER_OFFSET_HOUR
               * PREVIOUS_DAY_LATER_OFFSET_MINUTE
               * PREVIOUS_END_OF_MONTH
               * PREVIOUS_FRIDAY
               * PREVIOUS_HOUR
               * PREVIOUS_HOUR_CYCLE
               * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
               * PREVIOUS_MINUTE_CYCLE
               * PREVIOUS_MONTH
               * PREVIOUS_WEEK
               * PREVIOUS_WEEKEND
               * RECENT_DATE
        """
        pulumi.set(__self__, "main_cyclic_config", main_cyclic_config)
        pulumi.set(__self__, "task_id", task_id)
        if dependency_strategy is not None:
            pulumi.set(__self__, "dependency_strategy", dependency_strategy)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if subordinate_cyclic_config is not None:
            pulumi.set(__self__, "subordinate_cyclic_config", subordinate_cyclic_config)

    @_builtins.property
    @pulumi.getter(name="mainCyclicConfig")
    def main_cyclic_config(self) -> _builtins.str:
        """
        Main dependency configuration. Valid values:

        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR
        """
        return pulumi.get(self, "main_cyclic_config")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="dependencyStrategy")
    def dependency_strategy(self) -> Optional['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListDependencyStrategyResult']:
        """
        Dependency Execution Policy
        """
        return pulumi.get(self, "dependency_strategy")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.str]:
        """
        Offset in Range/List Mode
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter(name="subordinateCyclicConfig")
    def subordinate_cyclic_config(self) -> Optional[_builtins.str]:
        """
        Configures secondary dependencies.  Valid values:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE
        """
        return pulumi.get(self, "subordinate_cyclic_config")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationDownStreamDependencyConfigListDependencyStrategyResult(dict):
    def __init__(__self__, *,
                 polling_null_strategy: Optional[_builtins.str] = None,
                 task_dependency_executing_strategies: Optional[Sequence[_builtins.str]] = None,
                 task_dependency_executing_timeout_value: Optional[_builtins.int] = None):
        """
        :param _builtins.str polling_null_strategy: Wait upstream task instance policy: EXECUTING (execute); WAITING (wait).
        :param Sequence[_builtins.str] task_dependency_executing_strategies: This field is required only when PollingNullStrategy is set to EXECUTING.
               Type: List
               
               NOT_EXIST (default) - In cases where minute depends on minute / hour depends on hour, the parent instance does not fall within the scheduling time range of the downstream instance.
               
               PARENT_EXPIRED - The parent instance failed.
               
               PARENT_TIMEOUT - The parent instance timed out.
               
               If any of the above conditions are met, the dependency check for that parent task instance is considered satisfied. In all other cases, the system must wait for the parent instance.
        :param _builtins.int task_dependency_executing_timeout_value: This field is required only when TaskDependencyExecutingStrategies includes PARENT_TIMEOUT.
               Specifies the timeout duration (in minutes) for the downstream task's dependency on the parent instance execution.
        """
        if polling_null_strategy is not None:
            pulumi.set(__self__, "polling_null_strategy", polling_null_strategy)
        if task_dependency_executing_strategies is not None:
            pulumi.set(__self__, "task_dependency_executing_strategies", task_dependency_executing_strategies)
        if task_dependency_executing_timeout_value is not None:
            pulumi.set(__self__, "task_dependency_executing_timeout_value", task_dependency_executing_timeout_value)

    @_builtins.property
    @pulumi.getter(name="pollingNullStrategy")
    def polling_null_strategy(self) -> Optional[_builtins.str]:
        """
        Wait upstream task instance policy: EXECUTING (execute); WAITING (wait).
        """
        return pulumi.get(self, "polling_null_strategy")

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingStrategies")
    def task_dependency_executing_strategies(self) -> Optional[Sequence[_builtins.str]]:
        """
        This field is required only when PollingNullStrategy is set to EXECUTING.
        Type: List

        NOT_EXIST (default) - In cases where minute depends on minute / hour depends on hour, the parent instance does not fall within the scheduling time range of the downstream instance.

        PARENT_EXPIRED - The parent instance failed.

        PARENT_TIMEOUT - The parent instance timed out.

        If any of the above conditions are met, the dependency check for that parent task instance is considered satisfied. In all other cases, the system must wait for the parent instance.
        """
        return pulumi.get(self, "task_dependency_executing_strategies")

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingTimeoutValue")
    def task_dependency_executing_timeout_value(self) -> Optional[_builtins.int]:
        """
        This field is required only when TaskDependencyExecutingStrategies includes PARENT_TIMEOUT.
        Specifies the timeout duration (in minutes) for the downstream task's dependency on the parent instance execution.
        """
        return pulumi.get(self, "task_dependency_executing_timeout_value")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListResult(dict):
    def __init__(__self__, *,
                 event_broadcast_type: _builtins.str,
                 event_name: _builtins.str,
                 event_sub_type: _builtins.str,
                 properties_lists: Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListPropertiesListResult']] = None):
        """
        :param _builtins.str event_broadcast_type: Event BROADCAST type: SINGLE, BROADCAST.
        :param _builtins.str event_name: Event name
        :param _builtins.str event_sub_type: Event cycle. valid values: SECOND, MIN, HOUR, DAY.
        :param Sequence['GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs'] properties_lists: Extension Information
        """
        pulumi.set(__self__, "event_broadcast_type", event_broadcast_type)
        pulumi.set(__self__, "event_name", event_name)
        pulumi.set(__self__, "event_sub_type", event_sub_type)
        if properties_lists is not None:
            pulumi.set(__self__, "properties_lists", properties_lists)

    @_builtins.property
    @pulumi.getter(name="eventBroadcastType")
    def event_broadcast_type(self) -> _builtins.str:
        """
        Event BROADCAST type: SINGLE, BROADCAST.
        """
        return pulumi.get(self, "event_broadcast_type")

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> _builtins.str:
        """
        Event name
        """
        return pulumi.get(self, "event_name")

    @_builtins.property
    @pulumi.getter(name="eventSubType")
    def event_sub_type(self) -> _builtins.str:
        """
        Event cycle. valid values: SECOND, MIN, HOUR, DAY.
        """
        return pulumi.get(self, "event_sub_type")

    @_builtins.property
    @pulumi.getter(name="propertiesLists")
    def properties_lists(self) -> Optional[Sequence['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListPropertiesListResult']]:
        """
        Extension Information
        """
        return pulumi.get(self, "properties_lists")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationEventListenerListPropertiesListResult(dict):
    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskInListResult(dict):
    def __init__(__self__, *,
                 from_param_key: _builtins.str,
                 from_task_id: _builtins.str,
                 param_desc: _builtins.str,
                 param_key: _builtins.str):
        """
        :param _builtins.str from_param_key: Parent task parameter key.
        :param _builtins.str from_task_id: Parent Task ID
        :param _builtins.str param_desc: Parameter Description: The format is ProjectIdentifier.TaskName.ParameterName
               Example: project_wedata_1.sh_250820_104107.pp_out
        :param _builtins.str param_key: Parameter name.
        """
        pulumi.set(__self__, "from_param_key", from_param_key)
        pulumi.set(__self__, "from_task_id", from_task_id)
        pulumi.set(__self__, "param_desc", param_desc)
        pulumi.set(__self__, "param_key", param_key)

    @_builtins.property
    @pulumi.getter(name="fromParamKey")
    def from_param_key(self) -> _builtins.str:
        """
        Parent task parameter key.
        """
        return pulumi.get(self, "from_param_key")

    @_builtins.property
    @pulumi.getter(name="fromTaskId")
    def from_task_id(self) -> _builtins.str:
        """
        Parent Task ID
        """
        return pulumi.get(self, "from_task_id")

    @_builtins.property
    @pulumi.getter(name="paramDesc")
    def param_desc(self) -> _builtins.str:
        """
        Parameter Description: The format is ProjectIdentifier.TaskName.ParameterName
        Example: project_wedata_1.sh_250820_104107.pp_out
        """
        return pulumi.get(self, "param_desc")

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationParamTaskOutListResult(dict):
    def __init__(__self__, *,
                 param_key: _builtins.str,
                 param_value: _builtins.str):
        """
        :param _builtins.str param_key: Parameter name.
        :param _builtins.str param_value: Parameter definition.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Parameter definition.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationTaskOutputRegistryListResult(dict):
    def __init__(__self__, *,
                 data_flow_type: _builtins.str,
                 database_name: _builtins.str,
                 datasource_id: _builtins.str,
                 partition_name: _builtins.str,
                 table_name: _builtins.str,
                 table_physical_id: _builtins.str,
                 db_guid: Optional[_builtins.str] = None,
                 table_guid: Optional[_builtins.str] = None):
        """
        :param _builtins.str data_flow_type: Input output table data type.
               Input stream:
                UPSTREAM,
               Output stream:
                 DOWNSTREAM;.
        :param _builtins.str database_name: Database name.
        :param _builtins.str datasource_id: Data source ID.
        :param _builtins.str partition_name: Partition name
        :param _builtins.str table_name: Table name
        :param _builtins.str table_physical_id: Physical unique ID..
        :param _builtins.str db_guid: Database unique id..
        :param _builtins.str table_guid: Unique id of the table.
        """
        pulumi.set(__self__, "data_flow_type", data_flow_type)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "datasource_id", datasource_id)
        pulumi.set(__self__, "partition_name", partition_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "table_physical_id", table_physical_id)
        if db_guid is not None:
            pulumi.set(__self__, "db_guid", db_guid)
        if table_guid is not None:
            pulumi.set(__self__, "table_guid", table_guid)

    @_builtins.property
    @pulumi.getter(name="dataFlowType")
    def data_flow_type(self) -> _builtins.str:
        """
        Input output table data type.
        Input stream:
         UPSTREAM,
        Output stream:
          DOWNSTREAM;.
        """
        return pulumi.get(self, "data_flow_type")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> _builtins.str:
        """
        Data source ID.
        """
        return pulumi.get(self, "datasource_id")

    @_builtins.property
    @pulumi.getter(name="partitionName")
    def partition_name(self) -> _builtins.str:
        """
        Partition name
        """
        return pulumi.get(self, "partition_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        """
        Table name
        """
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="tablePhysicalId")
    def table_physical_id(self) -> _builtins.str:
        """
        Physical unique ID..
        """
        return pulumi.get(self, "table_physical_id")

    @_builtins.property
    @pulumi.getter(name="dbGuid")
    def db_guid(self) -> Optional[_builtins.str]:
        """
        Database unique id..
        """
        return pulumi.get(self, "db_guid")

    @_builtins.property
    @pulumi.getter(name="tableGuid")
    def table_guid(self) -> Optional[_builtins.str]:
        """
        Unique id of the table.
        """
        return pulumi.get(self, "table_guid")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListResult(dict):
    def __init__(__self__, *,
                 main_cyclic_config: _builtins.str,
                 task_id: _builtins.str,
                 dependency_strategy: Optional['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyResult'] = None,
                 offset: Optional[_builtins.str] = None,
                 subordinate_cyclic_config: Optional[_builtins.str] = None):
        """
        :param _builtins.str main_cyclic_config: Main dependency configuration. Valid values:
               
               * CRONTAB
               * DAY
               * HOUR
               * LIST_DAY
               * LIST_HOUR
               * LIST_MINUTE
               * MINUTE
               * MONTH
               * RANGE_DAY
               * RANGE_HOUR
               * RANGE_MINUTE
               * WEEK
               * YEAR
        :param _builtins.str task_id: Task ID.
        :param 'GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs' dependency_strategy: Dependency Execution Policy
        :param _builtins.str offset: Offset in Range/List Mode
        :param _builtins.str subordinate_cyclic_config: Configures secondary dependencies.  Valid values:
               * ALL_DAY_OF_YEAR
               * ALL_MONTH_OF_YEAR
               * CURRENT
               * CURRENT_DAY
               * CURRENT_HOUR
               * CURRENT_MINUTE
               * CURRENT_MONTH
               * CURRENT_WEEK
               * CURRENT_YEAR
               * PREVIOUS_BEGIN_OF_MONTH
               * PREVIOUS_DAY
               * PREVIOUS_DAY_LATER_OFFSET_HOUR
               * PREVIOUS_DAY_LATER_OFFSET_MINUTE
               * PREVIOUS_END_OF_MONTH
               * PREVIOUS_FRIDAY
               * PREVIOUS_HOUR
               * PREVIOUS_HOUR_CYCLE
               * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
               * PREVIOUS_MINUTE_CYCLE
               * PREVIOUS_MONTH
               * PREVIOUS_WEEK
               * PREVIOUS_WEEKEND
               * RECENT_DATE
        """
        pulumi.set(__self__, "main_cyclic_config", main_cyclic_config)
        pulumi.set(__self__, "task_id", task_id)
        if dependency_strategy is not None:
            pulumi.set(__self__, "dependency_strategy", dependency_strategy)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if subordinate_cyclic_config is not None:
            pulumi.set(__self__, "subordinate_cyclic_config", subordinate_cyclic_config)

    @_builtins.property
    @pulumi.getter(name="mainCyclicConfig")
    def main_cyclic_config(self) -> _builtins.str:
        """
        Main dependency configuration. Valid values:

        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR
        """
        return pulumi.get(self, "main_cyclic_config")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="dependencyStrategy")
    def dependency_strategy(self) -> Optional['outputs.GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyResult']:
        """
        Dependency Execution Policy
        """
        return pulumi.get(self, "dependency_strategy")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.str]:
        """
        Offset in Range/List Mode
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter(name="subordinateCyclicConfig")
    def subordinate_cyclic_config(self) -> Optional[_builtins.str]:
        """
        Configures secondary dependencies.  Valid values:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE
        """
        return pulumi.get(self, "subordinate_cyclic_config")


@pulumi.output_type
class GetTaskVersionDataTaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyResult(dict):
    def __init__(__self__, *,
                 polling_null_strategy: Optional[_builtins.str] = None,
                 task_dependency_executing_strategies: Optional[Sequence[_builtins.str]] = None,
                 task_dependency_executing_timeout_value: Optional[_builtins.int] = None):
        """
        :param _builtins.str polling_null_strategy: Wait upstream task instance policy: EXECUTING (execute); WAITING (wait).
        :param Sequence[_builtins.str] task_dependency_executing_strategies: This field is required only when PollingNullStrategy is set to EXECUTING.
               Type: List
               
               NOT_EXIST (default) - In cases where minute depends on minute / hour depends on hour, the parent instance does not fall within the scheduling time range of the downstream instance.
               
               PARENT_EXPIRED - The parent instance failed.
               
               PARENT_TIMEOUT - The parent instance timed out.
               
               If any of the above conditions are met, the dependency check for that parent task instance is considered satisfied. In all other cases, the system must wait for the parent instance.
        :param _builtins.int task_dependency_executing_timeout_value: This field is required only when TaskDependencyExecutingStrategies includes PARENT_TIMEOUT.
               Specifies the timeout duration (in minutes) for the downstream task's dependency on the parent instance execution.
        """
        if polling_null_strategy is not None:
            pulumi.set(__self__, "polling_null_strategy", polling_null_strategy)
        if task_dependency_executing_strategies is not None:
            pulumi.set(__self__, "task_dependency_executing_strategies", task_dependency_executing_strategies)
        if task_dependency_executing_timeout_value is not None:
            pulumi.set(__self__, "task_dependency_executing_timeout_value", task_dependency_executing_timeout_value)

    @_builtins.property
    @pulumi.getter(name="pollingNullStrategy")
    def polling_null_strategy(self) -> Optional[_builtins.str]:
        """
        Wait upstream task instance policy: EXECUTING (execute); WAITING (wait).
        """
        return pulumi.get(self, "polling_null_strategy")

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingStrategies")
    def task_dependency_executing_strategies(self) -> Optional[Sequence[_builtins.str]]:
        """
        This field is required only when PollingNullStrategy is set to EXECUTING.
        Type: List

        NOT_EXIST (default) - In cases where minute depends on minute / hour depends on hour, the parent instance does not fall within the scheduling time range of the downstream instance.

        PARENT_EXPIRED - The parent instance failed.

        PARENT_TIMEOUT - The parent instance timed out.

        If any of the above conditions are met, the dependency check for that parent task instance is considered satisfied. In all other cases, the system must wait for the parent instance.
        """
        return pulumi.get(self, "task_dependency_executing_strategies")

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingTimeoutValue")
    def task_dependency_executing_timeout_value(self) -> Optional[_builtins.int]:
        """
        This field is required only when TaskDependencyExecutingStrategies includes PARENT_TIMEOUT.
        Specifies the timeout duration (in minutes) for the downstream task's dependency on the parent instance execution.
        """
        return pulumi.get(self, "task_dependency_executing_timeout_value")


@pulumi.output_type
class GetTaskVersionsDataResult(dict):
    def __init__(__self__, *,
                 approve_status: _builtins.str,
                 approve_user_uin: _builtins.str,
                 create_time: _builtins.str,
                 create_user_uin: _builtins.str,
                 status: _builtins.str,
                 version_id: _builtins.str,
                 version_num: _builtins.str,
                 version_remark: _builtins.str):
        """
        :param _builtins.str approve_status: Approval status (only for submit version).
        :param _builtins.str approve_user_uin: Approver (only for submit version).
        :param _builtins.str create_time: Creation time.
        :param _builtins.str create_user_uin: Creator ID.
        :param _builtins.str status: Production status (only for submit version).
        :param _builtins.str version_id: Saved version ID.
        :param _builtins.str version_num: Version number.
        :param _builtins.str version_remark: Version description.
        """
        pulumi.set(__self__, "approve_status", approve_status)
        pulumi.set(__self__, "approve_user_uin", approve_user_uin)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "create_user_uin", create_user_uin)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version_id", version_id)
        pulumi.set(__self__, "version_num", version_num)
        pulumi.set(__self__, "version_remark", version_remark)

    @_builtins.property
    @pulumi.getter(name="approveStatus")
    def approve_status(self) -> _builtins.str:
        """
        Approval status (only for submit version).
        """
        return pulumi.get(self, "approve_status")

    @_builtins.property
    @pulumi.getter(name="approveUserUin")
    def approve_user_uin(self) -> _builtins.str:
        """
        Approver (only for submit version).
        """
        return pulumi.get(self, "approve_user_uin")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> _builtins.str:
        """
        Creator ID.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Production status (only for submit version).
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.str:
        """
        Saved version ID.
        """
        return pulumi.get(self, "version_id")

    @_builtins.property
    @pulumi.getter(name="versionNum")
    def version_num(self) -> _builtins.str:
        """
        Version number.
        """
        return pulumi.get(self, "version_num")

    @_builtins.property
    @pulumi.getter(name="versionRemark")
    def version_remark(self) -> _builtins.str:
        """
        Version description.
        """
        return pulumi.get(self, "version_remark")


@pulumi.output_type
class GetTasksDataResult(dict):
    def __init__(__self__, *,
                 task_id: _builtins.str,
                 task_type_id: _builtins.int,
                 workflow_id: _builtins.str,
                 create_time: Optional[_builtins.str] = None,
                 create_user_uin: Optional[_builtins.str] = None,
                 last_ops_time: Optional[_builtins.str] = None,
                 last_ops_user_name: Optional[_builtins.str] = None,
                 last_update_time: Optional[_builtins.str] = None,
                 last_update_user_name: Optional[_builtins.str] = None,
                 owner_uin: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 submit: Optional[_builtins.bool] = None,
                 task_description: Optional[_builtins.str] = None,
                 task_latest_submit_version_no: Optional[_builtins.str] = None,
                 task_latest_version_no: Optional[_builtins.str] = None,
                 task_name: Optional[_builtins.str] = None,
                 update_user_uin: Optional[_builtins.str] = None,
                 workflow_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str task_id: Task ID.
        :param _builtins.int task_type_id: Task type.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str create_time: Creation time range (yyyy-MM-dd HH:MM:ss). Two time values must be provided in the array.
        :param _builtins.str create_user_uin: Creator ID.
        :param _builtins.str last_ops_time: Last operation time.
        :param _builtins.str last_ops_user_name: Last operator name.
        :param _builtins.str last_update_time: Last update time. example: 2025-08-13 16:34:06.
        :param _builtins.str last_update_user_name: Last Updated By (Name).
        :param _builtins.str owner_uin: Owner ID.
        :param _builtins.str status: Task Status:
               * N: New
               * Y: Scheduling
               * F: Offline
               * O: Paused
               * T: Offlining
               * INVALID: Invalid.
        :param _builtins.bool submit: Submission status.
        :param _builtins.str task_description: Task description.
        :param _builtins.str task_latest_submit_version_no: Last submit version number.
        :param _builtins.str task_latest_version_no: Last save version number.
        :param _builtins.str task_name: Task name.
        :param _builtins.str update_user_uin: Last Updated User ID.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if create_user_uin is not None:
            pulumi.set(__self__, "create_user_uin", create_user_uin)
        if last_ops_time is not None:
            pulumi.set(__self__, "last_ops_time", last_ops_time)
        if last_ops_user_name is not None:
            pulumi.set(__self__, "last_ops_user_name", last_ops_user_name)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if last_update_user_name is not None:
            pulumi.set(__self__, "last_update_user_name", last_update_user_name)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if submit is not None:
            pulumi.set(__self__, "submit", submit)
        if task_description is not None:
            pulumi.set(__self__, "task_description", task_description)
        if task_latest_submit_version_no is not None:
            pulumi.set(__self__, "task_latest_submit_version_no", task_latest_submit_version_no)
        if task_latest_version_no is not None:
            pulumi.set(__self__, "task_latest_version_no", task_latest_version_no)
        if task_name is not None:
            pulumi.set(__self__, "task_name", task_name)
        if update_user_uin is not None:
            pulumi.set(__self__, "update_user_uin", update_user_uin)
        if workflow_name is not None:
            pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        Creation time range (yyyy-MM-dd HH:MM:ss). Two time values must be provided in the array.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> Optional[_builtins.str]:
        """
        Creator ID.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter(name="lastOpsTime")
    def last_ops_time(self) -> Optional[_builtins.str]:
        """
        Last operation time.
        """
        return pulumi.get(self, "last_ops_time")

    @_builtins.property
    @pulumi.getter(name="lastOpsUserName")
    def last_ops_user_name(self) -> Optional[_builtins.str]:
        """
        Last operator name.
        """
        return pulumi.get(self, "last_ops_user_name")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[_builtins.str]:
        """
        Last update time. example: 2025-08-13 16:34:06.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="lastUpdateUserName")
    def last_update_user_name(self) -> Optional[_builtins.str]:
        """
        Last Updated By (Name).
        """
        return pulumi.get(self, "last_update_user_name")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[_builtins.str]:
        """
        Owner ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Task Status:
        * N: New
        * Y: Scheduling
        * F: Offline
        * O: Paused
        * T: Offlining
        * INVALID: Invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def submit(self) -> Optional[_builtins.bool]:
        """
        Submission status.
        """
        return pulumi.get(self, "submit")

    @_builtins.property
    @pulumi.getter(name="taskDescription")
    def task_description(self) -> Optional[_builtins.str]:
        """
        Task description.
        """
        return pulumi.get(self, "task_description")

    @_builtins.property
    @pulumi.getter(name="taskLatestSubmitVersionNo")
    def task_latest_submit_version_no(self) -> Optional[_builtins.str]:
        """
        Last submit version number.
        """
        return pulumi.get(self, "task_latest_submit_version_no")

    @_builtins.property
    @pulumi.getter(name="taskLatestVersionNo")
    def task_latest_version_no(self) -> Optional[_builtins.str]:
        """
        Last save version number.
        """
        return pulumi.get(self, "task_latest_version_no")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> Optional[_builtins.str]:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="updateUserUin")
    def update_user_uin(self) -> Optional[_builtins.str]:
        """
        Last Updated User ID.
        """
        return pulumi.get(self, "update_user_uin")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> Optional[_builtins.str]:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetTenantRolesDataResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 role_display_name: _builtins.str,
                 role_id: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str description: Description.
        :param _builtins.str role_display_name: Role Chinese display name fuzzy search, can only pass one value.
        :param _builtins.str role_id: Role ID.
        :param _builtins.str role_name: Role name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "role_display_name", role_display_name)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="roleDisplayName")
    def role_display_name(self) -> _builtins.str:
        """
        Role Chinese display name fuzzy search, can only pass one value.
        """
        return pulumi.get(self, "role_display_name")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Role ID.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        Role name.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetUpstreamTaskInstancesDataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetUpstreamTaskInstancesDataItemResult'],
                 page_number: _builtins.int,
                 page_size: _builtins.int,
                 total_count: _builtins.int,
                 total_page_number: _builtins.int):
        """
        :param Sequence['GetUpstreamTaskInstancesDataItemArgs'] items: Data list.
        :param _builtins.int page_number: Page number.
        :param _builtins.int page_size: Page size.
        :param _builtins.int total_count: Total count.
        :param _builtins.int total_page_number: Total pages.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "page_number", page_number)
        pulumi.set(__self__, "page_size", page_size)
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "total_page_number", total_page_number)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetUpstreamTaskInstancesDataItemResult']:
        """
        Data list.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> _builtins.int:
        """
        Page number.
        """
        return pulumi.get(self, "page_number")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> _builtins.int:
        """
        Page size.
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter(name="totalPageNumber")
    def total_page_number(self) -> _builtins.int:
        """
        Total pages.
        """
        return pulumi.get(self, "total_page_number")


@pulumi.output_type
class GetUpstreamTaskInstancesDataItemResult(dict):
    def __init__(__self__, *,
                 cost_time: _builtins.int,
                 cur_run_date: _builtins.str,
                 cycle_type: _builtins.str,
                 end_time: _builtins.str,
                 executor_group_id: _builtins.str,
                 executor_group_name: _builtins.str,
                 folder_id: _builtins.str,
                 folder_name: _builtins.str,
                 instance_key: _builtins.str,
                 instance_state: _builtins.str,
                 instance_type: _builtins.int,
                 last_update_time: _builtins.str,
                 owner_uin_lists: Sequence[_builtins.str],
                 project_id: _builtins.str,
                 scheduler_time: _builtins.str,
                 start_time: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type: _builtins.str,
                 task_type_id: _builtins.int,
                 total_run_num: _builtins.int,
                 tries: _builtins.int,
                 try_limit: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.int cost_time: Execution duration, in ms.
        :param _builtins.str cur_run_date: Instance data time.
        :param _builtins.str cycle_type: Task cycle type.
               Supports filtering multiple types with OR relationship.
               * O: ONEOFF_CYCLE
               * Y: YEAR_CYCLE
               * M: MONTH_CYCLE
               * W: WEEK_CYCLE
               * D: DAY_CYCLE
               * H: HOUR_CYCLE
               * I: MINUTE_CYCLE
               * C: CRONTAB_CYCLE.
        :param _builtins.str end_time: Execution end time.
        :param _builtins.str executor_group_id: Executor resource group ID.
        :param _builtins.str executor_group_name: Resource group name.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str folder_name: Folder name.
        :param _builtins.str instance_key: Unique instance identifier.
        :param _builtins.str instance_state: Instance status.
               - WAIT_EVENT: Waiting for event
               - WAIT_UPSTREAM: Waiting for upstream
               - WAIT_RUN: Waiting to run
               - RUNNING: Running
               - SKIP_RUNNING: Skipped running
               - FAILED_RETRY: Failed retry
               - EXPIRED: Failed
               - COMPLETED: Success.
        :param _builtins.int instance_type: Instance type.
               
               - 0: Backfill type
               - 1: Periodic instance
               - 2: Non-periodic instance.
        :param _builtins.str last_update_time: Last update time, format yyyy-MM-dd HH:mm:ss.
        :param Sequence[_builtins.str] owner_uin_lists: Owner list.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str scheduler_time: Scheduled time.
        :param _builtins.str start_time: Execution start time.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type: Task type description.
        :param _builtins.int task_type_id: Task type ID.
        :param _builtins.int total_run_num: Total run count.
        :param _builtins.int tries: Failed retry count.
               Reset to 0 when manually rerun or backfilled.
        :param _builtins.int try_limit: Retry limit per run failure.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "cost_time", cost_time)
        pulumi.set(__self__, "cur_run_date", cur_run_date)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "executor_group_id", executor_group_id)
        pulumi.set(__self__, "executor_group_name", executor_group_name)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_name", folder_name)
        pulumi.set(__self__, "instance_key", instance_key)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "last_update_time", last_update_time)
        pulumi.set(__self__, "owner_uin_lists", owner_uin_lists)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "scheduler_time", scheduler_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "total_run_num", total_run_num)
        pulumi.set(__self__, "tries", tries)
        pulumi.set(__self__, "try_limit", try_limit)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="costTime")
    def cost_time(self) -> _builtins.int:
        """
        Execution duration, in ms.
        """
        return pulumi.get(self, "cost_time")

    @_builtins.property
    @pulumi.getter(name="curRunDate")
    def cur_run_date(self) -> _builtins.str:
        """
        Instance data time.
        """
        return pulumi.get(self, "cur_run_date")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Task cycle type.
        Supports filtering multiple types with OR relationship.
        * O: ONEOFF_CYCLE
        * Y: YEAR_CYCLE
        * M: MONTH_CYCLE
        * W: WEEK_CYCLE
        * D: DAY_CYCLE
        * H: HOUR_CYCLE
        * I: MINUTE_CYCLE
        * C: CRONTAB_CYCLE.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Execution end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="executorGroupId")
    def executor_group_id(self) -> _builtins.str:
        """
        Executor resource group ID.
        """
        return pulumi.get(self, "executor_group_id")

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> _builtins.str:
        """
        Resource group name.
        """
        return pulumi.get(self, "executor_group_name")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> _builtins.str:
        """
        Folder name.
        """
        return pulumi.get(self, "folder_name")

    @_builtins.property
    @pulumi.getter(name="instanceKey")
    def instance_key(self) -> _builtins.str:
        """
        Unique instance identifier.
        """
        return pulumi.get(self, "instance_key")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        Instance status.
        - WAIT_EVENT: Waiting for event
        - WAIT_UPSTREAM: Waiting for upstream
        - WAIT_RUN: Waiting to run
        - RUNNING: Running
        - SKIP_RUNNING: Skipped running
        - FAILED_RETRY: Failed retry
        - EXPIRED: Failed
        - COMPLETED: Success.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.int:
        """
        Instance type.

        - 0: Backfill type
        - 1: Periodic instance
        - 2: Non-periodic instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> _builtins.str:
        """
        Last update time, format yyyy-MM-dd HH:mm:ss.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="ownerUinLists")
    def owner_uin_lists(self) -> Sequence[_builtins.str]:
        """
        Owner list.
        """
        return pulumi.get(self, "owner_uin_lists")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="schedulerTime")
    def scheduler_time(self) -> _builtins.str:
        """
        Scheduled time.
        """
        return pulumi.get(self, "scheduler_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Execution start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Task type description.
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type ID.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="totalRunNum")
    def total_run_num(self) -> _builtins.int:
        """
        Total run count.
        """
        return pulumi.get(self, "total_run_num")

    @_builtins.property
    @pulumi.getter
    def tries(self) -> _builtins.int:
        """
        Failed retry count.
        Reset to 0 when manually rerun or backfilled.
        """
        return pulumi.get(self, "tries")

    @_builtins.property
    @pulumi.getter(name="tryLimit")
    def try_limit(self) -> _builtins.int:
        """
        Retry limit per run failure.
        """
        return pulumi.get(self, "try_limit")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetUpstreamTasksDataResult(dict):
    def __init__(__self__, *,
                 crontab_expression: _builtins.str,
                 cycle_type: _builtins.str,
                 delay_time: _builtins.int,
                 end_time: _builtins.str,
                 init_strategy: _builtins.str,
                 owner_uin: _builtins.str,
                 project_id: _builtins.str,
                 schedule_desc: _builtins.str,
                 start_time: _builtins.str,
                 status: _builtins.str,
                 task_action: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type_desc: _builtins.str,
                 task_type_id: _builtins.int,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str):
        """
        :param _builtins.str crontab_expression: crontab expression.
        :param _builtins.str cycle_type: Cycle Type, Default: D
               Supported types:
               * O: One-time
               
               * Y: Yearly
               
               * M: Monthly
               
               * W: Weekly
               
               * D: Daily
               
               * H: Hourly
               
               * I: Minute
               
               * C: Crontab expression type.
        :param _builtins.int delay_time: Delay time.
        :param _builtins.str end_time: Task end time.
        :param _builtins.str init_strategy: Initialization strategy for scheduling.
        :param _builtins.str owner_uin: Owner ID.
        :param _builtins.str project_id: Project ID.
        :param _builtins.str schedule_desc: Specifies scheduling plan display description information.
        :param _builtins.str start_time: Task start time.
        :param _builtins.str status: Task Status:
               
               * N: New
               
               * Y: Scheduling
               
               * F: Offline
               
               * O: Paused
               
               * T: Offlining (in the process of being taken offline)
               
               I* NVALID: Invalid.
        :param _builtins.str task_action: Elastic cycle configuration.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task name.
        :param _builtins.str task_type_desc: Task type description.
               -20: universal data synchronization.
                - 25:  ETLTaskType
                - 26:  ETLTaskType
                - 30:  python
                - 31:  pyspark
                - 34:  hivesql
                - 35:  shell
                - 36:  sparksql
                - 21:  jdbcsql
                - 32:  dlc
                - 33:  ImpalaTaskType
                - 40:  CDWTaskType
                - 41:  kettle
                - 42:  TCHouse-X
                - 43:  TCHouse-X SQL
                - 46:  dlcsparkTaskType
                - 47:  TiOneMachineLearningTaskType
                - 48:  Trino
                - 50:  DLCPyspark
                - 23:  TencentDistributedSQL
                - 39:  spark
                - 92:  MRTaskType
                - 38:  ShellScript
                - 70:  HiveSQLScrip
               -130: branch.
               -131: merge.
               -132: Notebook 
               -133: SSH node.
                - 134:  StarRocks
                - 137:  For-each
               -10000: custom business common.
        :param _builtins.int task_type_id: Task type id.
        :param _builtins.str workflow_id: Workflow id.
        :param _builtins.str workflow_name: Workflow name.
        """
        pulumi.set(__self__, "crontab_expression", crontab_expression)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "delay_time", delay_time)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "init_strategy", init_strategy)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "schedule_desc", schedule_desc)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_action", task_action)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type_desc", task_type_desc)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> _builtins.str:
        """
        crontab expression.
        """
        return pulumi.get(self, "crontab_expression")

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> _builtins.str:
        """
        Cycle Type, Default: D
        Supported types:
        * O: One-time

        * Y: Yearly

        * M: Monthly

        * W: Weekly

        * D: Daily

        * H: Hourly

        * I: Minute

        * C: Crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @_builtins.property
    @pulumi.getter(name="delayTime")
    def delay_time(self) -> _builtins.int:
        """
        Delay time.
        """
        return pulumi.get(self, "delay_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Task end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="initStrategy")
    def init_strategy(self) -> _builtins.str:
        """
        Initialization strategy for scheduling.
        """
        return pulumi.get(self, "init_strategy")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Owner ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="scheduleDesc")
    def schedule_desc(self) -> _builtins.str:
        """
        Specifies scheduling plan display description information.
        """
        return pulumi.get(self, "schedule_desc")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Task start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Task Status:

        * N: New

        * Y: Scheduling

        * F: Offline

        * O: Paused

        * T: Offlining (in the process of being taken offline)

        I* NVALID: Invalid.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskAction")
    def task_action(self) -> _builtins.str:
        """
        Elastic cycle configuration.
        """
        return pulumi.get(self, "task_action")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskTypeDesc")
    def task_type_desc(self) -> _builtins.str:
        """
        Task type description.
        -20: universal data synchronization.
         - 25:  ETLTaskType
         - 26:  ETLTaskType
         - 30:  python
         - 31:  pyspark
         - 34:  hivesql
         - 35:  shell
         - 36:  sparksql
         - 21:  jdbcsql
         - 32:  dlc
         - 33:  ImpalaTaskType
         - 40:  CDWTaskType
         - 41:  kettle
         - 42:  TCHouse-X
         - 43:  TCHouse-X SQL
         - 46:  dlcsparkTaskType
         - 47:  TiOneMachineLearningTaskType
         - 48:  Trino
         - 50:  DLCPyspark
         - 23:  TencentDistributedSQL
         - 39:  spark
         - 92:  MRTaskType
         - 38:  ShellScript
         - 70:  HiveSQLScrip
        -130: branch.
        -131: merge.
        -132: Notebook 
        -133: SSH node.
         - 134:  StarRocks
         - 137:  For-each
        -10000: custom business common.
        """
        return pulumi.get(self, "task_type_desc")

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> _builtins.int:
        """
        Task type id.
        """
        return pulumi.get(self, "task_type_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow id.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetWorkflowFoldersDataResult(dict):
    def __init__(__self__, *,
                 create_user_uin: _builtins.str,
                 folder_id: _builtins.str,
                 folder_path: _builtins.str,
                 project_id: _builtins.str):
        """
        :param _builtins.str create_user_uin: Creator ID.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str folder_path: Specifies the absolute path of the folder.
        :param _builtins.str project_id: Project ID.
        """
        pulumi.set(__self__, "create_user_uin", create_user_uin)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_path", folder_path)
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> _builtins.str:
        """
        Creator ID.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> _builtins.str:
        """
        Specifies the absolute path of the folder.
        """
        return pulumi.get(self, "folder_path")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetWorkflowsDataResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 create_user_uin: _builtins.str,
                 modify_time: _builtins.str,
                 owner_uin: _builtins.str,
                 update_user_uin: _builtins.str,
                 workflow_desc: _builtins.str,
                 workflow_id: _builtins.str,
                 workflow_name: _builtins.str,
                 workflow_type: _builtins.str):
        """
        :param _builtins.str create_time: Creation time range yyyy-MM-dd HH:MM:ss. two times must be filled in the array.
        :param _builtins.str create_user_uin: Creator ID.
        :param _builtins.str modify_time: Modification time interval yyyy-MM-dd HH:MM:ss. fill in two times in the array.
        :param _builtins.str owner_uin: Owner ID.
        :param _builtins.str update_user_uin: Last updated user ID.
        :param _builtins.str workflow_desc: Workflow description.
        :param _builtins.str workflow_id: Workflow ID.
        :param _builtins.str workflow_name: Workflow name.
        :param _builtins.str workflow_type: Workflow type. valid values: cycle and manual.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "create_user_uin", create_user_uin)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "owner_uin", owner_uin)
        pulumi.set(__self__, "update_user_uin", update_user_uin)
        pulumi.set(__self__, "workflow_desc", workflow_desc)
        pulumi.set(__self__, "workflow_id", workflow_id)
        pulumi.set(__self__, "workflow_name", workflow_name)
        pulumi.set(__self__, "workflow_type", workflow_type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time range yyyy-MM-dd HH:MM:ss. two times must be filled in the array.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createUserUin")
    def create_user_uin(self) -> _builtins.str:
        """
        Creator ID.
        """
        return pulumi.get(self, "create_user_uin")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        Modification time interval yyyy-MM-dd HH:MM:ss. fill in two times in the array.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> _builtins.str:
        """
        Owner ID.
        """
        return pulumi.get(self, "owner_uin")

    @_builtins.property
    @pulumi.getter(name="updateUserUin")
    def update_user_uin(self) -> _builtins.str:
        """
        Last updated user ID.
        """
        return pulumi.get(self, "update_user_uin")

    @_builtins.property
    @pulumi.getter(name="workflowDesc")
    def workflow_desc(self) -> _builtins.str:
        """
        Workflow description.
        """
        return pulumi.get(self, "workflow_desc")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> _builtins.str:
        """
        Workflow name.
        """
        return pulumi.get(self, "workflow_name")

    @_builtins.property
    @pulumi.getter(name="workflowType")
    def workflow_type(self) -> _builtins.str:
        """
        Workflow type. valid values: cycle and manual.
        """
        return pulumi.get(self, "workflow_type")


