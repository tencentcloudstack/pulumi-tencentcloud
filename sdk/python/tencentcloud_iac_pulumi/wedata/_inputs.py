# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AddCalcEnginesToProjectOperationDlcInfoArgs',
    'AddCalcEnginesToProjectOperationDlcInfoArgsDict',
    'CodeFileCodeFileConfigArgs',
    'CodeFileCodeFileConfigArgsDict',
    'CodeFileCodeFileConfigNotebookSessionInfoArgs',
    'CodeFileCodeFileConfigNotebookSessionInfoArgsDict',
    'DataBackfillPlanOperationDataBackfillRangeListArgs',
    'DataBackfillPlanOperationDataBackfillRangeListArgsDict',
    'DataBackfillPlanOperationRedefineParamListArgs',
    'DataBackfillPlanOperationRedefineParamListArgsDict',
    'DqRuleCompareRuleArgs',
    'DqRuleCompareRuleArgsDict',
    'DqRuleCompareRuleItemArgs',
    'DqRuleCompareRuleItemArgsDict',
    'DqRuleCompareRuleItemValueListArgs',
    'DqRuleCompareRuleItemValueListArgsDict',
    'DqRuleFieldConfigArgs',
    'DqRuleFieldConfigArgsDict',
    'DqRuleFieldConfigTableConfigArgs',
    'DqRuleFieldConfigTableConfigArgsDict',
    'DqRuleFieldConfigTableConfigFieldConfigArgs',
    'DqRuleFieldConfigTableConfigFieldConfigArgsDict',
    'DqRuleFieldConfigWhereConfigArgs',
    'DqRuleFieldConfigWhereConfigArgsDict',
    'FunctionResourceListArgs',
    'FunctionResourceListArgsDict',
    'IntegrationOfflineTaskTaskInfoArgs',
    'IntegrationOfflineTaskTaskInfoArgsDict',
    'IntegrationOfflineTaskTaskInfoConfigArgs',
    'IntegrationOfflineTaskTaskInfoConfigArgsDict',
    'IntegrationOfflineTaskTaskInfoExecuteContextArgs',
    'IntegrationOfflineTaskTaskInfoExecuteContextArgsDict',
    'IntegrationOfflineTaskTaskInfoExtConfigArgs',
    'IntegrationOfflineTaskTaskInfoExtConfigArgsDict',
    'IntegrationOfflineTaskTaskInfoMappingArgs',
    'IntegrationOfflineTaskTaskInfoMappingArgsDict',
    'IntegrationOfflineTaskTaskInfoMappingExtConfigArgs',
    'IntegrationOfflineTaskTaskInfoMappingExtConfigArgsDict',
    'IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgs',
    'IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgsDict',
    'IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgs',
    'IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgsDict',
    'IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgs',
    'IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgsDict',
    'IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgs',
    'IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgsDict',
    'IntegrationRealtimeTaskTaskInfoArgs',
    'IntegrationRealtimeTaskTaskInfoArgsDict',
    'IntegrationRealtimeTaskTaskInfoConfigArgs',
    'IntegrationRealtimeTaskTaskInfoConfigArgsDict',
    'IntegrationRealtimeTaskTaskInfoExecuteContextArgs',
    'IntegrationRealtimeTaskTaskInfoExecuteContextArgsDict',
    'IntegrationRealtimeTaskTaskInfoExtConfigArgs',
    'IntegrationRealtimeTaskTaskInfoExtConfigArgsDict',
    'IntegrationRealtimeTaskTaskInfoMappingArgs',
    'IntegrationRealtimeTaskTaskInfoMappingArgsDict',
    'IntegrationRealtimeTaskTaskInfoMappingExtConfigArgs',
    'IntegrationRealtimeTaskTaskInfoMappingExtConfigArgsDict',
    'IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgs',
    'IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgsDict',
    'IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgs',
    'IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgsDict',
    'IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgs',
    'IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeArgs',
    'IntegrationRealtimeTaskTaskInfoNodeArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeConfigArgs',
    'IntegrationRealtimeTaskTaskInfoNodeConfigArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeExtConfigArgs',
    'IntegrationRealtimeTaskTaskInfoNodeExtConfigArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgs',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgs',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgs',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgs',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgs',
    'IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeSchemaArgs',
    'IntegrationRealtimeTaskTaskInfoNodeSchemaArgsDict',
    'IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgs',
    'IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgsDict',
    'IntegrationTaskNodeNodeInfoArgs',
    'IntegrationTaskNodeNodeInfoArgsDict',
    'IntegrationTaskNodeNodeInfoConfigArgs',
    'IntegrationTaskNodeNodeInfoConfigArgsDict',
    'IntegrationTaskNodeNodeInfoExtConfigArgs',
    'IntegrationTaskNodeNodeInfoExtConfigArgsDict',
    'IntegrationTaskNodeNodeInfoNodeMappingArgs',
    'IntegrationTaskNodeNodeInfoNodeMappingArgsDict',
    'IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgs',
    'IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgsDict',
    'IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgs',
    'IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgsDict',
    'IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgs',
    'IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgsDict',
    'IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgs',
    'IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgsDict',
    'IntegrationTaskNodeNodeInfoSchemaArgs',
    'IntegrationTaskNodeNodeInfoSchemaArgsDict',
    'IntegrationTaskNodeNodeInfoSchemaPropertyArgs',
    'IntegrationTaskNodeNodeInfoSchemaPropertyArgsDict',
    'LineageAttachmentRelationsArgs',
    'LineageAttachmentRelationsArgsDict',
    'LineageAttachmentRelationsProcessesArgs',
    'LineageAttachmentRelationsProcessesArgsDict',
    'LineageAttachmentRelationsProcessesProcessPropertyArgs',
    'LineageAttachmentRelationsProcessesProcessPropertyArgsDict',
    'LineageAttachmentRelationsSourceArgs',
    'LineageAttachmentRelationsSourceArgsDict',
    'LineageAttachmentRelationsSourceResourcePropertyArgs',
    'LineageAttachmentRelationsSourceResourcePropertyArgsDict',
    'LineageAttachmentRelationsTargetArgs',
    'LineageAttachmentRelationsTargetArgsDict',
    'LineageAttachmentRelationsTargetResourcePropertyArgs',
    'LineageAttachmentRelationsTargetResourcePropertyArgsDict',
    'OpsAlarmRuleAlarmGroupArgs',
    'OpsAlarmRuleAlarmGroupArgsDict',
    'OpsAlarmRuleAlarmGroupNotificationFatigueArgs',
    'OpsAlarmRuleAlarmGroupNotificationFatigueArgsDict',
    'OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgs',
    'OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgsDict',
    'OpsAlarmRuleAlarmGroupWebHookArgs',
    'OpsAlarmRuleAlarmGroupWebHookArgsDict',
    'OpsAlarmRuleAlarmRuleDetailArgs',
    'OpsAlarmRuleAlarmRuleDetailArgsDict',
    'OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs',
    'OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgsDict',
    'OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs',
    'OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgsDict',
    'OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgs',
    'OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgsDict',
    'OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgs',
    'OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgsDict',
    'ProjectDlcInfoArgs',
    'ProjectDlcInfoArgsDict',
    'ProjectProjectArgs',
    'ProjectProjectArgsDict',
    'SqlScriptScriptConfigArgs',
    'SqlScriptScriptConfigArgsDict',
    'TaskRerunInstanceAsyncRedefineParamListArgs',
    'TaskRerunInstanceAsyncRedefineParamListArgsDict',
    'TaskTaskBaseAttributeArgs',
    'TaskTaskBaseAttributeArgsDict',
    'TaskTaskConfigurationArgs',
    'TaskTaskConfigurationArgsDict',
    'TaskTaskConfigurationTaskExtConfigurationListArgs',
    'TaskTaskConfigurationTaskExtConfigurationListArgsDict',
    'TaskTaskConfigurationTaskSchedulingParameterListArgs',
    'TaskTaskConfigurationTaskSchedulingParameterListArgsDict',
    'TaskTaskSchedulerConfigurationArgs',
    'TaskTaskSchedulerConfigurationArgsDict',
    'TaskTaskSchedulerConfigurationEventListenerListArgs',
    'TaskTaskSchedulerConfigurationEventListenerListArgsDict',
    'TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs',
    'TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgsDict',
    'TaskTaskSchedulerConfigurationParamTaskInListArgs',
    'TaskTaskSchedulerConfigurationParamTaskInListArgsDict',
    'TaskTaskSchedulerConfigurationParamTaskOutListArgs',
    'TaskTaskSchedulerConfigurationParamTaskOutListArgsDict',
    'TaskTaskSchedulerConfigurationTaskOutputRegistryListArgs',
    'TaskTaskSchedulerConfigurationTaskOutputRegistryListArgsDict',
    'TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs',
    'TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgsDict',
    'TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs',
    'TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgsDict',
    'WeDataDataSourceDevFileUploadArgs',
    'WeDataDataSourceDevFileUploadArgsDict',
    'WeDataDataSourceListFilterArgs',
    'WeDataDataSourceListFilterArgsDict',
    'WeDataDataSourceListOrderFieldArgs',
    'WeDataDataSourceListOrderFieldArgsDict',
    'WeDataDataSourceProdFileUploadArgs',
    'WeDataDataSourceProdFileUploadArgsDict',
    'WorkflowWorkflowParamArgs',
    'WorkflowWorkflowParamArgsDict',
    'WorkflowWorkflowSchedulerConfigurationArgs',
    'WorkflowWorkflowSchedulerConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AddCalcEnginesToProjectOperationDlcInfoArgsDict(TypedDict):
        compute_resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        DLC resource names (need to add role Uin to DLC, otherwise resources may not be available).
        """
        default_database: pulumi.Input[_builtins.str]
        """
        Specify the default database for the DLC cluster.
        """
        region: pulumi.Input[_builtins.str]
        """
        DLC region.
        """
        access_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
        It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failures when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.

        Enum values:
        - TASK_RUNNER (Task Runner)
        - OWNER (Main Account Mode)
        - SUB (Sub-Account Mode).
        """
        standard_mode_env_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
        - Prod  (Production environment)
        - Dev  (Development environment).
        """
        sub_account_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
elif False:
    AddCalcEnginesToProjectOperationDlcInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddCalcEnginesToProjectOperationDlcInfoArgs:
    def __init__(__self__, *,
                 compute_resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 default_database: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_account: Optional[pulumi.Input[_builtins.str]] = None,
                 standard_mode_env_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_account_uin: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] compute_resources: DLC resource names (need to add role Uin to DLC, otherwise resources may not be available).
        :param pulumi.Input[_builtins.str] default_database: Specify the default database for the DLC cluster.
        :param pulumi.Input[_builtins.str] region: DLC region.
        :param pulumi.Input[_builtins.str] access_account: Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
               It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failures when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.
               
               Enum values:
               - TASK_RUNNER (Task Runner)
               - OWNER (Main Account Mode)
               - SUB (Sub-Account Mode).
        :param pulumi.Input[_builtins.str] standard_mode_env_tag: Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
               - Prod  (Production environment)
               - Dev  (Development environment).
        :param pulumi.Input[_builtins.str] sub_account_uin: Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        pulumi.set(__self__, "compute_resources", compute_resources)
        pulumi.set(__self__, "default_database", default_database)
        pulumi.set(__self__, "region", region)
        if access_account is not None:
            pulumi.set(__self__, "access_account", access_account)
        if standard_mode_env_tag is not None:
            pulumi.set(__self__, "standard_mode_env_tag", standard_mode_env_tag)
        if sub_account_uin is not None:
            pulumi.set(__self__, "sub_account_uin", sub_account_uin)

    @_builtins.property
    @pulumi.getter(name="computeResources")
    def compute_resources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        DLC resource names (need to add role Uin to DLC, otherwise resources may not be available).
        """
        return pulumi.get(self, "compute_resources")

    @compute_resources.setter
    def compute_resources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "compute_resources", value)

    @_builtins.property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> pulumi.Input[_builtins.str]:
        """
        Specify the default database for the DLC cluster.
        """
        return pulumi.get(self, "default_database")

    @default_database.setter
    def default_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_database", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        DLC region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessAccount")
    def access_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
        It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failures when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.

        Enum values:
        - TASK_RUNNER (Task Runner)
        - OWNER (Main Account Mode)
        - SUB (Sub-Account Mode).
        """
        return pulumi.get(self, "access_account")

    @access_account.setter
    def access_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_account", value)

    @_builtins.property
    @pulumi.getter(name="standardModeEnvTag")
    def standard_mode_env_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
        - Prod  (Production environment)
        - Dev  (Development environment).
        """
        return pulumi.get(self, "standard_mode_env_tag")

    @standard_mode_env_tag.setter
    def standard_mode_env_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "standard_mode_env_tag", value)

    @_builtins.property
    @pulumi.getter(name="subAccountUin")
    def sub_account_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        return pulumi.get(self, "sub_account_uin")

    @sub_account_uin.setter
    def sub_account_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_account_uin", value)


if not MYPY:
    class CodeFileCodeFileConfigArgsDict(TypedDict):
        notebook_session_info: NotRequired[pulumi.Input['CodeFileCodeFileConfigNotebookSessionInfoArgsDict']]
        """
        Notebook kernel session information.
        """
        params: NotRequired[pulumi.Input[_builtins.str]]
        """
        Advanced runtime parameters, variable substitution, map-json String,String.
        """
elif False:
    CodeFileCodeFileConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeFileCodeFileConfigArgs:
    def __init__(__self__, *,
                 notebook_session_info: Optional[pulumi.Input['CodeFileCodeFileConfigNotebookSessionInfoArgs']] = None,
                 params: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CodeFileCodeFileConfigNotebookSessionInfoArgs'] notebook_session_info: Notebook kernel session information.
        :param pulumi.Input[_builtins.str] params: Advanced runtime parameters, variable substitution, map-json String,String.
        """
        if notebook_session_info is not None:
            pulumi.set(__self__, "notebook_session_info", notebook_session_info)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter(name="notebookSessionInfo")
    def notebook_session_info(self) -> Optional[pulumi.Input['CodeFileCodeFileConfigNotebookSessionInfoArgs']]:
        """
        Notebook kernel session information.
        """
        return pulumi.get(self, "notebook_session_info")

    @notebook_session_info.setter
    def notebook_session_info(self, value: Optional[pulumi.Input['CodeFileCodeFileConfigNotebookSessionInfoArgs']]):
        pulumi.set(self, "notebook_session_info", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Advanced runtime parameters, variable substitution, map-json String,String.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "params", value)


if not MYPY:
    class CodeFileCodeFileConfigNotebookSessionInfoArgsDict(TypedDict):
        notebook_session_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Session ID.
        """
        notebook_session_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Session name.
        """
elif False:
    CodeFileCodeFileConfigNotebookSessionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeFileCodeFileConfigNotebookSessionInfoArgs:
    def __init__(__self__, *,
                 notebook_session_id: Optional[pulumi.Input[_builtins.str]] = None,
                 notebook_session_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] notebook_session_id: Session ID.
        :param pulumi.Input[_builtins.str] notebook_session_name: Session name.
        """
        if notebook_session_id is not None:
            pulumi.set(__self__, "notebook_session_id", notebook_session_id)
        if notebook_session_name is not None:
            pulumi.set(__self__, "notebook_session_name", notebook_session_name)

    @_builtins.property
    @pulumi.getter(name="notebookSessionId")
    def notebook_session_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Session ID.
        """
        return pulumi.get(self, "notebook_session_id")

    @notebook_session_id.setter
    def notebook_session_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notebook_session_id", value)

    @_builtins.property
    @pulumi.getter(name="notebookSessionName")
    def notebook_session_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Session name.
        """
        return pulumi.get(self, "notebook_session_name")

    @notebook_session_name.setter
    def notebook_session_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notebook_session_name", value)


if not MYPY:
    class DataBackfillPlanOperationDataBackfillRangeListArgsDict(TypedDict):
        end_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        End date in the format yyyy-MM-dd, indicates ending at 23:59:59 of the specified date.
        """
        execution_end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time point between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        """
        execution_start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time of each day between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        """
        start_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start date in yyyy-MM-dd format. indicates the start from 00:00:00 on the specified date.
        """
elif False:
    DataBackfillPlanOperationDataBackfillRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataBackfillPlanOperationDataBackfillRangeListArgs:
    def __init__(__self__, *,
                 end_date: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_date: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end_date: End date in the format yyyy-MM-dd, indicates ending at 23:59:59 of the specified date.
        :param pulumi.Input[_builtins.str] execution_end_time: End time point between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        :param pulumi.Input[_builtins.str] execution_start_time: Start time of each day between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        :param pulumi.Input[_builtins.str] start_date: Start date in yyyy-MM-dd format. indicates the start from 00:00:00 on the specified date.
        """
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End date in the format yyyy-MM-dd, indicates ending at 23:59:59 of the specified date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_date", value)

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time point between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        """
        return pulumi.get(self, "execution_end_time")

    @execution_end_time.setter
    def execution_end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_end_time", value)

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time of each day between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.
        """
        return pulumi.get(self, "execution_start_time")

    @execution_start_time.setter
    def execution_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_start_time", value)

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start date in yyyy-MM-dd format. indicates the start from 00:00:00 on the specified date.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_date", value)


if not MYPY:
    class DataBackfillPlanOperationRedefineParamListArgsDict(TypedDict):
        k: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key name.
        """
        v: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value. do not pass SQL (the request will be deemed as an attack on the api). if needed, transcode the SQL with Base64 and decode it.
        """
elif False:
    DataBackfillPlanOperationRedefineParamListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataBackfillPlanOperationRedefineParamListArgs:
    def __init__(__self__, *,
                 k: Optional[pulumi.Input[_builtins.str]] = None,
                 v: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] k: Key name.
        :param pulumi.Input[_builtins.str] v: The value. do not pass SQL (the request will be deemed as an attack on the api). if needed, transcode the SQL with Base64 and decode it.
        """
        if k is not None:
            pulumi.set(__self__, "k", k)
        if v is not None:
            pulumi.set(__self__, "v", v)

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key name.
        """
        return pulumi.get(self, "k")

    @k.setter
    def k(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "k", value)

    @_builtins.property
    @pulumi.getter
    def v(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value. do not pass SQL (the request will be deemed as an attack on the api). if needed, transcode the SQL with Base64 and decode it.
        """
        return pulumi.get(self, "v")

    @v.setter
    def v(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "v", value)


if not MYPY:
    class DqRuleCompareRuleArgsDict(TypedDict):
        cycle_step: NotRequired[pulumi.Input[_builtins.int]]
        """
        Periodic Indicates the default period of a template, in secondsNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemArgsDict']]]]
        """
        Comparison condition listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    DqRuleCompareRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DqRuleCompareRuleArgs:
    def __init__(__self__, *,
                 cycle_step: Optional[pulumi.Input[_builtins.int]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] cycle_step: Periodic Indicates the default period of a template, in secondsNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemArgs']]] items: Comparison condition listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if cycle_step is not None:
            pulumi.set(__self__, "cycle_step", cycle_step)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="cycleStep")
    def cycle_step(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Periodic Indicates the default period of a template, in secondsNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "cycle_step")

    @cycle_step.setter
    def cycle_step(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cycle_step", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemArgs']]]]:
        """
        Comparison condition listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DqRuleCompareRuleItemArgsDict(TypedDict):
        compare_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Comparison type 1. Fixed value 2. Fluctuating value 3. Comparison of value range 4. Enumeration range comparison 5. Do not compareNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comparison operation type &amp;lt; &amp;lt;= == =&amp;gt; &amp;gt;Note: This field may return null, indicating that a valid value cannot be obtained.
        """
        value_compute_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Quality statistics Type 1. Absolute value 2. Increase 3. Decrease 4. C contains 5. N C does not containNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        value_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemValueListArgsDict']]]]
        """
        Compare the threshold listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    DqRuleCompareRuleItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DqRuleCompareRuleItemArgs:
    def __init__(__self__, *,
                 compare_type: Optional[pulumi.Input[_builtins.int]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 value_compute_type: Optional[pulumi.Input[_builtins.int]] = None,
                 value_lists: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemValueListArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] compare_type: Comparison type 1. Fixed value 2. Fluctuating value 3. Comparison of value range 4. Enumeration range comparison 5. Do not compareNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] operator: Comparison operation type &amp;lt; &amp;lt;= == =&amp;gt; &amp;gt;Note: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.int] value_compute_type: Quality statistics Type 1. Absolute value 2. Increase 3. Decrease 4. C contains 5. N C does not containNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemValueListArgs']]] value_lists: Compare the threshold listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if compare_type is not None:
            pulumi.set(__self__, "compare_type", compare_type)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value_compute_type is not None:
            pulumi.set(__self__, "value_compute_type", value_compute_type)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)

    @_builtins.property
    @pulumi.getter(name="compareType")
    def compare_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Comparison type 1. Fixed value 2. Fluctuating value 3. Comparison of value range 4. Enumeration range comparison 5. Do not compareNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "compare_type")

    @compare_type.setter
    def compare_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "compare_type", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comparison operation type &amp;lt; &amp;lt;= == =&amp;gt; &amp;gt;Note: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter(name="valueComputeType")
    def value_compute_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Quality statistics Type 1. Absolute value 2. Increase 3. Decrease 4. C contains 5. N C does not containNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value_compute_type")

    @value_compute_type.setter
    def value_compute_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value_compute_type", value)

    @_builtins.property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemValueListArgs']]]]:
        """
        Compare the threshold listNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value_lists")

    @value_lists.setter
    def value_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleCompareRuleItemValueListArgs']]]]):
        pulumi.set(self, "value_lists", value)


if not MYPY:
    class DqRuleCompareRuleItemValueListArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threshold valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        value_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold type 1. Low threshold 2. High threshold 3. Common threshold 4. Enumerated valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    DqRuleCompareRuleItemValueListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DqRuleCompareRuleItemValueListArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] value: Threshold valueNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.int] value_type: Threshold type 1. Low threshold 2. High threshold 3. Common threshold 4. Enumerated valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threshold valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold type 1. Low threshold 2. High threshold 3. Common threshold 4. Enumerated valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class DqRuleFieldConfigArgsDict(TypedDict):
        table_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigArgsDict']]]]
        """
        Library table variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        where_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigWhereConfigArgsDict']]]]
        """
        Where variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    DqRuleFieldConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DqRuleFieldConfigArgs:
    def __init__(__self__, *,
                 table_configs: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigArgs']]]] = None,
                 where_configs: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigWhereConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigArgs']]] table_configs: Library table variableNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigWhereConfigArgs']]] where_configs: Where variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if table_configs is not None:
            pulumi.set(__self__, "table_configs", table_configs)
        if where_configs is not None:
            pulumi.set(__self__, "where_configs", where_configs)

    @_builtins.property
    @pulumi.getter(name="tableConfigs")
    def table_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigArgs']]]]:
        """
        Library table variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_configs")

    @table_configs.setter
    def table_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigArgs']]]]):
        pulumi.set(self, "table_configs", value)

    @_builtins.property
    @pulumi.getter(name="whereConfigs")
    def where_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigWhereConfigArgs']]]]:
        """
        Where variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "where_configs")

    @where_configs.setter
    def where_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigWhereConfigArgs']]]]):
        pulumi.set(self, "where_configs", value)


if not MYPY:
    class DqRuleFieldConfigTableConfigArgsDict(TypedDict):
        database_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Database idNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Database nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        field_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigFieldConfigArgsDict']]]]
        """
        Field variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        table_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Table idNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        table_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Table keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        table_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Table nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    DqRuleFieldConfigTableConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DqRuleFieldConfigTableConfigArgs:
    def __init__(__self__, *,
                 database_id: Optional[pulumi.Input[_builtins.str]] = None,
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 field_configs: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigFieldConfigArgs']]]] = None,
                 table_id: Optional[pulumi.Input[_builtins.str]] = None,
                 table_key: Optional[pulumi.Input[_builtins.str]] = None,
                 table_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database_id: Database idNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] database_name: Database nameNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigFieldConfigArgs']]] field_configs: Field variableNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] table_id: Table idNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] table_key: Table keyNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] table_name: Table nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if field_configs is not None:
            pulumi.set(__self__, "field_configs", field_configs)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)
        if table_key is not None:
            pulumi.set(__self__, "table_key", table_key)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Database idNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_id", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Database nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldConfigs")
    def field_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigFieldConfigArgs']]]]:
        """
        Field variableNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_configs")

    @field_configs.setter
    def field_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DqRuleFieldConfigTableConfigFieldConfigArgs']]]]):
        pulumi.set(self, "field_configs", value)

    @_builtins.property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Table idNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_id", value)

    @_builtins.property
    @pulumi.getter(name="tableKey")
    def table_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Table keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_key")

    @table_key.setter
    def table_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_key", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Table nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class DqRuleFieldConfigTableConfigFieldConfigArgsDict(TypedDict):
        field_data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        field_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        field_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    DqRuleFieldConfigTableConfigFieldConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DqRuleFieldConfigTableConfigFieldConfigArgs:
    def __init__(__self__, *,
                 field_data_type: Optional[pulumi.Input[_builtins.str]] = None,
                 field_key: Optional[pulumi.Input[_builtins.str]] = None,
                 field_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] field_data_type: Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] field_key: Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] field_value: Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if field_data_type is not None:
            pulumi.set(__self__, "field_data_type", field_data_type)
        if field_key is not None:
            pulumi.set(__self__, "field_key", field_key)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)

    @_builtins.property
    @pulumi.getter(name="fieldDataType")
    def field_data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_data_type")

    @field_data_type.setter
    def field_data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_data_type", value)

    @_builtins.property
    @pulumi.getter(name="fieldKey")
    def field_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_key")

    @field_key.setter
    def field_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_key", value)

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_value")

    @field_value.setter
    def field_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_value", value)


if not MYPY:
    class DqRuleFieldConfigWhereConfigArgsDict(TypedDict):
        field_data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        field_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        field_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    DqRuleFieldConfigWhereConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DqRuleFieldConfigWhereConfigArgs:
    def __init__(__self__, *,
                 field_data_type: Optional[pulumi.Input[_builtins.str]] = None,
                 field_key: Optional[pulumi.Input[_builtins.str]] = None,
                 field_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] field_data_type: Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] field_key: Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        :param pulumi.Input[_builtins.str] field_value: Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        if field_data_type is not None:
            pulumi.set(__self__, "field_data_type", field_data_type)
        if field_key is not None:
            pulumi.set(__self__, "field_key", field_key)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)

    @_builtins.property
    @pulumi.getter(name="fieldDataType")
    def field_data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_data_type")

    @field_data_type.setter
    def field_data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_data_type", value)

    @_builtins.property
    @pulumi.getter(name="fieldKey")
    def field_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_key")

    @field_key.setter
    def field_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_key", value)

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "field_value")

    @field_value.setter
    def field_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_value", value)


if not MYPY:
    class FunctionResourceListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Resource Name.
        """
        path: pulumi.Input[_builtins.str]
        """
        Resource Path.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource ID.
        """
        md5: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource MD5 Value.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource Type.
        """
elif False:
    FunctionResourceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionResourceListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 md5: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Resource Name.
        :param pulumi.Input[_builtins.str] path: Resource Path.
        :param pulumi.Input[_builtins.str] id: Resource ID.
        :param pulumi.Input[_builtins.str] md5: Resource MD5 Value.
        :param pulumi.Input[_builtins.str] type: Resource Type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Resource Path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource MD5 Value.
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "md5", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoArgsDict(TypedDict):
        app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        User App Id.
        """
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoConfigArgsDict']]]]
        """
        Task configuration.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Create time.
        """
        creator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creator User ID.
        """
        data_proxy_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Data proxy url.
        """
        execute_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExecuteContextArgsDict']]]]
        """
        Execute context.
        """
        executor_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Executor group name.
        """
        executor_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Executor resource ID.
        """
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        has_version: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the task been submitted.
        """
        in_long_manager_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        InLong manager url.
        """
        in_long_manager_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        InLong manager version.
        """
        in_long_stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        InLong stream id.
        """
        incharge: NotRequired[pulumi.Input[_builtins.str]]
        """
        Incharge user.
        """
        input_datasource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Input datasource type.
        """
        instance_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Instance version.
        """
        last_run_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last time the task was run.
        """
        locked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the task been locked.
        """
        locker: NotRequired[pulumi.Input[_builtins.str]]
        """
        User locked task.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingArgsDict']]]]
        """
        Node mapping.
        """
        num_records_in: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of reads.
        """
        num_records_out: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of writes.
        """
        num_restarts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Times of restarts.
        """
        offline_task_add_entity: NotRequired[pulumi.Input['IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgsDict']]
        """
        Offline task scheduling configuration.
        """
        operator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator User ID.
        """
        output_datasource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Output datasource type.
        """
        owner_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Owner User ID.
        """
        read_phase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        """
        reader_delay: NotRequired[pulumi.Input[_builtins.float]]
        """
        Read latency.
        """
        running_cu: NotRequired[pulumi.Input[_builtins.float]]
        """
        The amount of resources consumed by real-time task.
        """
        schedule_task_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Task scheduling id (job id such as oceanus or us).
        """
        status: NotRequired[pulumi.Input[_builtins.int]]
        """
        Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        """
        stop_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the task was stopped.
        """
        submit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the task version has been submitted for operation and maintenance.
        """
        switch_resource: NotRequired[pulumi.Input[_builtins.int]]
        """
        Resource tiering status, 0: in progress, 1: successful, 2: failed.
        """
        sync_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Synchronization type: 1. Whole database synchronization, 2. Single table synchronization.
        """
        task_alarm_regular_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Task alarm regular.
        """
        task_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inlong Task Group ID.
        """
        task_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Task display mode, 0: canvas mode, 1: form mode.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Update time.
        """
        workflow_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The workflow id to which the task belongs.
        """
elif False:
    IntegrationOfflineTaskTaskInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoConfigArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 creator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 data_proxy_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 execute_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExecuteContextArgs']]]] = None,
                 executor_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 executor_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExtConfigArgs']]]] = None,
                 has_version: Optional[pulumi.Input[_builtins.bool]] = None,
                 in_long_manager_url: Optional[pulumi.Input[_builtins.str]] = None,
                 in_long_manager_version: Optional[pulumi.Input[_builtins.str]] = None,
                 in_long_stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 incharge: Optional[pulumi.Input[_builtins.str]] = None,
                 input_datasource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_version: Optional[pulumi.Input[_builtins.int]] = None,
                 last_run_time: Optional[pulumi.Input[_builtins.str]] = None,
                 locked: Optional[pulumi.Input[_builtins.bool]] = None,
                 locker: Optional[pulumi.Input[_builtins.str]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingArgs']]]] = None,
                 num_records_in: Optional[pulumi.Input[_builtins.int]] = None,
                 num_records_out: Optional[pulumi.Input[_builtins.int]] = None,
                 num_restarts: Optional[pulumi.Input[_builtins.int]] = None,
                 offline_task_add_entity: Optional[pulumi.Input['IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgs']] = None,
                 operator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 output_datasource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 owner_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 read_phase: Optional[pulumi.Input[_builtins.int]] = None,
                 reader_delay: Optional[pulumi.Input[_builtins.float]] = None,
                 running_cu: Optional[pulumi.Input[_builtins.float]] = None,
                 schedule_task_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_time: Optional[pulumi.Input[_builtins.str]] = None,
                 submit: Optional[pulumi.Input[_builtins.bool]] = None,
                 switch_resource: Optional[pulumi.Input[_builtins.int]] = None,
                 sync_type: Optional[pulumi.Input[_builtins.int]] = None,
                 task_alarm_regular_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 task_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 task_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None,
                 workflow_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] app_id: User App Id.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoConfigArgs']]] configs: Task configuration.
        :param pulumi.Input[_builtins.str] create_time: Create time.
        :param pulumi.Input[_builtins.str] creator_uin: Creator User ID.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_proxy_urls: Data proxy url.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExecuteContextArgs']]] execute_contexts: Execute context.
        :param pulumi.Input[_builtins.str] executor_group_name: Executor group name.
        :param pulumi.Input[_builtins.str] executor_id: Executor resource ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input[_builtins.bool] has_version: Whether the task been submitted.
        :param pulumi.Input[_builtins.str] in_long_manager_url: InLong manager url.
        :param pulumi.Input[_builtins.str] in_long_manager_version: InLong manager version.
        :param pulumi.Input[_builtins.str] in_long_stream_id: InLong stream id.
        :param pulumi.Input[_builtins.str] incharge: Incharge user.
        :param pulumi.Input[_builtins.str] input_datasource_type: Input datasource type.
        :param pulumi.Input[_builtins.int] instance_version: Instance version.
        :param pulumi.Input[_builtins.str] last_run_time: The last time the task was run.
        :param pulumi.Input[_builtins.bool] locked: Whether the task been locked.
        :param pulumi.Input[_builtins.str] locker: User locked task.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingArgs']]] mappings: Node mapping.
        :param pulumi.Input[_builtins.int] num_records_in: Number of reads.
        :param pulumi.Input[_builtins.int] num_records_out: Number of writes.
        :param pulumi.Input[_builtins.int] num_restarts: Times of restarts.
        :param pulumi.Input['IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgs'] offline_task_add_entity: Offline task scheduling configuration.
        :param pulumi.Input[_builtins.str] operator_uin: Operator User ID.
        :param pulumi.Input[_builtins.str] output_datasource_type: Output datasource type.
        :param pulumi.Input[_builtins.str] owner_uin: Owner User ID.
        :param pulumi.Input[_builtins.int] read_phase: Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        :param pulumi.Input[_builtins.float] reader_delay: Read latency.
        :param pulumi.Input[_builtins.float] running_cu: The amount of resources consumed by real-time task.
        :param pulumi.Input[_builtins.str] schedule_task_id: Task scheduling id (job id such as oceanus or us).
        :param pulumi.Input[_builtins.int] status: Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        :param pulumi.Input[_builtins.str] stop_time: The time the task was stopped.
        :param pulumi.Input[_builtins.bool] submit: Whether the task version has been submitted for operation and maintenance.
        :param pulumi.Input[_builtins.int] switch_resource: Resource tiering status, 0: in progress, 1: successful, 2: failed.
        :param pulumi.Input[_builtins.int] sync_type: Synchronization type: 1. Whole database synchronization, 2. Single table synchronization.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] task_alarm_regular_lists: Task alarm regular.
        :param pulumi.Input[_builtins.str] task_group_id: Inlong Task Group ID.
        :param pulumi.Input[_builtins.str] task_mode: Task display mode, 0: canvas mode, 1: form mode.
        :param pulumi.Input[_builtins.str] update_time: Update time.
        :param pulumi.Input[_builtins.str] workflow_id: The workflow id to which the task belongs.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if data_proxy_urls is not None:
            pulumi.set(__self__, "data_proxy_urls", data_proxy_urls)
        if execute_contexts is not None:
            pulumi.set(__self__, "execute_contexts", execute_contexts)
        if executor_group_name is not None:
            pulumi.set(__self__, "executor_group_name", executor_group_name)
        if executor_id is not None:
            pulumi.set(__self__, "executor_id", executor_id)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if has_version is not None:
            pulumi.set(__self__, "has_version", has_version)
        if in_long_manager_url is not None:
            pulumi.set(__self__, "in_long_manager_url", in_long_manager_url)
        if in_long_manager_version is not None:
            pulumi.set(__self__, "in_long_manager_version", in_long_manager_version)
        if in_long_stream_id is not None:
            pulumi.set(__self__, "in_long_stream_id", in_long_stream_id)
        if incharge is not None:
            pulumi.set(__self__, "incharge", incharge)
        if input_datasource_type is not None:
            pulumi.set(__self__, "input_datasource_type", input_datasource_type)
        if instance_version is not None:
            pulumi.set(__self__, "instance_version", instance_version)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if locker is not None:
            pulumi.set(__self__, "locker", locker)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if num_records_in is not None:
            pulumi.set(__self__, "num_records_in", num_records_in)
        if num_records_out is not None:
            pulumi.set(__self__, "num_records_out", num_records_out)
        if num_restarts is not None:
            pulumi.set(__self__, "num_restarts", num_restarts)
        if offline_task_add_entity is not None:
            pulumi.set(__self__, "offline_task_add_entity", offline_task_add_entity)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if output_datasource_type is not None:
            pulumi.set(__self__, "output_datasource_type", output_datasource_type)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if read_phase is not None:
            pulumi.set(__self__, "read_phase", read_phase)
        if reader_delay is not None:
            pulumi.set(__self__, "reader_delay", reader_delay)
        if running_cu is not None:
            pulumi.set(__self__, "running_cu", running_cu)
        if schedule_task_id is not None:
            pulumi.set(__self__, "schedule_task_id", schedule_task_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stop_time is not None:
            pulumi.set(__self__, "stop_time", stop_time)
        if submit is not None:
            pulumi.set(__self__, "submit", submit)
        if switch_resource is not None:
            pulumi.set(__self__, "switch_resource", switch_resource)
        if sync_type is not None:
            pulumi.set(__self__, "sync_type", sync_type)
        if task_alarm_regular_lists is not None:
            pulumi.set(__self__, "task_alarm_regular_lists", task_alarm_regular_lists)
        if task_group_id is not None:
            pulumi.set(__self__, "task_group_id", task_group_id)
        if task_mode is not None:
            pulumi.set(__self__, "task_mode", task_mode)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_id", value)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoConfigArgs']]]]:
        """
        Task configuration.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoConfigArgs']]]]):
        pulumi.set(self, "configs", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @creator_uin.setter
    def creator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creator_uin", value)

    @_builtins.property
    @pulumi.getter(name="dataProxyUrls")
    def data_proxy_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Data proxy url.
        """
        return pulumi.get(self, "data_proxy_urls")

    @data_proxy_urls.setter
    def data_proxy_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_proxy_urls", value)

    @_builtins.property
    @pulumi.getter(name="executeContexts")
    def execute_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExecuteContextArgs']]]]:
        """
        Execute context.
        """
        return pulumi.get(self, "execute_contexts")

    @execute_contexts.setter
    def execute_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExecuteContextArgs']]]]):
        pulumi.set(self, "execute_contexts", value)

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Executor group name.
        """
        return pulumi.get(self, "executor_group_name")

    @executor_group_name.setter
    def executor_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "executor_group_name", value)

    @_builtins.property
    @pulumi.getter(name="executorId")
    def executor_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Executor resource ID.
        """
        return pulumi.get(self, "executor_id")

    @executor_id.setter
    def executor_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "executor_id", value)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter(name="hasVersion")
    def has_version(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the task been submitted.
        """
        return pulumi.get(self, "has_version")

    @has_version.setter
    def has_version(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "has_version", value)

    @_builtins.property
    @pulumi.getter(name="inLongManagerUrl")
    def in_long_manager_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        InLong manager url.
        """
        return pulumi.get(self, "in_long_manager_url")

    @in_long_manager_url.setter
    def in_long_manager_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_long_manager_url", value)

    @_builtins.property
    @pulumi.getter(name="inLongManagerVersion")
    def in_long_manager_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        InLong manager version.
        """
        return pulumi.get(self, "in_long_manager_version")

    @in_long_manager_version.setter
    def in_long_manager_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_long_manager_version", value)

    @_builtins.property
    @pulumi.getter(name="inLongStreamId")
    def in_long_stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        InLong stream id.
        """
        return pulumi.get(self, "in_long_stream_id")

    @in_long_stream_id.setter
    def in_long_stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_long_stream_id", value)

    @_builtins.property
    @pulumi.getter
    def incharge(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Incharge user.
        """
        return pulumi.get(self, "incharge")

    @incharge.setter
    def incharge(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "incharge", value)

    @_builtins.property
    @pulumi.getter(name="inputDatasourceType")
    def input_datasource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Input datasource type.
        """
        return pulumi.get(self, "input_datasource_type")

    @input_datasource_type.setter
    def input_datasource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_datasource_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceVersion")
    def instance_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Instance version.
        """
        return pulumi.get(self, "instance_version")

    @instance_version.setter
    def instance_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_version", value)

    @_builtins.property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last time the task was run.
        """
        return pulumi.get(self, "last_run_time")

    @last_run_time.setter
    def last_run_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_run_time", value)

    @_builtins.property
    @pulumi.getter
    def locked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the task been locked.
        """
        return pulumi.get(self, "locked")

    @locked.setter
    def locked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "locked", value)

    @_builtins.property
    @pulumi.getter
    def locker(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User locked task.
        """
        return pulumi.get(self, "locker")

    @locker.setter
    def locker(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locker", value)

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingArgs']]]]:
        """
        Node mapping.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingArgs']]]]):
        pulumi.set(self, "mappings", value)

    @_builtins.property
    @pulumi.getter(name="numRecordsIn")
    def num_records_in(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of reads.
        """
        return pulumi.get(self, "num_records_in")

    @num_records_in.setter
    def num_records_in(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_records_in", value)

    @_builtins.property
    @pulumi.getter(name="numRecordsOut")
    def num_records_out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of writes.
        """
        return pulumi.get(self, "num_records_out")

    @num_records_out.setter
    def num_records_out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_records_out", value)

    @_builtins.property
    @pulumi.getter(name="numRestarts")
    def num_restarts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Times of restarts.
        """
        return pulumi.get(self, "num_restarts")

    @num_restarts.setter
    def num_restarts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_restarts", value)

    @_builtins.property
    @pulumi.getter(name="offlineTaskAddEntity")
    def offline_task_add_entity(self) -> Optional[pulumi.Input['IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgs']]:
        """
        Offline task scheduling configuration.
        """
        return pulumi.get(self, "offline_task_add_entity")

    @offline_task_add_entity.setter
    def offline_task_add_entity(self, value: Optional[pulumi.Input['IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgs']]):
        pulumi.set(self, "offline_task_add_entity", value)

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @operator_uin.setter
    def operator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator_uin", value)

    @_builtins.property
    @pulumi.getter(name="outputDatasourceType")
    def output_datasource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Output datasource type.
        """
        return pulumi.get(self, "output_datasource_type")

    @output_datasource_type.setter
    def output_datasource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_datasource_type", value)

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @owner_uin.setter
    def owner_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner_uin", value)

    @_builtins.property
    @pulumi.getter(name="readPhase")
    def read_phase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        """
        return pulumi.get(self, "read_phase")

    @read_phase.setter
    def read_phase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_phase", value)

    @_builtins.property
    @pulumi.getter(name="readerDelay")
    def reader_delay(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Read latency.
        """
        return pulumi.get(self, "reader_delay")

    @reader_delay.setter
    def reader_delay(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "reader_delay", value)

    @_builtins.property
    @pulumi.getter(name="runningCu")
    def running_cu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The amount of resources consumed by real-time task.
        """
        return pulumi.get(self, "running_cu")

    @running_cu.setter
    def running_cu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "running_cu", value)

    @_builtins.property
    @pulumi.getter(name="scheduleTaskId")
    def schedule_task_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Task scheduling id (job id such as oceanus or us).
        """
        return pulumi.get(self, "schedule_task_id")

    @schedule_task_id.setter
    def schedule_task_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_task_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="stopTime")
    def stop_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the task was stopped.
        """
        return pulumi.get(self, "stop_time")

    @stop_time.setter
    def stop_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stop_time", value)

    @_builtins.property
    @pulumi.getter
    def submit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the task version has been submitted for operation and maintenance.
        """
        return pulumi.get(self, "submit")

    @submit.setter
    def submit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "submit", value)

    @_builtins.property
    @pulumi.getter(name="switchResource")
    def switch_resource(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Resource tiering status, 0: in progress, 1: successful, 2: failed.
        """
        return pulumi.get(self, "switch_resource")

    @switch_resource.setter
    def switch_resource(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "switch_resource", value)

    @_builtins.property
    @pulumi.getter(name="syncType")
    def sync_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Synchronization type: 1. Whole database synchronization, 2. Single table synchronization.
        """
        return pulumi.get(self, "sync_type")

    @sync_type.setter
    def sync_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sync_type", value)

    @_builtins.property
    @pulumi.getter(name="taskAlarmRegularLists")
    def task_alarm_regular_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Task alarm regular.
        """
        return pulumi.get(self, "task_alarm_regular_lists")

    @task_alarm_regular_lists.setter
    def task_alarm_regular_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "task_alarm_regular_lists", value)

    @_builtins.property
    @pulumi.getter(name="taskGroupId")
    def task_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inlong Task Group ID.
        """
        return pulumi.get(self, "task_group_id")

    @task_group_id.setter
    def task_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "task_group_id", value)

    @_builtins.property
    @pulumi.getter(name="taskMode")
    def task_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Task display mode, 0: canvas mode, 1: form mode.
        """
        return pulumi.get(self, "task_mode")

    @task_mode.setter
    def task_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "task_mode", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The workflow id to which the task belongs.
        """
        return pulumi.get(self, "workflow_id")

    @workflow_id.setter
    def workflow_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_id", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationOfflineTaskTaskInfoConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoExecuteContextArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationOfflineTaskTaskInfoExecuteContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoExecuteContextArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationOfflineTaskTaskInfoExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoMappingArgsDict(TypedDict):
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        schema_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgsDict']]]]
        """
        Schema mapping information.
        """
        sink_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sink node ID.
        """
        source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source node ID.
        """
        source_schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgsDict']]]]
        """
        Source node schema information.
        """
elif False:
    IntegrationOfflineTaskTaskInfoMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoMappingArgs:
    def __init__(__self__, *,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingExtConfigArgs']]]] = None,
                 schema_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgs']]]] = None,
                 sink_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_schemas: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgs']]] schema_mappings: Schema mapping information.
        :param pulumi.Input[_builtins.str] sink_id: Sink node ID.
        :param pulumi.Input[_builtins.str] source_id: Source node ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgs']]] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgs']]]]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @schema_mappings.setter
    def schema_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgs']]]]):
        pulumi.set(self, "schema_mappings", value)

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @sink_id.setter
    def sink_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sink_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgs']]]]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")

    @source_schemas.setter
    def source_schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgs']]]]):
        pulumi.set(self, "source_schemas", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoMappingExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationOfflineTaskTaskInfoMappingExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoMappingExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgsDict(TypedDict):
        sink_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from sink node.
        """
        source_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from source node.
        """
elif False:
    IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoMappingSchemaMappingArgs:
    def __init__(__self__, *,
                 sink_schema_id: pulumi.Input[_builtins.str],
                 source_schema_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] sink_schema_id: Schema ID from sink node.
        :param pulumi.Input[_builtins.str] source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @sink_schema_id.setter
    def sink_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sink_schema_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")

    @source_schema_id.setter
    def source_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_schema_id", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Schema ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        Schema name.
        """
        type: pulumi.Input[_builtins.str]
        """
        Schema type.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema alias.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema comment.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgsDict']]]]
        """
        Schema extended attributes.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema value.
        """
elif False:
    IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoMappingSourceSchemaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Schema ID.
        :param pulumi.Input[_builtins.str] name: Schema name.
        :param pulumi.Input[_builtins.str] type: Schema type.
        :param pulumi.Input[_builtins.str] alias: Schema alias.
        :param pulumi.Input[_builtins.str] comment: Schema comment.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgs']]] properties: Schema extended attributes.
        :param pulumi.Input[_builtins.str] value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgs']]]]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes value.
        """
elif False:
    IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoMappingSourceSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Attributes name.
        :param pulumi.Input[_builtins.str] value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgsDict(TypedDict):
        crontab_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Crontab expression.
        """
        cycle_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Scheduling type, 0: crontab type, 1: minutes, 2: hours, 3: days, 4: weeks, 5: months, 6: one-time, 7: user-driven, 10: elastic period (week), 11: elastic period (month), 12: year, 13: instant trigger.
        """
        execution_end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduling execution end time.
        """
        execution_start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduling execution start time.
        """
        retriable: NotRequired[pulumi.Input[_builtins.int]]
        """
        Whether to retry.
        """
        retry_wait: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retry waiting time, unit is minutes.
        """
        self_depend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Self-dependent rules, 1: Ordered serial one at a time, queued execution, 2: Unordered serial one at a time, not queued execution, 3: Parallel, multiple at once.
        """
        try_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of retries.
        """
elif False:
    IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOfflineTaskTaskInfoOfflineTaskAddEntityArgs:
    def __init__(__self__, *,
                 crontab_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 cycle_type: Optional[pulumi.Input[_builtins.int]] = None,
                 execution_end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 retriable: Optional[pulumi.Input[_builtins.int]] = None,
                 retry_wait: Optional[pulumi.Input[_builtins.int]] = None,
                 self_depend: Optional[pulumi.Input[_builtins.int]] = None,
                 try_limit: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] crontab_expression: Crontab expression.
        :param pulumi.Input[_builtins.int] cycle_type: Scheduling type, 0: crontab type, 1: minutes, 2: hours, 3: days, 4: weeks, 5: months, 6: one-time, 7: user-driven, 10: elastic period (week), 11: elastic period (month), 12: year, 13: instant trigger.
        :param pulumi.Input[_builtins.str] execution_end_time: Scheduling execution end time.
        :param pulumi.Input[_builtins.str] execution_start_time: Scheduling execution start time.
        :param pulumi.Input[_builtins.int] retriable: Whether to retry.
        :param pulumi.Input[_builtins.int] retry_wait: Retry waiting time, unit is minutes.
        :param pulumi.Input[_builtins.int] self_depend: Self-dependent rules, 1: Ordered serial one at a time, queued execution, 2: Unordered serial one at a time, not queued execution, 3: Parallel, multiple at once.
        :param pulumi.Input[_builtins.int] try_limit: Number of retries.
        """
        if crontab_expression is not None:
            pulumi.set(__self__, "crontab_expression", crontab_expression)
        if cycle_type is not None:
            pulumi.set(__self__, "cycle_type", cycle_type)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if retriable is not None:
            pulumi.set(__self__, "retriable", retriable)
        if retry_wait is not None:
            pulumi.set(__self__, "retry_wait", retry_wait)
        if self_depend is not None:
            pulumi.set(__self__, "self_depend", self_depend)
        if try_limit is not None:
            pulumi.set(__self__, "try_limit", try_limit)

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Crontab expression.
        """
        return pulumi.get(self, "crontab_expression")

    @crontab_expression.setter
    def crontab_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crontab_expression", value)

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Scheduling type, 0: crontab type, 1: minutes, 2: hours, 3: days, 4: weeks, 5: months, 6: one-time, 7: user-driven, 10: elastic period (week), 11: elastic period (month), 12: year, 13: instant trigger.
        """
        return pulumi.get(self, "cycle_type")

    @cycle_type.setter
    def cycle_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cycle_type", value)

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduling execution end time.
        """
        return pulumi.get(self, "execution_end_time")

    @execution_end_time.setter
    def execution_end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_end_time", value)

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduling execution start time.
        """
        return pulumi.get(self, "execution_start_time")

    @execution_start_time.setter
    def execution_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_start_time", value)

    @_builtins.property
    @pulumi.getter
    def retriable(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether to retry.
        """
        return pulumi.get(self, "retriable")

    @retriable.setter
    def retriable(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retriable", value)

    @_builtins.property
    @pulumi.getter(name="retryWait")
    def retry_wait(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retry waiting time, unit is minutes.
        """
        return pulumi.get(self, "retry_wait")

    @retry_wait.setter
    def retry_wait(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retry_wait", value)

    @_builtins.property
    @pulumi.getter(name="selfDepend")
    def self_depend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Self-dependent rules, 1: Ordered serial one at a time, queued execution, 2: Unordered serial one at a time, not queued execution, 3: Parallel, multiple at once.
        """
        return pulumi.get(self, "self_depend")

    @self_depend.setter
    def self_depend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "self_depend", value)

    @_builtins.property
    @pulumi.getter(name="tryLimit")
    def try_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of retries.
        """
        return pulumi.get(self, "try_limit")

    @try_limit.setter
    def try_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "try_limit", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoArgsDict(TypedDict):
        app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        User App Id.
        """
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoConfigArgsDict']]]]
        """
        Task configuration.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Create time.
        """
        creator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creator User ID.
        """
        data_proxy_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Data proxy url.
        """
        execute_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExecuteContextArgsDict']]]]
        """
        Execute context.
        """
        executor_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Executor group name.
        """
        executor_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Executor resource ID.
        """
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        has_version: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the task been submitted.
        """
        in_long_manager_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        InLong manager url.
        """
        in_long_manager_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        InLong manager version.
        """
        in_long_stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        InLong stream id.
        """
        incharge: NotRequired[pulumi.Input[_builtins.str]]
        """
        Incharge user.
        """
        input_datasource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Input datasource type.
        """
        instance_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Instance version.
        """
        last_run_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last time the task was run.
        """
        locked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the task been locked.
        """
        locker: NotRequired[pulumi.Input[_builtins.str]]
        """
        User locked task.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingArgsDict']]]]
        """
        Node mapping.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeArgsDict']]]]
        """
        Task Node Information.
        """
        num_records_in: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of reads.
        """
        num_records_out: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of writes.
        """
        num_restarts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Times of restarts.
        """
        operator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator User ID.
        """
        output_datasource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Output datasource type.
        """
        owner_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Owner User ID.
        """
        read_phase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        """
        reader_delay: NotRequired[pulumi.Input[_builtins.float]]
        """
        Read latency.
        """
        running_cu: NotRequired[pulumi.Input[_builtins.float]]
        """
        The amount of resources consumed by real-time task.
        """
        schedule_task_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Task scheduling id (job id such as oceanus or us).
        """
        status: NotRequired[pulumi.Input[_builtins.int]]
        """
        Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        """
        stop_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the task was stopped.
        """
        submit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the task version has been submitted for operation and maintenance.
        """
        switch_resource: NotRequired[pulumi.Input[_builtins.int]]
        """
        Resource tiering status, 0: in progress, 1: successful, 2: failed.
        """
        task_alarm_regular_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Task alarm regular.
        """
        task_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inlong Task Group ID.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Update time.
        """
        workflow_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The workflow id to which the task belongs.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoConfigArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 creator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 data_proxy_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 execute_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExecuteContextArgs']]]] = None,
                 executor_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 executor_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExtConfigArgs']]]] = None,
                 has_version: Optional[pulumi.Input[_builtins.bool]] = None,
                 in_long_manager_url: Optional[pulumi.Input[_builtins.str]] = None,
                 in_long_manager_version: Optional[pulumi.Input[_builtins.str]] = None,
                 in_long_stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 incharge: Optional[pulumi.Input[_builtins.str]] = None,
                 input_datasource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_version: Optional[pulumi.Input[_builtins.int]] = None,
                 last_run_time: Optional[pulumi.Input[_builtins.str]] = None,
                 locked: Optional[pulumi.Input[_builtins.bool]] = None,
                 locker: Optional[pulumi.Input[_builtins.str]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingArgs']]]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeArgs']]]] = None,
                 num_records_in: Optional[pulumi.Input[_builtins.int]] = None,
                 num_records_out: Optional[pulumi.Input[_builtins.int]] = None,
                 num_restarts: Optional[pulumi.Input[_builtins.int]] = None,
                 operator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 output_datasource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 owner_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 read_phase: Optional[pulumi.Input[_builtins.int]] = None,
                 reader_delay: Optional[pulumi.Input[_builtins.float]] = None,
                 running_cu: Optional[pulumi.Input[_builtins.float]] = None,
                 schedule_task_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_time: Optional[pulumi.Input[_builtins.str]] = None,
                 submit: Optional[pulumi.Input[_builtins.bool]] = None,
                 switch_resource: Optional[pulumi.Input[_builtins.int]] = None,
                 task_alarm_regular_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 task_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None,
                 workflow_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] app_id: User App Id.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoConfigArgs']]] configs: Task configuration.
        :param pulumi.Input[_builtins.str] create_time: Create time.
        :param pulumi.Input[_builtins.str] creator_uin: Creator User ID.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_proxy_urls: Data proxy url.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExecuteContextArgs']]] execute_contexts: Execute context.
        :param pulumi.Input[_builtins.str] executor_group_name: Executor group name.
        :param pulumi.Input[_builtins.str] executor_id: Executor resource ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input[_builtins.bool] has_version: Whether the task been submitted.
        :param pulumi.Input[_builtins.str] in_long_manager_url: InLong manager url.
        :param pulumi.Input[_builtins.str] in_long_manager_version: InLong manager version.
        :param pulumi.Input[_builtins.str] in_long_stream_id: InLong stream id.
        :param pulumi.Input[_builtins.str] incharge: Incharge user.
        :param pulumi.Input[_builtins.str] input_datasource_type: Input datasource type.
        :param pulumi.Input[_builtins.int] instance_version: Instance version.
        :param pulumi.Input[_builtins.str] last_run_time: The last time the task was run.
        :param pulumi.Input[_builtins.bool] locked: Whether the task been locked.
        :param pulumi.Input[_builtins.str] locker: User locked task.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingArgs']]] mappings: Node mapping.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeArgs']]] nodes: Task Node Information.
        :param pulumi.Input[_builtins.int] num_records_in: Number of reads.
        :param pulumi.Input[_builtins.int] num_records_out: Number of writes.
        :param pulumi.Input[_builtins.int] num_restarts: Times of restarts.
        :param pulumi.Input[_builtins.str] operator_uin: Operator User ID.
        :param pulumi.Input[_builtins.str] output_datasource_type: Output datasource type.
        :param pulumi.Input[_builtins.str] owner_uin: Owner User ID.
        :param pulumi.Input[_builtins.int] read_phase: Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        :param pulumi.Input[_builtins.float] reader_delay: Read latency.
        :param pulumi.Input[_builtins.float] running_cu: The amount of resources consumed by real-time task.
        :param pulumi.Input[_builtins.str] schedule_task_id: Task scheduling id (job id such as oceanus or us).
        :param pulumi.Input[_builtins.int] status: Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        :param pulumi.Input[_builtins.str] stop_time: The time the task was stopped.
        :param pulumi.Input[_builtins.bool] submit: Whether the task version has been submitted for operation and maintenance.
        :param pulumi.Input[_builtins.int] switch_resource: Resource tiering status, 0: in progress, 1: successful, 2: failed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] task_alarm_regular_lists: Task alarm regular.
        :param pulumi.Input[_builtins.str] task_group_id: Inlong Task Group ID.
        :param pulumi.Input[_builtins.str] update_time: Update time.
        :param pulumi.Input[_builtins.str] workflow_id: The workflow id to which the task belongs.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if data_proxy_urls is not None:
            pulumi.set(__self__, "data_proxy_urls", data_proxy_urls)
        if execute_contexts is not None:
            pulumi.set(__self__, "execute_contexts", execute_contexts)
        if executor_group_name is not None:
            pulumi.set(__self__, "executor_group_name", executor_group_name)
        if executor_id is not None:
            pulumi.set(__self__, "executor_id", executor_id)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if has_version is not None:
            pulumi.set(__self__, "has_version", has_version)
        if in_long_manager_url is not None:
            pulumi.set(__self__, "in_long_manager_url", in_long_manager_url)
        if in_long_manager_version is not None:
            pulumi.set(__self__, "in_long_manager_version", in_long_manager_version)
        if in_long_stream_id is not None:
            pulumi.set(__self__, "in_long_stream_id", in_long_stream_id)
        if incharge is not None:
            pulumi.set(__self__, "incharge", incharge)
        if input_datasource_type is not None:
            pulumi.set(__self__, "input_datasource_type", input_datasource_type)
        if instance_version is not None:
            pulumi.set(__self__, "instance_version", instance_version)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if locker is not None:
            pulumi.set(__self__, "locker", locker)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if num_records_in is not None:
            pulumi.set(__self__, "num_records_in", num_records_in)
        if num_records_out is not None:
            pulumi.set(__self__, "num_records_out", num_records_out)
        if num_restarts is not None:
            pulumi.set(__self__, "num_restarts", num_restarts)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if output_datasource_type is not None:
            pulumi.set(__self__, "output_datasource_type", output_datasource_type)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if read_phase is not None:
            pulumi.set(__self__, "read_phase", read_phase)
        if reader_delay is not None:
            pulumi.set(__self__, "reader_delay", reader_delay)
        if running_cu is not None:
            pulumi.set(__self__, "running_cu", running_cu)
        if schedule_task_id is not None:
            pulumi.set(__self__, "schedule_task_id", schedule_task_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stop_time is not None:
            pulumi.set(__self__, "stop_time", stop_time)
        if submit is not None:
            pulumi.set(__self__, "submit", submit)
        if switch_resource is not None:
            pulumi.set(__self__, "switch_resource", switch_resource)
        if task_alarm_regular_lists is not None:
            pulumi.set(__self__, "task_alarm_regular_lists", task_alarm_regular_lists)
        if task_group_id is not None:
            pulumi.set(__self__, "task_group_id", task_group_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_id", value)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoConfigArgs']]]]:
        """
        Task configuration.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoConfigArgs']]]]):
        pulumi.set(self, "configs", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @creator_uin.setter
    def creator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creator_uin", value)

    @_builtins.property
    @pulumi.getter(name="dataProxyUrls")
    def data_proxy_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Data proxy url.
        """
        return pulumi.get(self, "data_proxy_urls")

    @data_proxy_urls.setter
    def data_proxy_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_proxy_urls", value)

    @_builtins.property
    @pulumi.getter(name="executeContexts")
    def execute_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExecuteContextArgs']]]]:
        """
        Execute context.
        """
        return pulumi.get(self, "execute_contexts")

    @execute_contexts.setter
    def execute_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExecuteContextArgs']]]]):
        pulumi.set(self, "execute_contexts", value)

    @_builtins.property
    @pulumi.getter(name="executorGroupName")
    def executor_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Executor group name.
        """
        return pulumi.get(self, "executor_group_name")

    @executor_group_name.setter
    def executor_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "executor_group_name", value)

    @_builtins.property
    @pulumi.getter(name="executorId")
    def executor_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Executor resource ID.
        """
        return pulumi.get(self, "executor_id")

    @executor_id.setter
    def executor_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "executor_id", value)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter(name="hasVersion")
    def has_version(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the task been submitted.
        """
        return pulumi.get(self, "has_version")

    @has_version.setter
    def has_version(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "has_version", value)

    @_builtins.property
    @pulumi.getter(name="inLongManagerUrl")
    def in_long_manager_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        InLong manager url.
        """
        return pulumi.get(self, "in_long_manager_url")

    @in_long_manager_url.setter
    def in_long_manager_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_long_manager_url", value)

    @_builtins.property
    @pulumi.getter(name="inLongManagerVersion")
    def in_long_manager_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        InLong manager version.
        """
        return pulumi.get(self, "in_long_manager_version")

    @in_long_manager_version.setter
    def in_long_manager_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_long_manager_version", value)

    @_builtins.property
    @pulumi.getter(name="inLongStreamId")
    def in_long_stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        InLong stream id.
        """
        return pulumi.get(self, "in_long_stream_id")

    @in_long_stream_id.setter
    def in_long_stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "in_long_stream_id", value)

    @_builtins.property
    @pulumi.getter
    def incharge(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Incharge user.
        """
        return pulumi.get(self, "incharge")

    @incharge.setter
    def incharge(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "incharge", value)

    @_builtins.property
    @pulumi.getter(name="inputDatasourceType")
    def input_datasource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Input datasource type.
        """
        return pulumi.get(self, "input_datasource_type")

    @input_datasource_type.setter
    def input_datasource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_datasource_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceVersion")
    def instance_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Instance version.
        """
        return pulumi.get(self, "instance_version")

    @instance_version.setter
    def instance_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_version", value)

    @_builtins.property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last time the task was run.
        """
        return pulumi.get(self, "last_run_time")

    @last_run_time.setter
    def last_run_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_run_time", value)

    @_builtins.property
    @pulumi.getter
    def locked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the task been locked.
        """
        return pulumi.get(self, "locked")

    @locked.setter
    def locked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "locked", value)

    @_builtins.property
    @pulumi.getter
    def locker(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User locked task.
        """
        return pulumi.get(self, "locker")

    @locker.setter
    def locker(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locker", value)

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingArgs']]]]:
        """
        Node mapping.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingArgs']]]]):
        pulumi.set(self, "mappings", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeArgs']]]]:
        """
        Task Node Information.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter(name="numRecordsIn")
    def num_records_in(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of reads.
        """
        return pulumi.get(self, "num_records_in")

    @num_records_in.setter
    def num_records_in(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_records_in", value)

    @_builtins.property
    @pulumi.getter(name="numRecordsOut")
    def num_records_out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of writes.
        """
        return pulumi.get(self, "num_records_out")

    @num_records_out.setter
    def num_records_out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_records_out", value)

    @_builtins.property
    @pulumi.getter(name="numRestarts")
    def num_restarts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Times of restarts.
        """
        return pulumi.get(self, "num_restarts")

    @num_restarts.setter
    def num_restarts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_restarts", value)

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @operator_uin.setter
    def operator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator_uin", value)

    @_builtins.property
    @pulumi.getter(name="outputDatasourceType")
    def output_datasource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Output datasource type.
        """
        return pulumi.get(self, "output_datasource_type")

    @output_datasource_type.setter
    def output_datasource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_datasource_type", value)

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @owner_uin.setter
    def owner_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner_uin", value)

    @_builtins.property
    @pulumi.getter(name="readPhase")
    def read_phase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
        """
        return pulumi.get(self, "read_phase")

    @read_phase.setter
    def read_phase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_phase", value)

    @_builtins.property
    @pulumi.getter(name="readerDelay")
    def reader_delay(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Read latency.
        """
        return pulumi.get(self, "reader_delay")

    @reader_delay.setter
    def reader_delay(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "reader_delay", value)

    @_builtins.property
    @pulumi.getter(name="runningCu")
    def running_cu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The amount of resources consumed by real-time task.
        """
        return pulumi.get(self, "running_cu")

    @running_cu.setter
    def running_cu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "running_cu", value)

    @_builtins.property
    @pulumi.getter(name="scheduleTaskId")
    def schedule_task_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Task scheduling id (job id such as oceanus or us).
        """
        return pulumi.get(self, "schedule_task_id")

    @schedule_task_id.setter
    def schedule_task_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_task_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="stopTime")
    def stop_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the task was stopped.
        """
        return pulumi.get(self, "stop_time")

    @stop_time.setter
    def stop_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stop_time", value)

    @_builtins.property
    @pulumi.getter
    def submit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the task version has been submitted for operation and maintenance.
        """
        return pulumi.get(self, "submit")

    @submit.setter
    def submit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "submit", value)

    @_builtins.property
    @pulumi.getter(name="switchResource")
    def switch_resource(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Resource tiering status, 0: in progress, 1: successful, 2: failed.
        """
        return pulumi.get(self, "switch_resource")

    @switch_resource.setter
    def switch_resource(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "switch_resource", value)

    @_builtins.property
    @pulumi.getter(name="taskAlarmRegularLists")
    def task_alarm_regular_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Task alarm regular.
        """
        return pulumi.get(self, "task_alarm_regular_lists")

    @task_alarm_regular_lists.setter
    def task_alarm_regular_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "task_alarm_regular_lists", value)

    @_builtins.property
    @pulumi.getter(name="taskGroupId")
    def task_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inlong Task Group ID.
        """
        return pulumi.get(self, "task_group_id")

    @task_group_id.setter
    def task_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "task_group_id", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The workflow id to which the task belongs.
        """
        return pulumi.get(self, "workflow_id")

    @workflow_id.setter
    def workflow_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_id", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoExecuteContextArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoExecuteContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoExecuteContextArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoMappingArgsDict(TypedDict):
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        schema_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgsDict']]]]
        """
        Schema mapping information.
        """
        sink_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sink node ID.
        """
        source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source node ID.
        """
        source_schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgsDict']]]]
        """
        Source node schema information.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoMappingArgs:
    def __init__(__self__, *,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingExtConfigArgs']]]] = None,
                 schema_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgs']]]] = None,
                 sink_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_schemas: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgs']]] schema_mappings: Schema mapping information.
        :param pulumi.Input[_builtins.str] sink_id: Sink node ID.
        :param pulumi.Input[_builtins.str] source_id: Source node ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgs']]] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgs']]]]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @schema_mappings.setter
    def schema_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgs']]]]):
        pulumi.set(self, "schema_mappings", value)

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @sink_id.setter
    def sink_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sink_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgs']]]]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")

    @source_schemas.setter
    def source_schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgs']]]]):
        pulumi.set(self, "source_schemas", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoMappingExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoMappingExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoMappingExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgsDict(TypedDict):
        sink_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from sink node.
        """
        source_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from source node.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoMappingSchemaMappingArgs:
    def __init__(__self__, *,
                 sink_schema_id: pulumi.Input[_builtins.str],
                 source_schema_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] sink_schema_id: Schema ID from sink node.
        :param pulumi.Input[_builtins.str] source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @sink_schema_id.setter
    def sink_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sink_schema_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")

    @source_schema_id.setter
    def source_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_schema_id", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Schema ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        Schema name.
        """
        type: pulumi.Input[_builtins.str]
        """
        Schema type.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema alias.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema comment.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgsDict']]]]
        """
        Schema extended attributes.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoMappingSourceSchemaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Schema ID.
        :param pulumi.Input[_builtins.str] name: Schema name.
        :param pulumi.Input[_builtins.str] type: Schema type.
        :param pulumi.Input[_builtins.str] alias: Schema alias.
        :param pulumi.Input[_builtins.str] comment: Schema comment.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgs']]] properties: Schema extended attributes.
        :param pulumi.Input[_builtins.str] value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgs']]]]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoMappingSourceSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Attributes name.
        :param pulumi.Input[_builtins.str] value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeArgsDict(TypedDict):
        app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        User App Id.
        """
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeConfigArgsDict']]]]
        """
        Node configuration information.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Create time.
        """
        creator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creator User ID.
        """
        data_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source type: MYSQL, POSTGRE, ORACLE, SQLSERVER, FTP, HIVE, HDFS, ICEBERG, KAFKA, HBASE, SPARK, TBASE, DB2, DM, GAUSSDB, GBASE, IMPALA, ES, S3_DATAINSIGHT, GREENPLUM, PHOENIX, SAP_HANA, SFTP, OCEANBASE, CLICKHOUSE, KUDU, VERTICA, REDIS, COS, DLC, DORIS, CKAFKA, DTS_KAFKA, S3, CDW, TDSQLC, TDSQL, MONGODB, SYBASE, REST_API, StarRocks, TCHOUSE_X.
        """
        datasource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Datasource ID.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node Description.
        """
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema name.
        """
        node_mapping: NotRequired[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgsDict']]
        """
        Node mapping.
        """
        node_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node type: INPUT,OUTPUT,JOIN,FILTER,TRANSFORM.
        """
        operator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator User ID.
        """
        owner_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Owner User ID.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project ID.
        """
        schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaArgsDict']]]]
        """
        Schema information.
        """
        task_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The task id to which the node belongs.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Update time.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeConfigArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 creator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 datasource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeExtConfigArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 node_mapping: Optional[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgs']] = None,
                 node_type: Optional[pulumi.Input[_builtins.str]] = None,
                 operator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 owner_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaArgs']]]] = None,
                 task_id: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] app_id: User App Id.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeConfigArgs']]] configs: Node configuration information.
        :param pulumi.Input[_builtins.str] create_time: Create time.
        :param pulumi.Input[_builtins.str] creator_uin: Creator User ID.
        :param pulumi.Input[_builtins.str] data_source_type: Data source type: MYSQL, POSTGRE, ORACLE, SQLSERVER, FTP, HIVE, HDFS, ICEBERG, KAFKA, HBASE, SPARK, TBASE, DB2, DM, GAUSSDB, GBASE, IMPALA, ES, S3_DATAINSIGHT, GREENPLUM, PHOENIX, SAP_HANA, SFTP, OCEANBASE, CLICKHOUSE, KUDU, VERTICA, REDIS, COS, DLC, DORIS, CKAFKA, DTS_KAFKA, S3, CDW, TDSQLC, TDSQL, MONGODB, SYBASE, REST_API, StarRocks, TCHOUSE_X.
        :param pulumi.Input[_builtins.str] datasource_id: Datasource ID.
        :param pulumi.Input[_builtins.str] description: Node Description.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input[_builtins.str] id: Schema ID.
        :param pulumi.Input[_builtins.str] name: Schema name.
        :param pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgs'] node_mapping: Node mapping.
        :param pulumi.Input[_builtins.str] node_type: Node type: INPUT,OUTPUT,JOIN,FILTER,TRANSFORM.
        :param pulumi.Input[_builtins.str] operator_uin: Operator User ID.
        :param pulumi.Input[_builtins.str] owner_uin: Owner User ID.
        :param pulumi.Input[_builtins.str] project_id: Project ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaArgs']]] schemas: Schema information.
        :param pulumi.Input[_builtins.str] task_id: The task id to which the node belongs.
        :param pulumi.Input[_builtins.str] update_time: Update time.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if data_source_type is not None:
            pulumi.set(__self__, "data_source_type", data_source_type)
        if datasource_id is not None:
            pulumi.set(__self__, "datasource_id", datasource_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_mapping is not None:
            pulumi.set(__self__, "node_mapping", node_mapping)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if task_id is not None:
            pulumi.set(__self__, "task_id", task_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_id", value)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeConfigArgs']]]]:
        """
        Node configuration information.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeConfigArgs']]]]):
        pulumi.set(self, "configs", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @creator_uin.setter
    def creator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creator_uin", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceType")
    def data_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source type: MYSQL, POSTGRE, ORACLE, SQLSERVER, FTP, HIVE, HDFS, ICEBERG, KAFKA, HBASE, SPARK, TBASE, DB2, DM, GAUSSDB, GBASE, IMPALA, ES, S3_DATAINSIGHT, GREENPLUM, PHOENIX, SAP_HANA, SFTP, OCEANBASE, CLICKHOUSE, KUDU, VERTICA, REDIS, COS, DLC, DORIS, CKAFKA, DTS_KAFKA, S3, CDW, TDSQLC, TDSQL, MONGODB, SYBASE, REST_API, StarRocks, TCHOUSE_X.
        """
        return pulumi.get(self, "data_source_type")

    @data_source_type.setter
    def data_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_type", value)

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Datasource ID.
        """
        return pulumi.get(self, "datasource_id")

    @datasource_id.setter
    def datasource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datasource_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node Description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nodeMapping")
    def node_mapping(self) -> Optional[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgs']]:
        """
        Node mapping.
        """
        return pulumi.get(self, "node_mapping")

    @node_mapping.setter
    def node_mapping(self, value: Optional[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgs']]):
        pulumi.set(self, "node_mapping", value)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node type: INPUT,OUTPUT,JOIN,FILTER,TRANSFORM.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_type", value)

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @operator_uin.setter
    def operator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator_uin", value)

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @owner_uin.setter
    def owner_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner_uin", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project ID.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaArgs']]]]:
        """
        Schema information.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaArgs']]]]):
        pulumi.set(self, "schemas", value)

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The task id to which the node belongs.
        """
        return pulumi.get(self, "task_id")

    @task_id.setter
    def task_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "task_id", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgsDict(TypedDict):
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        schema_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgsDict']]]]
        """
        Schema mapping information.
        """
        sink_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sink node ID.
        """
        source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source node ID.
        """
        source_schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgsDict']]]]
        """
        Source node schema information.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingArgs:
    def __init__(__self__, *,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgs']]]] = None,
                 schema_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgs']]]] = None,
                 sink_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_schemas: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgs']]] schema_mappings: Schema mapping information.
        :param pulumi.Input[_builtins.str] sink_id: Sink node ID.
        :param pulumi.Input[_builtins.str] source_id: Source node ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgs']]] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgs']]]]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @schema_mappings.setter
    def schema_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgs']]]]):
        pulumi.set(self, "schema_mappings", value)

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @sink_id.setter
    def sink_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sink_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgs']]]]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")

    @source_schemas.setter
    def source_schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgs']]]]):
        pulumi.set(self, "source_schemas", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgsDict(TypedDict):
        sink_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from sink node.
        """
        source_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from source node.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMappingArgs:
    def __init__(__self__, *,
                 sink_schema_id: pulumi.Input[_builtins.str],
                 source_schema_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] sink_schema_id: Schema ID from sink node.
        :param pulumi.Input[_builtins.str] source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @sink_schema_id.setter
    def sink_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sink_schema_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")

    @source_schema_id.setter
    def source_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_schema_id", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Schema ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        Schema name.
        """
        type: pulumi.Input[_builtins.str]
        """
        Schema type.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema alias.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema comment.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgsDict']]]]
        """
        Schema extended attributes.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Schema ID.
        :param pulumi.Input[_builtins.str] name: Schema name.
        :param pulumi.Input[_builtins.str] type: Schema type.
        :param pulumi.Input[_builtins.str] alias: Schema alias.
        :param pulumi.Input[_builtins.str] comment: Schema comment.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgs']]] properties: Schema extended attributes.
        :param pulumi.Input[_builtins.str] value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgs']]]]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Attributes name.
        :param pulumi.Input[_builtins.str] value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeSchemaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Schema ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        Schema name.
        """
        type: pulumi.Input[_builtins.str]
        """
        Schema type.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema alias.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema comment.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgsDict']]]]
        """
        Schema extended attributes.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeSchemaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Schema ID.
        :param pulumi.Input[_builtins.str] name: Schema name.
        :param pulumi.Input[_builtins.str] type: Schema type.
        :param pulumi.Input[_builtins.str] alias: Schema alias.
        :param pulumi.Input[_builtins.str] comment: Schema comment.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgs']]] properties: Schema extended attributes.
        :param pulumi.Input[_builtins.str] value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgs']]]]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes value.
        """
elif False:
    IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRealtimeTaskTaskInfoNodeSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Attributes name.
        :param pulumi.Input[_builtins.str] value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoArgsDict(TypedDict):
        app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        User App Id.
        """
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoConfigArgsDict']]]]
        """
        Node configuration information.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Create time.
        """
        creator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creator User ID.
        """
        datasource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Datasource ID.
        """
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        node_mapping: NotRequired[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingArgsDict']]
        """
        Node mapping.
        """
        operator_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator User ID.
        """
        owner_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Owner User ID.
        """
        schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaArgsDict']]]]
        """
        Schema information.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Update time.
        """
elif False:
    IntegrationTaskNodeNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoConfigArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 creator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 datasource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoExtConfigArgs']]]] = None,
                 node_mapping: Optional[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingArgs']] = None,
                 operator_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 owner_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaArgs']]]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] app_id: User App Id.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoConfigArgs']]] configs: Node configuration information.
        :param pulumi.Input[_builtins.str] create_time: Create time.
        :param pulumi.Input[_builtins.str] creator_uin: Creator User ID.
        :param pulumi.Input[_builtins.str] datasource_id: Datasource ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingArgs'] node_mapping: Node mapping.
        :param pulumi.Input[_builtins.str] operator_uin: Operator User ID.
        :param pulumi.Input[_builtins.str] owner_uin: Owner User ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaArgs']]] schemas: Schema information.
        :param pulumi.Input[_builtins.str] update_time: Update time.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator_uin is not None:
            pulumi.set(__self__, "creator_uin", creator_uin)
        if datasource_id is not None:
            pulumi.set(__self__, "datasource_id", datasource_id)
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if node_mapping is not None:
            pulumi.set(__self__, "node_mapping", node_mapping)
        if operator_uin is not None:
            pulumi.set(__self__, "operator_uin", operator_uin)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User App Id.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_id", value)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoConfigArgs']]]]:
        """
        Node configuration information.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoConfigArgs']]]]):
        pulumi.set(self, "configs", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="creatorUin")
    def creator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creator User ID.
        """
        return pulumi.get(self, "creator_uin")

    @creator_uin.setter
    def creator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creator_uin", value)

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Datasource ID.
        """
        return pulumi.get(self, "datasource_id")

    @datasource_id.setter
    def datasource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datasource_id", value)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter(name="nodeMapping")
    def node_mapping(self) -> Optional[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingArgs']]:
        """
        Node mapping.
        """
        return pulumi.get(self, "node_mapping")

    @node_mapping.setter
    def node_mapping(self, value: Optional[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingArgs']]):
        pulumi.set(self, "node_mapping", value)

    @_builtins.property
    @pulumi.getter(name="operatorUin")
    def operator_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator User ID.
        """
        return pulumi.get(self, "operator_uin")

    @operator_uin.setter
    def operator_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator_uin", value)

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Owner User ID.
        """
        return pulumi.get(self, "owner_uin")

    @owner_uin.setter
    def owner_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner_uin", value)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaArgs']]]]:
        """
        Schema information.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaArgs']]]]):
        pulumi.set(self, "schemas", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationTaskNodeNodeInfoConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationTaskNodeNodeInfoExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoNodeMappingArgsDict(TypedDict):
        ext_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgsDict']]]]
        """
        Node extension configuration information.
        """
        schema_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgsDict']]]]
        """
        Schema mapping information.
        """
        sink_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sink node ID.
        """
        source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source node ID.
        """
        source_schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgsDict']]]]
        """
        Source node schema information.
        """
elif False:
    IntegrationTaskNodeNodeInfoNodeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoNodeMappingArgs:
    def __init__(__self__, *,
                 ext_configs: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgs']]]] = None,
                 schema_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgs']]]] = None,
                 sink_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_schemas: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgs']]] ext_configs: Node extension configuration information.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgs']]] schema_mappings: Schema mapping information.
        :param pulumi.Input[_builtins.str] sink_id: Sink node ID.
        :param pulumi.Input[_builtins.str] source_id: Source node ID.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgs']]] source_schemas: Source node schema information.
        """
        if ext_configs is not None:
            pulumi.set(__self__, "ext_configs", ext_configs)
        if schema_mappings is not None:
            pulumi.set(__self__, "schema_mappings", schema_mappings)
        if sink_id is not None:
            pulumi.set(__self__, "sink_id", sink_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_schemas is not None:
            pulumi.set(__self__, "source_schemas", source_schemas)

    @_builtins.property
    @pulumi.getter(name="extConfigs")
    def ext_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgs']]]]:
        """
        Node extension configuration information.
        """
        return pulumi.get(self, "ext_configs")

    @ext_configs.setter
    def ext_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgs']]]]):
        pulumi.set(self, "ext_configs", value)

    @_builtins.property
    @pulumi.getter(name="schemaMappings")
    def schema_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgs']]]]:
        """
        Schema mapping information.
        """
        return pulumi.get(self, "schema_mappings")

    @schema_mappings.setter
    def schema_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgs']]]]):
        pulumi.set(self, "schema_mappings", value)

    @_builtins.property
    @pulumi.getter(name="sinkId")
    def sink_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sink node ID.
        """
        return pulumi.get(self, "sink_id")

    @sink_id.setter
    def sink_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sink_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source node ID.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemas")
    def source_schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgs']]]]:
        """
        Source node schema information.
        """
        return pulumi.get(self, "source_schemas")

    @source_schemas.setter
    def source_schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgs']]]]):
        pulumi.set(self, "source_schemas", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration value.
        """
elif False:
    IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoNodeMappingExtConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Configuration name.
        :param pulumi.Input[_builtins.str] value: Configuration value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgsDict(TypedDict):
        sink_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from sink node.
        """
        source_schema_id: pulumi.Input[_builtins.str]
        """
        Schema ID from source node.
        """
elif False:
    IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoNodeMappingSchemaMappingArgs:
    def __init__(__self__, *,
                 sink_schema_id: pulumi.Input[_builtins.str],
                 source_schema_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] sink_schema_id: Schema ID from sink node.
        :param pulumi.Input[_builtins.str] source_schema_id: Schema ID from source node.
        """
        pulumi.set(__self__, "sink_schema_id", sink_schema_id)
        pulumi.set(__self__, "source_schema_id", source_schema_id)

    @_builtins.property
    @pulumi.getter(name="sinkSchemaId")
    def sink_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from sink node.
        """
        return pulumi.get(self, "sink_schema_id")

    @sink_schema_id.setter
    def sink_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sink_schema_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSchemaId")
    def source_schema_id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID from source node.
        """
        return pulumi.get(self, "source_schema_id")

    @source_schema_id.setter
    def source_schema_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_schema_id", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Schema ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        Schema name.
        """
        type: pulumi.Input[_builtins.str]
        """
        Schema type.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema alias.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema comment.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgsDict']]]]
        """
        Schema extended attributes.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema value.
        """
elif False:
    IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Schema ID.
        :param pulumi.Input[_builtins.str] name: Schema name.
        :param pulumi.Input[_builtins.str] type: Schema type.
        :param pulumi.Input[_builtins.str] alias: Schema alias.
        :param pulumi.Input[_builtins.str] comment: Schema comment.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgs']]] properties: Schema extended attributes.
        :param pulumi.Input[_builtins.str] value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgs']]]]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes value.
        """
elif False:
    IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Attributes name.
        :param pulumi.Input[_builtins.str] value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoSchemaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Schema ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        Schema name.
        """
        type: pulumi.Input[_builtins.str]
        """
        Schema type.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema alias.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema comment.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaPropertyArgsDict']]]]
        """
        Schema extended attributes.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema value.
        """
elif False:
    IntegrationTaskNodeNodeInfoSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoSchemaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaPropertyArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Schema ID.
        :param pulumi.Input[_builtins.str] name: Schema name.
        :param pulumi.Input[_builtins.str] type: Schema type.
        :param pulumi.Input[_builtins.str] alias: Schema alias.
        :param pulumi.Input[_builtins.str] comment: Schema comment.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaPropertyArgs']]] properties: Schema extended attributes.
        :param pulumi.Input[_builtins.str] value: Schema value.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Schema ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Schema type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema comment.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaPropertyArgs']]]]:
        """
        Schema extended attributes.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskNodeNodeInfoSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationTaskNodeNodeInfoSchemaPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attributes value.
        """
elif False:
    IntegrationTaskNodeNodeInfoSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskNodeNodeInfoSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Attributes name.
        :param pulumi.Input[_builtins.str] value: Attributes value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attributes value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LineageAttachmentRelationsArgsDict(TypedDict):
        processes: pulumi.Input['LineageAttachmentRelationsProcessesArgsDict']
        """
        Lineage processing process.
        """
        source: pulumi.Input['LineageAttachmentRelationsSourceArgsDict']
        """
        Source.
        """
        target: pulumi.Input['LineageAttachmentRelationsTargetArgsDict']
        """
        Target.
        """
elif False:
    LineageAttachmentRelationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LineageAttachmentRelationsArgs:
    def __init__(__self__, *,
                 processes: pulumi.Input['LineageAttachmentRelationsProcessesArgs'],
                 source: pulumi.Input['LineageAttachmentRelationsSourceArgs'],
                 target: pulumi.Input['LineageAttachmentRelationsTargetArgs']):
        """
        :param pulumi.Input['LineageAttachmentRelationsProcessesArgs'] processes: Lineage processing process.
        :param pulumi.Input['LineageAttachmentRelationsSourceArgs'] source: Source.
        :param pulumi.Input['LineageAttachmentRelationsTargetArgs'] target: Target.
        """
        pulumi.set(__self__, "processes", processes)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def processes(self) -> pulumi.Input['LineageAttachmentRelationsProcessesArgs']:
        """
        Lineage processing process.
        """
        return pulumi.get(self, "processes")

    @processes.setter
    def processes(self, value: pulumi.Input['LineageAttachmentRelationsProcessesArgs']):
        pulumi.set(self, "processes", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input['LineageAttachmentRelationsSourceArgs']:
        """
        Source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['LineageAttachmentRelationsSourceArgs']):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input['LineageAttachmentRelationsTargetArgs']:
        """
        Target.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['LineageAttachmentRelationsTargetArgs']):
        pulumi.set(self, "target", value)


if not MYPY:
    class LineageAttachmentRelationsProcessesArgsDict(TypedDict):
        platform: pulumi.Input[_builtins.str]
        """
        WEDATA, THIRD.
        """
        process_id: pulumi.Input[_builtins.str]
        """
        Original unique ID.
        """
        process_type: pulumi.Input[_builtins.str]
        """
        Task type.
        //Scheduled task
        SCHEDULE_TASK,
        //Integration task
        INTEGRATION_TASK,
        //Third-party reporting
        THIRD_REPORT,
        //Data modeling
        TABLE_MODEL,
        //Model creates metric
        MODEL_METRIC,
        //Atomic metric creates derived metric
        METRIC_METRIC,
        //Data service
        DATA_SERVICE.
        """
        lineage_node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Lineage task unique node ID.
        """
        process_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsProcessesProcessPropertyArgsDict']]]]
        """
        Additional extension parameters.
        """
        process_sub_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Task subtype.
        SQL_TASK,
        //Integrated real-time task lineage
        INTEGRATED_STREAM,
        //Integrated offline task lineage
        INTEGRATED_OFFLINE.
        """
elif False:
    LineageAttachmentRelationsProcessesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LineageAttachmentRelationsProcessesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[_builtins.str],
                 process_id: pulumi.Input[_builtins.str],
                 process_type: pulumi.Input[_builtins.str],
                 lineage_node_id: Optional[pulumi.Input[_builtins.str]] = None,
                 process_properties: Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsProcessesProcessPropertyArgs']]]] = None,
                 process_sub_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] platform: WEDATA, THIRD.
        :param pulumi.Input[_builtins.str] process_id: Original unique ID.
        :param pulumi.Input[_builtins.str] process_type: Task type.
               //Scheduled task
               SCHEDULE_TASK,
               //Integration task
               INTEGRATION_TASK,
               //Third-party reporting
               THIRD_REPORT,
               //Data modeling
               TABLE_MODEL,
               //Model creates metric
               MODEL_METRIC,
               //Atomic metric creates derived metric
               METRIC_METRIC,
               //Data service
               DATA_SERVICE.
        :param pulumi.Input[_builtins.str] lineage_node_id: Lineage task unique node ID.
        :param pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsProcessesProcessPropertyArgs']]] process_properties: Additional extension parameters.
        :param pulumi.Input[_builtins.str] process_sub_type: Task subtype.
               SQL_TASK,
               //Integrated real-time task lineage
               INTEGRATED_STREAM,
               //Integrated offline task lineage
               INTEGRATED_OFFLINE.
        """
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "process_id", process_id)
        pulumi.set(__self__, "process_type", process_type)
        if lineage_node_id is not None:
            pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        if process_properties is not None:
            pulumi.set(__self__, "process_properties", process_properties)
        if process_sub_type is not None:
            pulumi.set(__self__, "process_sub_type", process_sub_type)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> pulumi.Input[_builtins.str]:
        """
        WEDATA, THIRD.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter(name="processId")
    def process_id(self) -> pulumi.Input[_builtins.str]:
        """
        Original unique ID.
        """
        return pulumi.get(self, "process_id")

    @process_id.setter
    def process_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "process_id", value)

    @_builtins.property
    @pulumi.getter(name="processType")
    def process_type(self) -> pulumi.Input[_builtins.str]:
        """
        Task type.
        //Scheduled task
        SCHEDULE_TASK,
        //Integration task
        INTEGRATION_TASK,
        //Third-party reporting
        THIRD_REPORT,
        //Data modeling
        TABLE_MODEL,
        //Model creates metric
        MODEL_METRIC,
        //Atomic metric creates derived metric
        METRIC_METRIC,
        //Data service
        DATA_SERVICE.
        """
        return pulumi.get(self, "process_type")

    @process_type.setter
    def process_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "process_type", value)

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Lineage task unique node ID.
        """
        return pulumi.get(self, "lineage_node_id")

    @lineage_node_id.setter
    def lineage_node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lineage_node_id", value)

    @_builtins.property
    @pulumi.getter(name="processProperties")
    def process_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsProcessesProcessPropertyArgs']]]]:
        """
        Additional extension parameters.
        """
        return pulumi.get(self, "process_properties")

    @process_properties.setter
    def process_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsProcessesProcessPropertyArgs']]]]):
        pulumi.set(self, "process_properties", value)

    @_builtins.property
    @pulumi.getter(name="processSubType")
    def process_sub_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Task subtype.
        SQL_TASK,
        //Integrated real-time task lineage
        INTEGRATED_STREAM,
        //Integrated offline task lineage
        INTEGRATED_OFFLINE.
        """
        return pulumi.get(self, "process_sub_type")

    @process_sub_type.setter
    def process_sub_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "process_sub_type", value)


if not MYPY:
    class LineageAttachmentRelationsProcessesProcessPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property value.
        """
elif False:
    LineageAttachmentRelationsProcessesProcessPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LineageAttachmentRelationsProcessesProcessPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Property name.
        :param pulumi.Input[_builtins.str] value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LineageAttachmentRelationsSourceArgsDict(TypedDict):
        platform: pulumi.Input[_builtins.str]
        """
        Source: WEDATA|THIRD.
        Default is wedata.
        """
        resource_type: pulumi.Input[_builtins.str]
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        resource_unique_id: pulumi.Input[_builtins.str]
        """
        Entity original unique ID.\\n
        Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description: table type | metric description | model description | field description.
        """
        lineage_node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Lineage node unique identifier.
        """
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Business name: database.table | metric name | model name | field name.
        """
        resource_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsSourceResourcePropertyArgsDict']]]]
        """
        Resource additional extension parameters.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Update time.
        """
elif False:
    LineageAttachmentRelationsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LineageAttachmentRelationsSourceArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[_builtins.str],
                 resource_type: pulumi.Input[_builtins.str],
                 resource_unique_id: pulumi.Input[_builtins.str],
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 lineage_node_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_properties: Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsSourceResourcePropertyArgs']]]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] platform: Source: WEDATA|THIRD.
               Default is wedata.
        :param pulumi.Input[_builtins.str] resource_type: Entity type.
               TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param pulumi.Input[_builtins.str] resource_unique_id: Entity original unique ID.\\n
               Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        :param pulumi.Input[_builtins.str] create_time: Creation time.
        :param pulumi.Input[_builtins.str] description: Description: table type | metric description | model description | field description.
        :param pulumi.Input[_builtins.str] lineage_node_id: Lineage node unique identifier.
        :param pulumi.Input[_builtins.str] resource_name: Business name: database.table | metric name | model name | field name.
        :param pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsSourceResourcePropertyArgs']]] resource_properties: Resource additional extension parameters.
        :param pulumi.Input[_builtins.str] update_time: Update time.
        """
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if lineage_node_id is not None:
            pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> pulumi.Input[_builtins.str]:
        """
        Source: WEDATA|THIRD.
        Default is wedata.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> pulumi.Input[_builtins.str]:
        """
        Entity original unique ID.\\n
        Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        """
        return pulumi.get(self, "resource_unique_id")

    @resource_unique_id.setter
    def resource_unique_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_unique_id", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description: table type | metric description | model description | field description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @lineage_node_id.setter
    def lineage_node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lineage_node_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Business name: database.table | metric name | model name | field name.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsSourceResourcePropertyArgs']]]]:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @resource_properties.setter
    def resource_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsSourceResourcePropertyArgs']]]]):
        pulumi.set(self, "resource_properties", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class LineageAttachmentRelationsSourceResourcePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property value.
        """
elif False:
    LineageAttachmentRelationsSourceResourcePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LineageAttachmentRelationsSourceResourcePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Property name.
        :param pulumi.Input[_builtins.str] value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LineageAttachmentRelationsTargetArgsDict(TypedDict):
        platform: pulumi.Input[_builtins.str]
        """
        Source: WEDATA|THIRD.
        Default is wedata.
        """
        resource_type: pulumi.Input[_builtins.str]
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        resource_unique_id: pulumi.Input[_builtins.str]
        """
        Entity original unique ID.\\n
        Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation time.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description: table type | metric description | model description | field description.
        """
        lineage_node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Lineage node unique identifier.
        """
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Business name: database.table | metric name | model name | field name.
        """
        resource_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsTargetResourcePropertyArgsDict']]]]
        """
        Resource additional extension parameters.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Update time.
        """
elif False:
    LineageAttachmentRelationsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LineageAttachmentRelationsTargetArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[_builtins.str],
                 resource_type: pulumi.Input[_builtins.str],
                 resource_unique_id: pulumi.Input[_builtins.str],
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 lineage_node_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_properties: Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsTargetResourcePropertyArgs']]]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] platform: Source: WEDATA|THIRD.
               Default is wedata.
        :param pulumi.Input[_builtins.str] resource_type: Entity type.
               TABLE|METRIC|MODEL|SERVICE|COLUMN.
        :param pulumi.Input[_builtins.str] resource_unique_id: Entity original unique ID.\\n
               Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        :param pulumi.Input[_builtins.str] create_time: Creation time.
        :param pulumi.Input[_builtins.str] description: Description: table type | metric description | model description | field description.
        :param pulumi.Input[_builtins.str] lineage_node_id: Lineage node unique identifier.
        :param pulumi.Input[_builtins.str] resource_name: Business name: database.table | metric name | model name | field name.
        :param pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsTargetResourcePropertyArgs']]] resource_properties: Resource additional extension parameters.
        :param pulumi.Input[_builtins.str] update_time: Update time.
        """
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "resource_unique_id", resource_unique_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if lineage_node_id is not None:
            pulumi.set(__self__, "lineage_node_id", lineage_node_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> pulumi.Input[_builtins.str]:
        """
        Source: WEDATA|THIRD.
        Default is wedata.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        Entity type.
        TABLE|METRIC|MODEL|SERVICE|COLUMN.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="resourceUniqueId")
    def resource_unique_id(self) -> pulumi.Input[_builtins.str]:
        """
        Entity original unique ID.\\n
        Note: When lineage is for table columns, the unique ID should be passed as TableResourceUniqueId::FieldName.
        """
        return pulumi.get(self, "resource_unique_id")

    @resource_unique_id.setter
    def resource_unique_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_unique_id", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description: table type | metric description | model description | field description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="lineageNodeId")
    def lineage_node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Lineage node unique identifier.
        """
        return pulumi.get(self, "lineage_node_id")

    @lineage_node_id.setter
    def lineage_node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lineage_node_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Business name: database.table | metric name | model name | field name.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsTargetResourcePropertyArgs']]]]:
        """
        Resource additional extension parameters.
        """
        return pulumi.get(self, "resource_properties")

    @resource_properties.setter
    def resource_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LineageAttachmentRelationsTargetResourcePropertyArgs']]]]):
        pulumi.set(self, "resource_properties", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class LineageAttachmentRelationsTargetResourcePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property value.
        """
elif False:
    LineageAttachmentRelationsTargetResourcePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LineageAttachmentRelationsTargetResourcePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Property name.
        :param pulumi.Input[_builtins.str] value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OpsAlarmRuleAlarmGroupArgsDict(TypedDict):
        alarm_escalation_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm escalation interval.
        """
        alarm_escalation_recipient_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.
        """
        alarm_recipient_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.
        """
        alarm_recipient_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).
        """
        alarm_ways: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.
        """
        notification_fatigue: NotRequired[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueArgsDict']]
        """
        Alarm notification fatigue configuration.
        """
        web_hooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupWebHookArgsDict']]]]
        """
        List of webhook addresses for the alarm group.
        """
elif False:
    OpsAlarmRuleAlarmGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmGroupArgs:
    def __init__(__self__, *,
                 alarm_escalation_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_escalation_recipient_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 alarm_recipient_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 alarm_recipient_type: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_ways: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 notification_fatigue: Optional[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueArgs']] = None,
                 web_hooks: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupWebHookArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] alarm_escalation_interval: Alarm escalation interval.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alarm_escalation_recipient_ids: Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alarm_recipient_ids: Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.
        :param pulumi.Input[_builtins.int] alarm_recipient_type: Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alarm_ways: Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.
        :param pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueArgs'] notification_fatigue: Alarm notification fatigue configuration.
        :param pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupWebHookArgs']]] web_hooks: List of webhook addresses for the alarm group.
        """
        if alarm_escalation_interval is not None:
            pulumi.set(__self__, "alarm_escalation_interval", alarm_escalation_interval)
        if alarm_escalation_recipient_ids is not None:
            pulumi.set(__self__, "alarm_escalation_recipient_ids", alarm_escalation_recipient_ids)
        if alarm_recipient_ids is not None:
            pulumi.set(__self__, "alarm_recipient_ids", alarm_recipient_ids)
        if alarm_recipient_type is not None:
            pulumi.set(__self__, "alarm_recipient_type", alarm_recipient_type)
        if alarm_ways is not None:
            pulumi.set(__self__, "alarm_ways", alarm_ways)
        if notification_fatigue is not None:
            pulumi.set(__self__, "notification_fatigue", notification_fatigue)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @_builtins.property
    @pulumi.getter(name="alarmEscalationInterval")
    def alarm_escalation_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm escalation interval.
        """
        return pulumi.get(self, "alarm_escalation_interval")

    @alarm_escalation_interval.setter
    def alarm_escalation_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_escalation_interval", value)

    @_builtins.property
    @pulumi.getter(name="alarmEscalationRecipientIds")
    def alarm_escalation_recipient_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.
        """
        return pulumi.get(self, "alarm_escalation_recipient_ids")

    @alarm_escalation_recipient_ids.setter
    def alarm_escalation_recipient_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alarm_escalation_recipient_ids", value)

    @_builtins.property
    @pulumi.getter(name="alarmRecipientIds")
    def alarm_recipient_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.
        """
        return pulumi.get(self, "alarm_recipient_ids")

    @alarm_recipient_ids.setter
    def alarm_recipient_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alarm_recipient_ids", value)

    @_builtins.property
    @pulumi.getter(name="alarmRecipientType")
    def alarm_recipient_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).
        """
        return pulumi.get(self, "alarm_recipient_type")

    @alarm_recipient_type.setter
    def alarm_recipient_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_recipient_type", value)

    @_builtins.property
    @pulumi.getter(name="alarmWays")
    def alarm_ways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.
        """
        return pulumi.get(self, "alarm_ways")

    @alarm_ways.setter
    def alarm_ways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alarm_ways", value)

    @_builtins.property
    @pulumi.getter(name="notificationFatigue")
    def notification_fatigue(self) -> Optional[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueArgs']]:
        """
        Alarm notification fatigue configuration.
        """
        return pulumi.get(self, "notification_fatigue")

    @notification_fatigue.setter
    def notification_fatigue(self, value: Optional[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueArgs']]):
        pulumi.set(self, "notification_fatigue", value)

    @_builtins.property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupWebHookArgs']]]]:
        """
        List of webhook addresses for the alarm group.
        """
        return pulumi.get(self, "web_hooks")

    @web_hooks.setter
    def web_hooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupWebHookArgs']]]]):
        pulumi.set(self, "web_hooks", value)


if not MYPY:
    class OpsAlarmRuleAlarmGroupNotificationFatigueArgsDict(TypedDict):
        notify_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of alarms.
        """
        notify_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm interval, in minutes.
        """
        quiet_intervals: NotRequired[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgsDict']]]]
        """
        Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: "00:00:00", EndTime: "09:00:00"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.
        """
elif False:
    OpsAlarmRuleAlarmGroupNotificationFatigueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmGroupNotificationFatigueArgs:
    def __init__(__self__, *,
                 notify_count: Optional[pulumi.Input[_builtins.int]] = None,
                 notify_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 quiet_intervals: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] notify_count: Number of alarms.
        :param pulumi.Input[_builtins.int] notify_interval: Alarm interval, in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgs']]] quiet_intervals: Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: "00:00:00", EndTime: "09:00:00"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.
        """
        if notify_count is not None:
            pulumi.set(__self__, "notify_count", notify_count)
        if notify_interval is not None:
            pulumi.set(__self__, "notify_interval", notify_interval)
        if quiet_intervals is not None:
            pulumi.set(__self__, "quiet_intervals", quiet_intervals)

    @_builtins.property
    @pulumi.getter(name="notifyCount")
    def notify_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of alarms.
        """
        return pulumi.get(self, "notify_count")

    @notify_count.setter
    def notify_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "notify_count", value)

    @_builtins.property
    @pulumi.getter(name="notifyInterval")
    def notify_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm interval, in minutes.
        """
        return pulumi.get(self, "notify_interval")

    @notify_interval.setter
    def notify_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "notify_interval", value)

    @_builtins.property
    @pulumi.getter(name="quietIntervals")
    def quiet_intervals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgs']]]]:
        """
        Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: "00:00:00", EndTime: "09:00:00"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.
        """
        return pulumi.get(self, "quiet_intervals")

    @quiet_intervals.setter
    def quiet_intervals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgs']]]]):
        pulumi.set(self, "quiet_intervals", value)


if not MYPY:
    class OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgsDict(TypedDict):
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        According to the ISO standard, 1 represents Monday and 7 represents Sunday.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
elif False:
    OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmGroupNotificationFatigueQuietIntervalArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days_of_weeks: According to the ISO standard, 1 represents Monday and 7 represents Sunday.
        :param pulumi.Input[_builtins.str] end_time: End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        :param pulumi.Input[_builtins.str] start_time: Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        According to the ISO standard, 1 represents Monday and 7 represents Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "days_of_weeks", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class OpsAlarmRuleAlarmGroupWebHookArgsDict(TypedDict):
        alarm_way: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.
        """
        web_hooks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of webhook addresses for the alarm group.
        """
elif False:
    OpsAlarmRuleAlarmGroupWebHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmGroupWebHookArgs:
    def __init__(__self__, *,
                 alarm_way: Optional[pulumi.Input[_builtins.str]] = None,
                 web_hooks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] alarm_way: Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] web_hooks: List of webhook addresses for the alarm group.
        """
        if alarm_way is not None:
            pulumi.set(__self__, "alarm_way", alarm_way)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @_builtins.property
    @pulumi.getter(name="alarmWay")
    def alarm_way(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.
        """
        return pulumi.get(self, "alarm_way")

    @alarm_way.setter
    def alarm_way(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_way", value)

    @_builtins.property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of webhook addresses for the alarm group.
        """
        return pulumi.get(self, "web_hooks")

    @web_hooks.setter
    def web_hooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "web_hooks", value)


if not MYPY:
    class OpsAlarmRuleAlarmRuleDetailArgsDict(TypedDict):
        data_backfill_or_rerun_time_out_ext_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgsDict']]]]
        """
        Detailed configuration of re-running and re-recording instance timeout.
        """
        data_backfill_or_rerun_trigger: NotRequired[pulumi.Input[_builtins.int]]
        """
        Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.
        """
        project_instance_statistics_alarm_info_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgsDict']]]]
        """
        Project fluctuation alarm configuration details.
        """
        reconciliation_ext_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgsDict']]]]
        """
        Offline integrated reconciliation alarm configuration information.
        """
        time_out_ext_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgsDict']]]]
        """
        Periodic instance timeout configuration details.
        """
        trigger: NotRequired[pulumi.Input[_builtins.int]]
        """
        Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).
        """
elif False:
    OpsAlarmRuleAlarmRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmRuleDetailArgs:
    def __init__(__self__, *,
                 data_backfill_or_rerun_time_out_ext_infos: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs']]]] = None,
                 data_backfill_or_rerun_trigger: Optional[pulumi.Input[_builtins.int]] = None,
                 project_instance_statistics_alarm_info_lists: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs']]]] = None,
                 reconciliation_ext_infos: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgs']]]] = None,
                 time_out_ext_infos: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgs']]]] = None,
                 trigger: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs']]] data_backfill_or_rerun_time_out_ext_infos: Detailed configuration of re-running and re-recording instance timeout.
        :param pulumi.Input[_builtins.int] data_backfill_or_rerun_trigger: Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.
        :param pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs']]] project_instance_statistics_alarm_info_lists: Project fluctuation alarm configuration details.
        :param pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgs']]] reconciliation_ext_infos: Offline integrated reconciliation alarm configuration information.
        :param pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgs']]] time_out_ext_infos: Periodic instance timeout configuration details.
        :param pulumi.Input[_builtins.int] trigger: Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).
        """
        if data_backfill_or_rerun_time_out_ext_infos is not None:
            pulumi.set(__self__, "data_backfill_or_rerun_time_out_ext_infos", data_backfill_or_rerun_time_out_ext_infos)
        if data_backfill_or_rerun_trigger is not None:
            pulumi.set(__self__, "data_backfill_or_rerun_trigger", data_backfill_or_rerun_trigger)
        if project_instance_statistics_alarm_info_lists is not None:
            pulumi.set(__self__, "project_instance_statistics_alarm_info_lists", project_instance_statistics_alarm_info_lists)
        if reconciliation_ext_infos is not None:
            pulumi.set(__self__, "reconciliation_ext_infos", reconciliation_ext_infos)
        if time_out_ext_infos is not None:
            pulumi.set(__self__, "time_out_ext_infos", time_out_ext_infos)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter(name="dataBackfillOrRerunTimeOutExtInfos")
    def data_backfill_or_rerun_time_out_ext_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs']]]]:
        """
        Detailed configuration of re-running and re-recording instance timeout.
        """
        return pulumi.get(self, "data_backfill_or_rerun_time_out_ext_infos")

    @data_backfill_or_rerun_time_out_ext_infos.setter
    def data_backfill_or_rerun_time_out_ext_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs']]]]):
        pulumi.set(self, "data_backfill_or_rerun_time_out_ext_infos", value)

    @_builtins.property
    @pulumi.getter(name="dataBackfillOrRerunTrigger")
    def data_backfill_or_rerun_trigger(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.
        """
        return pulumi.get(self, "data_backfill_or_rerun_trigger")

    @data_backfill_or_rerun_trigger.setter
    def data_backfill_or_rerun_trigger(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_backfill_or_rerun_trigger", value)

    @_builtins.property
    @pulumi.getter(name="projectInstanceStatisticsAlarmInfoLists")
    def project_instance_statistics_alarm_info_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs']]]]:
        """
        Project fluctuation alarm configuration details.
        """
        return pulumi.get(self, "project_instance_statistics_alarm_info_lists")

    @project_instance_statistics_alarm_info_lists.setter
    def project_instance_statistics_alarm_info_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs']]]]):
        pulumi.set(self, "project_instance_statistics_alarm_info_lists", value)

    @_builtins.property
    @pulumi.getter(name="reconciliationExtInfos")
    def reconciliation_ext_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgs']]]]:
        """
        Offline integrated reconciliation alarm configuration information.
        """
        return pulumi.get(self, "reconciliation_ext_infos")

    @reconciliation_ext_infos.setter
    def reconciliation_ext_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgs']]]]):
        pulumi.set(self, "reconciliation_ext_infos", value)

    @_builtins.property
    @pulumi.getter(name="timeOutExtInfos")
    def time_out_ext_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgs']]]]:
        """
        Periodic instance timeout configuration details.
        """
        return pulumi.get(self, "time_out_ext_infos")

    @time_out_ext_infos.setter
    def time_out_ext_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgs']]]]):
        pulumi.set(self, "time_out_ext_infos", value)

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgsDict(TypedDict):
        hour: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specify the timeout value in hours. The default value is 0.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        rule_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        schedule_time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
elif False:
    OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmRuleDetailDataBackfillOrRerunTimeOutExtInfoArgs:
    def __init__(__self__, *,
                 hour: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_type: Optional[pulumi.Input[_builtins.int]] = None,
                 schedule_time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] hour: Specify the timeout value in hours. The default value is 0.
        :param pulumi.Input[_builtins.int] min: The timeout value is specified in minutes. The default value is 1.
        :param pulumi.Input[_builtins.int] rule_type: Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        :param pulumi.Input[_builtins.str] schedule_time_zone: The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        :param pulumi.Input[_builtins.int] type: Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specify the timeout value in hours. The default value is 0.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hour", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @schedule_time_zone.setter
    def schedule_time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_time_zone", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgsDict(TypedDict):
        alarm_type: pulumi.Input[_builtins.str]
        """
        Alarm type: projectFailureInstanceUpwardFluctuationAlarm: Failure instance upward fluctuation alarm; projectSuccessInstanceDownwardFluctuationAlarm: Success instance downward fluctuation alarm.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.
        """
        instance_threshold_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cumulative instance number fluctuation threshold.
        """
        instance_threshold_count_percent: NotRequired[pulumi.Input[_builtins.int]]
        """
        The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.
        """
        is_cumulant: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to calculate cumulatively, false: continuous, true: cumulative.
        """
        stabilize_statistics_cycle: NotRequired[pulumi.Input[_builtins.int]]
        """
        Stability statistics period (number of anti-shake configuration statistics periods).
        """
        stabilize_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Stability threshold (number of statistical cycles for anti-shake configuration).
        """
elif False:
    OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmRuleDetailProjectInstanceStatisticsAlarmInfoListArgs:
    def __init__(__self__, *,
                 alarm_type: pulumi.Input[_builtins.str],
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_threshold_count: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_threshold_count_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 is_cumulant: Optional[pulumi.Input[_builtins.bool]] = None,
                 stabilize_statistics_cycle: Optional[pulumi.Input[_builtins.int]] = None,
                 stabilize_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] alarm_type: Alarm type: projectFailureInstanceUpwardFluctuationAlarm: Failure instance upward fluctuation alarm; projectSuccessInstanceDownwardFluctuationAlarm: Success instance downward fluctuation alarm.
        :param pulumi.Input[_builtins.int] instance_count: The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.
        :param pulumi.Input[_builtins.int] instance_threshold_count: The cumulative instance number fluctuation threshold.
        :param pulumi.Input[_builtins.int] instance_threshold_count_percent: The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.
        :param pulumi.Input[_builtins.bool] is_cumulant: Whether to calculate cumulatively, false: continuous, true: cumulative.
        :param pulumi.Input[_builtins.int] stabilize_statistics_cycle: Stability statistics period (number of anti-shake configuration statistics periods).
        :param pulumi.Input[_builtins.int] stabilize_threshold: Stability threshold (number of statistical cycles for anti-shake configuration).
        """
        pulumi.set(__self__, "alarm_type", alarm_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_threshold_count is not None:
            pulumi.set(__self__, "instance_threshold_count", instance_threshold_count)
        if instance_threshold_count_percent is not None:
            pulumi.set(__self__, "instance_threshold_count_percent", instance_threshold_count_percent)
        if is_cumulant is not None:
            pulumi.set(__self__, "is_cumulant", is_cumulant)
        if stabilize_statistics_cycle is not None:
            pulumi.set(__self__, "stabilize_statistics_cycle", stabilize_statistics_cycle)
        if stabilize_threshold is not None:
            pulumi.set(__self__, "stabilize_threshold", stabilize_threshold)

    @_builtins.property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> pulumi.Input[_builtins.str]:
        """
        Alarm type: projectFailureInstanceUpwardFluctuationAlarm: Failure instance upward fluctuation alarm; projectSuccessInstanceDownwardFluctuationAlarm: Success instance downward fluctuation alarm.
        """
        return pulumi.get(self, "alarm_type")

    @alarm_type.setter
    def alarm_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="instanceThresholdCount")
    def instance_threshold_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cumulative instance number fluctuation threshold.
        """
        return pulumi.get(self, "instance_threshold_count")

    @instance_threshold_count.setter
    def instance_threshold_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_threshold_count", value)

    @_builtins.property
    @pulumi.getter(name="instanceThresholdCountPercent")
    def instance_threshold_count_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.
        """
        return pulumi.get(self, "instance_threshold_count_percent")

    @instance_threshold_count_percent.setter
    def instance_threshold_count_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_threshold_count_percent", value)

    @_builtins.property
    @pulumi.getter(name="isCumulant")
    def is_cumulant(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to calculate cumulatively, false: continuous, true: cumulative.
        """
        return pulumi.get(self, "is_cumulant")

    @is_cumulant.setter
    def is_cumulant(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_cumulant", value)

    @_builtins.property
    @pulumi.getter(name="stabilizeStatisticsCycle")
    def stabilize_statistics_cycle(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Stability statistics period (number of anti-shake configuration statistics periods).
        """
        return pulumi.get(self, "stabilize_statistics_cycle")

    @stabilize_statistics_cycle.setter
    def stabilize_statistics_cycle(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stabilize_statistics_cycle", value)

    @_builtins.property
    @pulumi.getter(name="stabilizeThreshold")
    def stabilize_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Stability threshold (number of statistical cycles for anti-shake configuration).
        """
        return pulumi.get(self, "stabilize_threshold")

    @stabilize_threshold.setter
    def stabilize_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stabilize_threshold", value)


if not MYPY:
    class OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgsDict(TypedDict):
        hour: NotRequired[pulumi.Input[_builtins.int]]
        """
        Reconciliation task timeout threshold: hours, default is 0.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        Reconciliation task timeout threshold: minutes, default is 1.
        """
        mismatch_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.
        """
        rule_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).
        """
elif False:
    OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmRuleDetailReconciliationExtInfoArgs:
    def __init__(__self__, *,
                 hour: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None,
                 mismatch_count: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] hour: Reconciliation task timeout threshold: hours, default is 0.
        :param pulumi.Input[_builtins.int] min: Reconciliation task timeout threshold: minutes, default is 1.
        :param pulumi.Input[_builtins.int] mismatch_count: Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.
        :param pulumi.Input[_builtins.str] rule_type: Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if mismatch_count is not None:
            pulumi.set(__self__, "mismatch_count", mismatch_count)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Reconciliation task timeout threshold: hours, default is 0.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hour", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Reconciliation task timeout threshold: minutes, default is 1.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter(name="mismatchCount")
    def mismatch_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.
        """
        return pulumi.get(self, "mismatch_count")

    @mismatch_count.setter
    def mismatch_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mismatch_count", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_type", value)


if not MYPY:
    class OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgsDict(TypedDict):
        hour: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specify the timeout value in hours. The default value is 0.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        rule_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        schedule_time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
elif False:
    OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpsAlarmRuleAlarmRuleDetailTimeOutExtInfoArgs:
    def __init__(__self__, *,
                 hour: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_type: Optional[pulumi.Input[_builtins.int]] = None,
                 schedule_time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] hour: Specify the timeout value in hours. The default value is 0.
        :param pulumi.Input[_builtins.int] min: The timeout value is specified in minutes. The default value is 1.
        :param pulumi.Input[_builtins.int] rule_type: Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        :param pulumi.Input[_builtins.str] schedule_time_zone: The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        :param pulumi.Input[_builtins.int] type: Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specify the timeout value in hours. The default value is 0.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hour", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout value is specified in minutes. The default value is 1.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @schedule_time_zone.setter
    def schedule_time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_time_zone", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout value configuration type: 1-Specified value; 2-Average value.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProjectDlcInfoArgsDict(TypedDict):
        compute_resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        DLC resource name (need to add role Uin to DLC, otherwise may not be able to obtain resources).
        """
        default_database: pulumi.Input[_builtins.str]
        """
        Specify the default database for DLC cluster.
        """
        region: pulumi.Input[_builtins.str]
        """
        DLC region.
        """
        access_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
        It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failure when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.

        Enum values:
        - TASK_RUNNER (Task Runner)
        - OWNER (Main Account Mode)
        - SUB (Sub Account Mode).
        """
        standard_mode_env_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
        - Prod  (Production environment)
        - Dev  (Development environment).
        """
        sub_account_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
elif False:
    ProjectDlcInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectDlcInfoArgs:
    def __init__(__self__, *,
                 compute_resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 default_database: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_account: Optional[pulumi.Input[_builtins.str]] = None,
                 standard_mode_env_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_account_uin: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] compute_resources: DLC resource name (need to add role Uin to DLC, otherwise may not be able to obtain resources).
        :param pulumi.Input[_builtins.str] default_database: Specify the default database for DLC cluster.
        :param pulumi.Input[_builtins.str] region: DLC region.
        :param pulumi.Input[_builtins.str] access_account: Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
               It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failure when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.
               
               Enum values:
               - TASK_RUNNER (Task Runner)
               - OWNER (Main Account Mode)
               - SUB (Sub Account Mode).
        :param pulumi.Input[_builtins.str] standard_mode_env_tag: Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
               - Prod  (Production environment)
               - Dev  (Development environment).
        :param pulumi.Input[_builtins.str] sub_account_uin: Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        pulumi.set(__self__, "compute_resources", compute_resources)
        pulumi.set(__self__, "default_database", default_database)
        pulumi.set(__self__, "region", region)
        if access_account is not None:
            pulumi.set(__self__, "access_account", access_account)
        if standard_mode_env_tag is not None:
            pulumi.set(__self__, "standard_mode_env_tag", standard_mode_env_tag)
        if sub_account_uin is not None:
            pulumi.set(__self__, "sub_account_uin", sub_account_uin)

    @_builtins.property
    @pulumi.getter(name="computeResources")
    def compute_resources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        DLC resource name (need to add role Uin to DLC, otherwise may not be able to obtain resources).
        """
        return pulumi.get(self, "compute_resources")

    @compute_resources.setter
    def compute_resources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "compute_resources", value)

    @_builtins.property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> pulumi.Input[_builtins.str]:
        """
        Specify the default database for DLC cluster.
        """
        return pulumi.get(self, "default_database")

    @default_database.setter
    def default_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_database", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        DLC region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessAccount")
    def access_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access account (only effective for standard mode projects and required for standard mode), used to submit DLC tasks.
        It is recommended to use a specified sub-account and set corresponding database table permissions for the sub-account; task runner mode may cause task failure when the responsible person leaves; main account mode is not easy for permission control when multiple projects have different permissions.

        Enum values:
        - TASK_RUNNER (Task Runner)
        - OWNER (Main Account Mode)
        - SUB (Sub Account Mode).
        """
        return pulumi.get(self, "access_account")

    @access_account.setter
    def access_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_account", value)

    @_builtins.property
    @pulumi.getter(name="standardModeEnvTag")
    def standard_mode_env_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster configuration tag (only effective for standard mode projects and required for standard mode). Enum values:
        - Prod  (Production environment)
        - Dev  (Development environment).
        """
        return pulumi.get(self, "standard_mode_env_tag")

    @standard_mode_env_tag.setter
    def standard_mode_env_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "standard_mode_env_tag", value)

    @_builtins.property
    @pulumi.getter(name="subAccountUin")
    def sub_account_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sub-account ID (only effective for standard mode projects), when AccessAccount is in sub-account mode, the sub-account ID information needs to be specified, other modes do not need to be specified.
        """
        return pulumi.get(self, "sub_account_uin")

    @sub_account_uin.setter
    def sub_account_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_account_uin", value)


if not MYPY:
    class ProjectProjectArgsDict(TypedDict):
        display_name: pulumi.Input[_builtins.str]
        """
        Project display name, can be Chinese name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        """
        project_name: pulumi.Input[_builtins.str]
        """
        Project identifier, English name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        """
        project_model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project mode, SIMPLE (default): Simple mode STANDARD: Standard mode.
        """
elif False:
    ProjectProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProjectArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[_builtins.str],
                 project_name: pulumi.Input[_builtins.str],
                 project_model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: Project display name, can be Chinese name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        :param pulumi.Input[_builtins.str] project_name: Project identifier, English name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        :param pulumi.Input[_builtins.str] project_model: Project mode, SIMPLE (default): Simple mode STANDARD: Standard mode.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "project_name", project_name)
        if project_model is not None:
            pulumi.set(__self__, "project_model", project_model)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        Project display name, can be Chinese name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> pulumi.Input[_builtins.str]:
        """
        Project identifier, English name starting with a letter, can contain letters, numbers, and underscores, cannot exceed 32 characters.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_name", value)

    @_builtins.property
    @pulumi.getter(name="projectModel")
    def project_model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project mode, SIMPLE (default): Simple mode STANDARD: Standard mode.
        """
        return pulumi.get(self, "project_model")

    @project_model.setter
    def project_model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_model", value)


if not MYPY:
    class SqlScriptScriptConfigArgsDict(TypedDict):
        advance_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        Advanced settings, execution configuration parameters, map-json String,String. Encoded in Base64.
        """
        compute_resource: NotRequired[pulumi.Input[_builtins.str]]
        """
        Computing resource.
        """
        datasource_env: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source environment.
        """
        datasource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source ID.
        """
        executor_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution resource group.
        """
        params: NotRequired[pulumi.Input[_builtins.str]]
        """
        Advanced runtime parameters, variable substitution, map-json String,String.
        """
elif False:
    SqlScriptScriptConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlScriptScriptConfigArgs:
    def __init__(__self__, *,
                 advance_config: Optional[pulumi.Input[_builtins.str]] = None,
                 compute_resource: Optional[pulumi.Input[_builtins.str]] = None,
                 datasource_env: Optional[pulumi.Input[_builtins.str]] = None,
                 datasource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 executor_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advance_config: Advanced settings, execution configuration parameters, map-json String,String. Encoded in Base64.
        :param pulumi.Input[_builtins.str] compute_resource: Computing resource.
        :param pulumi.Input[_builtins.str] datasource_env: Data source environment.
        :param pulumi.Input[_builtins.str] datasource_id: Data source ID.
        :param pulumi.Input[_builtins.str] executor_group_id: Execution resource group.
        :param pulumi.Input[_builtins.str] params: Advanced runtime parameters, variable substitution, map-json String,String.
        """
        if advance_config is not None:
            pulumi.set(__self__, "advance_config", advance_config)
        if compute_resource is not None:
            pulumi.set(__self__, "compute_resource", compute_resource)
        if datasource_env is not None:
            pulumi.set(__self__, "datasource_env", datasource_env)
        if datasource_id is not None:
            pulumi.set(__self__, "datasource_id", datasource_id)
        if executor_group_id is not None:
            pulumi.set(__self__, "executor_group_id", executor_group_id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter(name="advanceConfig")
    def advance_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Advanced settings, execution configuration parameters, map-json String,String. Encoded in Base64.
        """
        return pulumi.get(self, "advance_config")

    @advance_config.setter
    def advance_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advance_config", value)

    @_builtins.property
    @pulumi.getter(name="computeResource")
    def compute_resource(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Computing resource.
        """
        return pulumi.get(self, "compute_resource")

    @compute_resource.setter
    def compute_resource(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compute_resource", value)

    @_builtins.property
    @pulumi.getter(name="datasourceEnv")
    def datasource_env(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source environment.
        """
        return pulumi.get(self, "datasource_env")

    @datasource_env.setter
    def datasource_env(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datasource_env", value)

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source ID.
        """
        return pulumi.get(self, "datasource_id")

    @datasource_id.setter
    def datasource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datasource_id", value)

    @_builtins.property
    @pulumi.getter(name="executorGroupId")
    def executor_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution resource group.
        """
        return pulumi.get(self, "executor_group_id")

    @executor_group_id.setter
    def executor_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "executor_group_id", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Advanced runtime parameters, variable substitution, map-json String,String.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "params", value)


if not MYPY:
    class TaskRerunInstanceAsyncRedefineParamListArgsDict(TypedDict):
        k: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key.
        """
        v: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value.
        """
elif False:
    TaskRerunInstanceAsyncRedefineParamListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRerunInstanceAsyncRedefineParamListArgs:
    def __init__(__self__, *,
                 k: Optional[pulumi.Input[_builtins.str]] = None,
                 v: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] k: Key.
        :param pulumi.Input[_builtins.str] v: Value.
        """
        if k is not None:
            pulumi.set(__self__, "k", k)
        if v is not None:
            pulumi.set(__self__, "v", v)

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key.
        """
        return pulumi.get(self, "k")

    @k.setter
    def k(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "k", value)

    @_builtins.property
    @pulumi.getter
    def v(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value.
        """
        return pulumi.get(self, "v")

    @v.setter
    def v(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "v", value)


if not MYPY:
    class TaskTaskBaseAttributeArgsDict(TypedDict):
        task_name: pulumi.Input[_builtins.str]
        """
        Task name.
        """
        task_type_id: pulumi.Input[_builtins.str]
        """
        Task type ID:

        * 21:JDBC SQL
        * 23:TDSQL-PostgreSQL
        * 26:OfflineSynchronization
        * 30:Python
        * 31:PySpark
        * 32:DLC SQL
        * 33:Impala
        * 34:Hive SQL
        * 35:Shell
        * 36:Spark SQL
        * 38:Shell Form Mode
        * 39:Spark
        * 40:TCHouse-P
        * 41:Kettle
        * 42:Tchouse-X
        * 43:TCHouse-X SQL
        * 46:DLC Spark
        * 47:TiOne
        * 48:Trino
        * 50:DLC PySpark
        * 92:MapReduce
        * 130:Branch Node
        * 131:Merged Node
        * 132:Notebook
        * 133:SSH
        * 134:StarRocks
        * 137:For-each
        * 138:Setats SQL.
        """
        workflow_id: pulumi.Input[_builtins.str]
        """
        Workflow ID.
        """
        owner_uin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Task owner ID, defaults to current user.
        """
        task_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Task description.
        """
elif False:
    TaskTaskBaseAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskBaseAttributeArgs:
    def __init__(__self__, *,
                 task_name: pulumi.Input[_builtins.str],
                 task_type_id: pulumi.Input[_builtins.str],
                 workflow_id: pulumi.Input[_builtins.str],
                 owner_uin: Optional[pulumi.Input[_builtins.str]] = None,
                 task_description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] task_name: Task name.
        :param pulumi.Input[_builtins.str] task_type_id: Task type ID:
               
               * 21:JDBC SQL
               * 23:TDSQL-PostgreSQL
               * 26:OfflineSynchronization
               * 30:Python
               * 31:PySpark
               * 32:DLC SQL
               * 33:Impala
               * 34:Hive SQL
               * 35:Shell
               * 36:Spark SQL
               * 38:Shell Form Mode
               * 39:Spark
               * 40:TCHouse-P
               * 41:Kettle
               * 42:Tchouse-X
               * 43:TCHouse-X SQL
               * 46:DLC Spark
               * 47:TiOne
               * 48:Trino
               * 50:DLC PySpark
               * 92:MapReduce
               * 130:Branch Node
               * 131:Merged Node
               * 132:Notebook
               * 133:SSH
               * 134:StarRocks
               * 137:For-each
               * 138:Setats SQL.
        :param pulumi.Input[_builtins.str] workflow_id: Workflow ID.
        :param pulumi.Input[_builtins.str] owner_uin: Task owner ID, defaults to current user.
        :param pulumi.Input[_builtins.str] task_description: Task description.
        """
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type_id", task_type_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        if owner_uin is not None:
            pulumi.set(__self__, "owner_uin", owner_uin)
        if task_description is not None:
            pulumi.set(__self__, "task_description", task_description)

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> pulumi.Input[_builtins.str]:
        """
        Task name.
        """
        return pulumi.get(self, "task_name")

    @task_name.setter
    def task_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "task_name", value)

    @_builtins.property
    @pulumi.getter(name="taskTypeId")
    def task_type_id(self) -> pulumi.Input[_builtins.str]:
        """
        Task type ID:

        * 21:JDBC SQL
        * 23:TDSQL-PostgreSQL
        * 26:OfflineSynchronization
        * 30:Python
        * 31:PySpark
        * 32:DLC SQL
        * 33:Impala
        * 34:Hive SQL
        * 35:Shell
        * 36:Spark SQL
        * 38:Shell Form Mode
        * 39:Spark
        * 40:TCHouse-P
        * 41:Kettle
        * 42:Tchouse-X
        * 43:TCHouse-X SQL
        * 46:DLC Spark
        * 47:TiOne
        * 48:Trino
        * 50:DLC PySpark
        * 92:MapReduce
        * 130:Branch Node
        * 131:Merged Node
        * 132:Notebook
        * 133:SSH
        * 134:StarRocks
        * 137:For-each
        * 138:Setats SQL.
        """
        return pulumi.get(self, "task_type_id")

    @task_type_id.setter
    def task_type_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "task_type_id", value)

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> pulumi.Input[_builtins.str]:
        """
        Workflow ID.
        """
        return pulumi.get(self, "workflow_id")

    @workflow_id.setter
    def workflow_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workflow_id", value)

    @_builtins.property
    @pulumi.getter(name="ownerUin")
    def owner_uin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Task owner ID, defaults to current user.
        """
        return pulumi.get(self, "owner_uin")

    @owner_uin.setter
    def owner_uin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner_uin", value)

    @_builtins.property
    @pulumi.getter(name="taskDescription")
    def task_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Task description.
        """
        return pulumi.get(self, "task_description")

    @task_description.setter
    def task_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "task_description", value)


if not MYPY:
    class TaskTaskConfigurationArgsDict(TypedDict):
        broker_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specified running node.
        """
        bundle_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID used by Bundle.
        """
        bundle_info: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bundle information.
        """
        code_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base64 encoded code content.
        """
        data_cluster: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster ID.
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource group ID: Need to obtain ExecutorGroupId via DescribeNormalSchedulerExecutorGroups.
        """
        source_service_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        """
        target_service_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        """
        task_ext_configuration_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskExtConfigurationListArgsDict']]]]
        """
        Task extended attribute configuration list.
        """
        task_scheduling_parameter_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskSchedulingParameterListArgsDict']]]]
        """
        Scheduling parameters.
        """
        yarn_queue: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource pool queue name, need to obtain via DescribeProjectClusterQueues.
        """
elif False:
    TaskTaskConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskConfigurationArgs:
    def __init__(__self__, *,
                 broker_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 bundle_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bundle_info: Optional[pulumi.Input[_builtins.str]] = None,
                 code_content: Optional[pulumi.Input[_builtins.str]] = None,
                 data_cluster: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None,
                 source_service_id: Optional[pulumi.Input[_builtins.str]] = None,
                 target_service_id: Optional[pulumi.Input[_builtins.str]] = None,
                 task_ext_configuration_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskExtConfigurationListArgs']]]] = None,
                 task_scheduling_parameter_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskSchedulingParameterListArgs']]]] = None,
                 yarn_queue: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] broker_ip: Specified running node.
        :param pulumi.Input[_builtins.str] bundle_id: ID used by Bundle.
        :param pulumi.Input[_builtins.str] bundle_info: Bundle information.
        :param pulumi.Input[_builtins.str] code_content: Base64 encoded code content.
        :param pulumi.Input[_builtins.str] data_cluster: Cluster ID.
        :param pulumi.Input[_builtins.str] resource_group: Resource group ID: Need to obtain ExecutorGroupId via DescribeNormalSchedulerExecutorGroups.
        :param pulumi.Input[_builtins.str] source_service_id: Source data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        :param pulumi.Input[_builtins.str] target_service_id: Target data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskExtConfigurationListArgs']]] task_ext_configuration_lists: Task extended attribute configuration list.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskSchedulingParameterListArgs']]] task_scheduling_parameter_lists: Scheduling parameters.
        :param pulumi.Input[_builtins.str] yarn_queue: Resource pool queue name, need to obtain via DescribeProjectClusterQueues.
        """
        if broker_ip is not None:
            pulumi.set(__self__, "broker_ip", broker_ip)
        if bundle_id is not None:
            pulumi.set(__self__, "bundle_id", bundle_id)
        if bundle_info is not None:
            pulumi.set(__self__, "bundle_info", bundle_info)
        if code_content is not None:
            pulumi.set(__self__, "code_content", code_content)
        if data_cluster is not None:
            pulumi.set(__self__, "data_cluster", data_cluster)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if source_service_id is not None:
            pulumi.set(__self__, "source_service_id", source_service_id)
        if target_service_id is not None:
            pulumi.set(__self__, "target_service_id", target_service_id)
        if task_ext_configuration_lists is not None:
            pulumi.set(__self__, "task_ext_configuration_lists", task_ext_configuration_lists)
        if task_scheduling_parameter_lists is not None:
            pulumi.set(__self__, "task_scheduling_parameter_lists", task_scheduling_parameter_lists)
        if yarn_queue is not None:
            pulumi.set(__self__, "yarn_queue", yarn_queue)

    @_builtins.property
    @pulumi.getter(name="brokerIp")
    def broker_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specified running node.
        """
        return pulumi.get(self, "broker_ip")

    @broker_ip.setter
    def broker_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "broker_ip", value)

    @_builtins.property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID used by Bundle.
        """
        return pulumi.get(self, "bundle_id")

    @bundle_id.setter
    def bundle_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bundle_id", value)

    @_builtins.property
    @pulumi.getter(name="bundleInfo")
    def bundle_info(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bundle information.
        """
        return pulumi.get(self, "bundle_info")

    @bundle_info.setter
    def bundle_info(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bundle_info", value)

    @_builtins.property
    @pulumi.getter(name="codeContent")
    def code_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base64 encoded code content.
        """
        return pulumi.get(self, "code_content")

    @code_content.setter
    def code_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code_content", value)

    @_builtins.property
    @pulumi.getter(name="dataCluster")
    def data_cluster(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "data_cluster")

    @data_cluster.setter
    def data_cluster(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_cluster", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource group ID: Need to obtain ExecutorGroupId via DescribeNormalSchedulerExecutorGroups.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter(name="sourceServiceId")
    def source_service_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        """
        return pulumi.get(self, "source_service_id")

    @source_service_id.setter
    def source_service_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_service_id", value)

    @_builtins.property
    @pulumi.getter(name="targetServiceId")
    def target_service_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target data source ID, separated by `;`, need to obtain via DescribeDataSourceWithoutInfo.
        """
        return pulumi.get(self, "target_service_id")

    @target_service_id.setter
    def target_service_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_service_id", value)

    @_builtins.property
    @pulumi.getter(name="taskExtConfigurationLists")
    def task_ext_configuration_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskExtConfigurationListArgs']]]]:
        """
        Task extended attribute configuration list.
        """
        return pulumi.get(self, "task_ext_configuration_lists")

    @task_ext_configuration_lists.setter
    def task_ext_configuration_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskExtConfigurationListArgs']]]]):
        pulumi.set(self, "task_ext_configuration_lists", value)

    @_builtins.property
    @pulumi.getter(name="taskSchedulingParameterLists")
    def task_scheduling_parameter_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskSchedulingParameterListArgs']]]]:
        """
        Scheduling parameters.
        """
        return pulumi.get(self, "task_scheduling_parameter_lists")

    @task_scheduling_parameter_lists.setter
    def task_scheduling_parameter_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskConfigurationTaskSchedulingParameterListArgs']]]]):
        pulumi.set(self, "task_scheduling_parameter_lists", value)

    @_builtins.property
    @pulumi.getter(name="yarnQueue")
    def yarn_queue(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource pool queue name, need to obtain via DescribeProjectClusterQueues.
        """
        return pulumi.get(self, "yarn_queue")

    @yarn_queue.setter
    def yarn_queue(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "yarn_queue", value)


if not MYPY:
    class TaskTaskConfigurationTaskExtConfigurationListArgsDict(TypedDict):
        param_key: pulumi.Input[_builtins.str]
        """
        Parameter name.
        """
        param_value: pulumi.Input[_builtins.str]
        """
        Parameter value.
        """
elif False:
    TaskTaskConfigurationTaskExtConfigurationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskConfigurationTaskExtConfigurationListArgs:
    def __init__(__self__, *,
                 param_key: pulumi.Input[_builtins.str],
                 param_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] param_key: Parameter name.
        :param pulumi.Input[_builtins.str] param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @param_key.setter
    def param_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_key", value)

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_value", value)


if not MYPY:
    class TaskTaskConfigurationTaskSchedulingParameterListArgsDict(TypedDict):
        param_key: pulumi.Input[_builtins.str]
        """
        Parameter name.
        """
        param_value: pulumi.Input[_builtins.str]
        """
        Parameter value.
        """
elif False:
    TaskTaskConfigurationTaskSchedulingParameterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskConfigurationTaskSchedulingParameterListArgs:
    def __init__(__self__, *,
                 param_key: pulumi.Input[_builtins.str],
                 param_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] param_key: Parameter name.
        :param pulumi.Input[_builtins.str] param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @param_key.setter
    def param_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_key", value)

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_value", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationArgsDict(TypedDict):
        allow_redo_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rerun & backfill configuration, defaults to ALL; ALL: can rerun or backfill after success or failure; FAILURE: cannot rerun or backfill after success, can rerun or backfill after failure; NONE: cannot rerun or backfill after success or failure.
        """
        calendar_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Calendar scheduling calendar ID.
        """
        calendar_open: NotRequired[pulumi.Input[_builtins.str]]
        """
        Calendar scheduling: Values are 0 and 1, 1 for enabled, 0 for disabled, defaults to 0.
        """
        crontab_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cron expression, defaults to 0 0 0 * * `?` *.
        """
        cycle_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cycle type: Defaults to DAY_CYCLE.

        Supported types are

        * ONEOFF_CYCLE: One-time
        * YEAR_CYCLE: Yearly
        * MONTH_CYCLE: Monthly
        * WEEK_CYCLE: Weekly
        * DAY_CYCLE: Daily
        * HOUR_CYCLE: Hourly
        * MINUTE_CYCLE: Minutely
        * CRONTAB_CYCLE: Crontab expression type.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End date, defaults to 2099-12-31 23:59:59.
        """
        event_listener_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListArgsDict']]]]
        """
        Event array.
        """
        execution_end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution time right-closed interval, default 23:59.
        """
        execution_start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution time left-closed interval, default 00:00.
        """
        execution_ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout handling strategy - running time timeout (unit: minutes) defaults to -1.
        """
        init_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        **Instance generation strategy**
        * T_PLUS_0: T+0 generation, default strategy
        * T_PLUS_1: T+1 generation.
        """
        max_retry_attempts: NotRequired[pulumi.Input[_builtins.str]]
        """
        Retry strategy - maximum number of attempts, default: 4.
        """
        param_task_in_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskInListArgsDict']]]]
        """
        Input parameter array.
        """
        param_task_out_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskOutListArgsDict']]]]
        """
        Output parameter array.
        """
        retry_wait: NotRequired[pulumi.Input[_builtins.str]]
        """
        Retry strategy - retry waiting time, unit: minutes: default: 5.
        """
        run_priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        Task scheduling priority: 4 for high, 5 for medium, 6 for low, default: 6.
        """
        schedule_run_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduling type: 0 Normal scheduling 1 Empty run scheduling, defaults to 0.
        """
        schedule_time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time zone, defaults to UTC+8.
        """
        self_depend: NotRequired[pulumi.Input[_builtins.str]]
        """
        Self-dependency, default value serial, values: parallel, serial, orderly.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effective date, defaults to 00:00:00 of current date.
        """
        task_output_registry_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationTaskOutputRegistryListArgsDict']]]]
        """
        Output registration.
        """
        upstream_dependency_config_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgsDict']]]]
        """
        Upstream dependency array.
        """
        wait_execution_total_ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout handling strategy - total waiting time timeout (unit: minutes) defaults to -1.
        """
elif False:
    TaskTaskSchedulerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationArgs:
    def __init__(__self__, *,
                 allow_redo_type: Optional[pulumi.Input[_builtins.str]] = None,
                 calendar_id: Optional[pulumi.Input[_builtins.str]] = None,
                 calendar_open: Optional[pulumi.Input[_builtins.str]] = None,
                 crontab_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 cycle_type: Optional[pulumi.Input[_builtins.str]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 event_listener_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListArgs']]]] = None,
                 execution_end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 init_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 max_retry_attempts: Optional[pulumi.Input[_builtins.str]] = None,
                 param_task_in_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskInListArgs']]]] = None,
                 param_task_out_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskOutListArgs']]]] = None,
                 retry_wait: Optional[pulumi.Input[_builtins.str]] = None,
                 run_priority: Optional[pulumi.Input[_builtins.str]] = None,
                 schedule_run_type: Optional[pulumi.Input[_builtins.str]] = None,
                 schedule_time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 self_depend: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 task_output_registry_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationTaskOutputRegistryListArgs']]]] = None,
                 upstream_dependency_config_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs']]]] = None,
                 wait_execution_total_ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] allow_redo_type: Rerun & backfill configuration, defaults to ALL; ALL: can rerun or backfill after success or failure; FAILURE: cannot rerun or backfill after success, can rerun or backfill after failure; NONE: cannot rerun or backfill after success or failure.
        :param pulumi.Input[_builtins.str] calendar_id: Calendar scheduling calendar ID.
        :param pulumi.Input[_builtins.str] calendar_open: Calendar scheduling: Values are 0 and 1, 1 for enabled, 0 for disabled, defaults to 0.
        :param pulumi.Input[_builtins.str] crontab_expression: Cron expression, defaults to 0 0 0 * * `?` *.
        :param pulumi.Input[_builtins.str] cycle_type: Cycle type: Defaults to DAY_CYCLE.
               
               Supported types are
               
               * ONEOFF_CYCLE: One-time
               * YEAR_CYCLE: Yearly
               * MONTH_CYCLE: Monthly
               * WEEK_CYCLE: Weekly
               * DAY_CYCLE: Daily
               * HOUR_CYCLE: Hourly
               * MINUTE_CYCLE: Minutely
               * CRONTAB_CYCLE: Crontab expression type.
        :param pulumi.Input[_builtins.str] end_time: End date, defaults to 2099-12-31 23:59:59.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListArgs']]] event_listener_lists: Event array.
        :param pulumi.Input[_builtins.str] execution_end_time: Execution time right-closed interval, default 23:59.
        :param pulumi.Input[_builtins.str] execution_start_time: Execution time left-closed interval, default 00:00.
        :param pulumi.Input[_builtins.str] execution_ttl: Timeout handling strategy - running time timeout (unit: minutes) defaults to -1.
        :param pulumi.Input[_builtins.str] init_strategy: **Instance generation strategy**
               * T_PLUS_0: T+0 generation, default strategy
               * T_PLUS_1: T+1 generation.
        :param pulumi.Input[_builtins.str] max_retry_attempts: Retry strategy - maximum number of attempts, default: 4.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskInListArgs']]] param_task_in_lists: Input parameter array.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskOutListArgs']]] param_task_out_lists: Output parameter array.
        :param pulumi.Input[_builtins.str] retry_wait: Retry strategy - retry waiting time, unit: minutes: default: 5.
        :param pulumi.Input[_builtins.str] run_priority: Task scheduling priority: 4 for high, 5 for medium, 6 for low, default: 6.
        :param pulumi.Input[_builtins.str] schedule_run_type: Scheduling type: 0 Normal scheduling 1 Empty run scheduling, defaults to 0.
        :param pulumi.Input[_builtins.str] schedule_time_zone: Time zone, defaults to UTC+8.
        :param pulumi.Input[_builtins.str] self_depend: Self-dependency, default value serial, values: parallel, serial, orderly.
        :param pulumi.Input[_builtins.str] start_time: Effective date, defaults to 00:00:00 of current date.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationTaskOutputRegistryListArgs']]] task_output_registry_lists: Output registration.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs']]] upstream_dependency_config_lists: Upstream dependency array.
        :param pulumi.Input[_builtins.str] wait_execution_total_ttl: Timeout handling strategy - total waiting time timeout (unit: minutes) defaults to -1.
        """
        if allow_redo_type is not None:
            pulumi.set(__self__, "allow_redo_type", allow_redo_type)
        if calendar_id is not None:
            pulumi.set(__self__, "calendar_id", calendar_id)
        if calendar_open is not None:
            pulumi.set(__self__, "calendar_open", calendar_open)
        if crontab_expression is not None:
            pulumi.set(__self__, "crontab_expression", crontab_expression)
        if cycle_type is not None:
            pulumi.set(__self__, "cycle_type", cycle_type)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if event_listener_lists is not None:
            pulumi.set(__self__, "event_listener_lists", event_listener_lists)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if execution_ttl is not None:
            pulumi.set(__self__, "execution_ttl", execution_ttl)
        if init_strategy is not None:
            pulumi.set(__self__, "init_strategy", init_strategy)
        if max_retry_attempts is not None:
            pulumi.set(__self__, "max_retry_attempts", max_retry_attempts)
        if param_task_in_lists is not None:
            pulumi.set(__self__, "param_task_in_lists", param_task_in_lists)
        if param_task_out_lists is not None:
            pulumi.set(__self__, "param_task_out_lists", param_task_out_lists)
        if retry_wait is not None:
            pulumi.set(__self__, "retry_wait", retry_wait)
        if run_priority is not None:
            pulumi.set(__self__, "run_priority", run_priority)
        if schedule_run_type is not None:
            pulumi.set(__self__, "schedule_run_type", schedule_run_type)
        if schedule_time_zone is not None:
            pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        if self_depend is not None:
            pulumi.set(__self__, "self_depend", self_depend)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if task_output_registry_lists is not None:
            pulumi.set(__self__, "task_output_registry_lists", task_output_registry_lists)
        if upstream_dependency_config_lists is not None:
            pulumi.set(__self__, "upstream_dependency_config_lists", upstream_dependency_config_lists)
        if wait_execution_total_ttl is not None:
            pulumi.set(__self__, "wait_execution_total_ttl", wait_execution_total_ttl)

    @_builtins.property
    @pulumi.getter(name="allowRedoType")
    def allow_redo_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rerun & backfill configuration, defaults to ALL; ALL: can rerun or backfill after success or failure; FAILURE: cannot rerun or backfill after success, can rerun or backfill after failure; NONE: cannot rerun or backfill after success or failure.
        """
        return pulumi.get(self, "allow_redo_type")

    @allow_redo_type.setter
    def allow_redo_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allow_redo_type", value)

    @_builtins.property
    @pulumi.getter(name="calendarId")
    def calendar_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Calendar scheduling calendar ID.
        """
        return pulumi.get(self, "calendar_id")

    @calendar_id.setter
    def calendar_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "calendar_id", value)

    @_builtins.property
    @pulumi.getter(name="calendarOpen")
    def calendar_open(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Calendar scheduling: Values are 0 and 1, 1 for enabled, 0 for disabled, defaults to 0.
        """
        return pulumi.get(self, "calendar_open")

    @calendar_open.setter
    def calendar_open(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "calendar_open", value)

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cron expression, defaults to 0 0 0 * * `?` *.
        """
        return pulumi.get(self, "crontab_expression")

    @crontab_expression.setter
    def crontab_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crontab_expression", value)

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cycle type: Defaults to DAY_CYCLE.

        Supported types are

        * ONEOFF_CYCLE: One-time
        * YEAR_CYCLE: Yearly
        * MONTH_CYCLE: Monthly
        * WEEK_CYCLE: Weekly
        * DAY_CYCLE: Daily
        * HOUR_CYCLE: Hourly
        * MINUTE_CYCLE: Minutely
        * CRONTAB_CYCLE: Crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @cycle_type.setter
    def cycle_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cycle_type", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End date, defaults to 2099-12-31 23:59:59.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="eventListenerLists")
    def event_listener_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListArgs']]]]:
        """
        Event array.
        """
        return pulumi.get(self, "event_listener_lists")

    @event_listener_lists.setter
    def event_listener_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListArgs']]]]):
        pulumi.set(self, "event_listener_lists", value)

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution time right-closed interval, default 23:59.
        """
        return pulumi.get(self, "execution_end_time")

    @execution_end_time.setter
    def execution_end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_end_time", value)

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution time left-closed interval, default 00:00.
        """
        return pulumi.get(self, "execution_start_time")

    @execution_start_time.setter
    def execution_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_start_time", value)

    @_builtins.property
    @pulumi.getter(name="executionTtl")
    def execution_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout handling strategy - running time timeout (unit: minutes) defaults to -1.
        """
        return pulumi.get(self, "execution_ttl")

    @execution_ttl.setter
    def execution_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_ttl", value)

    @_builtins.property
    @pulumi.getter(name="initStrategy")
    def init_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **Instance generation strategy**
        * T_PLUS_0: T+0 generation, default strategy
        * T_PLUS_1: T+1 generation.
        """
        return pulumi.get(self, "init_strategy")

    @init_strategy.setter
    def init_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "init_strategy", value)

    @_builtins.property
    @pulumi.getter(name="maxRetryAttempts")
    def max_retry_attempts(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Retry strategy - maximum number of attempts, default: 4.
        """
        return pulumi.get(self, "max_retry_attempts")

    @max_retry_attempts.setter
    def max_retry_attempts(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_retry_attempts", value)

    @_builtins.property
    @pulumi.getter(name="paramTaskInLists")
    def param_task_in_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskInListArgs']]]]:
        """
        Input parameter array.
        """
        return pulumi.get(self, "param_task_in_lists")

    @param_task_in_lists.setter
    def param_task_in_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskInListArgs']]]]):
        pulumi.set(self, "param_task_in_lists", value)

    @_builtins.property
    @pulumi.getter(name="paramTaskOutLists")
    def param_task_out_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskOutListArgs']]]]:
        """
        Output parameter array.
        """
        return pulumi.get(self, "param_task_out_lists")

    @param_task_out_lists.setter
    def param_task_out_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationParamTaskOutListArgs']]]]):
        pulumi.set(self, "param_task_out_lists", value)

    @_builtins.property
    @pulumi.getter(name="retryWait")
    def retry_wait(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Retry strategy - retry waiting time, unit: minutes: default: 5.
        """
        return pulumi.get(self, "retry_wait")

    @retry_wait.setter
    def retry_wait(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retry_wait", value)

    @_builtins.property
    @pulumi.getter(name="runPriority")
    def run_priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Task scheduling priority: 4 for high, 5 for medium, 6 for low, default: 6.
        """
        return pulumi.get(self, "run_priority")

    @run_priority.setter
    def run_priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "run_priority", value)

    @_builtins.property
    @pulumi.getter(name="scheduleRunType")
    def schedule_run_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduling type: 0 Normal scheduling 1 Empty run scheduling, defaults to 0.
        """
        return pulumi.get(self, "schedule_run_type")

    @schedule_run_type.setter
    def schedule_run_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_run_type", value)

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time zone, defaults to UTC+8.
        """
        return pulumi.get(self, "schedule_time_zone")

    @schedule_time_zone.setter
    def schedule_time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_time_zone", value)

    @_builtins.property
    @pulumi.getter(name="selfDepend")
    def self_depend(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Self-dependency, default value serial, values: parallel, serial, orderly.
        """
        return pulumi.get(self, "self_depend")

    @self_depend.setter
    def self_depend(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "self_depend", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effective date, defaults to 00:00:00 of current date.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="taskOutputRegistryLists")
    def task_output_registry_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationTaskOutputRegistryListArgs']]]]:
        """
        Output registration.
        """
        return pulumi.get(self, "task_output_registry_lists")

    @task_output_registry_lists.setter
    def task_output_registry_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationTaskOutputRegistryListArgs']]]]):
        pulumi.set(self, "task_output_registry_lists", value)

    @_builtins.property
    @pulumi.getter(name="upstreamDependencyConfigLists")
    def upstream_dependency_config_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs']]]]:
        """
        Upstream dependency array.
        """
        return pulumi.get(self, "upstream_dependency_config_lists")

    @upstream_dependency_config_lists.setter
    def upstream_dependency_config_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs']]]]):
        pulumi.set(self, "upstream_dependency_config_lists", value)

    @_builtins.property
    @pulumi.getter(name="waitExecutionTotalTtl")
    def wait_execution_total_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout handling strategy - total waiting time timeout (unit: minutes) defaults to -1.
        """
        return pulumi.get(self, "wait_execution_total_ttl")

    @wait_execution_total_ttl.setter
    def wait_execution_total_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wait_execution_total_ttl", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationEventListenerListArgsDict(TypedDict):
        event_broadcast_type: pulumi.Input[_builtins.str]
        """
        Event broadcast type: SINGLE, BROADCAST.
        """
        event_name: pulumi.Input[_builtins.str]
        """
        Event name.
        """
        event_sub_type: pulumi.Input[_builtins.str]
        """
        Event cycle: SECOND, MIN, HOUR, DAY.
        """
        properties_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgsDict']]]]
        """
        Extended information.
        """
elif False:
    TaskTaskSchedulerConfigurationEventListenerListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationEventListenerListArgs:
    def __init__(__self__, *,
                 event_broadcast_type: pulumi.Input[_builtins.str],
                 event_name: pulumi.Input[_builtins.str],
                 event_sub_type: pulumi.Input[_builtins.str],
                 properties_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] event_broadcast_type: Event broadcast type: SINGLE, BROADCAST.
        :param pulumi.Input[_builtins.str] event_name: Event name.
        :param pulumi.Input[_builtins.str] event_sub_type: Event cycle: SECOND, MIN, HOUR, DAY.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs']]] properties_lists: Extended information.
        """
        pulumi.set(__self__, "event_broadcast_type", event_broadcast_type)
        pulumi.set(__self__, "event_name", event_name)
        pulumi.set(__self__, "event_sub_type", event_sub_type)
        if properties_lists is not None:
            pulumi.set(__self__, "properties_lists", properties_lists)

    @_builtins.property
    @pulumi.getter(name="eventBroadcastType")
    def event_broadcast_type(self) -> pulumi.Input[_builtins.str]:
        """
        Event broadcast type: SINGLE, BROADCAST.
        """
        return pulumi.get(self, "event_broadcast_type")

    @event_broadcast_type.setter
    def event_broadcast_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_broadcast_type", value)

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> pulumi.Input[_builtins.str]:
        """
        Event name.
        """
        return pulumi.get(self, "event_name")

    @event_name.setter
    def event_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_name", value)

    @_builtins.property
    @pulumi.getter(name="eventSubType")
    def event_sub_type(self) -> pulumi.Input[_builtins.str]:
        """
        Event cycle: SECOND, MIN, HOUR, DAY.
        """
        return pulumi.get(self, "event_sub_type")

    @event_sub_type.setter
    def event_sub_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_sub_type", value)

    @_builtins.property
    @pulumi.getter(name="propertiesLists")
    def properties_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs']]]]:
        """
        Extended information.
        """
        return pulumi.get(self, "properties_lists")

    @properties_lists.setter
    def properties_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs']]]]):
        pulumi.set(self, "properties_lists", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgsDict(TypedDict):
        param_key: pulumi.Input[_builtins.str]
        """
        Parameter name.
        """
        param_value: pulumi.Input[_builtins.str]
        """
        Parameter value.
        """
elif False:
    TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationEventListenerListPropertiesListArgs:
    def __init__(__self__, *,
                 param_key: pulumi.Input[_builtins.str],
                 param_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] param_key: Parameter name.
        :param pulumi.Input[_builtins.str] param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @param_key.setter
    def param_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_key", value)

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_value", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationParamTaskInListArgsDict(TypedDict):
        from_param_key: pulumi.Input[_builtins.str]
        """
        Parent task parameter key.
        """
        from_task_id: pulumi.Input[_builtins.str]
        """
        Parent task ID.
        """
        param_desc: pulumi.Input[_builtins.str]
        """
        Parameter description: format is project_identifier.task_name.parameter_name; example: project_wedata_1.sh_250820_104107.pp_out.
        """
        param_key: pulumi.Input[_builtins.str]
        """
        Parameter name.
        """
elif False:
    TaskTaskSchedulerConfigurationParamTaskInListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationParamTaskInListArgs:
    def __init__(__self__, *,
                 from_param_key: pulumi.Input[_builtins.str],
                 from_task_id: pulumi.Input[_builtins.str],
                 param_desc: pulumi.Input[_builtins.str],
                 param_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] from_param_key: Parent task parameter key.
        :param pulumi.Input[_builtins.str] from_task_id: Parent task ID.
        :param pulumi.Input[_builtins.str] param_desc: Parameter description: format is project_identifier.task_name.parameter_name; example: project_wedata_1.sh_250820_104107.pp_out.
        :param pulumi.Input[_builtins.str] param_key: Parameter name.
        """
        pulumi.set(__self__, "from_param_key", from_param_key)
        pulumi.set(__self__, "from_task_id", from_task_id)
        pulumi.set(__self__, "param_desc", param_desc)
        pulumi.set(__self__, "param_key", param_key)

    @_builtins.property
    @pulumi.getter(name="fromParamKey")
    def from_param_key(self) -> pulumi.Input[_builtins.str]:
        """
        Parent task parameter key.
        """
        return pulumi.get(self, "from_param_key")

    @from_param_key.setter
    def from_param_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_param_key", value)

    @_builtins.property
    @pulumi.getter(name="fromTaskId")
    def from_task_id(self) -> pulumi.Input[_builtins.str]:
        """
        Parent task ID.
        """
        return pulumi.get(self, "from_task_id")

    @from_task_id.setter
    def from_task_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_task_id", value)

    @_builtins.property
    @pulumi.getter(name="paramDesc")
    def param_desc(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter description: format is project_identifier.task_name.parameter_name; example: project_wedata_1.sh_250820_104107.pp_out.
        """
        return pulumi.get(self, "param_desc")

    @param_desc.setter
    def param_desc(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_desc", value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @param_key.setter
    def param_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_key", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationParamTaskOutListArgsDict(TypedDict):
        param_key: pulumi.Input[_builtins.str]
        """
        Parameter name.
        """
        param_value: pulumi.Input[_builtins.str]
        """
        Parameter definition.
        """
elif False:
    TaskTaskSchedulerConfigurationParamTaskOutListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationParamTaskOutListArgs:
    def __init__(__self__, *,
                 param_key: pulumi.Input[_builtins.str],
                 param_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] param_key: Parameter name.
        :param pulumi.Input[_builtins.str] param_value: Parameter definition.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @param_key.setter
    def param_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_key", value)

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter definition.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_value", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationTaskOutputRegistryListArgsDict(TypedDict):
        data_flow_type: pulumi.Input[_builtins.str]
        """
        Input/output table type
        Input stream
        UPSTREAM,
        Output stream
        DOWNSTREAM.
        """
        database_name: pulumi.Input[_builtins.str]
        """
        Database name.
        """
        datasource_id: pulumi.Input[_builtins.str]
        """
        Data source ID.
        """
        partition_name: pulumi.Input[_builtins.str]
        """
        Partition name.
        """
        table_name: pulumi.Input[_builtins.str]
        """
        Table name.
        """
        table_physical_id: pulumi.Input[_builtins.str]
        """
        Table physical unique ID.
        """
        db_guid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Database unique identifier.
        """
        table_guid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Table unique identifier.
        """
elif False:
    TaskTaskSchedulerConfigurationTaskOutputRegistryListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationTaskOutputRegistryListArgs:
    def __init__(__self__, *,
                 data_flow_type: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 datasource_id: pulumi.Input[_builtins.str],
                 partition_name: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 table_physical_id: pulumi.Input[_builtins.str],
                 db_guid: Optional[pulumi.Input[_builtins.str]] = None,
                 table_guid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_flow_type: Input/output table type
               Input stream
               UPSTREAM,
               Output stream
               DOWNSTREAM.
        :param pulumi.Input[_builtins.str] database_name: Database name.
        :param pulumi.Input[_builtins.str] datasource_id: Data source ID.
        :param pulumi.Input[_builtins.str] partition_name: Partition name.
        :param pulumi.Input[_builtins.str] table_name: Table name.
        :param pulumi.Input[_builtins.str] table_physical_id: Table physical unique ID.
        :param pulumi.Input[_builtins.str] db_guid: Database unique identifier.
        :param pulumi.Input[_builtins.str] table_guid: Table unique identifier.
        """
        pulumi.set(__self__, "data_flow_type", data_flow_type)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "datasource_id", datasource_id)
        pulumi.set(__self__, "partition_name", partition_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "table_physical_id", table_physical_id)
        if db_guid is not None:
            pulumi.set(__self__, "db_guid", db_guid)
        if table_guid is not None:
            pulumi.set(__self__, "table_guid", table_guid)

    @_builtins.property
    @pulumi.getter(name="dataFlowType")
    def data_flow_type(self) -> pulumi.Input[_builtins.str]:
        """
        Input/output table type
        Input stream
        UPSTREAM,
        Output stream
        DOWNSTREAM.
        """
        return pulumi.get(self, "data_flow_type")

    @data_flow_type.setter
    def data_flow_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_flow_type", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="datasourceId")
    def datasource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Data source ID.
        """
        return pulumi.get(self, "datasource_id")

    @datasource_id.setter
    def datasource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "datasource_id", value)

    @_builtins.property
    @pulumi.getter(name="partitionName")
    def partition_name(self) -> pulumi.Input[_builtins.str]:
        """
        Partition name.
        """
        return pulumi.get(self, "partition_name")

    @partition_name.setter
    def partition_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "partition_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        """
        Table name.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="tablePhysicalId")
    def table_physical_id(self) -> pulumi.Input[_builtins.str]:
        """
        Table physical unique ID.
        """
        return pulumi.get(self, "table_physical_id")

    @table_physical_id.setter
    def table_physical_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_physical_id", value)

    @_builtins.property
    @pulumi.getter(name="dbGuid")
    def db_guid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Database unique identifier.
        """
        return pulumi.get(self, "db_guid")

    @db_guid.setter
    def db_guid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_guid", value)

    @_builtins.property
    @pulumi.getter(name="tableGuid")
    def table_guid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Table unique identifier.
        """
        return pulumi.get(self, "table_guid")

    @table_guid.setter
    def table_guid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_guid", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgsDict(TypedDict):
        main_cyclic_config: pulumi.Input[_builtins.str]
        """
        Main dependency configuration, values:

        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR.
        """
        task_id: pulumi.Input[_builtins.str]
        """
        Task ID.
        """
        dependency_strategy: NotRequired[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgsDict']]
        """
        Dependency execution strategy.
        """
        offset: NotRequired[pulumi.Input[_builtins.str]]
        """
        Offset in interval and list modes.
        """
        subordinate_cyclic_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary dependency configuration, values:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE.
        """
elif False:
    TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationUpstreamDependencyConfigListArgs:
    def __init__(__self__, *,
                 main_cyclic_config: pulumi.Input[_builtins.str],
                 task_id: pulumi.Input[_builtins.str],
                 dependency_strategy: Optional[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs']] = None,
                 offset: Optional[pulumi.Input[_builtins.str]] = None,
                 subordinate_cyclic_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] main_cyclic_config: Main dependency configuration, values:
               
               * CRONTAB
               * DAY
               * HOUR
               * LIST_DAY
               * LIST_HOUR
               * LIST_MINUTE
               * MINUTE
               * MONTH
               * RANGE_DAY
               * RANGE_HOUR
               * RANGE_MINUTE
               * WEEK
               * YEAR.
        :param pulumi.Input[_builtins.str] task_id: Task ID.
        :param pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs'] dependency_strategy: Dependency execution strategy.
        :param pulumi.Input[_builtins.str] offset: Offset in interval and list modes.
        :param pulumi.Input[_builtins.str] subordinate_cyclic_config: Secondary dependency configuration, values:
               * ALL_DAY_OF_YEAR
               * ALL_MONTH_OF_YEAR
               * CURRENT
               * CURRENT_DAY
               * CURRENT_HOUR
               * CURRENT_MINUTE
               * CURRENT_MONTH
               * CURRENT_WEEK
               * CURRENT_YEAR
               * PREVIOUS_BEGIN_OF_MONTH
               * PREVIOUS_DAY
               * PREVIOUS_DAY_LATER_OFFSET_HOUR
               * PREVIOUS_DAY_LATER_OFFSET_MINUTE
               * PREVIOUS_END_OF_MONTH
               * PREVIOUS_FRIDAY
               * PREVIOUS_HOUR
               * PREVIOUS_HOUR_CYCLE
               * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
               * PREVIOUS_MINUTE_CYCLE
               * PREVIOUS_MONTH
               * PREVIOUS_WEEK
               * PREVIOUS_WEEKEND
               * RECENT_DATE.
        """
        pulumi.set(__self__, "main_cyclic_config", main_cyclic_config)
        pulumi.set(__self__, "task_id", task_id)
        if dependency_strategy is not None:
            pulumi.set(__self__, "dependency_strategy", dependency_strategy)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if subordinate_cyclic_config is not None:
            pulumi.set(__self__, "subordinate_cyclic_config", subordinate_cyclic_config)

    @_builtins.property
    @pulumi.getter(name="mainCyclicConfig")
    def main_cyclic_config(self) -> pulumi.Input[_builtins.str]:
        """
        Main dependency configuration, values:

        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR.
        """
        return pulumi.get(self, "main_cyclic_config")

    @main_cyclic_config.setter
    def main_cyclic_config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "main_cyclic_config", value)

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> pulumi.Input[_builtins.str]:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @task_id.setter
    def task_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "task_id", value)

    @_builtins.property
    @pulumi.getter(name="dependencyStrategy")
    def dependency_strategy(self) -> Optional[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs']]:
        """
        Dependency execution strategy.
        """
        return pulumi.get(self, "dependency_strategy")

    @dependency_strategy.setter
    def dependency_strategy(self, value: Optional[pulumi.Input['TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs']]):
        pulumi.set(self, "dependency_strategy", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Offset in interval and list modes.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter(name="subordinateCyclicConfig")
    def subordinate_cyclic_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary dependency configuration, values:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE.
        """
        return pulumi.get(self, "subordinate_cyclic_config")

    @subordinate_cyclic_config.setter
    def subordinate_cyclic_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subordinate_cyclic_config", value)


if not MYPY:
    class TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgsDict(TypedDict):
        polling_null_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Strategy for waiting for upstream task instances: EXECUTING; WAITING.
        """
        task_dependency_executing_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This field is required only when PollingNullStrategy is EXECUTING, List type: NOT_EXIST (default, when minute depends on minute/hour depends on hour, parent instance is not within the downstream instance scheduling time range); PARENT_EXPIRED (parent instance failed); PARENT_TIMEOUT (parent instance timed out). If any of the above scenarios is met, the parent task instance dependency judgment can be passed; otherwise, it is necessary to wait for the parent instance.
        """
        task_dependency_executing_timeout_value: NotRequired[pulumi.Input[_builtins.int]]
        """
        This field is required only when TaskDependencyExecutingStrategies contains PARENT_TIMEOUT, the timeout time for downstream tasks depending on parent instance execution, unit: minutes.
        """
elif False:
    TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTaskSchedulerConfigurationUpstreamDependencyConfigListDependencyStrategyArgs:
    def __init__(__self__, *,
                 polling_null_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 task_dependency_executing_strategies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 task_dependency_executing_timeout_value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] polling_null_strategy: Strategy for waiting for upstream task instances: EXECUTING; WAITING.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] task_dependency_executing_strategies: This field is required only when PollingNullStrategy is EXECUTING, List type: NOT_EXIST (default, when minute depends on minute/hour depends on hour, parent instance is not within the downstream instance scheduling time range); PARENT_EXPIRED (parent instance failed); PARENT_TIMEOUT (parent instance timed out). If any of the above scenarios is met, the parent task instance dependency judgment can be passed; otherwise, it is necessary to wait for the parent instance.
        :param pulumi.Input[_builtins.int] task_dependency_executing_timeout_value: This field is required only when TaskDependencyExecutingStrategies contains PARENT_TIMEOUT, the timeout time for downstream tasks depending on parent instance execution, unit: minutes.
        """
        if polling_null_strategy is not None:
            pulumi.set(__self__, "polling_null_strategy", polling_null_strategy)
        if task_dependency_executing_strategies is not None:
            pulumi.set(__self__, "task_dependency_executing_strategies", task_dependency_executing_strategies)
        if task_dependency_executing_timeout_value is not None:
            pulumi.set(__self__, "task_dependency_executing_timeout_value", task_dependency_executing_timeout_value)

    @_builtins.property
    @pulumi.getter(name="pollingNullStrategy")
    def polling_null_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Strategy for waiting for upstream task instances: EXECUTING; WAITING.
        """
        return pulumi.get(self, "polling_null_strategy")

    @polling_null_strategy.setter
    def polling_null_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "polling_null_strategy", value)

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingStrategies")
    def task_dependency_executing_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This field is required only when PollingNullStrategy is EXECUTING, List type: NOT_EXIST (default, when minute depends on minute/hour depends on hour, parent instance is not within the downstream instance scheduling time range); PARENT_EXPIRED (parent instance failed); PARENT_TIMEOUT (parent instance timed out). If any of the above scenarios is met, the parent task instance dependency judgment can be passed; otherwise, it is necessary to wait for the parent instance.
        """
        return pulumi.get(self, "task_dependency_executing_strategies")

    @task_dependency_executing_strategies.setter
    def task_dependency_executing_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "task_dependency_executing_strategies", value)

    @_builtins.property
    @pulumi.getter(name="taskDependencyExecutingTimeoutValue")
    def task_dependency_executing_timeout_value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        This field is required only when TaskDependencyExecutingStrategies contains PARENT_TIMEOUT, the timeout time for downstream tasks depending on parent instance execution, unit: minutes.
        """
        return pulumi.get(self, "task_dependency_executing_timeout_value")

    @task_dependency_executing_timeout_value.setter
    def task_dependency_executing_timeout_value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "task_dependency_executing_timeout_value", value)


if not MYPY:
    class WeDataDataSourceDevFileUploadArgsDict(TypedDict):
        core_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        core-site.xml file.
        """
        hbase_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        hbase-site file.
        """
        hdfs_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        hdfs-site.xml file.
        """
        hive_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        hive-site.xml file.
        """
        key_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        Keystore authentication file, default filename keystore.jks.
        """
        key_tab: NotRequired[pulumi.Input[_builtins.str]]
        """
        keytab file, default filename [data source name].keytab.
        """
        krb5_conf: NotRequired[pulumi.Input[_builtins.str]]
        """
        krb5.conf file.
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private key, default filename private_key.pem.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public key, default filename public_key.pem.
        """
        trust_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        Truststore authentication file, default filename truststore.jks.
        """
elif False:
    WeDataDataSourceDevFileUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WeDataDataSourceDevFileUploadArgs:
    def __init__(__self__, *,
                 core_site: Optional[pulumi.Input[_builtins.str]] = None,
                 hbase_site: Optional[pulumi.Input[_builtins.str]] = None,
                 hdfs_site: Optional[pulumi.Input[_builtins.str]] = None,
                 hive_site: Optional[pulumi.Input[_builtins.str]] = None,
                 key_store: Optional[pulumi.Input[_builtins.str]] = None,
                 key_tab: Optional[pulumi.Input[_builtins.str]] = None,
                 krb5_conf: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_store: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] core_site: core-site.xml file.
        :param pulumi.Input[_builtins.str] hbase_site: hbase-site file.
        :param pulumi.Input[_builtins.str] hdfs_site: hdfs-site.xml file.
        :param pulumi.Input[_builtins.str] hive_site: hive-site.xml file.
        :param pulumi.Input[_builtins.str] key_store: Keystore authentication file, default filename keystore.jks.
        :param pulumi.Input[_builtins.str] key_tab: keytab file, default filename [data source name].keytab.
        :param pulumi.Input[_builtins.str] krb5_conf: krb5.conf file.
        :param pulumi.Input[_builtins.str] private_key: Private key, default filename private_key.pem.
        :param pulumi.Input[_builtins.str] public_key: Public key, default filename public_key.pem.
        :param pulumi.Input[_builtins.str] trust_store: Truststore authentication file, default filename truststore.jks.
        """
        if core_site is not None:
            pulumi.set(__self__, "core_site", core_site)
        if hbase_site is not None:
            pulumi.set(__self__, "hbase_site", hbase_site)
        if hdfs_site is not None:
            pulumi.set(__self__, "hdfs_site", hdfs_site)
        if hive_site is not None:
            pulumi.set(__self__, "hive_site", hive_site)
        if key_store is not None:
            pulumi.set(__self__, "key_store", key_store)
        if key_tab is not None:
            pulumi.set(__self__, "key_tab", key_tab)
        if krb5_conf is not None:
            pulumi.set(__self__, "krb5_conf", krb5_conf)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if trust_store is not None:
            pulumi.set(__self__, "trust_store", trust_store)

    @_builtins.property
    @pulumi.getter(name="coreSite")
    def core_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        core-site.xml file.
        """
        return pulumi.get(self, "core_site")

    @core_site.setter
    def core_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "core_site", value)

    @_builtins.property
    @pulumi.getter(name="hbaseSite")
    def hbase_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hbase-site file.
        """
        return pulumi.get(self, "hbase_site")

    @hbase_site.setter
    def hbase_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hbase_site", value)

    @_builtins.property
    @pulumi.getter(name="hdfsSite")
    def hdfs_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hdfs-site.xml file.
        """
        return pulumi.get(self, "hdfs_site")

    @hdfs_site.setter
    def hdfs_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hdfs_site", value)

    @_builtins.property
    @pulumi.getter(name="hiveSite")
    def hive_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hive-site.xml file.
        """
        return pulumi.get(self, "hive_site")

    @hive_site.setter
    def hive_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hive_site", value)

    @_builtins.property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Keystore authentication file, default filename keystore.jks.
        """
        return pulumi.get(self, "key_store")

    @key_store.setter
    def key_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_store", value)

    @_builtins.property
    @pulumi.getter(name="keyTab")
    def key_tab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        keytab file, default filename [data source name].keytab.
        """
        return pulumi.get(self, "key_tab")

    @key_tab.setter
    def key_tab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_tab", value)

    @_builtins.property
    @pulumi.getter(name="krb5Conf")
    def krb5_conf(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        krb5.conf file.
        """
        return pulumi.get(self, "krb5_conf")

    @krb5_conf.setter
    def krb5_conf(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "krb5_conf", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private key, default filename private_key.pem.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public key, default filename public_key.pem.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="trustStore")
    def trust_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Truststore authentication file, default filename truststore.jks.
        """
        return pulumi.get(self, "trust_store")

    @trust_store.setter
    def trust_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_store", value)


if not MYPY:
    class WeDataDataSourceListFilterArgsDict(TypedDict):
        name: NotRequired[_builtins.str]
        """
        Filter name.
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        Filter value.
        """
elif False:
    WeDataDataSourceListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WeDataDataSourceListFilterArgs:
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Filter name.
        :param Sequence[_builtins.str] values: Filter value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Filter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class WeDataDataSourceListOrderFieldArgsDict(TypedDict):
        direction: _builtins.str
        """
        OrderFields rule.
        """
        name: _builtins.str
        """
        OrderFields name.
        """
elif False:
    WeDataDataSourceListOrderFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WeDataDataSourceListOrderFieldArgs:
    def __init__(__self__, *,
                 direction: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str direction: OrderFields rule.
        :param _builtins.str name: OrderFields name.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        OrderFields rule.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: _builtins.str):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        OrderFields name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)


if not MYPY:
    class WeDataDataSourceProdFileUploadArgsDict(TypedDict):
        core_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        core-site.xml file.
        """
        hbase_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        hbase-site file.
        """
        hdfs_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        hdfs-site.xml file.
        """
        hive_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        hive-site.xml file.
        """
        key_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        Keystore authentication file, default filename keystore.jks.
        """
        key_tab: NotRequired[pulumi.Input[_builtins.str]]
        """
        keytab file, default filename [data source name].keytab.
        """
        krb5_conf: NotRequired[pulumi.Input[_builtins.str]]
        """
        krb5.conf file.
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private key, default filename private_key.pem.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public key, default filename public_key.pem.
        """
        trust_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        Truststore authentication file, default filename truststore.jks.
        """
elif False:
    WeDataDataSourceProdFileUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WeDataDataSourceProdFileUploadArgs:
    def __init__(__self__, *,
                 core_site: Optional[pulumi.Input[_builtins.str]] = None,
                 hbase_site: Optional[pulumi.Input[_builtins.str]] = None,
                 hdfs_site: Optional[pulumi.Input[_builtins.str]] = None,
                 hive_site: Optional[pulumi.Input[_builtins.str]] = None,
                 key_store: Optional[pulumi.Input[_builtins.str]] = None,
                 key_tab: Optional[pulumi.Input[_builtins.str]] = None,
                 krb5_conf: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_store: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] core_site: core-site.xml file.
        :param pulumi.Input[_builtins.str] hbase_site: hbase-site file.
        :param pulumi.Input[_builtins.str] hdfs_site: hdfs-site.xml file.
        :param pulumi.Input[_builtins.str] hive_site: hive-site.xml file.
        :param pulumi.Input[_builtins.str] key_store: Keystore authentication file, default filename keystore.jks.
        :param pulumi.Input[_builtins.str] key_tab: keytab file, default filename [data source name].keytab.
        :param pulumi.Input[_builtins.str] krb5_conf: krb5.conf file.
        :param pulumi.Input[_builtins.str] private_key: Private key, default filename private_key.pem.
        :param pulumi.Input[_builtins.str] public_key: Public key, default filename public_key.pem.
        :param pulumi.Input[_builtins.str] trust_store: Truststore authentication file, default filename truststore.jks.
        """
        if core_site is not None:
            pulumi.set(__self__, "core_site", core_site)
        if hbase_site is not None:
            pulumi.set(__self__, "hbase_site", hbase_site)
        if hdfs_site is not None:
            pulumi.set(__self__, "hdfs_site", hdfs_site)
        if hive_site is not None:
            pulumi.set(__self__, "hive_site", hive_site)
        if key_store is not None:
            pulumi.set(__self__, "key_store", key_store)
        if key_tab is not None:
            pulumi.set(__self__, "key_tab", key_tab)
        if krb5_conf is not None:
            pulumi.set(__self__, "krb5_conf", krb5_conf)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if trust_store is not None:
            pulumi.set(__self__, "trust_store", trust_store)

    @_builtins.property
    @pulumi.getter(name="coreSite")
    def core_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        core-site.xml file.
        """
        return pulumi.get(self, "core_site")

    @core_site.setter
    def core_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "core_site", value)

    @_builtins.property
    @pulumi.getter(name="hbaseSite")
    def hbase_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hbase-site file.
        """
        return pulumi.get(self, "hbase_site")

    @hbase_site.setter
    def hbase_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hbase_site", value)

    @_builtins.property
    @pulumi.getter(name="hdfsSite")
    def hdfs_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hdfs-site.xml file.
        """
        return pulumi.get(self, "hdfs_site")

    @hdfs_site.setter
    def hdfs_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hdfs_site", value)

    @_builtins.property
    @pulumi.getter(name="hiveSite")
    def hive_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hive-site.xml file.
        """
        return pulumi.get(self, "hive_site")

    @hive_site.setter
    def hive_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hive_site", value)

    @_builtins.property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Keystore authentication file, default filename keystore.jks.
        """
        return pulumi.get(self, "key_store")

    @key_store.setter
    def key_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_store", value)

    @_builtins.property
    @pulumi.getter(name="keyTab")
    def key_tab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        keytab file, default filename [data source name].keytab.
        """
        return pulumi.get(self, "key_tab")

    @key_tab.setter
    def key_tab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_tab", value)

    @_builtins.property
    @pulumi.getter(name="krb5Conf")
    def krb5_conf(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        krb5.conf file.
        """
        return pulumi.get(self, "krb5_conf")

    @krb5_conf.setter
    def krb5_conf(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "krb5_conf", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private key, default filename private_key.pem.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public key, default filename public_key.pem.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="trustStore")
    def trust_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Truststore authentication file, default filename truststore.jks.
        """
        return pulumi.get(self, "trust_store")

    @trust_store.setter
    def trust_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_store", value)


if not MYPY:
    class WorkflowWorkflowParamArgsDict(TypedDict):
        param_key: pulumi.Input[_builtins.str]
        """
        Parameter name.
        """
        param_value: pulumi.Input[_builtins.str]
        """
        Parameter value.
        """
elif False:
    WorkflowWorkflowParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowWorkflowParamArgs:
    def __init__(__self__, *,
                 param_key: pulumi.Input[_builtins.str],
                 param_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] param_key: Parameter name.
        :param pulumi.Input[_builtins.str] param_value: Parameter value.
        """
        pulumi.set(__self__, "param_key", param_key)
        pulumi.set(__self__, "param_value", param_value)

    @_builtins.property
    @pulumi.getter(name="paramKey")
    def param_key(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "param_key")

    @param_key.setter
    def param_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_key", value)

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> pulumi.Input[_builtins.str]:
        """
        Parameter value.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_value", value)


if not MYPY:
    class WorkflowWorkflowSchedulerConfigurationArgsDict(TypedDict):
        crontab_expression: pulumi.Input[_builtins.str]
        """
        Crontab expression.
        """
        cycle_type: pulumi.Input[_builtins.str]
        """
        Cycle type: Supported types are
        ONEOFF_CYCLE: One-time
        YEAR_CYCLE: Year
        MONTH_CYCLE: Month
        WEEK_CYCLE: Week
        DAY_CYCLE: Day
        HOUR_CYCLE: Hour
        MINUTE_CYCLE: Minute
        CRONTAB_CYCLE: crontab expression type.
        """
        end_time: pulumi.Input[_builtins.str]
        """
        End time.
        """
        schedule_time_zone: pulumi.Input[_builtins.str]
        """
        time zone.
        """
        self_depend: pulumi.Input[_builtins.str]
        """
        Self-dependence, default value serial, values are: parallel, serial, orderly.
        """
        start_time: pulumi.Input[_builtins.str]
        """
        Start time.
        """
        calendar_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        calendar id.
        """
        calendar_open: NotRequired[pulumi.Input[_builtins.str]]
        """
        Do you want to turn on calendar scheduling 1 on 0 off.
        """
        clear_link: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Workflows have cross-workflow dependencies and are scheduled using cron expressions. If you save unified scheduling, unsupported dependencies will be broken.
        """
        dependency_workflow: NotRequired[pulumi.Input[_builtins.str]]
        """
        Workflow dependence, yes or no.
        """
        execution_end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution time right-closed interval, example: 23:59, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        """
        execution_start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Execution time left-closed interval, example: 00:00, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        """
        main_cyclic_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effective when ModifyCycleValue is 1, indicating the default modified upstream dependence-time dimension. The value is: 
        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR

        https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
        modify_cycle_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        0: Do not modify 1: Change the upstream dependency configuration of the task to the default value.
        """
        subordinate_cyclic_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effective when ModifyCycleValue is 1, which means that the default modified upstream dependency-instance range
        value is:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE

        https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
elif False:
    WorkflowWorkflowSchedulerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowWorkflowSchedulerConfigurationArgs:
    def __init__(__self__, *,
                 crontab_expression: pulumi.Input[_builtins.str],
                 cycle_type: pulumi.Input[_builtins.str],
                 end_time: pulumi.Input[_builtins.str],
                 schedule_time_zone: pulumi.Input[_builtins.str],
                 self_depend: pulumi.Input[_builtins.str],
                 start_time: pulumi.Input[_builtins.str],
                 calendar_id: Optional[pulumi.Input[_builtins.str]] = None,
                 calendar_open: Optional[pulumi.Input[_builtins.str]] = None,
                 clear_link: Optional[pulumi.Input[_builtins.bool]] = None,
                 dependency_workflow: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 main_cyclic_config: Optional[pulumi.Input[_builtins.str]] = None,
                 modify_cycle_value: Optional[pulumi.Input[_builtins.str]] = None,
                 subordinate_cyclic_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] crontab_expression: Crontab expression.
        :param pulumi.Input[_builtins.str] cycle_type: Cycle type: Supported types are
               ONEOFF_CYCLE: One-time
               YEAR_CYCLE: Year
               MONTH_CYCLE: Month
               WEEK_CYCLE: Week
               DAY_CYCLE: Day
               HOUR_CYCLE: Hour
               MINUTE_CYCLE: Minute
               CRONTAB_CYCLE: crontab expression type.
        :param pulumi.Input[_builtins.str] end_time: End time.
        :param pulumi.Input[_builtins.str] schedule_time_zone: time zone.
        :param pulumi.Input[_builtins.str] self_depend: Self-dependence, default value serial, values are: parallel, serial, orderly.
        :param pulumi.Input[_builtins.str] start_time: Start time.
        :param pulumi.Input[_builtins.str] calendar_id: calendar id.
        :param pulumi.Input[_builtins.str] calendar_open: Do you want to turn on calendar scheduling 1 on 0 off.
        :param pulumi.Input[_builtins.bool] clear_link: Workflows have cross-workflow dependencies and are scheduled using cron expressions. If you save unified scheduling, unsupported dependencies will be broken.
        :param pulumi.Input[_builtins.str] dependency_workflow: Workflow dependence, yes or no.
        :param pulumi.Input[_builtins.str] execution_end_time: Execution time right-closed interval, example: 23:59, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        :param pulumi.Input[_builtins.str] execution_start_time: Execution time left-closed interval, example: 00:00, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        :param pulumi.Input[_builtins.str] main_cyclic_config: Effective when ModifyCycleValue is 1, indicating the default modified upstream dependence-time dimension. The value is: 
               * CRONTAB
               * DAY
               * HOUR
               * LIST_DAY
               * LIST_HOUR
               * LIST_MINUTE
               * MONTH
               * RANGE_DAY
               * RANGE_HOUR
               * RANGE_MINUTE
               * WEEK
               * YEAR
               
               https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        :param pulumi.Input[_builtins.str] modify_cycle_value: 0: Do not modify 1: Change the upstream dependency configuration of the task to the default value.
        :param pulumi.Input[_builtins.str] subordinate_cyclic_config: Effective when ModifyCycleValue is 1, which means that the default modified upstream dependency-instance range
               value is:
               * ALL_DAY_OF_YEAR
               * ALL_MONTH_OF_YEAR
               * CURRENT
               * CURRENT_DAY
               * CURRENT_HOUR
               * CURRENT_MINUTE
               * CURRENT_MONTH
               * CURRENT_WEEK
               * CURRENT_YEAR
               * PREVIOUS_BEGIN_OF_MONTH
               * PREVIOUS_DAY
               * PREVIOUS_DAY_LATER_OFFSET_HOUR
               * PREVIOUS_DAY_LATER_OFFSET_MINUTE
               * PREVIOUS_END_OF_MONTH
               * PREVIOUS_FRIDAY
               * PREVIOUS_HOUR
               * PREVIOUS_HOUR_CYCLE
               * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
               * PREVIOUS_MINUTE_CYCLE
               * PREVIOUS_MONTH
               * PREVIOUS_WEEK
               * PREVIOUS_WEEKEND
               * RECENT_DATE
               
               https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
        pulumi.set(__self__, "crontab_expression", crontab_expression)
        pulumi.set(__self__, "cycle_type", cycle_type)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "schedule_time_zone", schedule_time_zone)
        pulumi.set(__self__, "self_depend", self_depend)
        pulumi.set(__self__, "start_time", start_time)
        if calendar_id is not None:
            pulumi.set(__self__, "calendar_id", calendar_id)
        if calendar_open is not None:
            pulumi.set(__self__, "calendar_open", calendar_open)
        if clear_link is not None:
            pulumi.set(__self__, "clear_link", clear_link)
        if dependency_workflow is not None:
            pulumi.set(__self__, "dependency_workflow", dependency_workflow)
        if execution_end_time is not None:
            pulumi.set(__self__, "execution_end_time", execution_end_time)
        if execution_start_time is not None:
            pulumi.set(__self__, "execution_start_time", execution_start_time)
        if main_cyclic_config is not None:
            pulumi.set(__self__, "main_cyclic_config", main_cyclic_config)
        if modify_cycle_value is not None:
            pulumi.set(__self__, "modify_cycle_value", modify_cycle_value)
        if subordinate_cyclic_config is not None:
            pulumi.set(__self__, "subordinate_cyclic_config", subordinate_cyclic_config)

    @_builtins.property
    @pulumi.getter(name="crontabExpression")
    def crontab_expression(self) -> pulumi.Input[_builtins.str]:
        """
        Crontab expression.
        """
        return pulumi.get(self, "crontab_expression")

    @crontab_expression.setter
    def crontab_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "crontab_expression", value)

    @_builtins.property
    @pulumi.getter(name="cycleType")
    def cycle_type(self) -> pulumi.Input[_builtins.str]:
        """
        Cycle type: Supported types are
        ONEOFF_CYCLE: One-time
        YEAR_CYCLE: Year
        MONTH_CYCLE: Month
        WEEK_CYCLE: Week
        DAY_CYCLE: Day
        HOUR_CYCLE: Hour
        MINUTE_CYCLE: Minute
        CRONTAB_CYCLE: crontab expression type.
        """
        return pulumi.get(self, "cycle_type")

    @cycle_type.setter
    def cycle_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cycle_type", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[_builtins.str]:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="scheduleTimeZone")
    def schedule_time_zone(self) -> pulumi.Input[_builtins.str]:
        """
        time zone.
        """
        return pulumi.get(self, "schedule_time_zone")

    @schedule_time_zone.setter
    def schedule_time_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schedule_time_zone", value)

    @_builtins.property
    @pulumi.getter(name="selfDepend")
    def self_depend(self) -> pulumi.Input[_builtins.str]:
        """
        Self-dependence, default value serial, values are: parallel, serial, orderly.
        """
        return pulumi.get(self, "self_depend")

    @self_depend.setter
    def self_depend(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "self_depend", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.str]:
        """
        Start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="calendarId")
    def calendar_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        calendar id.
        """
        return pulumi.get(self, "calendar_id")

    @calendar_id.setter
    def calendar_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "calendar_id", value)

    @_builtins.property
    @pulumi.getter(name="calendarOpen")
    def calendar_open(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Do you want to turn on calendar scheduling 1 on 0 off.
        """
        return pulumi.get(self, "calendar_open")

    @calendar_open.setter
    def calendar_open(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "calendar_open", value)

    @_builtins.property
    @pulumi.getter(name="clearLink")
    def clear_link(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Workflows have cross-workflow dependencies and are scheduled using cron expressions. If you save unified scheduling, unsupported dependencies will be broken.
        """
        return pulumi.get(self, "clear_link")

    @clear_link.setter
    def clear_link(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "clear_link", value)

    @_builtins.property
    @pulumi.getter(name="dependencyWorkflow")
    def dependency_workflow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Workflow dependence, yes or no.
        """
        return pulumi.get(self, "dependency_workflow")

    @dependency_workflow.setter
    def dependency_workflow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dependency_workflow", value)

    @_builtins.property
    @pulumi.getter(name="executionEndTime")
    def execution_end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution time right-closed interval, example: 23:59, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        """
        return pulumi.get(self, "execution_end_time")

    @execution_end_time.setter
    def execution_end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_end_time", value)

    @_builtins.property
    @pulumi.getter(name="executionStartTime")
    def execution_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Execution time left-closed interval, example: 00:00, only if the cycle type is MINUTE_CYCLE needs to be filled in.
        """
        return pulumi.get(self, "execution_start_time")

    @execution_start_time.setter
    def execution_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_start_time", value)

    @_builtins.property
    @pulumi.getter(name="mainCyclicConfig")
    def main_cyclic_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effective when ModifyCycleValue is 1, indicating the default modified upstream dependence-time dimension. The value is: 
        * CRONTAB
        * DAY
        * HOUR
        * LIST_DAY
        * LIST_HOUR
        * LIST_MINUTE
        * MONTH
        * RANGE_DAY
        * RANGE_HOUR
        * RANGE_MINUTE
        * WEEK
        * YEAR

        https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
        return pulumi.get(self, "main_cyclic_config")

    @main_cyclic_config.setter
    def main_cyclic_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "main_cyclic_config", value)

    @_builtins.property
    @pulumi.getter(name="modifyCycleValue")
    def modify_cycle_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        0: Do not modify 1: Change the upstream dependency configuration of the task to the default value.
        """
        return pulumi.get(self, "modify_cycle_value")

    @modify_cycle_value.setter
    def modify_cycle_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modify_cycle_value", value)

    @_builtins.property
    @pulumi.getter(name="subordinateCyclicConfig")
    def subordinate_cyclic_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effective when ModifyCycleValue is 1, which means that the default modified upstream dependency-instance range
        value is:
        * ALL_DAY_OF_YEAR
        * ALL_MONTH_OF_YEAR
        * CURRENT
        * CURRENT_DAY
        * CURRENT_HOUR
        * CURRENT_MINUTE
        * CURRENT_MONTH
        * CURRENT_WEEK
        * CURRENT_YEAR
        * PREVIOUS_BEGIN_OF_MONTH
        * PREVIOUS_DAY
        * PREVIOUS_DAY_LATER_OFFSET_HOUR
        * PREVIOUS_DAY_LATER_OFFSET_MINUTE
        * PREVIOUS_END_OF_MONTH
        * PREVIOUS_FRIDAY
        * PREVIOUS_HOUR
        * PREVIOUS_HOUR_CYCLE
        * PREVIOUS_HOUR_LATER_OFFSET_MINUTE
        * PREVIOUS_MINUTE_CYCLE
        * PREVIOUS_MONTH
        * PREVIOUS_WEEK
        * PREVIOUS_WEEKEND
        * RECENT_DATE

        https://capi.woa.com/object/detail? product=wedata&env=api_dev&version=2025-08-06&name=WorkflowSchedulerConfigurationInfo.
        """
        return pulumi.get(self, "subordinate_cyclic_config")

    @subordinate_cyclic_config.setter
    def subordinate_cyclic_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subordinate_cyclic_config", value)


