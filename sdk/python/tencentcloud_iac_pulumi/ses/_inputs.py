# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BatchSendEmailAttachmentArgs',
    'BatchSendEmailAttachmentArgsDict',
    'BatchSendEmailCycleParamArgs',
    'BatchSendEmailCycleParamArgsDict',
    'BatchSendEmailTemplateArgs',
    'BatchSendEmailTemplateArgsDict',
    'BatchSendEmailTimedParamArgs',
    'BatchSendEmailTimedParamArgsDict',
    'DomainAttributeArgs',
    'DomainAttributeArgsDict',
    'ReceiverDataArgs',
    'ReceiverDataArgsDict',
    'SendEmailAttachmentArgs',
    'SendEmailAttachmentArgsDict',
    'SendEmailTemplateArgs',
    'SendEmailTemplateArgsDict',
    'TemplateTemplateContentArgs',
    'TemplateTemplateContentArgsDict',
]

MYPY = False

if not MYPY:
    class BatchSendEmailAttachmentArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
        """
        file_name: pulumi.Input[_builtins.str]
        """
        Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
        """
elif False:
    BatchSendEmailAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchSendEmailAttachmentArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 file_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] content: Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
        :param pulumi.Input[_builtins.str] file_name: Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "file_name", file_name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[_builtins.str]:
        """
        Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_name", value)


if not MYPY:
    class BatchSendEmailCycleParamArgsDict(TypedDict):
        begin_time: pulumi.Input[_builtins.str]
        """
        Start time of the task.
        """
        interval_time: pulumi.Input[_builtins.int]
        """
        Task recurrence in hours.
        """
        term_cycle: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies whether to end the cycle. This parameter is used to update the task. Valid values: 0: No; 1: Yes.
        """
elif False:
    BatchSendEmailCycleParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchSendEmailCycleParamArgs:
    def __init__(__self__, *,
                 begin_time: pulumi.Input[_builtins.str],
                 interval_time: pulumi.Input[_builtins.int],
                 term_cycle: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] begin_time: Start time of the task.
        :param pulumi.Input[_builtins.int] interval_time: Task recurrence in hours.
        :param pulumi.Input[_builtins.int] term_cycle: Specifies whether to end the cycle. This parameter is used to update the task. Valid values: 0: No; 1: Yes.
        """
        pulumi.set(__self__, "begin_time", begin_time)
        pulumi.set(__self__, "interval_time", interval_time)
        if term_cycle is not None:
            pulumi.set(__self__, "term_cycle", term_cycle)

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> pulumi.Input[_builtins.str]:
        """
        Start time of the task.
        """
        return pulumi.get(self, "begin_time")

    @begin_time.setter
    def begin_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "begin_time", value)

    @_builtins.property
    @pulumi.getter(name="intervalTime")
    def interval_time(self) -> pulumi.Input[_builtins.int]:
        """
        Task recurrence in hours.
        """
        return pulumi.get(self, "interval_time")

    @interval_time.setter
    def interval_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "interval_time", value)

    @_builtins.property
    @pulumi.getter(name="termCycle")
    def term_cycle(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies whether to end the cycle. This parameter is used to update the task. Valid values: 0: No; 1: Yes.
        """
        return pulumi.get(self, "term_cycle")

    @term_cycle.setter
    def term_cycle(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "term_cycle", value)


if not MYPY:
    class BatchSendEmailTemplateArgsDict(TypedDict):
        template_data: pulumi.Input[_builtins.str]
        """
        Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
        """
        template_id: pulumi.Input[_builtins.int]
        """
        Template ID. If you do not have any template, please create one.
        """
elif False:
    BatchSendEmailTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchSendEmailTemplateArgs:
    def __init__(__self__, *,
                 template_data: pulumi.Input[_builtins.str],
                 template_id: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] template_data: Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
        :param pulumi.Input[_builtins.int] template_id: Template ID. If you do not have any template, please create one.
        """
        pulumi.set(__self__, "template_data", template_data)
        pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="templateData")
    def template_data(self) -> pulumi.Input[_builtins.str]:
        """
        Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
        """
        return pulumi.get(self, "template_data")

    @template_data.setter
    def template_data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_data", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> pulumi.Input[_builtins.int]:
        """
        Template ID. If you do not have any template, please create one.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class BatchSendEmailTimedParamArgsDict(TypedDict):
        begin_time: pulumi.Input[_builtins.str]
        """
        Start time of a scheduled sending task.
        """
elif False:
    BatchSendEmailTimedParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchSendEmailTimedParamArgs:
    def __init__(__self__, *,
                 begin_time: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] begin_time: Start time of a scheduled sending task.
        """
        pulumi.set(__self__, "begin_time", begin_time)

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> pulumi.Input[_builtins.str]:
        """
        Start time of a scheduled sending task.
        """
        return pulumi.get(self, "begin_time")

    @begin_time.setter
    def begin_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "begin_time", value)


if not MYPY:
    class DomainAttributeArgsDict(TypedDict):
        expected_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Values that need to be configured.
        """
        send_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Record Type CNAME | A | TXT | MX.
        """
elif False:
    DomainAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAttributeArgs:
    def __init__(__self__, *,
                 expected_value: Optional[pulumi.Input[_builtins.str]] = None,
                 send_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expected_value: Values that need to be configured.
        :param pulumi.Input[_builtins.str] send_domain: Domain name.
        :param pulumi.Input[_builtins.str] type: Record Type CNAME | A | TXT | MX.
        """
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if send_domain is not None:
            pulumi.set(__self__, "send_domain", send_domain)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Values that need to be configured.
        """
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_value", value)

    @_builtins.property
    @pulumi.getter(name="sendDomain")
    def send_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain name.
        """
        return pulumi.get(self, "send_domain")

    @send_domain.setter
    def send_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_domain", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Record Type CNAME | A | TXT | MX.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ReceiverDataArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        Recipient email addresses.
        """
        template_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Variable parameters in the template, please use json.dump to format the JSON object as a string type. The object is a set of key-value pairs, where each key represents a variable in the template, and the variables in the template are represented by {{key}}, and the corresponding values will be replaced with {{value}} when sent.Note: Parameter values cannot be complex data such as HTML. The total length of TemplateData (the entire JSON structure) should be less than 800 bytes.
        """
elif False:
    ReceiverDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReceiverDataArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 template_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: Recipient email addresses.
        :param pulumi.Input[_builtins.str] template_data: Variable parameters in the template, please use json.dump to format the JSON object as a string type. The object is a set of key-value pairs, where each key represents a variable in the template, and the variables in the template are represented by {{key}}, and the corresponding values will be replaced with {{value}} when sent.Note: Parameter values cannot be complex data such as HTML. The total length of TemplateData (the entire JSON structure) should be less than 800 bytes.
        """
        pulumi.set(__self__, "email", email)
        if template_data is not None:
            pulumi.set(__self__, "template_data", template_data)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        Recipient email addresses.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="templateData")
    def template_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Variable parameters in the template, please use json.dump to format the JSON object as a string type. The object is a set of key-value pairs, where each key represents a variable in the template, and the variables in the template are represented by {{key}}, and the corresponding values will be replaced with {{value}} when sent.Note: Parameter values cannot be complex data such as HTML. The total length of TemplateData (the entire JSON structure) should be less than 800 bytes.
        """
        return pulumi.get(self, "template_data")

    @template_data.setter
    def template_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_data", value)


if not MYPY:
    class SendEmailAttachmentArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
        """
        file_name: pulumi.Input[_builtins.str]
        """
        Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
        """
elif False:
    SendEmailAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SendEmailAttachmentArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 file_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] content: Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
        :param pulumi.Input[_builtins.str] file_name: Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "file_name", file_name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[_builtins.str]:
        """
        Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_name", value)


if not MYPY:
    class SendEmailTemplateArgsDict(TypedDict):
        template_data: pulumi.Input[_builtins.str]
        """
        Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
        """
        template_id: pulumi.Input[_builtins.int]
        """
        Template ID. If you do not have any template, please create one.
        """
elif False:
    SendEmailTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SendEmailTemplateArgs:
    def __init__(__self__, *,
                 template_data: pulumi.Input[_builtins.str],
                 template_id: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] template_data: Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
        :param pulumi.Input[_builtins.int] template_id: Template ID. If you do not have any template, please create one.
        """
        pulumi.set(__self__, "template_data", template_data)
        pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="templateData")
    def template_data(self) -> pulumi.Input[_builtins.str]:
        """
        Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
        """
        return pulumi.get(self, "template_data")

    @template_data.setter
    def template_data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_data", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> pulumi.Input[_builtins.int]:
        """
        Template ID. If you do not have any template, please create one.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class TemplateTemplateContentArgsDict(TypedDict):
        html: NotRequired[pulumi.Input[_builtins.str]]
        """
        Html code after base64.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text content after base64.
        """
elif False:
    TemplateTemplateContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateTemplateContentArgs:
    def __init__(__self__, *,
                 html: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] html: Html code after base64.
        :param pulumi.Input[_builtins.str] text: Text content after base64.
        """
        if html is not None:
            pulumi.set(__self__, "html", html)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def html(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Html code after base64.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text content after base64.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


