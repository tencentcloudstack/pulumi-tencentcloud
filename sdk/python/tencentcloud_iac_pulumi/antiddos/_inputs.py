# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CcBlackWhiteIpBlackWhiteIpArgs',
    'CcBlackWhiteIpBlackWhiteIpArgsDict',
    'CcPrecisionPolicyPolicyListArgs',
    'CcPrecisionPolicyPolicyListArgsDict',
    'DdosGeoIpBlockConfigDdosGeoIpBlockConfigArgs',
    'DdosGeoIpBlockConfigDdosGeoIpBlockConfigArgsDict',
    'DdosSpeedLimitConfigDdosSpeedLimitConfigArgs',
    'DdosSpeedLimitConfigDdosSpeedLimitConfigArgsDict',
    'DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgs',
    'DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgsDict',
    'DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgs',
    'DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgsDict',
    'DefaultAlarmThresholdDefaultAlarmConfigArgs',
    'DefaultAlarmThresholdDefaultAlarmConfigArgsDict',
    'PacketFilterConfigPacketFilterConfigArgs',
    'PacketFilterConfigPacketFilterConfigArgsDict',
    'PortAclConfigAclConfigArgs',
    'PortAclConfigAclConfigArgsDict',
]

MYPY = False

if not MYPY:
    class CcBlackWhiteIpBlackWhiteIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        ip address.
        """
        mask: pulumi.Input[_builtins.int]
        """
        ip mask.
        """
elif False:
    CcBlackWhiteIpBlackWhiteIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CcBlackWhiteIpBlackWhiteIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 mask: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] ip: ip address.
        :param pulumi.Input[_builtins.int] mask: ip mask.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "mask", mask)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        ip address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def mask(self) -> pulumi.Input[_builtins.int]:
        """
        ip mask.
        """
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class CcPrecisionPolicyPolicyListArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Configuration fields can take values of cgi, ua, cookie, referer, accept, srcip.
        """
        field_type: pulumi.Input[_builtins.str]
        """
        field type.
        """
        value: pulumi.Input[_builtins.str]
        """
        value.
        """
        value_operator: pulumi.Input[_builtins.str]
        """
        Configuration item value comparison method, can take values of equal, not_ Equal, include.
        """
elif False:
    CcPrecisionPolicyPolicyListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CcPrecisionPolicyPolicyListArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 field_type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 value_operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field_name: Configuration fields can take values of cgi, ua, cookie, referer, accept, srcip.
        :param pulumi.Input[_builtins.str] field_type: field type.
        :param pulumi.Input[_builtins.str] value: value.
        :param pulumi.Input[_builtins.str] value_operator: Configuration item value comparison method, can take values of equal, not_ Equal, include.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_operator", value_operator)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Configuration fields can take values of cgi, ua, cookie, referer, accept, srcip.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> pulumi.Input[_builtins.str]:
        """
        field type.
        """
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueOperator")
    def value_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Configuration item value comparison method, can take values of equal, not_ Equal, include.
        """
        return pulumi.get(self, "value_operator")

    @value_operator.setter
    def value_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_operator", value)


if not MYPY:
    class DdosGeoIpBlockConfigDdosGeoIpBlockConfigArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Blocking action, value [drop (intercept) trans (release)].
        """
        region_type: pulumi.Input[_builtins.str]
        """
        Region type, value [oversea (overseas) China (domestic) customized (custom region)].
        """
        area_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        When RegionType is customized, an AreaList must be filled in, with a maximum of 128 entries;.
        """
elif False:
    DdosGeoIpBlockConfigDdosGeoIpBlockConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdosGeoIpBlockConfigDdosGeoIpBlockConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 region_type: pulumi.Input[_builtins.str],
                 area_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Blocking action, value [drop (intercept) trans (release)].
        :param pulumi.Input[_builtins.str] region_type: Region type, value [oversea (overseas) China (domestic) customized (custom region)].
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] area_lists: When RegionType is customized, an AreaList must be filled in, with a maximum of 128 entries;.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "region_type", region_type)
        if area_lists is not None:
            pulumi.set(__self__, "area_lists", area_lists)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Blocking action, value [drop (intercept) trans (release)].
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="regionType")
    def region_type(self) -> pulumi.Input[_builtins.str]:
        """
        Region type, value [oversea (overseas) China (domestic) customized (custom region)].
        """
        return pulumi.get(self, "region_type")

    @region_type.setter
    def region_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region_type", value)

    @_builtins.property
    @pulumi.getter(name="areaLists")
    def area_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        When RegionType is customized, an AreaList must be filled in, with a maximum of 128 entries;.
        """
        return pulumi.get(self, "area_lists")

    @area_lists.setter
    def area_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "area_lists", value)


if not MYPY:
    class DdosSpeedLimitConfigDdosSpeedLimitConfigArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.int]
        """
        Speed limit mode, value [1 (based on source IP speed limit) 2 (based on destination port speed limit)].
        """
        speed_values: pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgsDict']]]
        """
        Speed limit values, each type of speed limit value can support up to 1; This field array has at least one speed limit value.
        """
        dst_port_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        List of port ranges, up to 8, multiple; Separate and indicate the range with -; This port range must be filled in; Fill in style 1:0-65535, style 2: 80; 443; 1000-2000.
        """
        dst_port_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgsDict']]]]
        """
        This field has been deprecated. Please fill in the new field DstPortList.
        """
        protocol_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP protocol numbers, values [ALL (all protocols) TCP (tcp protocol) UDP (udp protocol) SMP (smp protocol) 1; 2-100 (custom protocol number range, up to 8)] Note: When customizing the protocol number range, only the protocol number can be filled in, multiple ranges; Separation; When filling in ALL, no other agreements or agreements can be filled inNumber.
        """
elif False:
    DdosSpeedLimitConfigDdosSpeedLimitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdosSpeedLimitConfigDdosSpeedLimitConfigArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.int],
                 speed_values: pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgs']]],
                 dst_port_list: Optional[pulumi.Input[_builtins.str]] = None,
                 dst_port_scopes: Optional[pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgs']]]] = None,
                 protocol_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] mode: Speed limit mode, value [1 (based on source IP speed limit) 2 (based on destination port speed limit)].
        :param pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgs']]] speed_values: Speed limit values, each type of speed limit value can support up to 1; This field array has at least one speed limit value.
        :param pulumi.Input[_builtins.str] dst_port_list: List of port ranges, up to 8, multiple; Separate and indicate the range with -; This port range must be filled in; Fill in style 1:0-65535, style 2: 80; 443; 1000-2000.
        :param pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgs']]] dst_port_scopes: This field has been deprecated. Please fill in the new field DstPortList.
        :param pulumi.Input[_builtins.str] protocol_list: IP protocol numbers, values [ALL (all protocols) TCP (tcp protocol) UDP (udp protocol) SMP (smp protocol) 1; 2-100 (custom protocol number range, up to 8)] Note: When customizing the protocol number range, only the protocol number can be filled in, multiple ranges; Separation; When filling in ALL, no other agreements or agreements can be filled inNumber.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "speed_values", speed_values)
        if dst_port_list is not None:
            pulumi.set(__self__, "dst_port_list", dst_port_list)
        if dst_port_scopes is not None:
            pulumi.set(__self__, "dst_port_scopes", dst_port_scopes)
        if protocol_list is not None:
            pulumi.set(__self__, "protocol_list", protocol_list)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.int]:
        """
        Speed limit mode, value [1 (based on source IP speed limit) 2 (based on destination port speed limit)].
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="speedValues")
    def speed_values(self) -> pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgs']]]:
        """
        Speed limit values, each type of speed limit value can support up to 1; This field array has at least one speed limit value.
        """
        return pulumi.get(self, "speed_values")

    @speed_values.setter
    def speed_values(self, value: pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgs']]]):
        pulumi.set(self, "speed_values", value)

    @_builtins.property
    @pulumi.getter(name="dstPortList")
    def dst_port_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        List of port ranges, up to 8, multiple; Separate and indicate the range with -; This port range must be filled in; Fill in style 1:0-65535, style 2: 80; 443; 1000-2000.
        """
        return pulumi.get(self, "dst_port_list")

    @dst_port_list.setter
    def dst_port_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dst_port_list", value)

    @_builtins.property
    @pulumi.getter(name="dstPortScopes")
    def dst_port_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgs']]]]:
        """
        This field has been deprecated. Please fill in the new field DstPortList.
        """
        return pulumi.get(self, "dst_port_scopes")

    @dst_port_scopes.setter
    def dst_port_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgs']]]]):
        pulumi.set(self, "dst_port_scopes", value)

    @_builtins.property
    @pulumi.getter(name="protocolList")
    def protocol_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP protocol numbers, values [ALL (all protocols) TCP (tcp protocol) UDP (udp protocol) SMP (smp protocol) 1; 2-100 (custom protocol number range, up to 8)] Note: When customizing the protocol number range, only the protocol number can be filled in, multiple ranges; Separation; When filling in ALL, no other agreements or agreements can be filled inNumber.
        """
        return pulumi.get(self, "protocol_list")

    @protocol_list.setter
    def protocol_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol_list", value)


if not MYPY:
    class DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgsDict(TypedDict):
        begin_port: pulumi.Input[_builtins.int]
        """
        Starting port, ranging from 1 to 65535.
        """
        end_port: pulumi.Input[_builtins.int]
        """
        end  port, ranging from 1 to 65535.
        """
elif False:
    DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScopeArgs:
    def __init__(__self__, *,
                 begin_port: pulumi.Input[_builtins.int],
                 end_port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] begin_port: Starting port, ranging from 1 to 65535.
        :param pulumi.Input[_builtins.int] end_port: end  port, ranging from 1 to 65535.
        """
        pulumi.set(__self__, "begin_port", begin_port)
        pulumi.set(__self__, "end_port", end_port)

    @_builtins.property
    @pulumi.getter(name="beginPort")
    def begin_port(self) -> pulumi.Input[_builtins.int]:
        """
        Starting port, ranging from 1 to 65535.
        """
        return pulumi.get(self, "begin_port")

    @begin_port.setter
    def begin_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "begin_port", value)

    @_builtins.property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[_builtins.int]:
        """
        end  port, ranging from 1 to 65535.
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "end_port", value)


if not MYPY:
    class DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgsDict(TypedDict):
        type: pulumi.Input[_builtins.int]
        """
        Speed limit value type, value [1 (packet rate pps) 2 (bandwidth bps)].
        """
        value: pulumi.Input[_builtins.int]
        """
        value.
        """
elif False:
    DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValueArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.int],
                 value: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] type: Speed limit value type, value [1 (packet rate pps) 2 (bandwidth bps)].
        :param pulumi.Input[_builtins.int] value: value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.int]:
        """
        Speed limit value type, value [1 (packet rate pps) 2 (bandwidth bps)].
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DefaultAlarmThresholdDefaultAlarmConfigArgsDict(TypedDict):
        alarm_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm threshold, in Mbps, with a value of&gt;=0; When used as an input parameter, setting 0 will delete the alarm threshold configuration;.
        """
        alarm_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm threshold type, value [1 (incoming traffic alarm threshold) 2 (attack cleaning traffic alarm threshold)].
        """
elif False:
    DefaultAlarmThresholdDefaultAlarmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefaultAlarmThresholdDefaultAlarmConfigArgs:
    def __init__(__self__, *,
                 alarm_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] alarm_threshold: Alarm threshold, in Mbps, with a value of&gt;=0; When used as an input parameter, setting 0 will delete the alarm threshold configuration;.
        :param pulumi.Input[_builtins.int] alarm_type: Alarm threshold type, value [1 (incoming traffic alarm threshold) 2 (attack cleaning traffic alarm threshold)].
        """
        if alarm_threshold is not None:
            pulumi.set(__self__, "alarm_threshold", alarm_threshold)
        if alarm_type is not None:
            pulumi.set(__self__, "alarm_type", alarm_type)

    @_builtins.property
    @pulumi.getter(name="alarmThreshold")
    def alarm_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm threshold, in Mbps, with a value of&gt;=0; When used as an input parameter, setting 0 will delete the alarm threshold configuration;.
        """
        return pulumi.get(self, "alarm_threshold")

    @alarm_threshold.setter
    def alarm_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_threshold", value)

    @_builtins.property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm threshold type, value [1 (incoming traffic alarm threshold) 2 (attack cleaning traffic alarm threshold)].
        """
        return pulumi.get(self, "alarm_type")

    @alarm_type.setter
    def alarm_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_type", value)


if not MYPY:
    class PacketFilterConfigPacketFilterConfigArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action, value [drop (discard) transmit (release) drop_black (discard and pull black) drop_rst (intercept) drop_black_rst (intercept and pull black) forward (continue protection)].
        """
        dport_end: pulumi.Input[_builtins.int]
        """
        end destination port, ranging from 0 to 65535.
        """
        dport_start: pulumi.Input[_builtins.int]
        """
        Starting destination port, ranging from 0 to 65535.
        """
        pktlen_max: pulumi.Input[_builtins.int]
        """
        The maximum message length, ranging from 1 to 1500, must be greater than or equal to the minimum message length.
        """
        pktlen_min: pulumi.Input[_builtins.int]
        """
        Minimum message length, ranging from 1 to 1500.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol, value [TCP udp icmp all].
        """
        sport_end: pulumi.Input[_builtins.int]
        """
        End source port, values range from 1 to 65535, must be greater than or equal to the start source port.
        """
        sport_start: pulumi.Input[_builtins.int]
        """
        Starting source port, ranging from 0 to 65535.
        """
        depth: NotRequired[pulumi.Input[_builtins.int]]
        """
        The detection depth starting from the detection position, with a value of [0-1500].
        """
        depth2: NotRequired[pulumi.Input[_builtins.int]]
        """
        The second detection depth starting from the second detection position, with a value of [01500].
        """
        is_not: NotRequired[pulumi.Input[_builtins.int]]
        """
        Whether to include detection values, with a value of [0 (inclusive) and 1 (exclusive)].
        """
        is_not2: NotRequired[pulumi.Input[_builtins.int]]
        """
        Whether the second detection includes detection values, with a value of [0 (inclusive) and 1 (exclusive)].
        """
        match_begin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detection position, value [begin_l3 (IP header) begin_l4 (TCP/UDP header) begin_l5 (T payload) no_match (mismatch)].
        """
        match_begin2: NotRequired[pulumi.Input[_builtins.str]]
        """
        Second detection position, value [begin_l5 (load) no_match (mismatch)].
        """
        match_logic: NotRequired[pulumi.Input[_builtins.str]]
        """
        When there is a second detection condition, the AND or relationship with the first detection condition, with the value [and (and relationship) none (fill in this value when there is no second detection condition)].
        """
        match_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detection type, value [Sunday (keyword) pcre (regular expression)].
        """
        match_type2: NotRequired[pulumi.Input[_builtins.str]]
        """
        The second detection type, with a value of [Sunday (keyword) pcre (regular expression)].
        """
        offset: NotRequired[pulumi.Input[_builtins.int]]
        """
        The offset from the detection position, with a value range of [0, Depth].
        """
        offset2: NotRequired[pulumi.Input[_builtins.int]]
        """
        The offset from the second detection position, with a value range of [0, Depth2].
        """
        pkt_len_gt: NotRequired[pulumi.Input[_builtins.int]]
        """
        Greater than message length, value 1+.
        """
        str: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detection value, key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
        """
        str2: NotRequired[pulumi.Input[_builtins.str]]
        """
        key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
        """
elif False:
    PacketFilterConfigPacketFilterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PacketFilterConfigPacketFilterConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 dport_end: pulumi.Input[_builtins.int],
                 dport_start: pulumi.Input[_builtins.int],
                 pktlen_max: pulumi.Input[_builtins.int],
                 pktlen_min: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 sport_end: pulumi.Input[_builtins.int],
                 sport_start: pulumi.Input[_builtins.int],
                 depth: Optional[pulumi.Input[_builtins.int]] = None,
                 depth2: Optional[pulumi.Input[_builtins.int]] = None,
                 is_not: Optional[pulumi.Input[_builtins.int]] = None,
                 is_not2: Optional[pulumi.Input[_builtins.int]] = None,
                 match_begin: Optional[pulumi.Input[_builtins.str]] = None,
                 match_begin2: Optional[pulumi.Input[_builtins.str]] = None,
                 match_logic: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type2: Optional[pulumi.Input[_builtins.str]] = None,
                 offset: Optional[pulumi.Input[_builtins.int]] = None,
                 offset2: Optional[pulumi.Input[_builtins.int]] = None,
                 pkt_len_gt: Optional[pulumi.Input[_builtins.int]] = None,
                 str: Optional[pulumi.Input[_builtins.str]] = None,
                 str2: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action, value [drop (discard) transmit (release) drop_black (discard and pull black) drop_rst (intercept) drop_black_rst (intercept and pull black) forward (continue protection)].
        :param pulumi.Input[_builtins.int] dport_end: end destination port, ranging from 0 to 65535.
        :param pulumi.Input[_builtins.int] dport_start: Starting destination port, ranging from 0 to 65535.
        :param pulumi.Input[_builtins.int] pktlen_max: The maximum message length, ranging from 1 to 1500, must be greater than or equal to the minimum message length.
        :param pulumi.Input[_builtins.int] pktlen_min: Minimum message length, ranging from 1 to 1500.
        :param pulumi.Input[_builtins.str] protocol: Protocol, value [TCP udp icmp all].
        :param pulumi.Input[_builtins.int] sport_end: End source port, values range from 1 to 65535, must be greater than or equal to the start source port.
        :param pulumi.Input[_builtins.int] sport_start: Starting source port, ranging from 0 to 65535.
        :param pulumi.Input[_builtins.int] depth: The detection depth starting from the detection position, with a value of [0-1500].
        :param pulumi.Input[_builtins.int] depth2: The second detection depth starting from the second detection position, with a value of [01500].
        :param pulumi.Input[_builtins.int] is_not: Whether to include detection values, with a value of [0 (inclusive) and 1 (exclusive)].
        :param pulumi.Input[_builtins.int] is_not2: Whether the second detection includes detection values, with a value of [0 (inclusive) and 1 (exclusive)].
        :param pulumi.Input[_builtins.str] match_begin: Detection position, value [begin_l3 (IP header) begin_l4 (TCP/UDP header) begin_l5 (T payload) no_match (mismatch)].
        :param pulumi.Input[_builtins.str] match_begin2: Second detection position, value [begin_l5 (load) no_match (mismatch)].
        :param pulumi.Input[_builtins.str] match_logic: When there is a second detection condition, the AND or relationship with the first detection condition, with the value [and (and relationship) none (fill in this value when there is no second detection condition)].
        :param pulumi.Input[_builtins.str] match_type: Detection type, value [Sunday (keyword) pcre (regular expression)].
        :param pulumi.Input[_builtins.str] match_type2: The second detection type, with a value of [Sunday (keyword) pcre (regular expression)].
        :param pulumi.Input[_builtins.int] offset: The offset from the detection position, with a value range of [0, Depth].
        :param pulumi.Input[_builtins.int] offset2: The offset from the second detection position, with a value range of [0, Depth2].
        :param pulumi.Input[_builtins.int] pkt_len_gt: Greater than message length, value 1+.
        :param pulumi.Input[_builtins.str] str: Detection value, key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
        :param pulumi.Input[_builtins.str] str2: key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "dport_end", dport_end)
        pulumi.set(__self__, "dport_start", dport_start)
        pulumi.set(__self__, "pktlen_max", pktlen_max)
        pulumi.set(__self__, "pktlen_min", pktlen_min)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "sport_end", sport_end)
        pulumi.set(__self__, "sport_start", sport_start)
        if depth is not None:
            pulumi.set(__self__, "depth", depth)
        if depth2 is not None:
            pulumi.set(__self__, "depth2", depth2)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)
        if is_not2 is not None:
            pulumi.set(__self__, "is_not2", is_not2)
        if match_begin is not None:
            pulumi.set(__self__, "match_begin", match_begin)
        if match_begin2 is not None:
            pulumi.set(__self__, "match_begin2", match_begin2)
        if match_logic is not None:
            pulumi.set(__self__, "match_logic", match_logic)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_type2 is not None:
            pulumi.set(__self__, "match_type2", match_type2)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if offset2 is not None:
            pulumi.set(__self__, "offset2", offset2)
        if pkt_len_gt is not None:
            pulumi.set(__self__, "pkt_len_gt", pkt_len_gt)
        if str is not None:
            pulumi.set(__self__, "str", str)
        if str2 is not None:
            pulumi.set(__self__, "str2", str2)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action, value [drop (discard) transmit (release) drop_black (discard and pull black) drop_rst (intercept) drop_black_rst (intercept and pull black) forward (continue protection)].
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="dportEnd")
    def dport_end(self) -> pulumi.Input[_builtins.int]:
        """
        end destination port, ranging from 0 to 65535.
        """
        return pulumi.get(self, "dport_end")

    @dport_end.setter
    def dport_end(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "dport_end", value)

    @_builtins.property
    @pulumi.getter(name="dportStart")
    def dport_start(self) -> pulumi.Input[_builtins.int]:
        """
        Starting destination port, ranging from 0 to 65535.
        """
        return pulumi.get(self, "dport_start")

    @dport_start.setter
    def dport_start(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "dport_start", value)

    @_builtins.property
    @pulumi.getter(name="pktlenMax")
    def pktlen_max(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum message length, ranging from 1 to 1500, must be greater than or equal to the minimum message length.
        """
        return pulumi.get(self, "pktlen_max")

    @pktlen_max.setter
    def pktlen_max(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "pktlen_max", value)

    @_builtins.property
    @pulumi.getter(name="pktlenMin")
    def pktlen_min(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum message length, ranging from 1 to 1500.
        """
        return pulumi.get(self, "pktlen_min")

    @pktlen_min.setter
    def pktlen_min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "pktlen_min", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol, value [TCP udp icmp all].
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="sportEnd")
    def sport_end(self) -> pulumi.Input[_builtins.int]:
        """
        End source port, values range from 1 to 65535, must be greater than or equal to the start source port.
        """
        return pulumi.get(self, "sport_end")

    @sport_end.setter
    def sport_end(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "sport_end", value)

    @_builtins.property
    @pulumi.getter(name="sportStart")
    def sport_start(self) -> pulumi.Input[_builtins.int]:
        """
        Starting source port, ranging from 0 to 65535.
        """
        return pulumi.get(self, "sport_start")

    @sport_start.setter
    def sport_start(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "sport_start", value)

    @_builtins.property
    @pulumi.getter
    def depth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The detection depth starting from the detection position, with a value of [0-1500].
        """
        return pulumi.get(self, "depth")

    @depth.setter
    def depth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "depth", value)

    @_builtins.property
    @pulumi.getter
    def depth2(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The second detection depth starting from the second detection position, with a value of [01500].
        """
        return pulumi.get(self, "depth2")

    @depth2.setter
    def depth2(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "depth2", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether to include detection values, with a value of [0 (inclusive) and 1 (exclusive)].
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_not", value)

    @_builtins.property
    @pulumi.getter(name="isNot2")
    def is_not2(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether the second detection includes detection values, with a value of [0 (inclusive) and 1 (exclusive)].
        """
        return pulumi.get(self, "is_not2")

    @is_not2.setter
    def is_not2(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_not2", value)

    @_builtins.property
    @pulumi.getter(name="matchBegin")
    def match_begin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detection position, value [begin_l3 (IP header) begin_l4 (TCP/UDP header) begin_l5 (T payload) no_match (mismatch)].
        """
        return pulumi.get(self, "match_begin")

    @match_begin.setter
    def match_begin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_begin", value)

    @_builtins.property
    @pulumi.getter(name="matchBegin2")
    def match_begin2(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Second detection position, value [begin_l5 (load) no_match (mismatch)].
        """
        return pulumi.get(self, "match_begin2")

    @match_begin2.setter
    def match_begin2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_begin2", value)

    @_builtins.property
    @pulumi.getter(name="matchLogic")
    def match_logic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When there is a second detection condition, the AND or relationship with the first detection condition, with the value [and (and relationship) none (fill in this value when there is no second detection condition)].
        """
        return pulumi.get(self, "match_logic")

    @match_logic.setter
    def match_logic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_logic", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detection type, value [Sunday (keyword) pcre (regular expression)].
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchType2")
    def match_type2(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The second detection type, with a value of [Sunday (keyword) pcre (regular expression)].
        """
        return pulumi.get(self, "match_type2")

    @match_type2.setter
    def match_type2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type2", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The offset from the detection position, with a value range of [0, Depth].
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def offset2(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The offset from the second detection position, with a value range of [0, Depth2].
        """
        return pulumi.get(self, "offset2")

    @offset2.setter
    def offset2(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "offset2", value)

    @_builtins.property
    @pulumi.getter(name="pktLenGt")
    def pkt_len_gt(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Greater than message length, value 1+.
        """
        return pulumi.get(self, "pkt_len_gt")

    @pkt_len_gt.setter
    def pkt_len_gt(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pkt_len_gt", value)

    @_builtins.property
    @pulumi.getter
    def str(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detection value, key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
        """
        return pulumi.get(self, "str")

    @str.setter
    def str(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "str", value)

    @_builtins.property
    @pulumi.getter
    def str2(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
        """
        return pulumi.get(self, "str2")

    @str2.setter
    def str2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "str2", value)


if not MYPY:
    class PortAclConfigAclConfigArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action, can take values: drop, transmit, forward.
        """
        d_port_end: pulumi.Input[_builtins.int]
        """
        end from port, with a range of 0~65535 values.
        """
        d_port_start: pulumi.Input[_builtins.int]
        """
        Starting from port, with a range of 0~65535 values.
        """
        forward_protocol: pulumi.Input[_builtins.str]
        """
        Protocol type, can take TCP, udp, all values.
        """
        s_port_end: pulumi.Input[_builtins.int]
        """
        end from the source port, with a value range of 0~65535.
        """
        s_port_start: pulumi.Input[_builtins.int]
        """
        Starting from the source port, with a value range of 0~65535.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The policy priority, the smaller the number, the higher the level, and the higher the matching of the rule, with values ranging from 1 to 1000. Note: This field may return null, indicating that a valid value cannot be obtained.
        """
elif False:
    PortAclConfigAclConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortAclConfigAclConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 d_port_end: pulumi.Input[_builtins.int],
                 d_port_start: pulumi.Input[_builtins.int],
                 forward_protocol: pulumi.Input[_builtins.str],
                 s_port_end: pulumi.Input[_builtins.int],
                 s_port_start: pulumi.Input[_builtins.int],
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action, can take values: drop, transmit, forward.
        :param pulumi.Input[_builtins.int] d_port_end: end from port, with a range of 0~65535 values.
        :param pulumi.Input[_builtins.int] d_port_start: Starting from port, with a range of 0~65535 values.
        :param pulumi.Input[_builtins.str] forward_protocol: Protocol type, can take TCP, udp, all values.
        :param pulumi.Input[_builtins.int] s_port_end: end from the source port, with a value range of 0~65535.
        :param pulumi.Input[_builtins.int] s_port_start: Starting from the source port, with a value range of 0~65535.
        :param pulumi.Input[_builtins.int] priority: The policy priority, the smaller the number, the higher the level, and the higher the matching of the rule, with values ranging from 1 to 1000. Note: This field may return null, indicating that a valid value cannot be obtained.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "d_port_end", d_port_end)
        pulumi.set(__self__, "d_port_start", d_port_start)
        pulumi.set(__self__, "forward_protocol", forward_protocol)
        pulumi.set(__self__, "s_port_end", s_port_end)
        pulumi.set(__self__, "s_port_start", s_port_start)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action, can take values: drop, transmit, forward.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="dPortEnd")
    def d_port_end(self) -> pulumi.Input[_builtins.int]:
        """
        end from port, with a range of 0~65535 values.
        """
        return pulumi.get(self, "d_port_end")

    @d_port_end.setter
    def d_port_end(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "d_port_end", value)

    @_builtins.property
    @pulumi.getter(name="dPortStart")
    def d_port_start(self) -> pulumi.Input[_builtins.int]:
        """
        Starting from port, with a range of 0~65535 values.
        """
        return pulumi.get(self, "d_port_start")

    @d_port_start.setter
    def d_port_start(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "d_port_start", value)

    @_builtins.property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol type, can take TCP, udp, all values.
        """
        return pulumi.get(self, "forward_protocol")

    @forward_protocol.setter
    def forward_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "forward_protocol", value)

    @_builtins.property
    @pulumi.getter(name="sPortEnd")
    def s_port_end(self) -> pulumi.Input[_builtins.int]:
        """
        end from the source port, with a value range of 0~65535.
        """
        return pulumi.get(self, "s_port_end")

    @s_port_end.setter
    def s_port_end(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "s_port_end", value)

    @_builtins.property
    @pulumi.getter(name="sPortStart")
    def s_port_start(self) -> pulumi.Input[_builtins.int]:
        """
        Starting from the source port, with a value range of 0~65535.
        """
        return pulumi.get(self, "s_port_start")

    @s_port_start.setter
    def s_port_start(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "s_port_start", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The policy priority, the smaller the number, the higher the level, and the higher the matching of the rule, with values ranging from 1 to 1000. Note: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


