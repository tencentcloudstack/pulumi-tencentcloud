# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AlarmAlarmTarget',
    'AlarmAnalysis',
    'AlarmAnalysisConfigInfo',
    'AlarmCallBack',
    'AlarmMonitorTime',
    'AlarmMultiCondition',
    'AlarmNoticeNoticeReceiver',
    'AlarmNoticeWebCallback',
    'CkafkaConsumerCkafka',
    'CkafkaConsumerContent',
    'ConfigExcludePath',
    'ConfigExtraContainerFile',
    'ConfigExtraContainerFileWorkload',
    'ConfigExtraContainerStdout',
    'ConfigExtraContainerStdoutWorkload',
    'ConfigExtraExcludePath',
    'ConfigExtraExtractRule',
    'ConfigExtraExtractRuleFilterKeyRegex',
    'ConfigExtraHostFile',
    'ConfigExtractRule',
    'ConfigExtractRuleFilterKeyRegex',
    'ConfigExtractRuleMetaTag',
    'CosRechargeExtractRuleInfo',
    'CosRechargeExtractRuleInfoFilterKeyRegex',
    'CosRechargeExtractRuleInfoMetaTag',
    'CosShipperCompress',
    'CosShipperContent',
    'CosShipperContentCsv',
    'CosShipperContentJson',
    'CosShipperFilterRule',
    'DataTransformDstResource',
    'IndexRule',
    'IndexRuleDynamicIndex',
    'IndexRuleFullText',
    'IndexRuleKeyValue',
    'IndexRuleKeyValueKeyValue',
    'IndexRuleKeyValueKeyValueValue',
    'IndexRuleTag',
    'IndexRuleTagKeyValue',
    'IndexRuleTagKeyValueValue',
    'KafkaRechargeLogRechargeRule',
    'KafkaRechargeProtocol',
    'MachineGroupMachineGroupType',
    'NoticeContentNoticeContents',
    'NoticeContentNoticeContentsRecoveryContent',
    'NoticeContentNoticeContentsTriggerContent',
    'ScheduledSqlDstResource',
    'TopicExtends',
    'TopicExtendsAnonymousAccess',
    'TopicExtendsAnonymousAccessCondition',
    'GetLogsetsFilterResult',
    'GetLogsetsLogsetResult',
    'GetLogsetsLogsetTagResult',
    'GetMachineGroupConfigsConfigResult',
    'GetMachineGroupConfigsConfigExcludePathResult',
    'GetMachineGroupConfigsConfigExtractRuleResult',
    'GetMachineGroupConfigsConfigExtractRuleFilterKeyRegexResult',
    'GetMachineGroupConfigsConfigExtractRuleMetaTagResult',
    'GetMachinesMachineResult',
    'GetShipperTasksTaskResult',
    'GetTopicsFilterResult',
    'GetTopicsTopicResult',
    'GetTopicsTopicTagResult',
]

@pulumi.output_type
class AlarmAlarmTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "logsetId":
            suggest = "logset_id"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "topicId":
            suggest = "topic_id"
        elif key == "syntaxRule":
            suggest = "syntax_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmAlarmTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmAlarmTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmAlarmTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time_offset: _builtins.int,
                 logset_id: _builtins.str,
                 number: _builtins.int,
                 query: _builtins.str,
                 start_time_offset: _builtins.int,
                 topic_id: _builtins.str,
                 syntax_rule: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_time_offset: search end time of offset.
        :param _builtins.str logset_id: logset id.
        :param _builtins.int number: the number of alarm object.
        :param _builtins.str query: query rules.
        :param _builtins.int start_time_offset: search start time of offset.
        :param _builtins.str topic_id: topic id.
        :param _builtins.int syntax_rule: Retrieve grammar rules, 0: Lucene syntax, 1: CQL syntax, Default value is 0.
        """
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "logset_id", logset_id)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        pulumi.set(__self__, "topic_id", topic_id)
        if syntax_rule is not None:
            pulumi.set(__self__, "syntax_rule", syntax_rule)

    @_builtins.property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> _builtins.int:
        """
        search end time of offset.
        """
        return pulumi.get(self, "end_time_offset")

    @_builtins.property
    @pulumi.getter(name="logsetId")
    def logset_id(self) -> _builtins.str:
        """
        logset id.
        """
        return pulumi.get(self, "logset_id")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        the number of alarm object.
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        """
        query rules.
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> _builtins.int:
        """
        search start time of offset.
        """
        return pulumi.get(self, "start_time_offset")

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> _builtins.str:
        """
        topic id.
        """
        return pulumi.get(self, "topic_id")

    @_builtins.property
    @pulumi.getter(name="syntaxRule")
    def syntax_rule(self) -> Optional[_builtins.int]:
        """
        Retrieve grammar rules, 0: Lucene syntax, 1: CQL syntax, Default value is 0.
        """
        return pulumi.get(self, "syntax_rule")


@pulumi.output_type
class AlarmAnalysis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configInfos":
            suggest = "config_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmAnalysis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmAnalysis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmAnalysis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 config_infos: Optional[Sequence['outputs.AlarmAnalysisConfigInfo']] = None):
        """
        :param _builtins.str content: analysis content.
        :param _builtins.str name: analysis name.
        :param _builtins.str type: analysis type.
        :param Sequence['AlarmAnalysisConfigInfoArgs'] config_infos: configuration.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if config_infos is not None:
            pulumi.set(__self__, "config_infos", config_infos)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        analysis content.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        analysis name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        analysis type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="configInfos")
    def config_infos(self) -> Optional[Sequence['outputs.AlarmAnalysisConfigInfo']]:
        """
        configuration.
        """
        return pulumi.get(self, "config_infos")


@pulumi.output_type
class AlarmAnalysisConfigInfo(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: key.
        :param _builtins.str value: value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlarmCallBack(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 headers: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str body: callback body.
        :param Sequence[_builtins.str] headers: callback headers.
        """
        pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        callback body.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        callback headers.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class AlarmMonitorTime(dict):
    def __init__(__self__, *,
                 time: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int time: time period or point in time.
        :param _builtins.str type: Period for periodic execution, Fixed for regular execution.
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.int:
        """
        time period or point in time.
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Period for periodic execution, Fixed for regular execution.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AlarmMultiCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmLevel":
            suggest = "alarm_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmMultiCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmMultiCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmMultiCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_level: Optional[_builtins.int] = None,
                 condition: Optional[_builtins.str] = None):
        """
        :param _builtins.int alarm_level: Alarm level. 0: Warning; 1: Info; 2: Critical. Default is 0.
        :param _builtins.str condition: Trigger condition.
        """
        if alarm_level is not None:
            pulumi.set(__self__, "alarm_level", alarm_level)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> Optional[_builtins.int]:
        """
        Alarm level. 0: Warning; 1: Info; 2: Critical. Default is 0.
        """
        return pulumi.get(self, "alarm_level")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        Trigger condition.
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class AlarmNoticeNoticeReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "receiverChannels":
            suggest = "receiver_channels"
        elif key == "receiverIds":
            suggest = "receiver_ids"
        elif key == "receiverType":
            suggest = "receiver_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "noticeContentId":
            suggest = "notice_content_id"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmNoticeNoticeReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmNoticeNoticeReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmNoticeNoticeReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 receiver_channels: Sequence[_builtins.str],
                 receiver_ids: Sequence[_builtins.int],
                 receiver_type: _builtins.str,
                 end_time: Optional[_builtins.str] = None,
                 index: Optional[_builtins.int] = None,
                 notice_content_id: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] receiver_channels: Receiver channels, Value: Email, Sms, WeChat, Phone.
        :param Sequence[_builtins.int] receiver_ids: Receiver id list.
        :param _builtins.str receiver_type: Receiver type, Uin or Group.
        :param _builtins.str end_time: End time allowed to receive messages.
        :param _builtins.int index: Index. The input parameter is invalid, but the output parameter is valid.
        :param _builtins.str notice_content_id: Notice content ID.
        :param _builtins.str start_time: Start time allowed to receive messages.
        """
        pulumi.set(__self__, "receiver_channels", receiver_channels)
        pulumi.set(__self__, "receiver_ids", receiver_ids)
        pulumi.set(__self__, "receiver_type", receiver_type)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if notice_content_id is not None:
            pulumi.set(__self__, "notice_content_id", notice_content_id)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="receiverChannels")
    def receiver_channels(self) -> Sequence[_builtins.str]:
        """
        Receiver channels, Value: Email, Sms, WeChat, Phone.
        """
        return pulumi.get(self, "receiver_channels")

    @_builtins.property
    @pulumi.getter(name="receiverIds")
    def receiver_ids(self) -> Sequence[_builtins.int]:
        """
        Receiver id list.
        """
        return pulumi.get(self, "receiver_ids")

    @_builtins.property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> _builtins.str:
        """
        Receiver type, Uin or Group.
        """
        return pulumi.get(self, "receiver_type")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time allowed to receive messages.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.int]:
        """
        Index. The input parameter is invalid, but the output parameter is valid.
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="noticeContentId")
    def notice_content_id(self) -> Optional[_builtins.str]:
        """
        Notice content ID.
        """
        return pulumi.get(self, "notice_content_id")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time allowed to receive messages.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AlarmNoticeWebCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "callbackType":
            suggest = "callback_type"
        elif key == "noticeContentId":
            suggest = "notice_content_id"
        elif key == "remindType":
            suggest = "remind_type"
        elif key == "userIds":
            suggest = "user_ids"
        elif key == "webCallbackId":
            suggest = "web_callback_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmNoticeWebCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmNoticeWebCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmNoticeWebCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 callback_type: _builtins.str,
                 url: _builtins.str,
                 body: Optional[_builtins.str] = None,
                 headers: Optional[Sequence[_builtins.str]] = None,
                 index: Optional[_builtins.int] = None,
                 method: Optional[_builtins.str] = None,
                 mobiles: Optional[Sequence[_builtins.str]] = None,
                 notice_content_id: Optional[_builtins.str] = None,
                 remind_type: Optional[_builtins.int] = None,
                 user_ids: Optional[Sequence[_builtins.str]] = None,
                 web_callback_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str callback_type: Callback type, Values: Http, WeCom, DingTalk, Lark.
        :param _builtins.str url: Callback url.
        :param _builtins.str body: This parameter is deprecated. Please use `notice_content_id`. Request body.
        :param Sequence[_builtins.str] headers: This parameter is deprecated. Please use `notice_content_id`. Request headers.
        :param _builtins.int index: Index. The input parameter is invalid, but the output parameter is valid.
        :param _builtins.str method: Method, POST or PUT.
        :param Sequence[_builtins.str] mobiles: Telephone list.
        :param _builtins.str notice_content_id: Notice content ID.
        :param _builtins.int remind_type: Remind type. 0: Do not remind; 1: Specified person; 2: Everyone.
        :param Sequence[_builtins.str] user_ids: User ID list.
        :param _builtins.str web_callback_id: Integration configuration ID.
        """
        pulumi.set(__self__, "callback_type", callback_type)
        pulumi.set(__self__, "url", url)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mobiles is not None:
            pulumi.set(__self__, "mobiles", mobiles)
        if notice_content_id is not None:
            pulumi.set(__self__, "notice_content_id", notice_content_id)
        if remind_type is not None:
            pulumi.set(__self__, "remind_type", remind_type)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)
        if web_callback_id is not None:
            pulumi.set(__self__, "web_callback_id", web_callback_id)

    @_builtins.property
    @pulumi.getter(name="callbackType")
    def callback_type(self) -> _builtins.str:
        """
        Callback type, Values: Http, WeCom, DingTalk, Lark.
        """
        return pulumi.get(self, "callback_type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Callback url.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please use `notice_content_id`.""")
    def body(self) -> Optional[_builtins.str]:
        """
        This parameter is deprecated. Please use `notice_content_id`. Request body.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please use `notice_content_id`.""")
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        This parameter is deprecated. Please use `notice_content_id`. Request headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.int]:
        """
        Index. The input parameter is invalid, but the output parameter is valid.
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Method, POST or PUT.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def mobiles(self) -> Optional[Sequence[_builtins.str]]:
        """
        Telephone list.
        """
        return pulumi.get(self, "mobiles")

    @_builtins.property
    @pulumi.getter(name="noticeContentId")
    def notice_content_id(self) -> Optional[_builtins.str]:
        """
        Notice content ID.
        """
        return pulumi.get(self, "notice_content_id")

    @_builtins.property
    @pulumi.getter(name="remindType")
    def remind_type(self) -> Optional[_builtins.int]:
        """
        Remind type. 0: Do not remind; 1: Specified person; 2: Everyone.
        """
        return pulumi.get(self, "remind_type")

    @_builtins.property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        User ID list.
        """
        return pulumi.get(self, "user_ids")

    @_builtins.property
    @pulumi.getter(name="webCallbackId")
    def web_callback_id(self) -> Optional[_builtins.str]:
        """
        Integration configuration ID.
        """
        return pulumi.get(self, "web_callback_id")


@pulumi.output_type
class CkafkaConsumerCkafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "topicId":
            suggest = "topic_id"
        elif key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CkafkaConsumerCkafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CkafkaConsumerCkafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CkafkaConsumerCkafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str,
                 topic_id: _builtins.str,
                 topic_name: _builtins.str,
                 vip: _builtins.str,
                 vport: _builtins.str):
        """
        :param _builtins.str instance_id: instance id.
        :param _builtins.str instance_name: instance name.
        :param _builtins.str topic_id: topic id of ckafka.
        :param _builtins.str topic_name: topic name of ckafka.
        :param _builtins.str vip: vip.
        :param _builtins.str vport: vport.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "topic_id", topic_id)
        pulumi.set(__self__, "topic_name", topic_name)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vport", vport)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        instance id.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        instance name.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> _builtins.str:
        """
        topic id of ckafka.
        """
        return pulumi.get(self, "topic_id")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        topic name of ckafka.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> _builtins.str:
        """
        vip.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter
    def vport(self) -> _builtins.str:
        """
        vport.
        """
        return pulumi.get(self, "vport")


@pulumi.output_type
class CkafkaConsumerContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableTag":
            suggest = "enable_tag"
        elif key == "metaFields":
            suggest = "meta_fields"
        elif key == "tagJsonNotTiled":
            suggest = "tag_json_not_tiled"
        elif key == "timestampAccuracy":
            suggest = "timestamp_accuracy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CkafkaConsumerContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CkafkaConsumerContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CkafkaConsumerContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_tag: _builtins.bool,
                 meta_fields: Sequence[_builtins.str],
                 tag_json_not_tiled: Optional[_builtins.bool] = None,
                 timestamp_accuracy: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable_tag: whether to deliver the TAG info.
        :param Sequence[_builtins.str] meta_fields: metadata info list.
        :param _builtins.bool tag_json_not_tiled: whether to tiling tag json.
        :param _builtins.int timestamp_accuracy: delivery timestamp precision,1 for second, 2 for millisecond.
        """
        pulumi.set(__self__, "enable_tag", enable_tag)
        pulumi.set(__self__, "meta_fields", meta_fields)
        if tag_json_not_tiled is not None:
            pulumi.set(__self__, "tag_json_not_tiled", tag_json_not_tiled)
        if timestamp_accuracy is not None:
            pulumi.set(__self__, "timestamp_accuracy", timestamp_accuracy)

    @_builtins.property
    @pulumi.getter(name="enableTag")
    def enable_tag(self) -> _builtins.bool:
        """
        whether to deliver the TAG info.
        """
        return pulumi.get(self, "enable_tag")

    @_builtins.property
    @pulumi.getter(name="metaFields")
    def meta_fields(self) -> Sequence[_builtins.str]:
        """
        metadata info list.
        """
        return pulumi.get(self, "meta_fields")

    @_builtins.property
    @pulumi.getter(name="tagJsonNotTiled")
    def tag_json_not_tiled(self) -> Optional[_builtins.bool]:
        """
        whether to tiling tag json.
        """
        return pulumi.get(self, "tag_json_not_tiled")

    @_builtins.property
    @pulumi.getter(name="timestampAccuracy")
    def timestamp_accuracy(self) -> Optional[_builtins.int]:
        """
        delivery timestamp precision,1 for second, 2 for millisecond.
        """
        return pulumi.get(self, "timestamp_accuracy")


@pulumi.output_type
class ConfigExcludePath(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type. Valid values: File, Path.
        :param _builtins.str value: Specific content corresponding to Type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type. Valid values: File, Path.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specific content corresponding to Type.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConfigExtraContainerFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePattern":
            suggest = "file_pattern"
        elif key == "logPath":
            suggest = "log_path"
        elif key == "excludeLabels":
            suggest = "exclude_labels"
        elif key == "excludeNamespace":
            suggest = "exclude_namespace"
        elif key == "includeLabels":
            suggest = "include_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigExtraContainerFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigExtraContainerFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigExtraContainerFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: _builtins.str,
                 file_pattern: _builtins.str,
                 log_path: _builtins.str,
                 namespace: _builtins.str,
                 exclude_labels: Optional[Sequence[_builtins.str]] = None,
                 exclude_namespace: Optional[_builtins.str] = None,
                 include_labels: Optional[Sequence[_builtins.str]] = None,
                 workload: Optional['outputs.ConfigExtraContainerFileWorkload'] = None):
        """
        :param _builtins.str container: container name.
        :param _builtins.str file_pattern: log name.
        :param _builtins.str log_path: Log Path.
        :param _builtins.str namespace: namespace.
        :param Sequence[_builtins.str] exclude_labels: Pod label to be excluded.
        :param _builtins.str exclude_namespace: Namespaces to be excluded, separated by separators, such as A, B.
        :param Sequence[_builtins.str] include_labels: Pod label info.
        :param 'ConfigExtraContainerFileWorkloadArgs' workload: Workload info.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "file_pattern", file_pattern)
        pulumi.set(__self__, "log_path", log_path)
        pulumi.set(__self__, "namespace", namespace)
        if exclude_labels is not None:
            pulumi.set(__self__, "exclude_labels", exclude_labels)
        if exclude_namespace is not None:
            pulumi.set(__self__, "exclude_namespace", exclude_namespace)
        if include_labels is not None:
            pulumi.set(__self__, "include_labels", include_labels)
        if workload is not None:
            pulumi.set(__self__, "workload", workload)

    @_builtins.property
    @pulumi.getter
    def container(self) -> _builtins.str:
        """
        container name.
        """
        return pulumi.get(self, "container")

    @_builtins.property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> _builtins.str:
        """
        log name.
        """
        return pulumi.get(self, "file_pattern")

    @_builtins.property
    @pulumi.getter(name="logPath")
    def log_path(self) -> _builtins.str:
        """
        Log Path.
        """
        return pulumi.get(self, "log_path")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="excludeLabels")
    def exclude_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod label to be excluded.
        """
        return pulumi.get(self, "exclude_labels")

    @_builtins.property
    @pulumi.getter(name="excludeNamespace")
    def exclude_namespace(self) -> Optional[_builtins.str]:
        """
        Namespaces to be excluded, separated by separators, such as A, B.
        """
        return pulumi.get(self, "exclude_namespace")

    @_builtins.property
    @pulumi.getter(name="includeLabels")
    def include_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod label info.
        """
        return pulumi.get(self, "include_labels")

    @_builtins.property
    @pulumi.getter
    def workload(self) -> Optional['outputs.ConfigExtraContainerFileWorkload']:
        """
        Workload info.
        """
        return pulumi.get(self, "workload")


@pulumi.output_type
class ConfigExtraContainerFileWorkload(dict):
    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: _builtins.str,
                 container: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: workload type.
        :param _builtins.str name: workload name.
        :param _builtins.str container: container name.
        :param _builtins.str namespace: namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        workload type.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        workload name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def container(self) -> Optional[_builtins.str]:
        """
        container name.
        """
        return pulumi.get(self, "container")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ConfigExtraContainerStdout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allContainers":
            suggest = "all_containers"
        elif key == "excludeLabels":
            suggest = "exclude_labels"
        elif key == "excludeNamespace":
            suggest = "exclude_namespace"
        elif key == "includeLabels":
            suggest = "include_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigExtraContainerStdout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigExtraContainerStdout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigExtraContainerStdout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_containers: _builtins.bool,
                 exclude_labels: Optional[Sequence[_builtins.str]] = None,
                 exclude_namespace: Optional[_builtins.str] = None,
                 include_labels: Optional[Sequence[_builtins.str]] = None,
                 namespace: Optional[_builtins.str] = None,
                 workloads: Optional[Sequence['outputs.ConfigExtraContainerStdoutWorkload']] = None):
        """
        :param _builtins.bool all_containers: Is all containers.
        :param Sequence[_builtins.str] exclude_labels: Pod label to be excluded.
        :param _builtins.str exclude_namespace: Namespaces to be excluded, separated by separators, such as A, B.
        :param Sequence[_builtins.str] include_labels: Pod label info.
        :param _builtins.str namespace: namespace.
        :param Sequence['ConfigExtraContainerStdoutWorkloadArgs'] workloads: Workload info.
        """
        pulumi.set(__self__, "all_containers", all_containers)
        if exclude_labels is not None:
            pulumi.set(__self__, "exclude_labels", exclude_labels)
        if exclude_namespace is not None:
            pulumi.set(__self__, "exclude_namespace", exclude_namespace)
        if include_labels is not None:
            pulumi.set(__self__, "include_labels", include_labels)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if workloads is not None:
            pulumi.set(__self__, "workloads", workloads)

    @_builtins.property
    @pulumi.getter(name="allContainers")
    def all_containers(self) -> _builtins.bool:
        """
        Is all containers.
        """
        return pulumi.get(self, "all_containers")

    @_builtins.property
    @pulumi.getter(name="excludeLabels")
    def exclude_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod label to be excluded.
        """
        return pulumi.get(self, "exclude_labels")

    @_builtins.property
    @pulumi.getter(name="excludeNamespace")
    def exclude_namespace(self) -> Optional[_builtins.str]:
        """
        Namespaces to be excluded, separated by separators, such as A, B.
        """
        return pulumi.get(self, "exclude_namespace")

    @_builtins.property
    @pulumi.getter(name="includeLabels")
    def include_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod label info.
        """
        return pulumi.get(self, "include_labels")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def workloads(self) -> Optional[Sequence['outputs.ConfigExtraContainerStdoutWorkload']]:
        """
        Workload info.
        """
        return pulumi.get(self, "workloads")


@pulumi.output_type
class ConfigExtraContainerStdoutWorkload(dict):
    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: _builtins.str,
                 container: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: workload type.
        :param _builtins.str name: workload name.
        :param _builtins.str container: container name.
        :param _builtins.str namespace: namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        workload type.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        workload name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def container(self) -> Optional[_builtins.str]:
        """
        container name.
        """
        return pulumi.get(self, "container")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ConfigExtraExcludePath(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type. Valid values: File, Path.
        :param _builtins.str value: Specific content corresponding to Type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type. Valid values: File, Path.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specific content corresponding to Type.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConfigExtraExtractRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginRegex":
            suggest = "begin_regex"
        elif key == "filterKeyRegexes":
            suggest = "filter_key_regexes"
        elif key == "logRegex":
            suggest = "log_regex"
        elif key == "timeFormat":
            suggest = "time_format"
        elif key == "timeKey":
            suggest = "time_key"
        elif key == "unMatchLogKey":
            suggest = "un_match_log_key"
        elif key == "unMatchUpLoadSwitch":
            suggest = "un_match_up_load_switch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigExtraExtractRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigExtraExtractRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigExtraExtractRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backtracking: Optional[_builtins.int] = None,
                 begin_regex: Optional[_builtins.str] = None,
                 delimiter: Optional[_builtins.str] = None,
                 filter_key_regexes: Optional[Sequence['outputs.ConfigExtraExtractRuleFilterKeyRegex']] = None,
                 keys: Optional[Sequence[_builtins.str]] = None,
                 log_regex: Optional[_builtins.str] = None,
                 time_format: Optional[_builtins.str] = None,
                 time_key: Optional[_builtins.str] = None,
                 un_match_log_key: Optional[_builtins.str] = None,
                 un_match_up_load_switch: Optional[_builtins.bool] = None):
        """
        :param _builtins.int backtracking: Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        :param _builtins.str begin_regex: First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        :param _builtins.str delimiter: Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        :param Sequence['ConfigExtraExtractRuleFilterKeyRegexArgs'] filter_key_regexes: Log keys to be filtered and the corresponding regex.
        :param Sequence[_builtins.str] keys: Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        :param _builtins.str log_regex: Full log matching rule, which is valid only if log_type is fullregex_log.
        :param _builtins.str time_format: Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        :param _builtins.str time_key: Time field key name. time_key and time_format must appear in pair.
        :param _builtins.str un_match_log_key: Unmatched log key.
        :param _builtins.bool un_match_up_load_switch: Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        if backtracking is not None:
            pulumi.set(__self__, "backtracking", backtracking)
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if filter_key_regexes is not None:
            pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @_builtins.property
    @pulumi.getter
    def backtracking(self) -> Optional[_builtins.int]:
        """
        Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        """
        return pulumi.get(self, "backtracking")

    @_builtins.property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[_builtins.str]:
        """
        First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        """
        return pulumi.get(self, "begin_regex")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Optional[Sequence['outputs.ConfigExtraExtractRuleFilterKeyRegex']]:
        """
        Log keys to be filtered and the corresponding regex.
        """
        return pulumi.get(self, "filter_key_regexes")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[_builtins.str]:
        """
        Full log matching rule, which is valid only if log_type is fullregex_log.
        """
        return pulumi.get(self, "log_regex")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[_builtins.str]:
        """
        Time field key name. time_key and time_format must appear in pair.
        """
        return pulumi.get(self, "time_key")

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[_builtins.str]:
        """
        Unmatched log key.
        """
        return pulumi.get(self, "un_match_log_key")

    @_builtins.property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[_builtins.bool]:
        """
        Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        return pulumi.get(self, "un_match_up_load_switch")


@pulumi.output_type
class ConfigExtraExtractRuleFilterKeyRegex(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Log key to be filtered.
        :param _builtins.str regex: Filter rule regex corresponding to key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Log key to be filtered.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Filter rule regex corresponding to key.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class ConfigExtraHostFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePattern":
            suggest = "file_pattern"
        elif key == "logPath":
            suggest = "log_path"
        elif key == "customLabels":
            suggest = "custom_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigExtraHostFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigExtraHostFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigExtraHostFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_pattern: _builtins.str,
                 log_path: _builtins.str,
                 custom_labels: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str file_pattern: Log file name.
        :param _builtins.str log_path: Log file dir.
        :param Sequence[_builtins.str] custom_labels: Metadata info.
        """
        pulumi.set(__self__, "file_pattern", file_pattern)
        pulumi.set(__self__, "log_path", log_path)
        if custom_labels is not None:
            pulumi.set(__self__, "custom_labels", custom_labels)

    @_builtins.property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> _builtins.str:
        """
        Log file name.
        """
        return pulumi.get(self, "file_pattern")

    @_builtins.property
    @pulumi.getter(name="logPath")
    def log_path(self) -> _builtins.str:
        """
        Log file dir.
        """
        return pulumi.get(self, "log_path")

    @_builtins.property
    @pulumi.getter(name="customLabels")
    def custom_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Metadata info.
        """
        return pulumi.get(self, "custom_labels")


@pulumi.output_type
class ConfigExtractRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginRegex":
            suggest = "begin_regex"
        elif key == "filterKeyRegexes":
            suggest = "filter_key_regexes"
        elif key == "isGbk":
            suggest = "is_gbk"
        elif key == "jsonStandard":
            suggest = "json_standard"
        elif key == "logRegex":
            suggest = "log_regex"
        elif key == "metaTags":
            suggest = "meta_tags"
        elif key == "metadataType":
            suggest = "metadata_type"
        elif key == "parseProtocol":
            suggest = "parse_protocol"
        elif key == "pathRegex":
            suggest = "path_regex"
        elif key == "timeFormat":
            suggest = "time_format"
        elif key == "timeKey":
            suggest = "time_key"
        elif key == "unMatchLogKey":
            suggest = "un_match_log_key"
        elif key == "unMatchUpLoadSwitch":
            suggest = "un_match_up_load_switch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigExtractRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigExtractRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigExtractRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 backtracking: Optional[_builtins.int] = None,
                 begin_regex: Optional[_builtins.str] = None,
                 delimiter: Optional[_builtins.str] = None,
                 filter_key_regexes: Optional[Sequence['outputs.ConfigExtractRuleFilterKeyRegex']] = None,
                 is_gbk: Optional[_builtins.int] = None,
                 json_standard: Optional[_builtins.int] = None,
                 keys: Optional[Sequence[_builtins.str]] = None,
                 log_regex: Optional[_builtins.str] = None,
                 meta_tags: Optional[Sequence['outputs.ConfigExtractRuleMetaTag']] = None,
                 metadata_type: Optional[_builtins.int] = None,
                 parse_protocol: Optional[_builtins.str] = None,
                 path_regex: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 time_format: Optional[_builtins.str] = None,
                 time_key: Optional[_builtins.str] = None,
                 un_match_log_key: Optional[_builtins.str] = None,
                 un_match_up_load_switch: Optional[_builtins.bool] = None):
        """
        :param _builtins.str address: syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        :param _builtins.int backtracking: Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        :param _builtins.str begin_regex: First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        :param _builtins.str delimiter: Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        :param Sequence['ConfigExtractRuleFilterKeyRegexArgs'] filter_key_regexes: Log keys to be filtered and the corresponding regex.
        :param _builtins.int is_gbk: GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
        :param _builtins.int json_standard: standard json. Default 0.
        :param Sequence[_builtins.str] keys: Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        :param _builtins.str log_regex: Full log matching rule, which is valid only if log_type is fullregex_log.
        :param Sequence['ConfigExtractRuleMetaTagArgs'] meta_tags: metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
        :param _builtins.int metadata_type: metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
        :param _builtins.str parse_protocol: parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        :param _builtins.str path_regex: metadata path regex.
        :param _builtins.str protocol: syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
        :param _builtins.str time_format: Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        :param _builtins.str time_key: Time field key name. time_key and time_format must appear in pair.
        :param _builtins.str un_match_log_key: Unmatched log key. Required when UnMatchUpLoadSwitch is true.
        :param _builtins.bool un_match_up_load_switch: Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if backtracking is not None:
            pulumi.set(__self__, "backtracking", backtracking)
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if filter_key_regexes is not None:
            pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        if is_gbk is not None:
            pulumi.set(__self__, "is_gbk", is_gbk)
        if json_standard is not None:
            pulumi.set(__self__, "json_standard", json_standard)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if meta_tags is not None:
            pulumi.set(__self__, "meta_tags", meta_tags)
        if metadata_type is not None:
            pulumi.set(__self__, "metadata_type", metadata_type)
        if parse_protocol is not None:
            pulumi.set(__self__, "parse_protocol", parse_protocol)
        if path_regex is not None:
            pulumi.set(__self__, "path_regex", path_regex)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def backtracking(self) -> Optional[_builtins.int]:
        """
        Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        """
        return pulumi.get(self, "backtracking")

    @_builtins.property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[_builtins.str]:
        """
        First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        """
        return pulumi.get(self, "begin_regex")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Optional[Sequence['outputs.ConfigExtractRuleFilterKeyRegex']]:
        """
        Log keys to be filtered and the corresponding regex.
        """
        return pulumi.get(self, "filter_key_regexes")

    @_builtins.property
    @pulumi.getter(name="isGbk")
    def is_gbk(self) -> Optional[_builtins.int]:
        """
        GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
        """
        return pulumi.get(self, "is_gbk")

    @_builtins.property
    @pulumi.getter(name="jsonStandard")
    def json_standard(self) -> Optional[_builtins.int]:
        """
        standard json. Default 0.
        """
        return pulumi.get(self, "json_standard")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[_builtins.str]:
        """
        Full log matching rule, which is valid only if log_type is fullregex_log.
        """
        return pulumi.get(self, "log_regex")

    @_builtins.property
    @pulumi.getter(name="metaTags")
    def meta_tags(self) -> Optional[Sequence['outputs.ConfigExtractRuleMetaTag']]:
        """
        metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
        """
        return pulumi.get(self, "meta_tags")

    @_builtins.property
    @pulumi.getter(name="metadataType")
    def metadata_type(self) -> Optional[_builtins.int]:
        """
        metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
        """
        return pulumi.get(self, "metadata_type")

    @_builtins.property
    @pulumi.getter(name="parseProtocol")
    def parse_protocol(self) -> Optional[_builtins.str]:
        """
        parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        """
        return pulumi.get(self, "parse_protocol")

    @_builtins.property
    @pulumi.getter(name="pathRegex")
    def path_regex(self) -> Optional[_builtins.str]:
        """
        metadata path regex.
        """
        return pulumi.get(self, "path_regex")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[_builtins.str]:
        """
        Time field key name. time_key and time_format must appear in pair.
        """
        return pulumi.get(self, "time_key")

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[_builtins.str]:
        """
        Unmatched log key. Required when UnMatchUpLoadSwitch is true.
        """
        return pulumi.get(self, "un_match_log_key")

    @_builtins.property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[_builtins.bool]:
        """
        Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        return pulumi.get(self, "un_match_up_load_switch")


@pulumi.output_type
class ConfigExtractRuleFilterKeyRegex(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Log key to be filtered.
        :param _builtins.str regex: Filter rule regex corresponding to key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Log key to be filtered.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Filter rule regex corresponding to key.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class ConfigExtractRuleMetaTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: tag key.
        :param _builtins.str value: tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CosRechargeExtractRuleInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginRegex":
            suggest = "begin_regex"
        elif key == "filterKeyRegexes":
            suggest = "filter_key_regexes"
        elif key == "isGbk":
            suggest = "is_gbk"
        elif key == "jsonStandard":
            suggest = "json_standard"
        elif key == "logRegex":
            suggest = "log_regex"
        elif key == "metaTags":
            suggest = "meta_tags"
        elif key == "metadataType":
            suggest = "metadata_type"
        elif key == "parseProtocol":
            suggest = "parse_protocol"
        elif key == "pathRegex":
            suggest = "path_regex"
        elif key == "timeFormat":
            suggest = "time_format"
        elif key == "timeKey":
            suggest = "time_key"
        elif key == "unMatchLogKey":
            suggest = "un_match_log_key"
        elif key == "unMatchUpLoadSwitch":
            suggest = "un_match_up_load_switch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CosRechargeExtractRuleInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CosRechargeExtractRuleInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CosRechargeExtractRuleInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 backtracking: Optional[_builtins.int] = None,
                 begin_regex: Optional[_builtins.str] = None,
                 delimiter: Optional[_builtins.str] = None,
                 filter_key_regexes: Optional[Sequence['outputs.CosRechargeExtractRuleInfoFilterKeyRegex']] = None,
                 is_gbk: Optional[_builtins.int] = None,
                 json_standard: Optional[_builtins.int] = None,
                 keys: Optional[Sequence[_builtins.str]] = None,
                 log_regex: Optional[_builtins.str] = None,
                 meta_tags: Optional[Sequence['outputs.CosRechargeExtractRuleInfoMetaTag']] = None,
                 metadata_type: Optional[_builtins.int] = None,
                 parse_protocol: Optional[_builtins.str] = None,
                 path_regex: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 time_format: Optional[_builtins.str] = None,
                 time_key: Optional[_builtins.str] = None,
                 un_match_log_key: Optional[_builtins.str] = None,
                 un_match_up_load_switch: Optional[_builtins.bool] = None):
        """
        :param _builtins.str address: syslog address.
        :param _builtins.int backtracking: backtracking data volume in incremental acquisition mode.
        :param _builtins.str begin_regex: begin line regex.
        :param _builtins.str delimiter: log delimiter.
        :param Sequence['CosRechargeExtractRuleInfoFilterKeyRegexArgs'] filter_key_regexes: rules that need to filter logs.
        :param _builtins.int is_gbk: gbk encoding.
        :param _builtins.int json_standard: is standard json.
        :param Sequence[_builtins.str] keys: key list.
        :param _builtins.str log_regex: log regex.
        :param Sequence['CosRechargeExtractRuleInfoMetaTagArgs'] meta_tags: metadata tag list.
        :param _builtins.int metadata_type: metadata type.
        :param _builtins.str parse_protocol: parse protocol.
        :param _builtins.str path_regex: metadata path regex.
        :param _builtins.str protocol: syslog protocol.
        :param _builtins.str time_format: time format.
        :param _builtins.str time_key: time key.
        :param _builtins.str un_match_log_key: parsing failure log key.
        :param _builtins.bool un_match_up_load_switch: whether to upload the parsing failure log.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if backtracking is not None:
            pulumi.set(__self__, "backtracking", backtracking)
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if filter_key_regexes is not None:
            pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        if is_gbk is not None:
            pulumi.set(__self__, "is_gbk", is_gbk)
        if json_standard is not None:
            pulumi.set(__self__, "json_standard", json_standard)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if meta_tags is not None:
            pulumi.set(__self__, "meta_tags", meta_tags)
        if metadata_type is not None:
            pulumi.set(__self__, "metadata_type", metadata_type)
        if parse_protocol is not None:
            pulumi.set(__self__, "parse_protocol", parse_protocol)
        if path_regex is not None:
            pulumi.set(__self__, "path_regex", path_regex)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        syslog address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def backtracking(self) -> Optional[_builtins.int]:
        """
        backtracking data volume in incremental acquisition mode.
        """
        return pulumi.get(self, "backtracking")

    @_builtins.property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[_builtins.str]:
        """
        begin line regex.
        """
        return pulumi.get(self, "begin_regex")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        log delimiter.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Optional[Sequence['outputs.CosRechargeExtractRuleInfoFilterKeyRegex']]:
        """
        rules that need to filter logs.
        """
        return pulumi.get(self, "filter_key_regexes")

    @_builtins.property
    @pulumi.getter(name="isGbk")
    def is_gbk(self) -> Optional[_builtins.int]:
        """
        gbk encoding.
        """
        return pulumi.get(self, "is_gbk")

    @_builtins.property
    @pulumi.getter(name="jsonStandard")
    def json_standard(self) -> Optional[_builtins.int]:
        """
        is standard json.
        """
        return pulumi.get(self, "json_standard")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        key list.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[_builtins.str]:
        """
        log regex.
        """
        return pulumi.get(self, "log_regex")

    @_builtins.property
    @pulumi.getter(name="metaTags")
    def meta_tags(self) -> Optional[Sequence['outputs.CosRechargeExtractRuleInfoMetaTag']]:
        """
        metadata tag list.
        """
        return pulumi.get(self, "meta_tags")

    @_builtins.property
    @pulumi.getter(name="metadataType")
    def metadata_type(self) -> Optional[_builtins.int]:
        """
        metadata type.
        """
        return pulumi.get(self, "metadata_type")

    @_builtins.property
    @pulumi.getter(name="parseProtocol")
    def parse_protocol(self) -> Optional[_builtins.str]:
        """
        parse protocol.
        """
        return pulumi.get(self, "parse_protocol")

    @_builtins.property
    @pulumi.getter(name="pathRegex")
    def path_regex(self) -> Optional[_builtins.str]:
        """
        metadata path regex.
        """
        return pulumi.get(self, "path_regex")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        syslog protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        time format.
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[_builtins.str]:
        """
        time key.
        """
        return pulumi.get(self, "time_key")

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[_builtins.str]:
        """
        parsing failure log key.
        """
        return pulumi.get(self, "un_match_log_key")

    @_builtins.property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[_builtins.bool]:
        """
        whether to upload the parsing failure log.
        """
        return pulumi.get(self, "un_match_up_load_switch")


@pulumi.output_type
class CosRechargeExtractRuleInfoFilterKeyRegex(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str key: need filter log key.
        :param _builtins.str regex: need filter log regex.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        need filter log key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        need filter log regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class CosRechargeExtractRuleInfoMetaTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: metadata key.
        :param _builtins.str value: metadata value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        metadata key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CosShipperCompress(dict):
    def __init__(__self__, *,
                 format: _builtins.str):
        """
        :param _builtins.str format: Compression format. Valid values: gzip, lzop, none (no compression).
        """
        pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        Compression format. Valid values: gzip, lzop, none (no compression).
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class CosShipperContent(dict):
    def __init__(__self__, *,
                 format: _builtins.str,
                 csv: Optional['outputs.CosShipperContentCsv'] = None,
                 json: Optional['outputs.CosShipperContentJson'] = None):
        """
        :param _builtins.str format: Content format. Valid values: json, csv.
        :param 'CosShipperContentCsvArgs' csv: CSV format content description.Note: this field may return null, indicating that no valid values can be obtained.
        :param 'CosShipperContentJsonArgs' json: JSON format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "format", format)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        Content format. Valid values: json, csv.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def csv(self) -> Optional['outputs.CosShipperContentCsv']:
        """
        CSV format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "csv")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional['outputs.CosShipperContentJson']:
        """
        JSON format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "json")


@pulumi.output_type
class CosShipperContentCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escapeChar":
            suggest = "escape_char"
        elif key == "nonExistingField":
            suggest = "non_existing_field"
        elif key == "printKey":
            suggest = "print_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CosShipperContentCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CosShipperContentCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CosShipperContentCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: _builtins.str,
                 escape_char: _builtins.str,
                 keys: Sequence[_builtins.str],
                 non_existing_field: _builtins.str,
                 print_key: _builtins.bool):
        """
        :param _builtins.str delimiter: Field delimiter.
        :param _builtins.str escape_char: Field delimiter.
        :param Sequence[_builtins.str] keys: Names of keys.Note: this field may return null, indicating that no valid values can be obtained.
        :param _builtins.str non_existing_field: Content used to populate non-existing fields.
        :param _builtins.bool print_key: Whether to print key on the first row of the CSV file.
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "escape_char", escape_char)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "non_existing_field", non_existing_field)
        pulumi.set(__self__, "print_key", print_key)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> _builtins.str:
        """
        Field delimiter.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> _builtins.str:
        """
        Field delimiter.
        """
        return pulumi.get(self, "escape_char")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence[_builtins.str]:
        """
        Names of keys.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="nonExistingField")
    def non_existing_field(self) -> _builtins.str:
        """
        Content used to populate non-existing fields.
        """
        return pulumi.get(self, "non_existing_field")

    @_builtins.property
    @pulumi.getter(name="printKey")
    def print_key(self) -> _builtins.bool:
        """
        Whether to print key on the first row of the CSV file.
        """
        return pulumi.get(self, "print_key")


@pulumi.output_type
class CosShipperContentJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableTag":
            suggest = "enable_tag"
        elif key == "metaFields":
            suggest = "meta_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CosShipperContentJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CosShipperContentJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CosShipperContentJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_tag: _builtins.bool,
                 meta_fields: Sequence[_builtins.str]):
        """
        :param _builtins.bool enable_tag: Enablement flag.
        :param Sequence[_builtins.str] meta_fields: Metadata information list
               Note: this field may return null, indicating that no valid values can be obtained..
        """
        pulumi.set(__self__, "enable_tag", enable_tag)
        pulumi.set(__self__, "meta_fields", meta_fields)

    @_builtins.property
    @pulumi.getter(name="enableTag")
    def enable_tag(self) -> _builtins.bool:
        """
        Enablement flag.
        """
        return pulumi.get(self, "enable_tag")

    @_builtins.property
    @pulumi.getter(name="metaFields")
    def meta_fields(self) -> Sequence[_builtins.str]:
        """
        Metadata information list
        Note: this field may return null, indicating that no valid values can be obtained..
        """
        return pulumi.get(self, "meta_fields")


@pulumi.output_type
class CosShipperFilterRule(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 regex: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Filter rule key.
        :param _builtins.str regex: Filter rule.
        :param _builtins.str value: Filter rule value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter rule key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Filter rule.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Filter rule value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataTransformDstResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicId":
            suggest = "topic_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataTransformDstResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataTransformDstResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataTransformDstResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: _builtins.str,
                 topic_id: _builtins.str):
        """
        :param _builtins.str alias: Alias.
        :param _builtins.str topic_id: Dst topic ID.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "topic_id", topic_id)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        Alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> _builtins.str:
        """
        Dst topic ID.
        """
        return pulumi.get(self, "topic_id")


@pulumi.output_type
class IndexRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicIndex":
            suggest = "dynamic_index"
        elif key == "fullText":
            suggest = "full_text"
        elif key == "keyValue":
            suggest = "key_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_index: Optional['outputs.IndexRuleDynamicIndex'] = None,
                 full_text: Optional['outputs.IndexRuleFullText'] = None,
                 key_value: Optional['outputs.IndexRuleKeyValue'] = None,
                 tag: Optional['outputs.IndexRuleTag'] = None):
        """
        :param 'IndexRuleDynamicIndexArgs' dynamic_index: The key value index is automatically configured. If it is empty, it means that the function is not enabled.
        :param 'IndexRuleFullTextArgs' full_text: Full-Text index configuration.
        :param 'IndexRuleKeyValueArgs' key_value: Key-Value index configuration.
        :param 'IndexRuleTagArgs' tag: Metafield index configuration.
        """
        if dynamic_index is not None:
            pulumi.set(__self__, "dynamic_index", dynamic_index)
        if full_text is not None:
            pulumi.set(__self__, "full_text", full_text)
        if key_value is not None:
            pulumi.set(__self__, "key_value", key_value)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="dynamicIndex")
    def dynamic_index(self) -> Optional['outputs.IndexRuleDynamicIndex']:
        """
        The key value index is automatically configured. If it is empty, it means that the function is not enabled.
        """
        return pulumi.get(self, "dynamic_index")

    @_builtins.property
    @pulumi.getter(name="fullText")
    def full_text(self) -> Optional['outputs.IndexRuleFullText']:
        """
        Full-Text index configuration.
        """
        return pulumi.get(self, "full_text")

    @_builtins.property
    @pulumi.getter(name="keyValue")
    def key_value(self) -> Optional['outputs.IndexRuleKeyValue']:
        """
        Key-Value index configuration.
        """
        return pulumi.get(self, "key_value")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional['outputs.IndexRuleTag']:
        """
        Metafield index configuration.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class IndexRuleDynamicIndex(dict):
    def __init__(__self__, *,
                 status: _builtins.bool):
        """
        :param _builtins.bool status: index automatic configuration switch.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.bool:
        """
        index automatic configuration switch.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class IndexRuleFullText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "containZH":
            suggest = "contain_zh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexRuleFullText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexRuleFullText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexRuleFullText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: _builtins.bool,
                 contain_zh: _builtins.bool,
                 tokenizer: _builtins.str):
        """
        :param _builtins.bool case_sensitive: Case sensitivity.
        :param _builtins.bool contain_zh: Whether Chinese characters are contained.
        :param _builtins.str tokenizer: Full-Text index delimiter. Each character in the string represents a delimiter.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        pulumi.set(__self__, "contain_zh", contain_zh)
        pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> _builtins.bool:
        """
        Case sensitivity.
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="containZH")
    def contain_zh(self) -> _builtins.bool:
        """
        Whether Chinese characters are contained.
        """
        return pulumi.get(self, "contain_zh")

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> _builtins.str:
        """
        Full-Text index delimiter. Each character in the string represents a delimiter.
        """
        return pulumi.get(self, "tokenizer")


@pulumi.output_type
class IndexRuleKeyValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "keyValues":
            suggest = "key_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexRuleKeyValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexRuleKeyValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexRuleKeyValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: _builtins.bool,
                 key_values: Optional[Sequence['outputs.IndexRuleKeyValueKeyValue']] = None):
        """
        :param _builtins.bool case_sensitive: Case sensitivity.
        :param Sequence['IndexRuleKeyValueKeyValueArgs'] key_values: Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key_values is not None:
            pulumi.set(__self__, "key_values", key_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> _builtins.bool:
        """
        Case sensitivity.
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="keyValues")
    def key_values(self) -> Optional[Sequence['outputs.IndexRuleKeyValueKeyValue']]:
        """
        Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        return pulumi.get(self, "key_values")


@pulumi.output_type
class IndexRuleKeyValueKeyValue(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional['outputs.IndexRuleKeyValueKeyValueValue'] = None):
        """
        :param _builtins.str key: When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        :param 'IndexRuleKeyValueKeyValueValueArgs' value: Field index description information.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.IndexRuleKeyValueKeyValueValue']:
        """
        Field index description information.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IndexRuleKeyValueKeyValueValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containZH":
            suggest = "contain_zh"
        elif key == "sqlFlag":
            suggest = "sql_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexRuleKeyValueKeyValueValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexRuleKeyValueKeyValueValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexRuleKeyValueKeyValueValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 contain_zh: Optional[_builtins.bool] = None,
                 sql_flag: Optional[_builtins.bool] = None,
                 tokenizer: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Field type. Valid values: long, text, double.
        :param _builtins.bool contain_zh: Whether Chinese characters are contained.
        :param _builtins.bool sql_flag: Whether the analysis feature is enabled for the field.
        :param _builtins.str tokenizer: Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        pulumi.set(__self__, "type", type)
        if contain_zh is not None:
            pulumi.set(__self__, "contain_zh", contain_zh)
        if sql_flag is not None:
            pulumi.set(__self__, "sql_flag", sql_flag)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Field type. Valid values: long, text, double.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="containZH")
    def contain_zh(self) -> Optional[_builtins.bool]:
        """
        Whether Chinese characters are contained.
        """
        return pulumi.get(self, "contain_zh")

    @_builtins.property
    @pulumi.getter(name="sqlFlag")
    def sql_flag(self) -> Optional[_builtins.bool]:
        """
        Whether the analysis feature is enabled for the field.
        """
        return pulumi.get(self, "sql_flag")

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[_builtins.str]:
        """
        Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        return pulumi.get(self, "tokenizer")


@pulumi.output_type
class IndexRuleTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "keyValues":
            suggest = "key_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexRuleTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexRuleTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexRuleTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: _builtins.bool,
                 key_values: Optional[Sequence['outputs.IndexRuleTagKeyValue']] = None):
        """
        :param _builtins.bool case_sensitive: Case sensitivity.
        :param Sequence['IndexRuleTagKeyValueArgs'] key_values: Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key_values is not None:
            pulumi.set(__self__, "key_values", key_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> _builtins.bool:
        """
        Case sensitivity.
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="keyValues")
    def key_values(self) -> Optional[Sequence['outputs.IndexRuleTagKeyValue']]:
        """
        Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        return pulumi.get(self, "key_values")


@pulumi.output_type
class IndexRuleTagKeyValue(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional['outputs.IndexRuleTagKeyValueValue'] = None):
        """
        :param _builtins.str key: When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        :param 'IndexRuleTagKeyValueValueArgs' value: Field index description information.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.IndexRuleTagKeyValueValue']:
        """
        Field index description information.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IndexRuleTagKeyValueValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containZH":
            suggest = "contain_zh"
        elif key == "sqlFlag":
            suggest = "sql_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexRuleTagKeyValueValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexRuleTagKeyValueValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexRuleTagKeyValueValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 contain_zh: Optional[_builtins.bool] = None,
                 sql_flag: Optional[_builtins.bool] = None,
                 tokenizer: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Field type. Valid values: long, text, double.
        :param _builtins.bool contain_zh: Whether Chinese characters are contained.
        :param _builtins.bool sql_flag: Whether the analysis feature is enabled for the field.
        :param _builtins.str tokenizer: Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        pulumi.set(__self__, "type", type)
        if contain_zh is not None:
            pulumi.set(__self__, "contain_zh", contain_zh)
        if sql_flag is not None:
            pulumi.set(__self__, "sql_flag", sql_flag)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Field type. Valid values: long, text, double.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="containZH")
    def contain_zh(self) -> Optional[_builtins.bool]:
        """
        Whether Chinese characters are contained.
        """
        return pulumi.get(self, "contain_zh")

    @_builtins.property
    @pulumi.getter(name="sqlFlag")
    def sql_flag(self) -> Optional[_builtins.bool]:
        """
        Whether the analysis feature is enabled for the field.
        """
        return pulumi.get(self, "sql_flag")

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[_builtins.str]:
        """
        Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        return pulumi.get(self, "tokenizer")


@pulumi.output_type
class KafkaRechargeLogRechargeRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTimeSwitch":
            suggest = "default_time_switch"
        elif key == "encodingFormat":
            suggest = "encoding_format"
        elif key == "rechargeType":
            suggest = "recharge_type"
        elif key == "defaultTimeSrc":
            suggest = "default_time_src"
        elif key == "logRegex":
            suggest = "log_regex"
        elif key == "timeFormat":
            suggest = "time_format"
        elif key == "timeKey":
            suggest = "time_key"
        elif key == "timeRegex":
            suggest = "time_regex"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "unMatchLogKey":
            suggest = "un_match_log_key"
        elif key == "unMatchLogSwitch":
            suggest = "un_match_log_switch"
        elif key == "unMatchLogTimeSrc":
            suggest = "un_match_log_time_src"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaRechargeLogRechargeRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaRechargeLogRechargeRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaRechargeLogRechargeRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_time_switch: _builtins.bool,
                 encoding_format: _builtins.int,
                 recharge_type: _builtins.str,
                 default_time_src: Optional[_builtins.int] = None,
                 keys: Optional[Sequence[_builtins.str]] = None,
                 log_regex: Optional[_builtins.str] = None,
                 metadatas: Optional[Sequence[_builtins.str]] = None,
                 time_format: Optional[_builtins.str] = None,
                 time_key: Optional[_builtins.str] = None,
                 time_regex: Optional[_builtins.str] = None,
                 time_zone: Optional[_builtins.str] = None,
                 un_match_log_key: Optional[_builtins.str] = None,
                 un_match_log_switch: Optional[_builtins.bool] = None,
                 un_match_log_time_src: Optional[_builtins.int] = None):
        """
        :param _builtins.bool default_time_switch: user default time.
        :param _builtins.int encoding_format: encoding format.
        :param _builtins.str recharge_type: recharge type.
        :param _builtins.int default_time_src: default time from.
        :param Sequence[_builtins.str] keys: log key list.
        :param _builtins.str log_regex: log regex.
        :param Sequence[_builtins.str] metadatas: metadata.
        :param _builtins.str time_format: time format.
        :param _builtins.str time_key: time key.
        :param _builtins.str time_regex: time regex.
        :param _builtins.str time_zone: time zone.
        :param _builtins.str un_match_log_key: parse failed log key.
        :param _builtins.bool un_match_log_switch: is push parse failed log.
        :param _builtins.int un_match_log_time_src: parse failed log time from.
        """
        pulumi.set(__self__, "default_time_switch", default_time_switch)
        pulumi.set(__self__, "encoding_format", encoding_format)
        pulumi.set(__self__, "recharge_type", recharge_type)
        if default_time_src is not None:
            pulumi.set(__self__, "default_time_src", default_time_src)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if time_regex is not None:
            pulumi.set(__self__, "time_regex", time_regex)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_log_switch is not None:
            pulumi.set(__self__, "un_match_log_switch", un_match_log_switch)
        if un_match_log_time_src is not None:
            pulumi.set(__self__, "un_match_log_time_src", un_match_log_time_src)

    @_builtins.property
    @pulumi.getter(name="defaultTimeSwitch")
    def default_time_switch(self) -> _builtins.bool:
        """
        user default time.
        """
        return pulumi.get(self, "default_time_switch")

    @_builtins.property
    @pulumi.getter(name="encodingFormat")
    def encoding_format(self) -> _builtins.int:
        """
        encoding format.
        """
        return pulumi.get(self, "encoding_format")

    @_builtins.property
    @pulumi.getter(name="rechargeType")
    def recharge_type(self) -> _builtins.str:
        """
        recharge type.
        """
        return pulumi.get(self, "recharge_type")

    @_builtins.property
    @pulumi.getter(name="defaultTimeSrc")
    def default_time_src(self) -> Optional[_builtins.int]:
        """
        default time from.
        """
        return pulumi.get(self, "default_time_src")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        log key list.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[_builtins.str]:
        """
        log regex.
        """
        return pulumi.get(self, "log_regex")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence[_builtins.str]]:
        """
        metadata.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        time format.
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[_builtins.str]:
        """
        time key.
        """
        return pulumi.get(self, "time_key")

    @_builtins.property
    @pulumi.getter(name="timeRegex")
    def time_regex(self) -> Optional[_builtins.str]:
        """
        time regex.
        """
        return pulumi.get(self, "time_regex")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        time zone.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[_builtins.str]:
        """
        parse failed log key.
        """
        return pulumi.get(self, "un_match_log_key")

    @_builtins.property
    @pulumi.getter(name="unMatchLogSwitch")
    def un_match_log_switch(self) -> Optional[_builtins.bool]:
        """
        is push parse failed log.
        """
        return pulumi.get(self, "un_match_log_switch")

    @_builtins.property
    @pulumi.getter(name="unMatchLogTimeSrc")
    def un_match_log_time_src(self) -> Optional[_builtins.int]:
        """
        parse failed log time from.
        """
        return pulumi.get(self, "un_match_log_time_src")


@pulumi.output_type
class KafkaRechargeProtocol(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaRechargeProtocol. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaRechargeProtocol.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaRechargeProtocol.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mechanism: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str mechanism: encryption type.
        :param _builtins.str password: user password.
        :param _builtins.str protocol: protocol type.
        :param _builtins.str user_name: username.
        """
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> Optional[_builtins.str]:
        """
        encryption type.
        """
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        user password.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        protocol type.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class MachineGroupMachineGroupType(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str type: Machine group type. Valid values: ip: the IP addresses of collection machines are stored in Values of the machine group; label: the tags of the machines are stored in Values of the machine group.
        :param Sequence[_builtins.str] values: Machine description list.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Machine group type. Valid values: ip: the IP addresses of collection machines are stored in Values of the machine group; label: the tags of the machines are stored in Values of the machine group.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Machine description list.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NoticeContentNoticeContents(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryContent":
            suggest = "recovery_content"
        elif key == "triggerContent":
            suggest = "trigger_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NoticeContentNoticeContents. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NoticeContentNoticeContents.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NoticeContentNoticeContents.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 recovery_content: Optional['outputs.NoticeContentNoticeContentsRecoveryContent'] = None,
                 trigger_content: Optional['outputs.NoticeContentNoticeContentsTriggerContent'] = None):
        """
        :param _builtins.str type: Channel type. Email: Email; Sms: SMS; WeChat: WeChat; Phone: Telephone; WeCom: Enterprise WeChat; DingTalk: DingTalk; Lark: Feishu; Http: Custom callback.
        :param 'NoticeContentNoticeContentsRecoveryContentArgs' recovery_content: Template for Alarm Recovery Notification Content.
        :param 'NoticeContentNoticeContentsTriggerContentArgs' trigger_content: Alarm triggered notification content template.
        """
        pulumi.set(__self__, "type", type)
        if recovery_content is not None:
            pulumi.set(__self__, "recovery_content", recovery_content)
        if trigger_content is not None:
            pulumi.set(__self__, "trigger_content", trigger_content)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Channel type. Email: Email; Sms: SMS; WeChat: WeChat; Phone: Telephone; WeCom: Enterprise WeChat; DingTalk: DingTalk; Lark: Feishu; Http: Custom callback.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="recoveryContent")
    def recovery_content(self) -> Optional['outputs.NoticeContentNoticeContentsRecoveryContent']:
        """
        Template for Alarm Recovery Notification Content.
        """
        return pulumi.get(self, "recovery_content")

    @_builtins.property
    @pulumi.getter(name="triggerContent")
    def trigger_content(self) -> Optional['outputs.NoticeContentNoticeContentsTriggerContent']:
        """
        Alarm triggered notification content template.
        """
        return pulumi.get(self, "trigger_content")


@pulumi.output_type
class NoticeContentNoticeContentsRecoveryContent(dict):
    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None,
                 headers: Optional[Sequence[_builtins.str]] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: Notification content template body information.
        :param Sequence[_builtins.str] headers: Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        :param _builtins.str title: Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Notification content template body information.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class NoticeContentNoticeContentsTriggerContent(dict):
    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None,
                 headers: Optional[Sequence[_builtins.str]] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: Notification content template body information.
        :param Sequence[_builtins.str] headers: Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        :param _builtins.str title: Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Notification content template body information.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class ScheduledSqlDstResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicId":
            suggest = "topic_id"
        elif key == "bizType":
            suggest = "biz_type"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledSqlDstResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledSqlDstResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledSqlDstResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_id: _builtins.str,
                 biz_type: Optional[_builtins.int] = None,
                 metric_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str topic_id: dst topic id.
        :param _builtins.int biz_type: topic type.
        :param _builtins.str metric_name: metric name.
        :param _builtins.str region: topic region.
        """
        pulumi.set(__self__, "topic_id", topic_id)
        if biz_type is not None:
            pulumi.set(__self__, "biz_type", biz_type)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> _builtins.str:
        """
        dst topic id.
        """
        return pulumi.get(self, "topic_id")

    @_builtins.property
    @pulumi.getter(name="bizType")
    def biz_type(self) -> Optional[_builtins.int]:
        """
        topic type.
        """
        return pulumi.get(self, "biz_type")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        topic region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class TopicExtends(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousAccess":
            suggest = "anonymous_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicExtends. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicExtends.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicExtends.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous_access: Optional['outputs.TopicExtendsAnonymousAccess'] = None):
        """
        :param 'TopicExtendsAnonymousAccessArgs' anonymous_access: Log topic authentication free configuration information.
        """
        if anonymous_access is not None:
            pulumi.set(__self__, "anonymous_access", anonymous_access)

    @_builtins.property
    @pulumi.getter(name="anonymousAccess")
    def anonymous_access(self) -> Optional['outputs.TopicExtendsAnonymousAccess']:
        """
        Log topic authentication free configuration information.
        """
        return pulumi.get(self, "anonymous_access")


@pulumi.output_type
class TopicExtendsAnonymousAccess(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.TopicExtendsAnonymousAccessCondition']] = None,
                 operations: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['TopicExtendsAnonymousAccessConditionArgs'] conditions: Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        :param Sequence[_builtins.str] operations: Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.TopicExtendsAnonymousAccessCondition']]:
        """
        Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
        return pulumi.get(self, "operations")


@pulumi.output_type
class TopicExtendsAnonymousAccessCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionValue":
            suggest = "condition_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicExtendsAnonymousAccessCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicExtendsAnonymousAccessCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicExtendsAnonymousAccessCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attributes: Optional[_builtins.str] = None,
                 condition_value: Optional[_builtins.str] = None,
                 rule: Optional[_builtins.int] = None):
        """
        :param _builtins.str attributes: Condition attribute, currently only VpcID is supported.
        :param _builtins.str condition_value: The value of the corresponding conditional attribute.
        :param _builtins.int rule: Conditional rule, 1: equal, 2: not equal.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if condition_value is not None:
            pulumi.set(__self__, "condition_value", condition_value)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[_builtins.str]:
        """
        Condition attribute, currently only VpcID is supported.
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> Optional[_builtins.str]:
        """
        The value of the corresponding conditional attribute.
        """
        return pulumi.get(self, "condition_value")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional[_builtins.int]:
        """
        Conditional rule, 1: equal, 2: not equal.
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class GetLogsetsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Fields that need to be filtered. Support: `logsetName`, `logsetId`, `tagKey`, `tag:tagKey`.
        :param Sequence[_builtins.str] values: The values that need to be filtered.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Fields that need to be filtered. Support: `logsetName`, `logsetId`, `tagKey`, `tag:tagKey`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that need to be filtered.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLogsetsLogsetResult(dict):
    def __init__(__self__, *,
                 assumer_name: _builtins.str,
                 create_time: _builtins.str,
                 logset_id: _builtins.str,
                 logset_name: _builtins.str,
                 role_name: _builtins.str,
                 tags: Sequence['outputs.GetLogsetsLogsetTagResult'],
                 topic_count: _builtins.int):
        """
        :param _builtins.str assumer_name: Cloud product identification, when the log set is created by another cloud product, this field will display the cloud product name, such as CDN, TKE.
        :param _builtins.str create_time: Create time.
        :param _builtins.str logset_id: Logset Id.
        :param _builtins.str logset_name: Logset name.
        :param _builtins.str role_name: If `assumer_name` is not empty, it indicates the service role that created the log set.
        :param Sequence['GetLogsetsLogsetTagArgs'] tags: Tags.
        :param _builtins.int topic_count: Topic count.
        """
        pulumi.set(__self__, "assumer_name", assumer_name)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "logset_id", logset_id)
        pulumi.set(__self__, "logset_name", logset_name)
        pulumi.set(__self__, "role_name", role_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "topic_count", topic_count)

    @_builtins.property
    @pulumi.getter(name="assumerName")
    def assumer_name(self) -> _builtins.str:
        """
        Cloud product identification, when the log set is created by another cloud product, this field will display the cloud product name, such as CDN, TKE.
        """
        return pulumi.get(self, "assumer_name")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="logsetId")
    def logset_id(self) -> _builtins.str:
        """
        Logset Id.
        """
        return pulumi.get(self, "logset_id")

    @_builtins.property
    @pulumi.getter(name="logsetName")
    def logset_name(self) -> _builtins.str:
        """
        Logset name.
        """
        return pulumi.get(self, "logset_name")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        If `assumer_name` is not empty, it indicates the service role that created the log set.
        """
        return pulumi.get(self, "role_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetLogsetsLogsetTagResult']:
        """
        Tags.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="topicCount")
    def topic_count(self) -> _builtins.int:
        """
        Topic count.
        """
        return pulumi.get(self, "topic_count")


@pulumi.output_type
class GetLogsetsLogsetTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Tag key.
        :param _builtins.str value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMachineGroupConfigsConfigResult(dict):
    def __init__(__self__, *,
                 config_id: _builtins.str,
                 create_time: _builtins.str,
                 exclude_paths: Sequence['outputs.GetMachineGroupConfigsConfigExcludePathResult'],
                 extract_rules: Sequence['outputs.GetMachineGroupConfigsConfigExtractRuleResult'],
                 log_format: _builtins.str,
                 log_type: _builtins.str,
                 name: _builtins.str,
                 output: _builtins.str,
                 path: _builtins.str,
                 update_time: _builtins.str,
                 user_define_rule: _builtins.str):
        """
        :param _builtins.str config_id: scrape config id.
        :param _builtins.str create_time: create time.
        :param Sequence['GetMachineGroupConfigsConfigExcludePathArgs'] exclude_paths: Collection path blocklist.
        :param Sequence['GetMachineGroupConfigsConfigExtractRuleArgs'] extract_rules: Extraction rule. If ExtractRule is set, LogType must be set.
        :param _builtins.str log_format: style of log format.
        :param _builtins.str log_type: log type.
        :param _builtins.str name: scrape config name.
        :param _builtins.str output: topicid.
        :param _builtins.str path: scrape log path.
        :param _builtins.str update_time: update time.
        :param _builtins.str user_define_rule: user define rule.
        """
        pulumi.set(__self__, "config_id", config_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "exclude_paths", exclude_paths)
        pulumi.set(__self__, "extract_rules", extract_rules)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output", output)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "user_define_rule", user_define_rule)

    @_builtins.property
    @pulumi.getter(name="configId")
    def config_id(self) -> _builtins.str:
        """
        scrape config id.
        """
        return pulumi.get(self, "config_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="excludePaths")
    def exclude_paths(self) -> Sequence['outputs.GetMachineGroupConfigsConfigExcludePathResult']:
        """
        Collection path blocklist.
        """
        return pulumi.get(self, "exclude_paths")

    @_builtins.property
    @pulumi.getter(name="extractRules")
    def extract_rules(self) -> Sequence['outputs.GetMachineGroupConfigsConfigExtractRuleResult']:
        """
        Extraction rule. If ExtractRule is set, LogType must be set.
        """
        return pulumi.get(self, "extract_rules")

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        """
        style of log format.
        """
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        """
        log type.
        """
        return pulumi.get(self, "log_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        scrape config name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def output(self) -> _builtins.str:
        """
        topicid.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        scrape log path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        update time.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="userDefineRule")
    def user_define_rule(self) -> _builtins.str:
        """
        user define rule.
        """
        return pulumi.get(self, "user_define_rule")


@pulumi.output_type
class GetMachineGroupConfigsConfigExcludePathResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str type: Type. Valid values: File, Path.
        :param _builtins.str value: tag value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type. Valid values: File, Path.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMachineGroupConfigsConfigExtractRuleResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 backtracking: _builtins.int,
                 begin_regex: _builtins.str,
                 delimiter: _builtins.str,
                 filter_key_regexes: Sequence['outputs.GetMachineGroupConfigsConfigExtractRuleFilterKeyRegexResult'],
                 is_gbk: _builtins.int,
                 json_standard: _builtins.int,
                 keys: Sequence[_builtins.str],
                 log_regex: _builtins.str,
                 meta_tags: Sequence['outputs.GetMachineGroupConfigsConfigExtractRuleMetaTagResult'],
                 metadata_type: _builtins.int,
                 parse_protocol: _builtins.str,
                 path_regex: _builtins.str,
                 protocol: _builtins.str,
                 time_format: _builtins.str,
                 time_key: _builtins.str,
                 un_match_log_key: _builtins.str,
                 un_match_up_load_switch: _builtins.bool):
        """
        :param _builtins.str address: syslog system log collection specifies the address and port that the collector listens to.
        :param _builtins.int backtracking: Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        :param _builtins.str begin_regex: First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        :param _builtins.str delimiter: Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        :param Sequence['GetMachineGroupConfigsConfigExtractRuleFilterKeyRegexArgs'] filter_key_regexes: Log keys to be filtered and the corresponding regex.
        :param _builtins.int is_gbk: GBK encoding. Default 0.
        :param _builtins.int json_standard: standard json. Default 0.
        :param Sequence[_builtins.str] keys: Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        :param _builtins.str log_regex: Full log matching rule, which is valid only if log_type is fullregex_log.
        :param Sequence['GetMachineGroupConfigsConfigExtractRuleMetaTagArgs'] meta_tags: metadata tags.
        :param _builtins.int metadata_type: metadata type.
        :param _builtins.str parse_protocol: parse protocol.
        :param _builtins.str path_regex: metadata path regex.
        :param _builtins.str protocol: syslog protocol, tcp or udp.
        :param _builtins.str time_format: Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        :param _builtins.str time_key: Time field key name. time_key and time_format must appear in pair.
        :param _builtins.str un_match_log_key: Unmatched log key.
        :param _builtins.bool un_match_up_load_switch: Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "backtracking", backtracking)
        pulumi.set(__self__, "begin_regex", begin_regex)
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        pulumi.set(__self__, "is_gbk", is_gbk)
        pulumi.set(__self__, "json_standard", json_standard)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "log_regex", log_regex)
        pulumi.set(__self__, "meta_tags", meta_tags)
        pulumi.set(__self__, "metadata_type", metadata_type)
        pulumi.set(__self__, "parse_protocol", parse_protocol)
        pulumi.set(__self__, "path_regex", path_regex)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "time_format", time_format)
        pulumi.set(__self__, "time_key", time_key)
        pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        syslog system log collection specifies the address and port that the collector listens to.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def backtracking(self) -> _builtins.int:
        """
        Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        """
        return pulumi.get(self, "backtracking")

    @_builtins.property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> _builtins.str:
        """
        First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        """
        return pulumi.get(self, "begin_regex")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> _builtins.str:
        """
        Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Sequence['outputs.GetMachineGroupConfigsConfigExtractRuleFilterKeyRegexResult']:
        """
        Log keys to be filtered and the corresponding regex.
        """
        return pulumi.get(self, "filter_key_regexes")

    @_builtins.property
    @pulumi.getter(name="isGbk")
    def is_gbk(self) -> _builtins.int:
        """
        GBK encoding. Default 0.
        """
        return pulumi.get(self, "is_gbk")

    @_builtins.property
    @pulumi.getter(name="jsonStandard")
    def json_standard(self) -> _builtins.int:
        """
        standard json. Default 0.
        """
        return pulumi.get(self, "json_standard")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence[_builtins.str]:
        """
        Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> _builtins.str:
        """
        Full log matching rule, which is valid only if log_type is fullregex_log.
        """
        return pulumi.get(self, "log_regex")

    @_builtins.property
    @pulumi.getter(name="metaTags")
    def meta_tags(self) -> Sequence['outputs.GetMachineGroupConfigsConfigExtractRuleMetaTagResult']:
        """
        metadata tags.
        """
        return pulumi.get(self, "meta_tags")

    @_builtins.property
    @pulumi.getter(name="metadataType")
    def metadata_type(self) -> _builtins.int:
        """
        metadata type.
        """
        return pulumi.get(self, "metadata_type")

    @_builtins.property
    @pulumi.getter(name="parseProtocol")
    def parse_protocol(self) -> _builtins.str:
        """
        parse protocol.
        """
        return pulumi.get(self, "parse_protocol")

    @_builtins.property
    @pulumi.getter(name="pathRegex")
    def path_regex(self) -> _builtins.str:
        """
        metadata path regex.
        """
        return pulumi.get(self, "path_regex")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        syslog protocol, tcp or udp.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> _builtins.str:
        """
        Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> _builtins.str:
        """
        Time field key name. time_key and time_format must appear in pair.
        """
        return pulumi.get(self, "time_key")

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> _builtins.str:
        """
        Unmatched log key.
        """
        return pulumi.get(self, "un_match_log_key")

    @_builtins.property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> _builtins.bool:
        """
        Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        return pulumi.get(self, "un_match_up_load_switch")


@pulumi.output_type
class GetMachineGroupConfigsConfigExtractRuleFilterKeyRegexResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str key: tag key.
        :param _builtins.str regex: Filter rule regex corresponding to key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Filter rule regex corresponding to key.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMachineGroupConfigsConfigExtractRuleMetaTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: tag key.
        :param _builtins.str value: tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMachinesMachineResult(dict):
    def __init__(__self__, *,
                 auto_update: _builtins.int,
                 err_code: _builtins.int,
                 err_msg: _builtins.str,
                 ip: _builtins.str,
                 offline_time: _builtins.str,
                 status: _builtins.int,
                 update_status: _builtins.int,
                 version: _builtins.str):
        """
        :param _builtins.int auto_update: if open auto update flag.
        :param _builtins.int err_code: code of update operation.
        :param _builtins.str err_msg: msg of update operation.
        :param _builtins.str ip: ip of machine.
        :param _builtins.str offline_time: offline time of machine.
        :param _builtins.int status: status of machine.
        :param _builtins.int update_status: machine update status.
        :param _builtins.str version: current machine version.
        """
        pulumi.set(__self__, "auto_update", auto_update)
        pulumi.set(__self__, "err_code", err_code)
        pulumi.set(__self__, "err_msg", err_msg)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "offline_time", offline_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_status", update_status)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> _builtins.int:
        """
        if open auto update flag.
        """
        return pulumi.get(self, "auto_update")

    @_builtins.property
    @pulumi.getter(name="errCode")
    def err_code(self) -> _builtins.int:
        """
        code of update operation.
        """
        return pulumi.get(self, "err_code")

    @_builtins.property
    @pulumi.getter(name="errMsg")
    def err_msg(self) -> _builtins.str:
        """
        msg of update operation.
        """
        return pulumi.get(self, "err_msg")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        ip of machine.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="offlineTime")
    def offline_time(self) -> _builtins.str:
        """
        offline time of machine.
        """
        return pulumi.get(self, "offline_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        status of machine.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateStatus")
    def update_status(self) -> _builtins.int:
        """
        machine update status.
        """
        return pulumi.get(self, "update_status")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        current machine version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetShipperTasksTaskResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.int,
                 message: _builtins.str,
                 range_end: _builtins.int,
                 range_start: _builtins.int,
                 shipper_id: _builtins.str,
                 start_time: _builtins.int,
                 status: _builtins.str,
                 task_id: _builtins.str,
                 topic_id: _builtins.str):
        """
        :param _builtins.int end_time: end time(ms).
        :param _builtins.str message: detail info.
        :param _builtins.int range_end: end time of current task (ms).
        :param _builtins.int range_start: start time of current task (ms).
        :param _builtins.str shipper_id: shipper id.
        :param _builtins.int start_time: start time(ms).
        :param _builtins.str status: status of current shipper task.
        :param _builtins.str task_id: task id.
        :param _builtins.str topic_id: topic id.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        pulumi.set(__self__, "shipper_id", shipper_id)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "topic_id", topic_id)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.int:
        """
        end time(ms).
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        detail info.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> _builtins.int:
        """
        end time of current task (ms).
        """
        return pulumi.get(self, "range_end")

    @_builtins.property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> _builtins.int:
        """
        start time of current task (ms).
        """
        return pulumi.get(self, "range_start")

    @_builtins.property
    @pulumi.getter(name="shipperId")
    def shipper_id(self) -> _builtins.str:
        """
        shipper id.
        """
        return pulumi.get(self, "shipper_id")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.int:
        """
        start time(ms).
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        status of current shipper task.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        task id.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> _builtins.str:
        """
        topic id.
        """
        return pulumi.get(self, "topic_id")


@pulumi.output_type
class GetTopicsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Field to be filtered.
        :param Sequence[_builtins.str] values: Value to be filtered.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Field to be filtered.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Value to be filtered.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTopicsTopicResult(dict):
    def __init__(__self__, *,
                 assumer_name: _builtins.str,
                 auto_split: _builtins.bool,
                 biz_type: _builtins.int,
                 create_time: _builtins.str,
                 describes: _builtins.str,
                 hot_period: _builtins.int,
                 index: _builtins.bool,
                 is_web_tracking: _builtins.bool,
                 logset_id: _builtins.str,
                 max_split_partitions: _builtins.int,
                 partition_count: _builtins.int,
                 period: _builtins.int,
                 status: _builtins.bool,
                 storage_type: _builtins.str,
                 sub_assumer_name: _builtins.str,
                 tags: Sequence['outputs.GetTopicsTopicTagResult'],
                 topic_id: _builtins.str,
                 topic_name: _builtins.str):
        """
        :param _builtins.str assumer_name: Cloud product identifier. When the topic is created by other cloud products, this field displays the name of the cloud product, such as CDN, TKE.Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.bool auto_split: Whether automatic split is enabled for this topic
               Note: this field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.int biz_type: Topic type
               - 0 (default): Log topic.
               - 1: Metric topic.
        :param _builtins.str create_time: Creation time.
        :param _builtins.str describes: Topic description
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int hot_period: Enable log sinking, with the lifecycle of standard storage, where hotPeriod < Period.For standard storage, hotPeriod is used, and for infrequent access storage, it is Period-hotPeriod. (The topic type must be a log topic)HotPeriod=0 indicates that log sinking is not enabled.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.bool index: Whether the topic has indexing enabled (the topic type must be log topic).
        :param _builtins.bool is_web_tracking: Free authentication switch. false: disabled; true: enabled.After enabling, anonymous access to the log topic will be supported for specified operations. For details, please refer to Log Topic (https://intl.cloud.tencent.com/document/product/614/41035?from_cn_redirect=1).Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str logset_id: Logset ID.
        :param _builtins.int max_split_partitions: Maximum number of partitions to split into for this topic if automatic split is enabled
               Note: this field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.int partition_count: Number of topic partitions.
        :param _builtins.int period: Lifecycle in days. Value range: 1-3600 (3640 indicates permanent retention)
               Note: This field may return `null`, indicating that no valid value was found.
        :param _builtins.bool status: Whether the topic has log collection enabled. true: collection enabled; false: collection disabled.Log collection is enabled by default when creating a log topic, and this field can be modified by calling ModifyTopic through the SDK.The console currently does not support modifying this parameter.
        :param _builtins.str storage_type: Storage type of the topicNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str sub_assumer_name: Cloud product sub-identifier. If the log topic is created by another cloud product, this field returns the name of the cloud product and its log type, such as `TKE-Audit` or `TKE-Event`. Some products only return the cloud product identifier (`AssumerName`), without this field.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetTopicsTopicTagArgs'] tags: Tag information bound to the topicNote: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str topic_id: Topic ID.
        :param _builtins.str topic_name: Topic Name.
        """
        pulumi.set(__self__, "assumer_name", assumer_name)
        pulumi.set(__self__, "auto_split", auto_split)
        pulumi.set(__self__, "biz_type", biz_type)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "describes", describes)
        pulumi.set(__self__, "hot_period", hot_period)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "is_web_tracking", is_web_tracking)
        pulumi.set(__self__, "logset_id", logset_id)
        pulumi.set(__self__, "max_split_partitions", max_split_partitions)
        pulumi.set(__self__, "partition_count", partition_count)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_type", storage_type)
        pulumi.set(__self__, "sub_assumer_name", sub_assumer_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "topic_id", topic_id)
        pulumi.set(__self__, "topic_name", topic_name)

    @_builtins.property
    @pulumi.getter(name="assumerName")
    def assumer_name(self) -> _builtins.str:
        """
        Cloud product identifier. When the topic is created by other cloud products, this field displays the name of the cloud product, such as CDN, TKE.Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "assumer_name")

    @_builtins.property
    @pulumi.getter(name="autoSplit")
    def auto_split(self) -> _builtins.bool:
        """
        Whether automatic split is enabled for this topic
        Note: this field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "auto_split")

    @_builtins.property
    @pulumi.getter(name="bizType")
    def biz_type(self) -> _builtins.int:
        """
        Topic type
        - 0 (default): Log topic.
        - 1: Metric topic.
        """
        return pulumi.get(self, "biz_type")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def describes(self) -> _builtins.str:
        """
        Topic description
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "describes")

    @_builtins.property
    @pulumi.getter(name="hotPeriod")
    def hot_period(self) -> _builtins.int:
        """
        Enable log sinking, with the lifecycle of standard storage, where hotPeriod < Period.For standard storage, hotPeriod is used, and for infrequent access storage, it is Period-hotPeriod. (The topic type must be a log topic)HotPeriod=0 indicates that log sinking is not enabled.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "hot_period")

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.bool:
        """
        Whether the topic has indexing enabled (the topic type must be log topic).
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="isWebTracking")
    def is_web_tracking(self) -> _builtins.bool:
        """
        Free authentication switch. false: disabled; true: enabled.After enabling, anonymous access to the log topic will be supported for specified operations. For details, please refer to Log Topic (https://intl.cloud.tencent.com/document/product/614/41035?from_cn_redirect=1).Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "is_web_tracking")

    @_builtins.property
    @pulumi.getter(name="logsetId")
    def logset_id(self) -> _builtins.str:
        """
        Logset ID.
        """
        return pulumi.get(self, "logset_id")

    @_builtins.property
    @pulumi.getter(name="maxSplitPartitions")
    def max_split_partitions(self) -> _builtins.int:
        """
        Maximum number of partitions to split into for this topic if automatic split is enabled
        Note: this field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "max_split_partitions")

    @_builtins.property
    @pulumi.getter(name="partitionCount")
    def partition_count(self) -> _builtins.int:
        """
        Number of topic partitions.
        """
        return pulumi.get(self, "partition_count")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        Lifecycle in days. Value range: 1-3600 (3640 indicates permanent retention)
        Note: This field may return `null`, indicating that no valid value was found.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.bool:
        """
        Whether the topic has log collection enabled. true: collection enabled; false: collection disabled.Log collection is enabled by default when creating a log topic, and this field can be modified by calling ModifyTopic through the SDK.The console currently does not support modifying this parameter.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> _builtins.str:
        """
        Storage type of the topicNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "storage_type")

    @_builtins.property
    @pulumi.getter(name="subAssumerName")
    def sub_assumer_name(self) -> _builtins.str:
        """
        Cloud product sub-identifier. If the log topic is created by another cloud product, this field returns the name of the cloud product and its log type, such as `TKE-Audit` or `TKE-Event`. Some products only return the cloud product identifier (`AssumerName`), without this field.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "sub_assumer_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetTopicsTopicTagResult']:
        """
        Tag information bound to the topicNote: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> _builtins.str:
        """
        Topic ID.
        """
        return pulumi.get(self, "topic_id")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        Topic Name.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class GetTopicsTopicTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The tag key.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str value: The tag value.
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The tag value.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "value")


