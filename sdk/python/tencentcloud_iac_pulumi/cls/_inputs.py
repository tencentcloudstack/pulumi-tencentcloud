# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlarmAlarmTargetArgs',
    'AlarmAlarmTargetArgsDict',
    'AlarmAnalysisArgs',
    'AlarmAnalysisArgsDict',
    'AlarmAnalysisConfigInfoArgs',
    'AlarmAnalysisConfigInfoArgsDict',
    'AlarmCallBackArgs',
    'AlarmCallBackArgsDict',
    'AlarmMonitorTimeArgs',
    'AlarmMonitorTimeArgsDict',
    'AlarmMultiConditionArgs',
    'AlarmMultiConditionArgsDict',
    'AlarmNoticeNoticeReceiverArgs',
    'AlarmNoticeNoticeReceiverArgsDict',
    'AlarmNoticeWebCallbackArgs',
    'AlarmNoticeWebCallbackArgsDict',
    'CkafkaConsumerCkafkaArgs',
    'CkafkaConsumerCkafkaArgsDict',
    'CkafkaConsumerContentArgs',
    'CkafkaConsumerContentArgsDict',
    'ConfigExcludePathArgs',
    'ConfigExcludePathArgsDict',
    'ConfigExtraContainerFileArgs',
    'ConfigExtraContainerFileArgsDict',
    'ConfigExtraContainerFileWorkloadArgs',
    'ConfigExtraContainerFileWorkloadArgsDict',
    'ConfigExtraContainerStdoutArgs',
    'ConfigExtraContainerStdoutArgsDict',
    'ConfigExtraContainerStdoutWorkloadArgs',
    'ConfigExtraContainerStdoutWorkloadArgsDict',
    'ConfigExtraExcludePathArgs',
    'ConfigExtraExcludePathArgsDict',
    'ConfigExtraExtractRuleArgs',
    'ConfigExtraExtractRuleArgsDict',
    'ConfigExtraExtractRuleFilterKeyRegexArgs',
    'ConfigExtraExtractRuleFilterKeyRegexArgsDict',
    'ConfigExtraHostFileArgs',
    'ConfigExtraHostFileArgsDict',
    'ConfigExtractRuleArgs',
    'ConfigExtractRuleArgsDict',
    'ConfigExtractRuleFilterKeyRegexArgs',
    'ConfigExtractRuleFilterKeyRegexArgsDict',
    'ConfigExtractRuleMetaTagArgs',
    'ConfigExtractRuleMetaTagArgsDict',
    'CosRechargeExtractRuleInfoArgs',
    'CosRechargeExtractRuleInfoArgsDict',
    'CosRechargeExtractRuleInfoFilterKeyRegexArgs',
    'CosRechargeExtractRuleInfoFilterKeyRegexArgsDict',
    'CosRechargeExtractRuleInfoMetaTagArgs',
    'CosRechargeExtractRuleInfoMetaTagArgsDict',
    'CosShipperCompressArgs',
    'CosShipperCompressArgsDict',
    'CosShipperContentArgs',
    'CosShipperContentArgsDict',
    'CosShipperContentCsvArgs',
    'CosShipperContentCsvArgsDict',
    'CosShipperContentJsonArgs',
    'CosShipperContentJsonArgsDict',
    'CosShipperFilterRuleArgs',
    'CosShipperFilterRuleArgsDict',
    'DataTransformDstResourceArgs',
    'DataTransformDstResourceArgsDict',
    'IndexRuleArgs',
    'IndexRuleArgsDict',
    'IndexRuleDynamicIndexArgs',
    'IndexRuleDynamicIndexArgsDict',
    'IndexRuleFullTextArgs',
    'IndexRuleFullTextArgsDict',
    'IndexRuleKeyValueArgs',
    'IndexRuleKeyValueArgsDict',
    'IndexRuleKeyValueKeyValueArgs',
    'IndexRuleKeyValueKeyValueArgsDict',
    'IndexRuleKeyValueKeyValueValueArgs',
    'IndexRuleKeyValueKeyValueValueArgsDict',
    'IndexRuleTagArgs',
    'IndexRuleTagArgsDict',
    'IndexRuleTagKeyValueArgs',
    'IndexRuleTagKeyValueArgsDict',
    'IndexRuleTagKeyValueValueArgs',
    'IndexRuleTagKeyValueValueArgsDict',
    'KafkaRechargeLogRechargeRuleArgs',
    'KafkaRechargeLogRechargeRuleArgsDict',
    'KafkaRechargeProtocolArgs',
    'KafkaRechargeProtocolArgsDict',
    'MachineGroupMachineGroupTypeArgs',
    'MachineGroupMachineGroupTypeArgsDict',
    'NoticeContentNoticeContentsArgs',
    'NoticeContentNoticeContentsArgsDict',
    'NoticeContentNoticeContentsRecoveryContentArgs',
    'NoticeContentNoticeContentsRecoveryContentArgsDict',
    'NoticeContentNoticeContentsTriggerContentArgs',
    'NoticeContentNoticeContentsTriggerContentArgsDict',
    'ScheduledSqlDstResourceArgs',
    'ScheduledSqlDstResourceArgsDict',
    'TopicExtendsArgs',
    'TopicExtendsArgsDict',
    'TopicExtendsAnonymousAccessArgs',
    'TopicExtendsAnonymousAccessArgsDict',
    'TopicExtendsAnonymousAccessConditionArgs',
    'TopicExtendsAnonymousAccessConditionArgsDict',
    'GetLogsetsFilterArgs',
    'GetLogsetsFilterArgsDict',
    'GetTopicsFilterArgs',
    'GetTopicsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AlarmAlarmTargetArgsDict(TypedDict):
        end_time_offset: pulumi.Input[_builtins.int]
        """
        search end time of offset.
        """
        logset_id: pulumi.Input[_builtins.str]
        """
        logset id.
        """
        number: pulumi.Input[_builtins.int]
        """
        the number of alarm object.
        """
        query: pulumi.Input[_builtins.str]
        """
        query rules.
        """
        start_time_offset: pulumi.Input[_builtins.int]
        """
        search start time of offset.
        """
        topic_id: pulumi.Input[_builtins.str]
        """
        topic id.
        """
        syntax_rule: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retrieve grammar rules, 0: Lucene syntax, 1: CQL syntax, Default value is 0.
        """
elif False:
    AlarmAlarmTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmAlarmTargetArgs:
    def __init__(__self__, *,
                 end_time_offset: pulumi.Input[_builtins.int],
                 logset_id: pulumi.Input[_builtins.str],
                 number: pulumi.Input[_builtins.int],
                 query: pulumi.Input[_builtins.str],
                 start_time_offset: pulumi.Input[_builtins.int],
                 topic_id: pulumi.Input[_builtins.str],
                 syntax_rule: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end_time_offset: search end time of offset.
        :param pulumi.Input[_builtins.str] logset_id: logset id.
        :param pulumi.Input[_builtins.int] number: the number of alarm object.
        :param pulumi.Input[_builtins.str] query: query rules.
        :param pulumi.Input[_builtins.int] start_time_offset: search start time of offset.
        :param pulumi.Input[_builtins.str] topic_id: topic id.
        :param pulumi.Input[_builtins.int] syntax_rule: Retrieve grammar rules, 0: Lucene syntax, 1: CQL syntax, Default value is 0.
        """
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "logset_id", logset_id)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        pulumi.set(__self__, "topic_id", topic_id)
        if syntax_rule is not None:
            pulumi.set(__self__, "syntax_rule", syntax_rule)

    @_builtins.property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> pulumi.Input[_builtins.int]:
        """
        search end time of offset.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "end_time_offset", value)

    @_builtins.property
    @pulumi.getter(name="logsetId")
    def logset_id(self) -> pulumi.Input[_builtins.str]:
        """
        logset id.
        """
        return pulumi.get(self, "logset_id")

    @logset_id.setter
    def logset_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "logset_id", value)

    @_builtins.property
    @pulumi.getter
    def number(self) -> pulumi.Input[_builtins.int]:
        """
        the number of alarm object.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> pulumi.Input[_builtins.str]:
        """
        query rules.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> pulumi.Input[_builtins.int]:
        """
        search start time of offset.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_time_offset", value)

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[_builtins.str]:
        """
        topic id.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_id", value)

    @_builtins.property
    @pulumi.getter(name="syntaxRule")
    def syntax_rule(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retrieve grammar rules, 0: Lucene syntax, 1: CQL syntax, Default value is 0.
        """
        return pulumi.get(self, "syntax_rule")

    @syntax_rule.setter
    def syntax_rule(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "syntax_rule", value)


if not MYPY:
    class AlarmAnalysisArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        analysis content.
        """
        name: pulumi.Input[_builtins.str]
        """
        analysis name.
        """
        type: pulumi.Input[_builtins.str]
        """
        analysis type.
        """
        config_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmAnalysisConfigInfoArgsDict']]]]
        """
        configuration.
        """
elif False:
    AlarmAnalysisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmAnalysisArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 config_infos: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmAnalysisConfigInfoArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] content: analysis content.
        :param pulumi.Input[_builtins.str] name: analysis name.
        :param pulumi.Input[_builtins.str] type: analysis type.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmAnalysisConfigInfoArgs']]] config_infos: configuration.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if config_infos is not None:
            pulumi.set(__self__, "config_infos", config_infos)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        analysis content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        analysis name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        analysis type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="configInfos")
    def config_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmAnalysisConfigInfoArgs']]]]:
        """
        configuration.
        """
        return pulumi.get(self, "config_infos")

    @config_infos.setter
    def config_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmAnalysisConfigInfoArgs']]]]):
        pulumi.set(self, "config_infos", value)


if not MYPY:
    class AlarmAnalysisConfigInfoArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        key.
        """
        value: pulumi.Input[_builtins.str]
        """
        value.
        """
elif False:
    AlarmAnalysisConfigInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmAnalysisConfigInfoArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: key.
        :param pulumi.Input[_builtins.str] value: value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmCallBackArgsDict(TypedDict):
        body: pulumi.Input[_builtins.str]
        """
        callback body.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        callback headers.
        """
elif False:
    AlarmCallBackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmCallBackArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[_builtins.str],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] body: callback body.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: callback headers.
        """
        pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def body(self) -> pulumi.Input[_builtins.str]:
        """
        callback body.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        callback headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class AlarmMonitorTimeArgsDict(TypedDict):
        time: pulumi.Input[_builtins.int]
        """
        time period or point in time.
        """
        type: pulumi.Input[_builtins.str]
        """
        Period for periodic execution, Fixed for regular execution.
        """
elif False:
    AlarmMonitorTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmMonitorTimeArgs:
    def __init__(__self__, *,
                 time: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] time: time period or point in time.
        :param pulumi.Input[_builtins.str] type: Period for periodic execution, Fixed for regular execution.
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def time(self) -> pulumi.Input[_builtins.int]:
        """
        time period or point in time.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "time", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Period for periodic execution, Fixed for regular execution.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmMultiConditionArgsDict(TypedDict):
        alarm_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm level. 0: Warning; 1: Info; 2: Critical. Default is 0.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Trigger condition.
        """
elif False:
    AlarmMultiConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmMultiConditionArgs:
    def __init__(__self__, *,
                 alarm_level: Optional[pulumi.Input[_builtins.int]] = None,
                 condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] alarm_level: Alarm level. 0: Warning; 1: Info; 2: Critical. Default is 0.
        :param pulumi.Input[_builtins.str] condition: Trigger condition.
        """
        if alarm_level is not None:
            pulumi.set(__self__, "alarm_level", alarm_level)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm level. 0: Warning; 1: Info; 2: Critical. Default is 0.
        """
        return pulumi.get(self, "alarm_level")

    @alarm_level.setter
    def alarm_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_level", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Trigger condition.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class AlarmNoticeNoticeReceiverArgsDict(TypedDict):
        receiver_channels: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Receiver channels, Value: Email, Sms, WeChat, Phone.
        """
        receiver_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        Receiver id list.
        """
        receiver_type: pulumi.Input[_builtins.str]
        """
        Receiver type, Uin or Group.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time allowed to receive messages.
        """
        index: NotRequired[pulumi.Input[_builtins.int]]
        """
        Index. The input parameter is invalid, but the output parameter is valid.
        """
        notice_content_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notice content ID.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time allowed to receive messages.
        """
elif False:
    AlarmNoticeNoticeReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmNoticeNoticeReceiverArgs:
    def __init__(__self__, *,
                 receiver_channels: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 receiver_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 receiver_type: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 index: Optional[pulumi.Input[_builtins.int]] = None,
                 notice_content_id: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] receiver_channels: Receiver channels, Value: Email, Sms, WeChat, Phone.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] receiver_ids: Receiver id list.
        :param pulumi.Input[_builtins.str] receiver_type: Receiver type, Uin or Group.
        :param pulumi.Input[_builtins.str] end_time: End time allowed to receive messages.
        :param pulumi.Input[_builtins.int] index: Index. The input parameter is invalid, but the output parameter is valid.
        :param pulumi.Input[_builtins.str] notice_content_id: Notice content ID.
        :param pulumi.Input[_builtins.str] start_time: Start time allowed to receive messages.
        """
        pulumi.set(__self__, "receiver_channels", receiver_channels)
        pulumi.set(__self__, "receiver_ids", receiver_ids)
        pulumi.set(__self__, "receiver_type", receiver_type)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if notice_content_id is not None:
            pulumi.set(__self__, "notice_content_id", notice_content_id)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="receiverChannels")
    def receiver_channels(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Receiver channels, Value: Email, Sms, WeChat, Phone.
        """
        return pulumi.get(self, "receiver_channels")

    @receiver_channels.setter
    def receiver_channels(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "receiver_channels", value)

    @_builtins.property
    @pulumi.getter(name="receiverIds")
    def receiver_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        Receiver id list.
        """
        return pulumi.get(self, "receiver_ids")

    @receiver_ids.setter
    def receiver_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "receiver_ids", value)

    @_builtins.property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> pulumi.Input[_builtins.str]:
        """
        Receiver type, Uin or Group.
        """
        return pulumi.get(self, "receiver_type")

    @receiver_type.setter
    def receiver_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "receiver_type", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time allowed to receive messages.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Index. The input parameter is invalid, but the output parameter is valid.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter(name="noticeContentId")
    def notice_content_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notice content ID.
        """
        return pulumi.get(self, "notice_content_id")

    @notice_content_id.setter
    def notice_content_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notice_content_id", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time allowed to receive messages.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AlarmNoticeWebCallbackArgsDict(TypedDict):
        callback_type: pulumi.Input[_builtins.str]
        """
        Callback type, Values: Http, WeCom, DingTalk, Lark.
        """
        url: pulumi.Input[_builtins.str]
        """
        Callback url.
        """
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        This parameter is deprecated. Please use `notice_content_id`. Request body.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This parameter is deprecated. Please use `notice_content_id`. Request headers.
        """
        index: NotRequired[pulumi.Input[_builtins.int]]
        """
        Index. The input parameter is invalid, but the output parameter is valid.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Method, POST or PUT.
        """
        mobiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Telephone list.
        """
        notice_content_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notice content ID.
        """
        remind_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remind type. 0: Do not remind; 1: Specified person; 2: Everyone.
        """
        user_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        User ID list.
        """
        web_callback_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Integration configuration ID.
        """
elif False:
    AlarmNoticeWebCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmNoticeWebCallbackArgs:
    def __init__(__self__, *,
                 callback_type: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 index: Optional[pulumi.Input[_builtins.int]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 mobiles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 notice_content_id: Optional[pulumi.Input[_builtins.str]] = None,
                 remind_type: Optional[pulumi.Input[_builtins.int]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 web_callback_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] callback_type: Callback type, Values: Http, WeCom, DingTalk, Lark.
        :param pulumi.Input[_builtins.str] url: Callback url.
        :param pulumi.Input[_builtins.str] body: This parameter is deprecated. Please use `notice_content_id`. Request body.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: This parameter is deprecated. Please use `notice_content_id`. Request headers.
        :param pulumi.Input[_builtins.int] index: Index. The input parameter is invalid, but the output parameter is valid.
        :param pulumi.Input[_builtins.str] method: Method, POST or PUT.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mobiles: Telephone list.
        :param pulumi.Input[_builtins.str] notice_content_id: Notice content ID.
        :param pulumi.Input[_builtins.int] remind_type: Remind type. 0: Do not remind; 1: Specified person; 2: Everyone.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_ids: User ID list.
        :param pulumi.Input[_builtins.str] web_callback_id: Integration configuration ID.
        """
        pulumi.set(__self__, "callback_type", callback_type)
        pulumi.set(__self__, "url", url)
        if body is not None:
            warnings.warn("""This parameter is deprecated. Please use `notice_content_id`.""", DeprecationWarning)
            pulumi.log.warn("""body is deprecated: This parameter is deprecated. Please use `notice_content_id`.""")
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            warnings.warn("""This parameter is deprecated. Please use `notice_content_id`.""", DeprecationWarning)
            pulumi.log.warn("""headers is deprecated: This parameter is deprecated. Please use `notice_content_id`.""")
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mobiles is not None:
            pulumi.set(__self__, "mobiles", mobiles)
        if notice_content_id is not None:
            pulumi.set(__self__, "notice_content_id", notice_content_id)
        if remind_type is not None:
            pulumi.set(__self__, "remind_type", remind_type)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)
        if web_callback_id is not None:
            pulumi.set(__self__, "web_callback_id", web_callback_id)

    @_builtins.property
    @pulumi.getter(name="callbackType")
    def callback_type(self) -> pulumi.Input[_builtins.str]:
        """
        Callback type, Values: Http, WeCom, DingTalk, Lark.
        """
        return pulumi.get(self, "callback_type")

    @callback_type.setter
    def callback_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "callback_type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Callback url.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please use `notice_content_id`.""")
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This parameter is deprecated. Please use `notice_content_id`. Request body.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please use `notice_content_id`.""")
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This parameter is deprecated. Please use `notice_content_id`. Request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Index. The input parameter is invalid, but the output parameter is valid.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Method, POST or PUT.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def mobiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Telephone list.
        """
        return pulumi.get(self, "mobiles")

    @mobiles.setter
    def mobiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mobiles", value)

    @_builtins.property
    @pulumi.getter(name="noticeContentId")
    def notice_content_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notice content ID.
        """
        return pulumi.get(self, "notice_content_id")

    @notice_content_id.setter
    def notice_content_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notice_content_id", value)

    @_builtins.property
    @pulumi.getter(name="remindType")
    def remind_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remind type. 0: Do not remind; 1: Specified person; 2: Everyone.
        """
        return pulumi.get(self, "remind_type")

    @remind_type.setter
    def remind_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remind_type", value)

    @_builtins.property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        User ID list.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_ids", value)

    @_builtins.property
    @pulumi.getter(name="webCallbackId")
    def web_callback_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Integration configuration ID.
        """
        return pulumi.get(self, "web_callback_id")

    @web_callback_id.setter
    def web_callback_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_callback_id", value)


if not MYPY:
    class CkafkaConsumerCkafkaArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        instance id.
        """
        instance_name: pulumi.Input[_builtins.str]
        """
        instance name.
        """
        topic_id: pulumi.Input[_builtins.str]
        """
        topic id of ckafka.
        """
        topic_name: pulumi.Input[_builtins.str]
        """
        topic name of ckafka.
        """
        vip: pulumi.Input[_builtins.str]
        """
        vip.
        """
        vport: pulumi.Input[_builtins.str]
        """
        vport.
        """
elif False:
    CkafkaConsumerCkafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CkafkaConsumerCkafkaArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 instance_name: pulumi.Input[_builtins.str],
                 topic_id: pulumi.Input[_builtins.str],
                 topic_name: pulumi.Input[_builtins.str],
                 vip: pulumi.Input[_builtins.str],
                 vport: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] instance_id: instance id.
        :param pulumi.Input[_builtins.str] instance_name: instance name.
        :param pulumi.Input[_builtins.str] topic_id: topic id of ckafka.
        :param pulumi.Input[_builtins.str] topic_name: topic name of ckafka.
        :param pulumi.Input[_builtins.str] vip: vip.
        :param pulumi.Input[_builtins.str] vport: vport.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "topic_id", topic_id)
        pulumi.set(__self__, "topic_name", topic_name)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vport", vport)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        instance id.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> pulumi.Input[_builtins.str]:
        """
        instance name.
        """
        return pulumi.get(self, "instance_name")

    @instance_name.setter
    def instance_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_name", value)

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[_builtins.str]:
        """
        topic id of ckafka.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_id", value)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[_builtins.str]:
        """
        topic name of ckafka.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_name", value)

    @_builtins.property
    @pulumi.getter
    def vip(self) -> pulumi.Input[_builtins.str]:
        """
        vip.
        """
        return pulumi.get(self, "vip")

    @vip.setter
    def vip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vip", value)

    @_builtins.property
    @pulumi.getter
    def vport(self) -> pulumi.Input[_builtins.str]:
        """
        vport.
        """
        return pulumi.get(self, "vport")

    @vport.setter
    def vport(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vport", value)


if not MYPY:
    class CkafkaConsumerContentArgsDict(TypedDict):
        enable_tag: pulumi.Input[_builtins.bool]
        """
        whether to deliver the TAG info.
        """
        meta_fields: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        metadata info list.
        """
        tag_json_not_tiled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        whether to tiling tag json.
        """
        timestamp_accuracy: NotRequired[pulumi.Input[_builtins.int]]
        """
        delivery timestamp precision,1 for second, 2 for millisecond.
        """
elif False:
    CkafkaConsumerContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CkafkaConsumerContentArgs:
    def __init__(__self__, *,
                 enable_tag: pulumi.Input[_builtins.bool],
                 meta_fields: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 tag_json_not_tiled: Optional[pulumi.Input[_builtins.bool]] = None,
                 timestamp_accuracy: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_tag: whether to deliver the TAG info.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] meta_fields: metadata info list.
        :param pulumi.Input[_builtins.bool] tag_json_not_tiled: whether to tiling tag json.
        :param pulumi.Input[_builtins.int] timestamp_accuracy: delivery timestamp precision,1 for second, 2 for millisecond.
        """
        pulumi.set(__self__, "enable_tag", enable_tag)
        pulumi.set(__self__, "meta_fields", meta_fields)
        if tag_json_not_tiled is not None:
            pulumi.set(__self__, "tag_json_not_tiled", tag_json_not_tiled)
        if timestamp_accuracy is not None:
            pulumi.set(__self__, "timestamp_accuracy", timestamp_accuracy)

    @_builtins.property
    @pulumi.getter(name="enableTag")
    def enable_tag(self) -> pulumi.Input[_builtins.bool]:
        """
        whether to deliver the TAG info.
        """
        return pulumi.get(self, "enable_tag")

    @enable_tag.setter
    def enable_tag(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_tag", value)

    @_builtins.property
    @pulumi.getter(name="metaFields")
    def meta_fields(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        metadata info list.
        """
        return pulumi.get(self, "meta_fields")

    @meta_fields.setter
    def meta_fields(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "meta_fields", value)

    @_builtins.property
    @pulumi.getter(name="tagJsonNotTiled")
    def tag_json_not_tiled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        whether to tiling tag json.
        """
        return pulumi.get(self, "tag_json_not_tiled")

    @tag_json_not_tiled.setter
    def tag_json_not_tiled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tag_json_not_tiled", value)

    @_builtins.property
    @pulumi.getter(name="timestampAccuracy")
    def timestamp_accuracy(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        delivery timestamp precision,1 for second, 2 for millisecond.
        """
        return pulumi.get(self, "timestamp_accuracy")

    @timestamp_accuracy.setter
    def timestamp_accuracy(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timestamp_accuracy", value)


if not MYPY:
    class ConfigExcludePathArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type. Valid values: File, Path.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specific content corresponding to Type.
        """
elif False:
    ConfigExcludePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExcludePathArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type. Valid values: File, Path.
        :param pulumi.Input[_builtins.str] value: Specific content corresponding to Type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type. Valid values: File, Path.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specific content corresponding to Type.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConfigExtraContainerFileArgsDict(TypedDict):
        container: pulumi.Input[_builtins.str]
        """
        container name.
        """
        file_pattern: pulumi.Input[_builtins.str]
        """
        log name.
        """
        log_path: pulumi.Input[_builtins.str]
        """
        Log Path.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        namespace.
        """
        exclude_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pod label to be excluded.
        """
        exclude_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespaces to be excluded, separated by separators, such as A, B.
        """
        include_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pod label info.
        """
        workload: NotRequired[pulumi.Input['ConfigExtraContainerFileWorkloadArgsDict']]
        """
        Workload info.
        """
elif False:
    ConfigExtraContainerFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraContainerFileArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[_builtins.str],
                 file_pattern: pulumi.Input[_builtins.str],
                 log_path: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 exclude_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exclude_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 include_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 workload: Optional[pulumi.Input['ConfigExtraContainerFileWorkloadArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] container: container name.
        :param pulumi.Input[_builtins.str] file_pattern: log name.
        :param pulumi.Input[_builtins.str] log_path: Log Path.
        :param pulumi.Input[_builtins.str] namespace: namespace.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_labels: Pod label to be excluded.
        :param pulumi.Input[_builtins.str] exclude_namespace: Namespaces to be excluded, separated by separators, such as A, B.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_labels: Pod label info.
        :param pulumi.Input['ConfigExtraContainerFileWorkloadArgs'] workload: Workload info.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "file_pattern", file_pattern)
        pulumi.set(__self__, "log_path", log_path)
        pulumi.set(__self__, "namespace", namespace)
        if exclude_labels is not None:
            pulumi.set(__self__, "exclude_labels", exclude_labels)
        if exclude_namespace is not None:
            pulumi.set(__self__, "exclude_namespace", exclude_namespace)
        if include_labels is not None:
            pulumi.set(__self__, "include_labels", include_labels)
        if workload is not None:
            pulumi.set(__self__, "workload", workload)

    @_builtins.property
    @pulumi.getter
    def container(self) -> pulumi.Input[_builtins.str]:
        """
        container name.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> pulumi.Input[_builtins.str]:
        """
        log name.
        """
        return pulumi.get(self, "file_pattern")

    @file_pattern.setter
    def file_pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_pattern", value)

    @_builtins.property
    @pulumi.getter(name="logPath")
    def log_path(self) -> pulumi.Input[_builtins.str]:
        """
        Log Path.
        """
        return pulumi.get(self, "log_path")

    @log_path.setter
    def log_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_path", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="excludeLabels")
    def exclude_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pod label to be excluded.
        """
        return pulumi.get(self, "exclude_labels")

    @exclude_labels.setter
    def exclude_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_labels", value)

    @_builtins.property
    @pulumi.getter(name="excludeNamespace")
    def exclude_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespaces to be excluded, separated by separators, such as A, B.
        """
        return pulumi.get(self, "exclude_namespace")

    @exclude_namespace.setter
    def exclude_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_namespace", value)

    @_builtins.property
    @pulumi.getter(name="includeLabels")
    def include_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pod label info.
        """
        return pulumi.get(self, "include_labels")

    @include_labels.setter
    def include_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_labels", value)

    @_builtins.property
    @pulumi.getter
    def workload(self) -> Optional[pulumi.Input['ConfigExtraContainerFileWorkloadArgs']]:
        """
        Workload info.
        """
        return pulumi.get(self, "workload")

    @workload.setter
    def workload(self, value: Optional[pulumi.Input['ConfigExtraContainerFileWorkloadArgs']]):
        pulumi.set(self, "workload", value)


if not MYPY:
    class ConfigExtraContainerFileWorkloadArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        workload type.
        """
        name: pulumi.Input[_builtins.str]
        """
        workload name.
        """
        container: NotRequired[pulumi.Input[_builtins.str]]
        """
        container name.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        namespace.
        """
elif False:
    ConfigExtraContainerFileWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraContainerFileWorkloadArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 container: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: workload type.
        :param pulumi.Input[_builtins.str] name: workload name.
        :param pulumi.Input[_builtins.str] container: container name.
        :param pulumi.Input[_builtins.str] namespace: namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        workload type.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        workload name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        container name.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ConfigExtraContainerStdoutArgsDict(TypedDict):
        all_containers: pulumi.Input[_builtins.bool]
        """
        Is all containers.
        """
        exclude_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pod label to be excluded.
        """
        exclude_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespaces to be excluded, separated by separators, such as A, B.
        """
        include_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pod label info.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        namespace.
        """
        workloads: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigExtraContainerStdoutWorkloadArgsDict']]]]
        """
        Workload info.
        """
elif False:
    ConfigExtraContainerStdoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraContainerStdoutArgs:
    def __init__(__self__, *,
                 all_containers: pulumi.Input[_builtins.bool],
                 exclude_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exclude_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 include_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 workloads: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtraContainerStdoutWorkloadArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] all_containers: Is all containers.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_labels: Pod label to be excluded.
        :param pulumi.Input[_builtins.str] exclude_namespace: Namespaces to be excluded, separated by separators, such as A, B.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_labels: Pod label info.
        :param pulumi.Input[_builtins.str] namespace: namespace.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigExtraContainerStdoutWorkloadArgs']]] workloads: Workload info.
        """
        pulumi.set(__self__, "all_containers", all_containers)
        if exclude_labels is not None:
            pulumi.set(__self__, "exclude_labels", exclude_labels)
        if exclude_namespace is not None:
            pulumi.set(__self__, "exclude_namespace", exclude_namespace)
        if include_labels is not None:
            pulumi.set(__self__, "include_labels", include_labels)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if workloads is not None:
            pulumi.set(__self__, "workloads", workloads)

    @_builtins.property
    @pulumi.getter(name="allContainers")
    def all_containers(self) -> pulumi.Input[_builtins.bool]:
        """
        Is all containers.
        """
        return pulumi.get(self, "all_containers")

    @all_containers.setter
    def all_containers(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "all_containers", value)

    @_builtins.property
    @pulumi.getter(name="excludeLabels")
    def exclude_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pod label to be excluded.
        """
        return pulumi.get(self, "exclude_labels")

    @exclude_labels.setter
    def exclude_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_labels", value)

    @_builtins.property
    @pulumi.getter(name="excludeNamespace")
    def exclude_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespaces to be excluded, separated by separators, such as A, B.
        """
        return pulumi.get(self, "exclude_namespace")

    @exclude_namespace.setter
    def exclude_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_namespace", value)

    @_builtins.property
    @pulumi.getter(name="includeLabels")
    def include_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pod label info.
        """
        return pulumi.get(self, "include_labels")

    @include_labels.setter
    def include_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_labels", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def workloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtraContainerStdoutWorkloadArgs']]]]:
        """
        Workload info.
        """
        return pulumi.get(self, "workloads")

    @workloads.setter
    def workloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtraContainerStdoutWorkloadArgs']]]]):
        pulumi.set(self, "workloads", value)


if not MYPY:
    class ConfigExtraContainerStdoutWorkloadArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        workload type.
        """
        name: pulumi.Input[_builtins.str]
        """
        workload name.
        """
        container: NotRequired[pulumi.Input[_builtins.str]]
        """
        container name.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        namespace.
        """
elif False:
    ConfigExtraContainerStdoutWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraContainerStdoutWorkloadArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 container: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: workload type.
        :param pulumi.Input[_builtins.str] name: workload name.
        :param pulumi.Input[_builtins.str] container: container name.
        :param pulumi.Input[_builtins.str] namespace: namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        workload type.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        workload name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        container name.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ConfigExtraExcludePathArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type. Valid values: File, Path.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specific content corresponding to Type.
        """
elif False:
    ConfigExtraExcludePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraExcludePathArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type. Valid values: File, Path.
        :param pulumi.Input[_builtins.str] value: Specific content corresponding to Type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type. Valid values: File, Path.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specific content corresponding to Type.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConfigExtraExtractRuleArgsDict(TypedDict):
        backtracking: NotRequired[pulumi.Input[_builtins.int]]
        """
        Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        """
        begin_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        """
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        """
        filter_key_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigExtraExtractRuleFilterKeyRegexArgsDict']]]]
        """
        Log keys to be filtered and the corresponding regex.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        """
        log_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full log matching rule, which is valid only if log_type is fullregex_log.
        """
        time_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        """
        time_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time field key name. time_key and time_format must appear in pair.
        """
        un_match_log_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unmatched log key.
        """
        un_match_up_load_switch: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
elif False:
    ConfigExtraExtractRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraExtractRuleArgs:
    def __init__(__self__, *,
                 backtracking: Optional[pulumi.Input[_builtins.int]] = None,
                 begin_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_key_regexes: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtraExtractRuleFilterKeyRegexArgs']]]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 log_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 time_format: Optional[pulumi.Input[_builtins.str]] = None,
                 time_key: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_log_key: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_up_load_switch: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] backtracking: Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        :param pulumi.Input[_builtins.str] begin_regex: First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        :param pulumi.Input[_builtins.str] delimiter: Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigExtraExtractRuleFilterKeyRegexArgs']]] filter_key_regexes: Log keys to be filtered and the corresponding regex.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        :param pulumi.Input[_builtins.str] log_regex: Full log matching rule, which is valid only if log_type is fullregex_log.
        :param pulumi.Input[_builtins.str] time_format: Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        :param pulumi.Input[_builtins.str] time_key: Time field key name. time_key and time_format must appear in pair.
        :param pulumi.Input[_builtins.str] un_match_log_key: Unmatched log key.
        :param pulumi.Input[_builtins.bool] un_match_up_load_switch: Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        if backtracking is not None:
            pulumi.set(__self__, "backtracking", backtracking)
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if filter_key_regexes is not None:
            pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @_builtins.property
    @pulumi.getter
    def backtracking(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        """
        return pulumi.get(self, "backtracking")

    @backtracking.setter
    def backtracking(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "backtracking", value)

    @_builtins.property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        """
        return pulumi.get(self, "begin_regex")

    @begin_regex.setter
    def begin_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "begin_regex", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtraExtractRuleFilterKeyRegexArgs']]]]:
        """
        Log keys to be filtered and the corresponding regex.
        """
        return pulumi.get(self, "filter_key_regexes")

    @filter_key_regexes.setter
    def filter_key_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtraExtractRuleFilterKeyRegexArgs']]]]):
        pulumi.set(self, "filter_key_regexes", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full log matching rule, which is valid only if log_type is fullregex_log.
        """
        return pulumi.get(self, "log_regex")

    @log_regex.setter
    def log_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_regex", value)

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_format", value)

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time field key name. time_key and time_format must appear in pair.
        """
        return pulumi.get(self, "time_key")

    @time_key.setter
    def time_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_key", value)

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unmatched log key.
        """
        return pulumi.get(self, "un_match_log_key")

    @un_match_log_key.setter
    def un_match_log_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "un_match_log_key", value)

    @_builtins.property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        return pulumi.get(self, "un_match_up_load_switch")

    @un_match_up_load_switch.setter
    def un_match_up_load_switch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "un_match_up_load_switch", value)


if not MYPY:
    class ConfigExtraExtractRuleFilterKeyRegexArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log key to be filtered.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter rule regex corresponding to key.
        """
elif False:
    ConfigExtraExtractRuleFilterKeyRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraExtractRuleFilterKeyRegexArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Log key to be filtered.
        :param pulumi.Input[_builtins.str] regex: Filter rule regex corresponding to key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log key to be filtered.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter rule regex corresponding to key.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class ConfigExtraHostFileArgsDict(TypedDict):
        file_pattern: pulumi.Input[_builtins.str]
        """
        Log file name.
        """
        log_path: pulumi.Input[_builtins.str]
        """
        Log file dir.
        """
        custom_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Metadata info.
        """
elif False:
    ConfigExtraHostFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtraHostFileArgs:
    def __init__(__self__, *,
                 file_pattern: pulumi.Input[_builtins.str],
                 log_path: pulumi.Input[_builtins.str],
                 custom_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] file_pattern: Log file name.
        :param pulumi.Input[_builtins.str] log_path: Log file dir.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_labels: Metadata info.
        """
        pulumi.set(__self__, "file_pattern", file_pattern)
        pulumi.set(__self__, "log_path", log_path)
        if custom_labels is not None:
            pulumi.set(__self__, "custom_labels", custom_labels)

    @_builtins.property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> pulumi.Input[_builtins.str]:
        """
        Log file name.
        """
        return pulumi.get(self, "file_pattern")

    @file_pattern.setter
    def file_pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_pattern", value)

    @_builtins.property
    @pulumi.getter(name="logPath")
    def log_path(self) -> pulumi.Input[_builtins.str]:
        """
        Log file dir.
        """
        return pulumi.get(self, "log_path")

    @log_path.setter
    def log_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_path", value)

    @_builtins.property
    @pulumi.getter(name="customLabels")
    def custom_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Metadata info.
        """
        return pulumi.get(self, "custom_labels")

    @custom_labels.setter
    def custom_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_labels", value)


if not MYPY:
    class ConfigExtractRuleArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        """
        backtracking: NotRequired[pulumi.Input[_builtins.int]]
        """
        Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        """
        begin_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        """
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        """
        filter_key_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleFilterKeyRegexArgsDict']]]]
        """
        Log keys to be filtered and the corresponding regex.
        """
        is_gbk: NotRequired[pulumi.Input[_builtins.int]]
        """
        GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
        """
        json_standard: NotRequired[pulumi.Input[_builtins.int]]
        """
        standard json. Default 0.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        """
        log_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full log matching rule, which is valid only if log_type is fullregex_log.
        """
        meta_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleMetaTagArgsDict']]]]
        """
        metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
        """
        metadata_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
        """
        parse_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        """
        path_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        metadata path regex.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
        """
        time_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        """
        time_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time field key name. time_key and time_format must appear in pair.
        """
        un_match_log_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unmatched log key. Required when UnMatchUpLoadSwitch is true.
        """
        un_match_up_load_switch: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
elif False:
    ConfigExtractRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtractRuleArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 backtracking: Optional[pulumi.Input[_builtins.int]] = None,
                 begin_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_key_regexes: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleFilterKeyRegexArgs']]]] = None,
                 is_gbk: Optional[pulumi.Input[_builtins.int]] = None,
                 json_standard: Optional[pulumi.Input[_builtins.int]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 log_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 meta_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleMetaTagArgs']]]] = None,
                 metadata_type: Optional[pulumi.Input[_builtins.int]] = None,
                 parse_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 path_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 time_format: Optional[pulumi.Input[_builtins.str]] = None,
                 time_key: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_log_key: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_up_load_switch: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] address: syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        :param pulumi.Input[_builtins.int] backtracking: Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        :param pulumi.Input[_builtins.str] begin_regex: First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        :param pulumi.Input[_builtins.str] delimiter: Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleFilterKeyRegexArgs']]] filter_key_regexes: Log keys to be filtered and the corresponding regex.
        :param pulumi.Input[_builtins.int] is_gbk: GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
        :param pulumi.Input[_builtins.int] json_standard: standard json. Default 0.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        :param pulumi.Input[_builtins.str] log_regex: Full log matching rule, which is valid only if log_type is fullregex_log.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleMetaTagArgs']]] meta_tags: metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
        :param pulumi.Input[_builtins.int] metadata_type: metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
        :param pulumi.Input[_builtins.str] parse_protocol: parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        :param pulumi.Input[_builtins.str] path_regex: metadata path regex.
        :param pulumi.Input[_builtins.str] protocol: syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
        :param pulumi.Input[_builtins.str] time_format: Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        :param pulumi.Input[_builtins.str] time_key: Time field key name. time_key and time_format must appear in pair.
        :param pulumi.Input[_builtins.str] un_match_log_key: Unmatched log key. Required when UnMatchUpLoadSwitch is true.
        :param pulumi.Input[_builtins.bool] un_match_up_load_switch: Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if backtracking is not None:
            pulumi.set(__self__, "backtracking", backtracking)
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if filter_key_regexes is not None:
            pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        if is_gbk is not None:
            pulumi.set(__self__, "is_gbk", is_gbk)
        if json_standard is not None:
            pulumi.set(__self__, "json_standard", json_standard)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if meta_tags is not None:
            pulumi.set(__self__, "meta_tags", meta_tags)
        if metadata_type is not None:
            pulumi.set(__self__, "metadata_type", metadata_type)
        if parse_protocol is not None:
            pulumi.set(__self__, "parse_protocol", parse_protocol)
        if path_regex is not None:
            pulumi.set(__self__, "path_regex", path_regex)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def backtracking(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
        """
        return pulumi.get(self, "backtracking")

    @backtracking.setter
    def backtracking(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "backtracking", value)

    @_builtins.property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
        """
        return pulumi.get(self, "begin_regex")

    @begin_regex.setter
    def begin_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "begin_regex", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Delimiter for delimited log, which is valid only if log_type is delimiter_log.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleFilterKeyRegexArgs']]]]:
        """
        Log keys to be filtered and the corresponding regex.
        """
        return pulumi.get(self, "filter_key_regexes")

    @filter_key_regexes.setter
    def filter_key_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleFilterKeyRegexArgs']]]]):
        pulumi.set(self, "filter_key_regexes", value)

    @_builtins.property
    @pulumi.getter(name="isGbk")
    def is_gbk(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
        """
        return pulumi.get(self, "is_gbk")

    @is_gbk.setter
    def is_gbk(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_gbk", value)

    @_builtins.property
    @pulumi.getter(name="jsonStandard")
    def json_standard(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        standard json. Default 0.
        """
        return pulumi.get(self, "json_standard")

    @json_standard.setter
    def json_standard(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "json_standard", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full log matching rule, which is valid only if log_type is fullregex_log.
        """
        return pulumi.get(self, "log_regex")

    @log_regex.setter
    def log_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_regex", value)

    @_builtins.property
    @pulumi.getter(name="metaTags")
    def meta_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleMetaTagArgs']]]]:
        """
        metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
        """
        return pulumi.get(self, "meta_tags")

    @meta_tags.setter
    def meta_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigExtractRuleMetaTagArgs']]]]):
        pulumi.set(self, "meta_tags", value)

    @_builtins.property
    @pulumi.getter(name="metadataType")
    def metadata_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
        """
        return pulumi.get(self, "metadata_type")

    @metadata_type.setter
    def metadata_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metadata_type", value)

    @_builtins.property
    @pulumi.getter(name="parseProtocol")
    def parse_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
        """
        return pulumi.get(self, "parse_protocol")

    @parse_protocol.setter
    def parse_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parse_protocol", value)

    @_builtins.property
    @pulumi.getter(name="pathRegex")
    def path_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        metadata path regex.
        """
        return pulumi.get(self, "path_regex")

    @path_regex.setter
    def path_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path_regex", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_format", value)

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time field key name. time_key and time_format must appear in pair.
        """
        return pulumi.get(self, "time_key")

    @time_key.setter
    def time_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_key", value)

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unmatched log key. Required when UnMatchUpLoadSwitch is true.
        """
        return pulumi.get(self, "un_match_log_key")

    @un_match_log_key.setter
    def un_match_log_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "un_match_log_key", value)

    @_builtins.property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
        """
        return pulumi.get(self, "un_match_up_load_switch")

    @un_match_up_load_switch.setter
    def un_match_up_load_switch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "un_match_up_load_switch", value)


if not MYPY:
    class ConfigExtractRuleFilterKeyRegexArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log key to be filtered.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter rule regex corresponding to key.
        """
elif False:
    ConfigExtractRuleFilterKeyRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtractRuleFilterKeyRegexArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Log key to be filtered.
        :param pulumi.Input[_builtins.str] regex: Filter rule regex corresponding to key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log key to be filtered.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter rule regex corresponding to key.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class ConfigExtractRuleMetaTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        tag key.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        tag value.
        """
elif False:
    ConfigExtractRuleMetaTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigExtractRuleMetaTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: tag key.
        :param pulumi.Input[_builtins.str] value: tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CosRechargeExtractRuleInfoArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        syslog address.
        """
        backtracking: NotRequired[pulumi.Input[_builtins.int]]
        """
        backtracking data volume in incremental acquisition mode.
        """
        begin_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        begin line regex.
        """
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        log delimiter.
        """
        filter_key_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoFilterKeyRegexArgsDict']]]]
        """
        rules that need to filter logs.
        """
        is_gbk: NotRequired[pulumi.Input[_builtins.int]]
        """
        gbk encoding.
        """
        json_standard: NotRequired[pulumi.Input[_builtins.int]]
        """
        is standard json.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        key list.
        """
        log_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        log regex.
        """
        meta_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoMetaTagArgsDict']]]]
        """
        metadata tag list.
        """
        metadata_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        metadata type.
        """
        parse_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        parse protocol.
        """
        path_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        metadata path regex.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        syslog protocol.
        """
        time_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        time format.
        """
        time_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        time key.
        """
        un_match_log_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        parsing failure log key.
        """
        un_match_up_load_switch: NotRequired[pulumi.Input[_builtins.bool]]
        """
        whether to upload the parsing failure log.
        """
elif False:
    CosRechargeExtractRuleInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosRechargeExtractRuleInfoArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 backtracking: Optional[pulumi.Input[_builtins.int]] = None,
                 begin_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_key_regexes: Optional[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoFilterKeyRegexArgs']]]] = None,
                 is_gbk: Optional[pulumi.Input[_builtins.int]] = None,
                 json_standard: Optional[pulumi.Input[_builtins.int]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 log_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 meta_tags: Optional[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoMetaTagArgs']]]] = None,
                 metadata_type: Optional[pulumi.Input[_builtins.int]] = None,
                 parse_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 path_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 time_format: Optional[pulumi.Input[_builtins.str]] = None,
                 time_key: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_log_key: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_up_load_switch: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] address: syslog address.
        :param pulumi.Input[_builtins.int] backtracking: backtracking data volume in incremental acquisition mode.
        :param pulumi.Input[_builtins.str] begin_regex: begin line regex.
        :param pulumi.Input[_builtins.str] delimiter: log delimiter.
        :param pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoFilterKeyRegexArgs']]] filter_key_regexes: rules that need to filter logs.
        :param pulumi.Input[_builtins.int] is_gbk: gbk encoding.
        :param pulumi.Input[_builtins.int] json_standard: is standard json.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: key list.
        :param pulumi.Input[_builtins.str] log_regex: log regex.
        :param pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoMetaTagArgs']]] meta_tags: metadata tag list.
        :param pulumi.Input[_builtins.int] metadata_type: metadata type.
        :param pulumi.Input[_builtins.str] parse_protocol: parse protocol.
        :param pulumi.Input[_builtins.str] path_regex: metadata path regex.
        :param pulumi.Input[_builtins.str] protocol: syslog protocol.
        :param pulumi.Input[_builtins.str] time_format: time format.
        :param pulumi.Input[_builtins.str] time_key: time key.
        :param pulumi.Input[_builtins.str] un_match_log_key: parsing failure log key.
        :param pulumi.Input[_builtins.bool] un_match_up_load_switch: whether to upload the parsing failure log.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if backtracking is not None:
            pulumi.set(__self__, "backtracking", backtracking)
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if filter_key_regexes is not None:
            pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        if is_gbk is not None:
            pulumi.set(__self__, "is_gbk", is_gbk)
        if json_standard is not None:
            pulumi.set(__self__, "json_standard", json_standard)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if meta_tags is not None:
            pulumi.set(__self__, "meta_tags", meta_tags)
        if metadata_type is not None:
            pulumi.set(__self__, "metadata_type", metadata_type)
        if parse_protocol is not None:
            pulumi.set(__self__, "parse_protocol", parse_protocol)
        if path_regex is not None:
            pulumi.set(__self__, "path_regex", path_regex)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        syslog address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def backtracking(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        backtracking data volume in incremental acquisition mode.
        """
        return pulumi.get(self, "backtracking")

    @backtracking.setter
    def backtracking(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "backtracking", value)

    @_builtins.property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        begin line regex.
        """
        return pulumi.get(self, "begin_regex")

    @begin_regex.setter
    def begin_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "begin_regex", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        log delimiter.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoFilterKeyRegexArgs']]]]:
        """
        rules that need to filter logs.
        """
        return pulumi.get(self, "filter_key_regexes")

    @filter_key_regexes.setter
    def filter_key_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoFilterKeyRegexArgs']]]]):
        pulumi.set(self, "filter_key_regexes", value)

    @_builtins.property
    @pulumi.getter(name="isGbk")
    def is_gbk(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        gbk encoding.
        """
        return pulumi.get(self, "is_gbk")

    @is_gbk.setter
    def is_gbk(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_gbk", value)

    @_builtins.property
    @pulumi.getter(name="jsonStandard")
    def json_standard(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        is standard json.
        """
        return pulumi.get(self, "json_standard")

    @json_standard.setter
    def json_standard(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "json_standard", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        key list.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        log regex.
        """
        return pulumi.get(self, "log_regex")

    @log_regex.setter
    def log_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_regex", value)

    @_builtins.property
    @pulumi.getter(name="metaTags")
    def meta_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoMetaTagArgs']]]]:
        """
        metadata tag list.
        """
        return pulumi.get(self, "meta_tags")

    @meta_tags.setter
    def meta_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CosRechargeExtractRuleInfoMetaTagArgs']]]]):
        pulumi.set(self, "meta_tags", value)

    @_builtins.property
    @pulumi.getter(name="metadataType")
    def metadata_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        metadata type.
        """
        return pulumi.get(self, "metadata_type")

    @metadata_type.setter
    def metadata_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metadata_type", value)

    @_builtins.property
    @pulumi.getter(name="parseProtocol")
    def parse_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        parse protocol.
        """
        return pulumi.get(self, "parse_protocol")

    @parse_protocol.setter
    def parse_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parse_protocol", value)

    @_builtins.property
    @pulumi.getter(name="pathRegex")
    def path_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        metadata path regex.
        """
        return pulumi.get(self, "path_regex")

    @path_regex.setter
    def path_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path_regex", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        syslog protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time format.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_format", value)

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time key.
        """
        return pulumi.get(self, "time_key")

    @time_key.setter
    def time_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_key", value)

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        parsing failure log key.
        """
        return pulumi.get(self, "un_match_log_key")

    @un_match_log_key.setter
    def un_match_log_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "un_match_log_key", value)

    @_builtins.property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        whether to upload the parsing failure log.
        """
        return pulumi.get(self, "un_match_up_load_switch")

    @un_match_up_load_switch.setter
    def un_match_up_load_switch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "un_match_up_load_switch", value)


if not MYPY:
    class CosRechargeExtractRuleInfoFilterKeyRegexArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        need filter log key.
        """
        regex: pulumi.Input[_builtins.str]
        """
        need filter log regex.
        """
elif False:
    CosRechargeExtractRuleInfoFilterKeyRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosRechargeExtractRuleInfoFilterKeyRegexArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 regex: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: need filter log key.
        :param pulumi.Input[_builtins.str] regex: need filter log regex.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        need filter log key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> pulumi.Input[_builtins.str]:
        """
        need filter log regex.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class CosRechargeExtractRuleInfoMetaTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        metadata key.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        metadata value.
        """
elif False:
    CosRechargeExtractRuleInfoMetaTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosRechargeExtractRuleInfoMetaTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: metadata key.
        :param pulumi.Input[_builtins.str] value: metadata value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        metadata key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        metadata value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CosShipperCompressArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        Compression format. Valid values: gzip, lzop, none (no compression).
        """
elif False:
    CosShipperCompressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosShipperCompressArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] format: Compression format. Valid values: gzip, lzop, none (no compression).
        """
        pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        Compression format. Valid values: gzip, lzop, none (no compression).
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)


if not MYPY:
    class CosShipperContentArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        Content format. Valid values: json, csv.
        """
        csv: NotRequired[pulumi.Input['CosShipperContentCsvArgsDict']]
        """
        CSV format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
        json: NotRequired[pulumi.Input['CosShipperContentJsonArgsDict']]
        """
        JSON format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CosShipperContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosShipperContentArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str],
                 csv: Optional[pulumi.Input['CosShipperContentCsvArgs']] = None,
                 json: Optional[pulumi.Input['CosShipperContentJsonArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] format: Content format. Valid values: json, csv.
        :param pulumi.Input['CosShipperContentCsvArgs'] csv: CSV format content description.Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input['CosShipperContentJsonArgs'] json: JSON format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "format", format)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        Content format. Valid values: json, csv.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['CosShipperContentCsvArgs']]:
        """
        CSV format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['CosShipperContentCsvArgs']]):
        pulumi.set(self, "csv", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['CosShipperContentJsonArgs']]:
        """
        JSON format content description.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['CosShipperContentJsonArgs']]):
        pulumi.set(self, "json", value)


if not MYPY:
    class CosShipperContentCsvArgsDict(TypedDict):
        delimiter: pulumi.Input[_builtins.str]
        """
        Field delimiter.
        """
        escape_char: pulumi.Input[_builtins.str]
        """
        Field delimiter.
        """
        keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Names of keys.Note: this field may return null, indicating that no valid values can be obtained.
        """
        non_existing_field: pulumi.Input[_builtins.str]
        """
        Content used to populate non-existing fields.
        """
        print_key: pulumi.Input[_builtins.bool]
        """
        Whether to print key on the first row of the CSV file.
        """
elif False:
    CosShipperContentCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosShipperContentCsvArgs:
    def __init__(__self__, *,
                 delimiter: pulumi.Input[_builtins.str],
                 escape_char: pulumi.Input[_builtins.str],
                 keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 non_existing_field: pulumi.Input[_builtins.str],
                 print_key: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.str] delimiter: Field delimiter.
        :param pulumi.Input[_builtins.str] escape_char: Field delimiter.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: Names of keys.Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] non_existing_field: Content used to populate non-existing fields.
        :param pulumi.Input[_builtins.bool] print_key: Whether to print key on the first row of the CSV file.
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "escape_char", escape_char)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "non_existing_field", non_existing_field)
        pulumi.set(__self__, "print_key", print_key)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> pulumi.Input[_builtins.str]:
        """
        Field delimiter.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> pulumi.Input[_builtins.str]:
        """
        Field delimiter.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "escape_char", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Names of keys.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="nonExistingField")
    def non_existing_field(self) -> pulumi.Input[_builtins.str]:
        """
        Content used to populate non-existing fields.
        """
        return pulumi.get(self, "non_existing_field")

    @non_existing_field.setter
    def non_existing_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "non_existing_field", value)

    @_builtins.property
    @pulumi.getter(name="printKey")
    def print_key(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether to print key on the first row of the CSV file.
        """
        return pulumi.get(self, "print_key")

    @print_key.setter
    def print_key(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "print_key", value)


if not MYPY:
    class CosShipperContentJsonArgsDict(TypedDict):
        enable_tag: pulumi.Input[_builtins.bool]
        """
        Enablement flag.
        """
        meta_fields: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Metadata information list
        Note: this field may return null, indicating that no valid values can be obtained..
        """
elif False:
    CosShipperContentJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosShipperContentJsonArgs:
    def __init__(__self__, *,
                 enable_tag: pulumi.Input[_builtins.bool],
                 meta_fields: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.bool] enable_tag: Enablement flag.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] meta_fields: Metadata information list
               Note: this field may return null, indicating that no valid values can be obtained..
        """
        pulumi.set(__self__, "enable_tag", enable_tag)
        pulumi.set(__self__, "meta_fields", meta_fields)

    @_builtins.property
    @pulumi.getter(name="enableTag")
    def enable_tag(self) -> pulumi.Input[_builtins.bool]:
        """
        Enablement flag.
        """
        return pulumi.get(self, "enable_tag")

    @enable_tag.setter
    def enable_tag(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_tag", value)

    @_builtins.property
    @pulumi.getter(name="metaFields")
    def meta_fields(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Metadata information list
        Note: this field may return null, indicating that no valid values can be obtained..
        """
        return pulumi.get(self, "meta_fields")

    @meta_fields.setter
    def meta_fields(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "meta_fields", value)


if not MYPY:
    class CosShipperFilterRuleArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Filter rule key.
        """
        regex: pulumi.Input[_builtins.str]
        """
        Filter rule.
        """
        value: pulumi.Input[_builtins.str]
        """
        Filter rule value.
        """
elif False:
    CosShipperFilterRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosShipperFilterRuleArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 regex: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Filter rule key.
        :param pulumi.Input[_builtins.str] regex: Filter rule.
        :param pulumi.Input[_builtins.str] value: Filter rule value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Filter rule key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> pulumi.Input[_builtins.str]:
        """
        Filter rule.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Filter rule value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataTransformDstResourceArgsDict(TypedDict):
        alias: pulumi.Input[_builtins.str]
        """
        Alias.
        """
        topic_id: pulumi.Input[_builtins.str]
        """
        Dst topic ID.
        """
elif False:
    DataTransformDstResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTransformDstResourceArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[_builtins.str],
                 topic_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] alias: Alias.
        :param pulumi.Input[_builtins.str] topic_id: Dst topic ID.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "topic_id", topic_id)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> pulumi.Input[_builtins.str]:
        """
        Alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[_builtins.str]:
        """
        Dst topic ID.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_id", value)


if not MYPY:
    class IndexRuleArgsDict(TypedDict):
        dynamic_index: NotRequired[pulumi.Input['IndexRuleDynamicIndexArgsDict']]
        """
        The key value index is automatically configured. If it is empty, it means that the function is not enabled.
        """
        full_text: NotRequired[pulumi.Input['IndexRuleFullTextArgsDict']]
        """
        Full-Text index configuration.
        """
        key_value: NotRequired[pulumi.Input['IndexRuleKeyValueArgsDict']]
        """
        Key-Value index configuration.
        """
        tag: NotRequired[pulumi.Input['IndexRuleTagArgsDict']]
        """
        Metafield index configuration.
        """
elif False:
    IndexRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleArgs:
    def __init__(__self__, *,
                 dynamic_index: Optional[pulumi.Input['IndexRuleDynamicIndexArgs']] = None,
                 full_text: Optional[pulumi.Input['IndexRuleFullTextArgs']] = None,
                 key_value: Optional[pulumi.Input['IndexRuleKeyValueArgs']] = None,
                 tag: Optional[pulumi.Input['IndexRuleTagArgs']] = None):
        """
        :param pulumi.Input['IndexRuleDynamicIndexArgs'] dynamic_index: The key value index is automatically configured. If it is empty, it means that the function is not enabled.
        :param pulumi.Input['IndexRuleFullTextArgs'] full_text: Full-Text index configuration.
        :param pulumi.Input['IndexRuleKeyValueArgs'] key_value: Key-Value index configuration.
        :param pulumi.Input['IndexRuleTagArgs'] tag: Metafield index configuration.
        """
        if dynamic_index is not None:
            pulumi.set(__self__, "dynamic_index", dynamic_index)
        if full_text is not None:
            pulumi.set(__self__, "full_text", full_text)
        if key_value is not None:
            pulumi.set(__self__, "key_value", key_value)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="dynamicIndex")
    def dynamic_index(self) -> Optional[pulumi.Input['IndexRuleDynamicIndexArgs']]:
        """
        The key value index is automatically configured. If it is empty, it means that the function is not enabled.
        """
        return pulumi.get(self, "dynamic_index")

    @dynamic_index.setter
    def dynamic_index(self, value: Optional[pulumi.Input['IndexRuleDynamicIndexArgs']]):
        pulumi.set(self, "dynamic_index", value)

    @_builtins.property
    @pulumi.getter(name="fullText")
    def full_text(self) -> Optional[pulumi.Input['IndexRuleFullTextArgs']]:
        """
        Full-Text index configuration.
        """
        return pulumi.get(self, "full_text")

    @full_text.setter
    def full_text(self, value: Optional[pulumi.Input['IndexRuleFullTextArgs']]):
        pulumi.set(self, "full_text", value)

    @_builtins.property
    @pulumi.getter(name="keyValue")
    def key_value(self) -> Optional[pulumi.Input['IndexRuleKeyValueArgs']]:
        """
        Key-Value index configuration.
        """
        return pulumi.get(self, "key_value")

    @key_value.setter
    def key_value(self, value: Optional[pulumi.Input['IndexRuleKeyValueArgs']]):
        pulumi.set(self, "key_value", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['IndexRuleTagArgs']]:
        """
        Metafield index configuration.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['IndexRuleTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class IndexRuleDynamicIndexArgsDict(TypedDict):
        status: pulumi.Input[_builtins.bool]
        """
        index automatic configuration switch.
        """
elif False:
    IndexRuleDynamicIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleDynamicIndexArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] status: index automatic configuration switch.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.bool]:
        """
        index automatic configuration switch.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "status", value)


if not MYPY:
    class IndexRuleFullTextArgsDict(TypedDict):
        case_sensitive: pulumi.Input[_builtins.bool]
        """
        Case sensitivity.
        """
        contain_zh: pulumi.Input[_builtins.bool]
        """
        Whether Chinese characters are contained.
        """
        tokenizer: pulumi.Input[_builtins.str]
        """
        Full-Text index delimiter. Each character in the string represents a delimiter.
        """
elif False:
    IndexRuleFullTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleFullTextArgs:
    def __init__(__self__, *,
                 case_sensitive: pulumi.Input[_builtins.bool],
                 contain_zh: pulumi.Input[_builtins.bool],
                 tokenizer: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] case_sensitive: Case sensitivity.
        :param pulumi.Input[_builtins.bool] contain_zh: Whether Chinese characters are contained.
        :param pulumi.Input[_builtins.str] tokenizer: Full-Text index delimiter. Each character in the string represents a delimiter.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        pulumi.set(__self__, "contain_zh", contain_zh)
        pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> pulumi.Input[_builtins.bool]:
        """
        Case sensitivity.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="containZH")
    def contain_zh(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Chinese characters are contained.
        """
        return pulumi.get(self, "contain_zh")

    @contain_zh.setter
    def contain_zh(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "contain_zh", value)

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> pulumi.Input[_builtins.str]:
        """
        Full-Text index delimiter. Each character in the string represents a delimiter.
        """
        return pulumi.get(self, "tokenizer")

    @tokenizer.setter
    def tokenizer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tokenizer", value)


if not MYPY:
    class IndexRuleKeyValueArgsDict(TypedDict):
        case_sensitive: pulumi.Input[_builtins.bool]
        """
        Case sensitivity.
        """
        key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexRuleKeyValueKeyValueArgsDict']]]]
        """
        Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
elif False:
    IndexRuleKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleKeyValueArgs:
    def __init__(__self__, *,
                 case_sensitive: pulumi.Input[_builtins.bool],
                 key_values: Optional[pulumi.Input[Sequence[pulumi.Input['IndexRuleKeyValueKeyValueArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] case_sensitive: Case sensitivity.
        :param pulumi.Input[Sequence[pulumi.Input['IndexRuleKeyValueKeyValueArgs']]] key_values: Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key_values is not None:
            pulumi.set(__self__, "key_values", key_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> pulumi.Input[_builtins.bool]:
        """
        Case sensitivity.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="keyValues")
    def key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexRuleKeyValueKeyValueArgs']]]]:
        """
        Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        return pulumi.get(self, "key_values")

    @key_values.setter
    def key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexRuleKeyValueKeyValueArgs']]]]):
        pulumi.set(self, "key_values", value)


if not MYPY:
    class IndexRuleKeyValueKeyValueArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        """
        value: NotRequired[pulumi.Input['IndexRuleKeyValueKeyValueValueArgsDict']]
        """
        Field index description information.
        """
elif False:
    IndexRuleKeyValueKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleKeyValueKeyValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input['IndexRuleKeyValueKeyValueValueArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] key: When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        :param pulumi.Input['IndexRuleKeyValueKeyValueValueArgs'] value: Field index description information.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['IndexRuleKeyValueKeyValueValueArgs']]:
        """
        Field index description information.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['IndexRuleKeyValueKeyValueValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IndexRuleKeyValueKeyValueValueArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Field type. Valid values: long, text, double.
        """
        contain_zh: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Chinese characters are contained.
        """
        sql_flag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the analysis feature is enabled for the field.
        """
        tokenizer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
elif False:
    IndexRuleKeyValueKeyValueValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleKeyValueKeyValueValueArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 contain_zh: Optional[pulumi.Input[_builtins.bool]] = None,
                 sql_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 tokenizer: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Field type. Valid values: long, text, double.
        :param pulumi.Input[_builtins.bool] contain_zh: Whether Chinese characters are contained.
        :param pulumi.Input[_builtins.bool] sql_flag: Whether the analysis feature is enabled for the field.
        :param pulumi.Input[_builtins.str] tokenizer: Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        pulumi.set(__self__, "type", type)
        if contain_zh is not None:
            pulumi.set(__self__, "contain_zh", contain_zh)
        if sql_flag is not None:
            pulumi.set(__self__, "sql_flag", sql_flag)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Field type. Valid values: long, text, double.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="containZH")
    def contain_zh(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Chinese characters are contained.
        """
        return pulumi.get(self, "contain_zh")

    @contain_zh.setter
    def contain_zh(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "contain_zh", value)

    @_builtins.property
    @pulumi.getter(name="sqlFlag")
    def sql_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the analysis feature is enabled for the field.
        """
        return pulumi.get(self, "sql_flag")

    @sql_flag.setter
    def sql_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sql_flag", value)

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        return pulumi.get(self, "tokenizer")

    @tokenizer.setter
    def tokenizer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tokenizer", value)


if not MYPY:
    class IndexRuleTagArgsDict(TypedDict):
        case_sensitive: pulumi.Input[_builtins.bool]
        """
        Case sensitivity.
        """
        key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexRuleTagKeyValueArgsDict']]]]
        """
        Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
elif False:
    IndexRuleTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleTagArgs:
    def __init__(__self__, *,
                 case_sensitive: pulumi.Input[_builtins.bool],
                 key_values: Optional[pulumi.Input[Sequence[pulumi.Input['IndexRuleTagKeyValueArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] case_sensitive: Case sensitivity.
        :param pulumi.Input[Sequence[pulumi.Input['IndexRuleTagKeyValueArgs']]] key_values: Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key_values is not None:
            pulumi.set(__self__, "key_values", key_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> pulumi.Input[_builtins.bool]:
        """
        Case sensitivity.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="keyValues")
    def key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexRuleTagKeyValueArgs']]]]:
        """
        Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
        """
        return pulumi.get(self, "key_values")

    @key_values.setter
    def key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexRuleTagKeyValueArgs']]]]):
        pulumi.set(self, "key_values", value)


if not MYPY:
    class IndexRuleTagKeyValueArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        """
        value: NotRequired[pulumi.Input['IndexRuleTagKeyValueValueArgsDict']]
        """
        Field index description information.
        """
elif False:
    IndexRuleTagKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleTagKeyValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input['IndexRuleTagKeyValueValueArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] key: When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        :param pulumi.Input['IndexRuleTagKeyValueValueArgs'] value: Field index description information.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['IndexRuleTagKeyValueValueArgs']]:
        """
        Field index description information.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['IndexRuleTagKeyValueValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IndexRuleTagKeyValueValueArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Field type. Valid values: long, text, double.
        """
        contain_zh: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Chinese characters are contained.
        """
        sql_flag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the analysis feature is enabled for the field.
        """
        tokenizer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
elif False:
    IndexRuleTagKeyValueValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexRuleTagKeyValueValueArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 contain_zh: Optional[pulumi.Input[_builtins.bool]] = None,
                 sql_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 tokenizer: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Field type. Valid values: long, text, double.
        :param pulumi.Input[_builtins.bool] contain_zh: Whether Chinese characters are contained.
        :param pulumi.Input[_builtins.bool] sql_flag: Whether the analysis feature is enabled for the field.
        :param pulumi.Input[_builtins.str] tokenizer: Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        pulumi.set(__self__, "type", type)
        if contain_zh is not None:
            pulumi.set(__self__, "contain_zh", contain_zh)
        if sql_flag is not None:
            pulumi.set(__self__, "sql_flag", sql_flag)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Field type. Valid values: long, text, double.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="containZH")
    def contain_zh(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Chinese characters are contained.
        """
        return pulumi.get(self, "contain_zh")

    @contain_zh.setter
    def contain_zh(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "contain_zh", value)

    @_builtins.property
    @pulumi.getter(name="sqlFlag")
    def sql_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the analysis feature is enabled for the field.
        """
        return pulumi.get(self, "sql_flag")

    @sql_flag.setter
    def sql_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sql_flag", value)

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
        """
        return pulumi.get(self, "tokenizer")

    @tokenizer.setter
    def tokenizer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tokenizer", value)


if not MYPY:
    class KafkaRechargeLogRechargeRuleArgsDict(TypedDict):
        default_time_switch: pulumi.Input[_builtins.bool]
        """
        user default time.
        """
        encoding_format: pulumi.Input[_builtins.int]
        """
        encoding format.
        """
        recharge_type: pulumi.Input[_builtins.str]
        """
        recharge type.
        """
        default_time_src: NotRequired[pulumi.Input[_builtins.int]]
        """
        default time from.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        log key list.
        """
        log_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        log regex.
        """
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        metadata.
        """
        time_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        time format.
        """
        time_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        time key.
        """
        time_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        time regex.
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        time zone.
        """
        un_match_log_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        parse failed log key.
        """
        un_match_log_switch: NotRequired[pulumi.Input[_builtins.bool]]
        """
        is push parse failed log.
        """
        un_match_log_time_src: NotRequired[pulumi.Input[_builtins.int]]
        """
        parse failed log time from.
        """
elif False:
    KafkaRechargeLogRechargeRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaRechargeLogRechargeRuleArgs:
    def __init__(__self__, *,
                 default_time_switch: pulumi.Input[_builtins.bool],
                 encoding_format: pulumi.Input[_builtins.int],
                 recharge_type: pulumi.Input[_builtins.str],
                 default_time_src: Optional[pulumi.Input[_builtins.int]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 log_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 time_format: Optional[pulumi.Input[_builtins.str]] = None,
                 time_key: Optional[pulumi.Input[_builtins.str]] = None,
                 time_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_log_key: Optional[pulumi.Input[_builtins.str]] = None,
                 un_match_log_switch: Optional[pulumi.Input[_builtins.bool]] = None,
                 un_match_log_time_src: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] default_time_switch: user default time.
        :param pulumi.Input[_builtins.int] encoding_format: encoding format.
        :param pulumi.Input[_builtins.str] recharge_type: recharge type.
        :param pulumi.Input[_builtins.int] default_time_src: default time from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: log key list.
        :param pulumi.Input[_builtins.str] log_regex: log regex.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metadatas: metadata.
        :param pulumi.Input[_builtins.str] time_format: time format.
        :param pulumi.Input[_builtins.str] time_key: time key.
        :param pulumi.Input[_builtins.str] time_regex: time regex.
        :param pulumi.Input[_builtins.str] time_zone: time zone.
        :param pulumi.Input[_builtins.str] un_match_log_key: parse failed log key.
        :param pulumi.Input[_builtins.bool] un_match_log_switch: is push parse failed log.
        :param pulumi.Input[_builtins.int] un_match_log_time_src: parse failed log time from.
        """
        pulumi.set(__self__, "default_time_switch", default_time_switch)
        pulumi.set(__self__, "encoding_format", encoding_format)
        pulumi.set(__self__, "recharge_type", recharge_type)
        if default_time_src is not None:
            pulumi.set(__self__, "default_time_src", default_time_src)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if time_regex is not None:
            pulumi.set(__self__, "time_regex", time_regex)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_log_switch is not None:
            pulumi.set(__self__, "un_match_log_switch", un_match_log_switch)
        if un_match_log_time_src is not None:
            pulumi.set(__self__, "un_match_log_time_src", un_match_log_time_src)

    @_builtins.property
    @pulumi.getter(name="defaultTimeSwitch")
    def default_time_switch(self) -> pulumi.Input[_builtins.bool]:
        """
        user default time.
        """
        return pulumi.get(self, "default_time_switch")

    @default_time_switch.setter
    def default_time_switch(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "default_time_switch", value)

    @_builtins.property
    @pulumi.getter(name="encodingFormat")
    def encoding_format(self) -> pulumi.Input[_builtins.int]:
        """
        encoding format.
        """
        return pulumi.get(self, "encoding_format")

    @encoding_format.setter
    def encoding_format(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "encoding_format", value)

    @_builtins.property
    @pulumi.getter(name="rechargeType")
    def recharge_type(self) -> pulumi.Input[_builtins.str]:
        """
        recharge type.
        """
        return pulumi.get(self, "recharge_type")

    @recharge_type.setter
    def recharge_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "recharge_type", value)

    @_builtins.property
    @pulumi.getter(name="defaultTimeSrc")
    def default_time_src(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        default time from.
        """
        return pulumi.get(self, "default_time_src")

    @default_time_src.setter
    def default_time_src(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_time_src", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        log key list.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        log regex.
        """
        return pulumi.get(self, "log_regex")

    @log_regex.setter
    def log_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_regex", value)

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        metadata.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadatas", value)

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time format.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_format", value)

    @_builtins.property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time key.
        """
        return pulumi.get(self, "time_key")

    @time_key.setter
    def time_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_key", value)

    @_builtins.property
    @pulumi.getter(name="timeRegex")
    def time_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time regex.
        """
        return pulumi.get(self, "time_regex")

    @time_regex.setter
    def time_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_regex", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        parse failed log key.
        """
        return pulumi.get(self, "un_match_log_key")

    @un_match_log_key.setter
    def un_match_log_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "un_match_log_key", value)

    @_builtins.property
    @pulumi.getter(name="unMatchLogSwitch")
    def un_match_log_switch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        is push parse failed log.
        """
        return pulumi.get(self, "un_match_log_switch")

    @un_match_log_switch.setter
    def un_match_log_switch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "un_match_log_switch", value)

    @_builtins.property
    @pulumi.getter(name="unMatchLogTimeSrc")
    def un_match_log_time_src(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        parse failed log time from.
        """
        return pulumi.get(self, "un_match_log_time_src")

    @un_match_log_time_src.setter
    def un_match_log_time_src(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "un_match_log_time_src", value)


if not MYPY:
    class KafkaRechargeProtocolArgsDict(TypedDict):
        mechanism: NotRequired[pulumi.Input[_builtins.str]]
        """
        encryption type.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        user password.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        protocol type.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        username.
        """
elif False:
    KafkaRechargeProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaRechargeProtocolArgs:
    def __init__(__self__, *,
                 mechanism: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mechanism: encryption type.
        :param pulumi.Input[_builtins.str] password: user password.
        :param pulumi.Input[_builtins.str] protocol: protocol type.
        :param pulumi.Input[_builtins.str] user_name: username.
        """
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        encryption type.
        """
        return pulumi.get(self, "mechanism")

    @mechanism.setter
    def mechanism(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mechanism", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        user password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        protocol type.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        username.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class MachineGroupMachineGroupTypeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Machine group type. Valid values: ip: the IP addresses of collection machines are stored in Values of the machine group; label: the tags of the machines are stored in Values of the machine group.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Machine description list.
        """
elif False:
    MachineGroupMachineGroupTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineGroupMachineGroupTypeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] type: Machine group type. Valid values: ip: the IP addresses of collection machines are stored in Values of the machine group; label: the tags of the machines are stored in Values of the machine group.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Machine description list.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Machine group type. Valid values: ip: the IP addresses of collection machines are stored in Values of the machine group; label: the tags of the machines are stored in Values of the machine group.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Machine description list.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NoticeContentNoticeContentsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Channel type. Email: Email; Sms: SMS; WeChat: WeChat; Phone: Telephone; WeCom: Enterprise WeChat; DingTalk: DingTalk; Lark: Feishu; Http: Custom callback.
        """
        recovery_content: NotRequired[pulumi.Input['NoticeContentNoticeContentsRecoveryContentArgsDict']]
        """
        Template for Alarm Recovery Notification Content.
        """
        trigger_content: NotRequired[pulumi.Input['NoticeContentNoticeContentsTriggerContentArgsDict']]
        """
        Alarm triggered notification content template.
        """
elif False:
    NoticeContentNoticeContentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NoticeContentNoticeContentsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 recovery_content: Optional[pulumi.Input['NoticeContentNoticeContentsRecoveryContentArgs']] = None,
                 trigger_content: Optional[pulumi.Input['NoticeContentNoticeContentsTriggerContentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Channel type. Email: Email; Sms: SMS; WeChat: WeChat; Phone: Telephone; WeCom: Enterprise WeChat; DingTalk: DingTalk; Lark: Feishu; Http: Custom callback.
        :param pulumi.Input['NoticeContentNoticeContentsRecoveryContentArgs'] recovery_content: Template for Alarm Recovery Notification Content.
        :param pulumi.Input['NoticeContentNoticeContentsTriggerContentArgs'] trigger_content: Alarm triggered notification content template.
        """
        pulumi.set(__self__, "type", type)
        if recovery_content is not None:
            pulumi.set(__self__, "recovery_content", recovery_content)
        if trigger_content is not None:
            pulumi.set(__self__, "trigger_content", trigger_content)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Channel type. Email: Email; Sms: SMS; WeChat: WeChat; Phone: Telephone; WeCom: Enterprise WeChat; DingTalk: DingTalk; Lark: Feishu; Http: Custom callback.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="recoveryContent")
    def recovery_content(self) -> Optional[pulumi.Input['NoticeContentNoticeContentsRecoveryContentArgs']]:
        """
        Template for Alarm Recovery Notification Content.
        """
        return pulumi.get(self, "recovery_content")

    @recovery_content.setter
    def recovery_content(self, value: Optional[pulumi.Input['NoticeContentNoticeContentsRecoveryContentArgs']]):
        pulumi.set(self, "recovery_content", value)

    @_builtins.property
    @pulumi.getter(name="triggerContent")
    def trigger_content(self) -> Optional[pulumi.Input['NoticeContentNoticeContentsTriggerContentArgs']]:
        """
        Alarm triggered notification content template.
        """
        return pulumi.get(self, "trigger_content")

    @trigger_content.setter
    def trigger_content(self, value: Optional[pulumi.Input['NoticeContentNoticeContentsTriggerContentArgs']]):
        pulumi.set(self, "trigger_content", value)


if not MYPY:
    class NoticeContentNoticeContentsRecoveryContentArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notification content template body information.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
elif False:
    NoticeContentNoticeContentsRecoveryContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NoticeContentNoticeContentsRecoveryContentArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: Notification content template body information.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        :param pulumi.Input[_builtins.str] title: Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notification content template body information.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class NoticeContentNoticeContentsTriggerContentArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notification content template body information.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
elif False:
    NoticeContentNoticeContentsTriggerContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NoticeContentNoticeContentsTriggerContentArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: Notification content template body information.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        :param pulumi.Input[_builtins.str] title: Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notification content template body information.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Request headers: In HTTP requests, request headers contain additional information sent by the client to the server, such as user agent, authorization credentials, expected response format, etc. Only `custom callback` supports this configuration.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notification content template title information. Some notification channel types do not support 'title', please refer to the Tencent Cloud Console page.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ScheduledSqlDstResourceArgsDict(TypedDict):
        topic_id: pulumi.Input[_builtins.str]
        """
        dst topic id.
        """
        biz_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        topic type.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        metric name.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        topic region.
        """
elif False:
    ScheduledSqlDstResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledSqlDstResourceArgs:
    def __init__(__self__, *,
                 topic_id: pulumi.Input[_builtins.str],
                 biz_type: Optional[pulumi.Input[_builtins.int]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_id: dst topic id.
        :param pulumi.Input[_builtins.int] biz_type: topic type.
        :param pulumi.Input[_builtins.str] metric_name: metric name.
        :param pulumi.Input[_builtins.str] region: topic region.
        """
        pulumi.set(__self__, "topic_id", topic_id)
        if biz_type is not None:
            pulumi.set(__self__, "biz_type", biz_type)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[_builtins.str]:
        """
        dst topic id.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_id", value)

    @_builtins.property
    @pulumi.getter(name="bizType")
    def biz_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        topic type.
        """
        return pulumi.get(self, "biz_type")

    @biz_type.setter
    def biz_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "biz_type", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        topic region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class TopicExtendsArgsDict(TypedDict):
        anonymous_access: NotRequired[pulumi.Input['TopicExtendsAnonymousAccessArgsDict']]
        """
        Log topic authentication free configuration information.
        """
elif False:
    TopicExtendsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicExtendsArgs:
    def __init__(__self__, *,
                 anonymous_access: Optional[pulumi.Input['TopicExtendsAnonymousAccessArgs']] = None):
        """
        :param pulumi.Input['TopicExtendsAnonymousAccessArgs'] anonymous_access: Log topic authentication free configuration information.
        """
        if anonymous_access is not None:
            pulumi.set(__self__, "anonymous_access", anonymous_access)

    @_builtins.property
    @pulumi.getter(name="anonymousAccess")
    def anonymous_access(self) -> Optional[pulumi.Input['TopicExtendsAnonymousAccessArgs']]:
        """
        Log topic authentication free configuration information.
        """
        return pulumi.get(self, "anonymous_access")

    @anonymous_access.setter
    def anonymous_access(self, value: Optional[pulumi.Input['TopicExtendsAnonymousAccessArgs']]):
        pulumi.set(self, "anonymous_access", value)


if not MYPY:
    class TopicExtendsAnonymousAccessArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicExtendsAnonymousAccessConditionArgsDict']]]]
        """
        Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
        operations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
elif False:
    TopicExtendsAnonymousAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicExtendsAnonymousAccessArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['TopicExtendsAnonymousAccessConditionArgs']]]] = None,
                 operations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TopicExtendsAnonymousAccessConditionArgs']]] conditions: Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] operations: Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicExtendsAnonymousAccessConditionArgs']]]]:
        """
        Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicExtendsAnonymousAccessConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Operation list, supporting trackLog (JS/HTTP upload log) and realtimeProducer (kafka protocol upload log).
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "operations", value)


if not MYPY:
    class TopicExtendsAnonymousAccessConditionArgsDict(TypedDict):
        attributes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Condition attribute, currently only VpcID is supported.
        """
        condition_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the corresponding conditional attribute.
        """
        rule: NotRequired[pulumi.Input[_builtins.int]]
        """
        Conditional rule, 1: equal, 2: not equal.
        """
elif False:
    TopicExtendsAnonymousAccessConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicExtendsAnonymousAccessConditionArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[_builtins.str]] = None,
                 condition_value: Optional[pulumi.Input[_builtins.str]] = None,
                 rule: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] attributes: Condition attribute, currently only VpcID is supported.
        :param pulumi.Input[_builtins.str] condition_value: The value of the corresponding conditional attribute.
        :param pulumi.Input[_builtins.int] rule: Conditional rule, 1: equal, 2: not equal.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if condition_value is not None:
            pulumi.set(__self__, "condition_value", condition_value)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Condition attribute, currently only VpcID is supported.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the corresponding conditional attribute.
        """
        return pulumi.get(self, "condition_value")

    @condition_value.setter
    def condition_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition_value", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Conditional rule, 1: equal, 2: not equal.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule", value)


if not MYPY:
    class GetLogsetsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Fields that need to be filtered. Support: `logsetName`, `logsetId`, `tagKey`, `tag:tagKey`.
        """
        values: Sequence[_builtins.str]
        """
        The values that need to be filtered.
        """
elif False:
    GetLogsetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogsetsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Fields that need to be filtered. Support: `logsetName`, `logsetId`, `tagKey`, `tag:tagKey`.
        :param Sequence[_builtins.str] values: The values that need to be filtered.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Fields that need to be filtered. Support: `logsetName`, `logsetId`, `tagKey`, `tag:tagKey`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values that need to be filtered.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTopicsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Field to be filtered.
        """
        values: Sequence[_builtins.str]
        """
        Value to be filtered.
        """
elif False:
    GetTopicsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTopicsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Field to be filtered.
        :param Sequence[_builtins.str] values: Value to be filtered.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Field to be filtered.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Value to be filtered.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


