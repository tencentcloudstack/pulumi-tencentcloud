# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AntiInfoLeakStrategy',
    'AttackWhiteRuleRule',
    'BotSceneUcbRuleRule',
    'BotSceneUcbRuleRuleActionList',
    'BotSceneUcbRuleRuleJobDateTime',
    'BotSceneUcbRuleRuleJobDateTimeCron',
    'BotSceneUcbRuleRuleJobDateTimeTimed',
    'BotSceneUcbRuleRuleRule',
    'BotSceneUcbRuleRuleRuleArea',
    'BotSceneUcbRuleRuleRuleValue',
    'BotStatusConfigCurrentGlobalScene',
    'ClbDomainLoadBalancerSet',
    'CustomRuleJobDateTime',
    'CustomRuleJobDateTimeCron',
    'CustomRuleJobDateTimeTimed',
    'CustomRuleStrategy',
    'CustomWhiteRuleJobDateTime',
    'CustomWhiteRuleJobDateTimeCron',
    'CustomWhiteRuleJobDateTimeTimed',
    'CustomWhiteRuleStrategy',
    'IpAccessControlItem',
    'IpAccessControlV2JobDateTime',
    'IpAccessControlV2JobDateTimeCron',
    'IpAccessControlV2JobDateTimeTimed',
    'LogPostCkafkaFlowWriteConfig',
    'OwaspWhiteRuleJobDateTime',
    'OwaspWhiteRuleJobDateTimeCron',
    'OwaspWhiteRuleJobDateTimeTimed',
    'OwaspWhiteRuleStrategy',
    'SaasDomainPort',
    'GetAttackLogHistogramDataResult',
    'GetAttackLogListDataResult',
    'GetCiphersCipherResult',
    'GetDomainsDomainResult',
    'GetDomainsDomainLoadBalancerSetResult',
    'GetDomainsDomainPortResult',
    'GetFindDomainsListResult',
    'GetInstanceQpsLimitQpsDataResult',
    'GetOwaspRuleTypesFilterResult',
    'GetOwaspRuleTypesListResult',
    'GetOwaspRulesFilterResult',
    'GetOwaspRulesListResult',
    'GetPeakPointsPointResult',
    'GetTlsVersionsTlResult',
    'GetUserClbRegionsRichDataResult',
    'GetUserDomainsUsersInfoResult',
]

@pulumi.output_type
class AntiInfoLeakStrategy(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 field: _builtins.str):
        """
        :param _builtins.str content: Matching content
               The following options are available when Field is set to information:
               idcard (ID card), phone (phone number), and bankcard (bank card).
               The following options are available when Field is set to returncode:
               400 (status code 400), 403 (status code 403), 404 (status code 404), 4xx (other 4xx status codes), 500 (status code 500), 501 (status code 501), 502 (status code 502), 504 (status code 504), and 5xx (other 5xx status codes).
               When Field is set to keywords, users need to input the matching content themselves.
        :param _builtins.str field: Matching Criteria, returncode (Response Code), keywords (Keywords), information (Sensitive Information).
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Matching content
        The following options are available when Field is set to information:
        idcard (ID card), phone (phone number), and bankcard (bank card).
        The following options are available when Field is set to returncode:
        400 (status code 400), 403 (status code 403), 404 (status code 404), 4xx (other 4xx status codes), 500 (status code 500), 501 (status code 501), 502 (status code 502), 504 (status code 504), and 5xx (other 5xx status codes).
        When Field is set to keywords, users need to input the matching content themselves.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Matching Criteria, returncode (Response Code), keywords (Keywords), information (Sensitive Information).
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class AttackWhiteRuleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchContent":
            suggest = "match_content"
        elif key == "matchField":
            suggest = "match_field"
        elif key == "matchMethod":
            suggest = "match_method"
        elif key == "matchParams":
            suggest = "match_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackWhiteRuleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackWhiteRuleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackWhiteRuleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_content: _builtins.str,
                 match_field: _builtins.str,
                 match_method: _builtins.str,
                 match_params: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_content: Matching content.
        :param _builtins.str match_field: Matching domains.
        :param _builtins.str match_method: Matching method.
        :param _builtins.str match_params: Matching params.
        """
        pulumi.set(__self__, "match_content", match_content)
        pulumi.set(__self__, "match_field", match_field)
        pulumi.set(__self__, "match_method", match_method)
        if match_params is not None:
            pulumi.set(__self__, "match_params", match_params)

    @_builtins.property
    @pulumi.getter(name="matchContent")
    def match_content(self) -> _builtins.str:
        """
        Matching content.
        """
        return pulumi.get(self, "match_content")

    @_builtins.property
    @pulumi.getter(name="matchField")
    def match_field(self) -> _builtins.str:
        """
        Matching domains.
        """
        return pulumi.get(self, "match_field")

    @_builtins.property
    @pulumi.getter(name="matchMethod")
    def match_method(self) -> _builtins.str:
        """
        Matching method.
        """
        return pulumi.get(self, "match_method")

    @_builtins.property
    @pulumi.getter(name="matchParams")
    def match_params(self) -> Optional[_builtins.str]:
        """
        Matching params.
        """
        return pulumi.get(self, "match_params")


@pulumi.output_type
class BotSceneUcbRuleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onOff":
            suggest = "on_off"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "actionLists":
            suggest = "action_lists"
        elif key == "additionArg":
            suggest = "addition_arg"
        elif key == "blockPageId":
            suggest = "block_page_id"
        elif key == "expireTime":
            suggest = "expire_time"
        elif key == "jobDateTime":
            suggest = "job_date_time"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "preDefine":
            suggest = "pre_define"
        elif key == "sceneId":
            suggest = "scene_id"
        elif key == "validStatus":
            suggest = "valid_status"
        elif key == "validTime":
            suggest = "valid_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotSceneUcbRuleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotSceneUcbRuleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotSceneUcbRuleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 domain: _builtins.str,
                 label: _builtins.str,
                 name: _builtins.str,
                 on_off: _builtins.str,
                 prior: _builtins.int,
                 rule_type: _builtins.int,
                 rules: Sequence['outputs.BotSceneUcbRuleRuleRule'],
                 action_lists: Optional[Sequence['outputs.BotSceneUcbRuleRuleActionList']] = None,
                 addition_arg: Optional[_builtins.str] = None,
                 appid: Optional[_builtins.int] = None,
                 block_page_id: Optional[_builtins.int] = None,
                 desc: Optional[_builtins.str] = None,
                 expire_time: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 job_date_time: Optional['outputs.BotSceneUcbRuleRuleJobDateTime'] = None,
                 job_type: Optional[_builtins.str] = None,
                 pre_define: Optional[_builtins.bool] = None,
                 scene_id: Optional[_builtins.str] = None,
                 valid_status: Optional[_builtins.int] = None,
                 valid_time: Optional[_builtins.int] = None):
        """
        :param _builtins.str action: Disposal action.
        :param _builtins.str domain: Domain.
        :param _builtins.str label: Label.
        :param _builtins.str name: Rule name.
        :param _builtins.str on_off: Rule switch.
        :param _builtins.int prior: Rule priority.
        :param _builtins.int rule_type: Rule type.
        :param Sequence['BotSceneUcbRuleRuleRuleArgs'] rules: Specific rule items of UCB.
        :param Sequence['BotSceneUcbRuleRuleActionListArgs'] action_lists: When Action=intercept, this field is mandatory.
        :param _builtins.str addition_arg: Additional parameters.
        :param _builtins.int appid: Appid.
        :param _builtins.int block_page_id: Customize interception page ID.
        :param _builtins.str desc: Rule description.
        :param _builtins.int expire_time: Effective deadline.
        :param _builtins.str id: Entry ID.
        :param 'BotSceneUcbRuleRuleJobDateTimeArgs' job_date_time: Scheduled task configuration.
        :param _builtins.str job_type: Scheduled task type.
        :param _builtins.bool pre_define: True - System preset rules False - Custom rules.
        :param _builtins.str scene_id: Scene ID.
        :param _builtins.int valid_status: Effective -1, Invalid -0.
        :param _builtins.int valid_time: Valid time.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "on_off", on_off)
        pulumi.set(__self__, "prior", prior)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "rules", rules)
        if action_lists is not None:
            pulumi.set(__self__, "action_lists", action_lists)
        if addition_arg is not None:
            pulumi.set(__self__, "addition_arg", addition_arg)
        if appid is not None:
            pulumi.set(__self__, "appid", appid)
        if block_page_id is not None:
            pulumi.set(__self__, "block_page_id", block_page_id)
        if desc is not None:
            pulumi.set(__self__, "desc", desc)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if job_date_time is not None:
            pulumi.set(__self__, "job_date_time", job_date_time)
        if job_type is not None:
            pulumi.set(__self__, "job_type", job_type)
        if pre_define is not None:
            pulumi.set(__self__, "pre_define", pre_define)
        if scene_id is not None:
            pulumi.set(__self__, "scene_id", scene_id)
        if valid_status is not None:
            pulumi.set(__self__, "valid_status", valid_status)
        if valid_time is not None:
            pulumi.set(__self__, "valid_time", valid_time)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Disposal action.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        Label.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="onOff")
    def on_off(self) -> _builtins.str:
        """
        Rule switch.
        """
        return pulumi.get(self, "on_off")

    @_builtins.property
    @pulumi.getter
    def prior(self) -> _builtins.int:
        """
        Rule priority.
        """
        return pulumi.get(self, "prior")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.int:
        """
        Rule type.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.BotSceneUcbRuleRuleRule']:
        """
        Specific rule items of UCB.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="actionLists")
    def action_lists(self) -> Optional[Sequence['outputs.BotSceneUcbRuleRuleActionList']]:
        """
        When Action=intercept, this field is mandatory.
        """
        return pulumi.get(self, "action_lists")

    @_builtins.property
    @pulumi.getter(name="additionArg")
    def addition_arg(self) -> Optional[_builtins.str]:
        """
        Additional parameters.
        """
        return pulumi.get(self, "addition_arg")

    @_builtins.property
    @pulumi.getter
    def appid(self) -> Optional[_builtins.int]:
        """
        Appid.
        """
        return pulumi.get(self, "appid")

    @_builtins.property
    @pulumi.getter(name="blockPageId")
    def block_page_id(self) -> Optional[_builtins.int]:
        """
        Customize interception page ID.
        """
        return pulumi.get(self, "block_page_id")

    @_builtins.property
    @pulumi.getter
    def desc(self) -> Optional[_builtins.str]:
        """
        Rule description.
        """
        return pulumi.get(self, "desc")

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[_builtins.int]:
        """
        Effective deadline.
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Entry ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="jobDateTime")
    def job_date_time(self) -> Optional['outputs.BotSceneUcbRuleRuleJobDateTime']:
        """
        Scheduled task configuration.
        """
        return pulumi.get(self, "job_date_time")

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> Optional[_builtins.str]:
        """
        Scheduled task type.
        """
        return pulumi.get(self, "job_type")

    @_builtins.property
    @pulumi.getter(name="preDefine")
    def pre_define(self) -> Optional[_builtins.bool]:
        """
        True - System preset rules False - Custom rules.
        """
        return pulumi.get(self, "pre_define")

    @_builtins.property
    @pulumi.getter(name="sceneId")
    def scene_id(self) -> Optional[_builtins.str]:
        """
        Scene ID.
        """
        return pulumi.get(self, "scene_id")

    @_builtins.property
    @pulumi.getter(name="validStatus")
    def valid_status(self) -> Optional[_builtins.int]:
        """
        Effective -1, Invalid -0.
        """
        return pulumi.get(self, "valid_status")

    @_builtins.property
    @pulumi.getter(name="validTime")
    def valid_time(self) -> Optional[_builtins.int]:
        """
        Valid time.
        """
        return pulumi.get(self, "valid_time")


@pulumi.output_type
class BotSceneUcbRuleRuleActionList(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 proportion: Optional[_builtins.float] = None):
        """
        :param _builtins.str action: Action.
        :param _builtins.float proportion: Proportion.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if proportion is not None:
            pulumi.set(__self__, "proportion", proportion)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Action.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def proportion(self) -> Optional[_builtins.float]:
        """
        Proportion.
        """
        return pulumi.get(self, "proportion")


@pulumi.output_type
class BotSceneUcbRuleRuleJobDateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTZone":
            suggest = "time_t_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotSceneUcbRuleRuleJobDateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotSceneUcbRuleRuleJobDateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotSceneUcbRuleRuleJobDateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crons: Optional[Sequence['outputs.BotSceneUcbRuleRuleJobDateTimeCron']] = None,
                 time_t_zone: Optional[_builtins.str] = None,
                 timeds: Optional[Sequence['outputs.BotSceneUcbRuleRuleJobDateTimeTimed']] = None):
        """
        :param Sequence['BotSceneUcbRuleRuleJobDateTimeCronArgs'] crons: Time parameter for cycle execution.
        :param _builtins.str time_t_zone: Time zone.
        :param Sequence['BotSceneUcbRuleRuleJobDateTimeTimedArgs'] timeds: Time parameter for timed execution.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[Sequence['outputs.BotSceneUcbRuleRuleJobDateTimeCron']]:
        """
        Time parameter for cycle execution.
        """
        return pulumi.get(self, "crons")

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[_builtins.str]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_t_zone")

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[Sequence['outputs.BotSceneUcbRuleRuleJobDateTimeTimed']]:
        """
        Time parameter for timed execution.
        """
        return pulumi.get(self, "timeds")


@pulumi.output_type
class BotSceneUcbRuleRuleJobDateTimeCron(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "wDays":
            suggest = "w_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotSceneUcbRuleRuleJobDateTimeCron. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotSceneUcbRuleRuleJobDateTimeCron.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotSceneUcbRuleRuleJobDateTimeCron.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 w_days: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence[_builtins.int] days: On what day of each month is it executed.
        :param _builtins.str end_time: End time.
        :param _builtins.str start_time: Start time.
        :param Sequence[_builtins.int] w_days: What day of the week is executed each week.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[Sequence[_builtins.int]]:
        """
        On what day of each month is it executed.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        What day of the week is executed each week.
        """
        return pulumi.get(self, "w_days")


@pulumi.output_type
class BotSceneUcbRuleRuleJobDateTimeTimed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDateTime":
            suggest = "end_date_time"
        elif key == "startDateTime":
            suggest = "start_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotSceneUcbRuleRuleJobDateTimeTimed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotSceneUcbRuleRuleJobDateTimeTimed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotSceneUcbRuleRuleJobDateTimeTimed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date_time: Optional[_builtins.int] = None,
                 start_date_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_date_time: End timestamp, in seconds.
        :param _builtins.int start_date_time: Start timestamp, in seconds.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[_builtins.int]:
        """
        End timestamp, in seconds.
        """
        return pulumi.get(self, "end_date_time")

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[_builtins.int]:
        """
        Start timestamp, in seconds.
        """
        return pulumi.get(self, "start_date_time")


@pulumi.output_type
class BotSceneUcbRuleRuleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opArgs":
            suggest = "op_args"
        elif key == "opOp":
            suggest = "op_op"
        elif key == "opValue":
            suggest = "op_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotSceneUcbRuleRuleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotSceneUcbRuleRuleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotSceneUcbRuleRuleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 areas: Optional[Sequence['outputs.BotSceneUcbRuleRuleRuleArea']] = None,
                 key: Optional[_builtins.str] = None,
                 lang: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 op: Optional[_builtins.str] = None,
                 op_args: Optional[Sequence[_builtins.str]] = None,
                 op_op: Optional[_builtins.str] = None,
                 op_value: Optional[_builtins.float] = None,
                 value: Optional['outputs.BotSceneUcbRuleRuleRuleValue'] = None):
        """
        :param Sequence['BotSceneUcbRuleRuleRuleAreaArgs'] areas: Regional selection.
        :param _builtins.str key: Key.
        :param _builtins.str lang: Language environment.
        :param _builtins.str name: Rule name.
        :param _builtins.str op: Operator.
        :param Sequence[_builtins.str] op_args: Optional supplementary parameters.
        :param _builtins.str op_op: Optional Supplementary Operators.
        :param _builtins.float op_value: Optional supplementary values.
        :param 'BotSceneUcbRuleRuleRuleValueArgs' value: Value.
        """
        if areas is not None:
            pulumi.set(__self__, "areas", areas)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if op_args is not None:
            pulumi.set(__self__, "op_args", op_args)
        if op_op is not None:
            pulumi.set(__self__, "op_op", op_op)
        if op_value is not None:
            pulumi.set(__self__, "op_value", op_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Optional[Sequence['outputs.BotSceneUcbRuleRuleRuleArea']]:
        """
        Regional selection.
        """
        return pulumi.get(self, "areas")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def lang(self) -> Optional[_builtins.str]:
        """
        Language environment.
        """
        return pulumi.get(self, "lang")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def op(self) -> Optional[_builtins.str]:
        """
        Operator.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter(name="opArgs")
    def op_args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional supplementary parameters.
        """
        return pulumi.get(self, "op_args")

    @_builtins.property
    @pulumi.getter(name="opOp")
    def op_op(self) -> Optional[_builtins.str]:
        """
        Optional Supplementary Operators.
        """
        return pulumi.get(self, "op_op")

    @_builtins.property
    @pulumi.getter(name="opValue")
    def op_value(self) -> Optional[_builtins.float]:
        """
        Optional supplementary values.
        """
        return pulumi.get(self, "op_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.BotSceneUcbRuleRuleRuleValue']:
        """
        Value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BotSceneUcbRuleRuleRuleArea(dict):
    def __init__(__self__, *,
                 country: _builtins.str,
                 city: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str country: In addition to standard countries, the country also supports two special identifiers: domestic and foreign.
        :param _builtins.str city: City.
        :param _builtins.str region: Province.
        """
        pulumi.set(__self__, "country", country)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        In addition to standard countries, the country also supports two special identifiers: domestic and foreign.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Province.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class BotSceneUcbRuleRuleRuleValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicValue":
            suggest = "basic_value"
        elif key == "belongValues":
            suggest = "belong_values"
        elif key == "logicValue":
            suggest = "logic_value"
        elif key == "multiValues":
            suggest = "multi_values"
        elif key == "validKey":
            suggest = "valid_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotSceneUcbRuleRuleRuleValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotSceneUcbRuleRuleRuleValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotSceneUcbRuleRuleRuleValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_value: Optional[_builtins.str] = None,
                 belong_values: Optional[Sequence[_builtins.str]] = None,
                 logic_value: Optional[_builtins.bool] = None,
                 multi_values: Optional[Sequence[_builtins.str]] = None,
                 valid_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str basic_value: String type value.
        :param Sequence[_builtins.str] belong_values: String array type value.
        :param _builtins.bool logic_value: Bool type value.
        :param Sequence[_builtins.str] multi_values: String array type value.
        :param _builtins.str valid_key: Indicate valid fields.
        """
        if basic_value is not None:
            pulumi.set(__self__, "basic_value", basic_value)
        if belong_values is not None:
            pulumi.set(__self__, "belong_values", belong_values)
        if logic_value is not None:
            pulumi.set(__self__, "logic_value", logic_value)
        if multi_values is not None:
            pulumi.set(__self__, "multi_values", multi_values)
        if valid_key is not None:
            pulumi.set(__self__, "valid_key", valid_key)

    @_builtins.property
    @pulumi.getter(name="basicValue")
    def basic_value(self) -> Optional[_builtins.str]:
        """
        String type value.
        """
        return pulumi.get(self, "basic_value")

    @_builtins.property
    @pulumi.getter(name="belongValues")
    def belong_values(self) -> Optional[Sequence[_builtins.str]]:
        """
        String array type value.
        """
        return pulumi.get(self, "belong_values")

    @_builtins.property
    @pulumi.getter(name="logicValue")
    def logic_value(self) -> Optional[_builtins.bool]:
        """
        Bool type value.
        """
        return pulumi.get(self, "logic_value")

    @_builtins.property
    @pulumi.getter(name="multiValues")
    def multi_values(self) -> Optional[Sequence[_builtins.str]]:
        """
        String array type value.
        """
        return pulumi.get(self, "multi_values")

    @_builtins.property
    @pulumi.getter(name="validKey")
    def valid_key(self) -> Optional[_builtins.str]:
        """
        Indicate valid fields.
        """
        return pulumi.get(self, "valid_key")


@pulumi.output_type
class BotStatusConfigCurrentGlobalScene(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sceneId":
            suggest = "scene_id"
        elif key == "sceneName":
            suggest = "scene_name"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotStatusConfigCurrentGlobalScene. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotStatusConfigCurrentGlobalScene.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotStatusConfigCurrentGlobalScene.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: Optional[_builtins.int] = None,
                 scene_id: Optional[_builtins.str] = None,
                 scene_name: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int priority: Priority.
        :param _builtins.str scene_id: Scene ID.
        :param _builtins.str scene_name: Scene name.
        :param _builtins.int update_time: Update time.
        """
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scene_id is not None:
            pulumi.set(__self__, "scene_id", scene_id)
        if scene_name is not None:
            pulumi.set(__self__, "scene_name", scene_name)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="sceneId")
    def scene_id(self) -> Optional[_builtins.str]:
        """
        Scene ID.
        """
        return pulumi.get(self, "scene_id")

    @_builtins.property
    @pulumi.getter(name="sceneName")
    def scene_name(self) -> Optional[_builtins.str]:
        """
        Scene name.
        """
        return pulumi.get(self, "scene_name")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.int]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class ClbDomainLoadBalancerSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenerId":
            suggest = "listener_id"
        elif key == "listenerName":
            suggest = "listener_name"
        elif key == "loadBalancerId":
            suggest = "load_balancer_id"
        elif key == "loadBalancerName":
            suggest = "load_balancer_name"
        elif key == "loadBalancerType":
            suggest = "load_balancer_type"
        elif key == "numericalVpcId":
            suggest = "numerical_vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClbDomainLoadBalancerSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClbDomainLoadBalancerSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClbDomainLoadBalancerSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 listener_id: _builtins.str,
                 listener_name: _builtins.str,
                 load_balancer_id: _builtins.str,
                 load_balancer_name: _builtins.str,
                 protocol: _builtins.str,
                 region: _builtins.str,
                 vip: _builtins.str,
                 vport: _builtins.int,
                 zone: _builtins.str,
                 load_balancer_type: Optional[_builtins.str] = None,
                 numerical_vpc_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str listener_id: Unique ID of listener in LB.
        :param _builtins.str listener_name: Listener name.
        :param _builtins.str load_balancer_id: LoadBalancer unique ID.
        :param _builtins.str load_balancer_name: LoadBalancer name.
        :param _builtins.str protocol: Protocol of listener, http or https.
        :param _builtins.str region: LoadBalancer region.
        :param _builtins.str vip: LoadBalancer IP.
        :param _builtins.int vport: LoadBalancer port.
        :param _builtins.str zone: LoadBalancer zone.
        :param _builtins.str load_balancer_type: Network type for load balancer.
        :param _builtins.int numerical_vpc_id: VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditions.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "listener_name", listener_name)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vport", vport)
        pulumi.set(__self__, "zone", zone)
        if load_balancer_type is not None:
            pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        if numerical_vpc_id is not None:
            pulumi.set(__self__, "numerical_vpc_id", numerical_vpc_id)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        Unique ID of listener in LB.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="listenerName")
    def listener_name(self) -> _builtins.str:
        """
        Listener name.
        """
        return pulumi.get(self, "listener_name")

    @_builtins.property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> _builtins.str:
        """
        LoadBalancer unique ID.
        """
        return pulumi.get(self, "load_balancer_id")

    @_builtins.property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> _builtins.str:
        """
        LoadBalancer name.
        """
        return pulumi.get(self, "load_balancer_name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol of listener, http or https.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        LoadBalancer region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> _builtins.str:
        """
        LoadBalancer IP.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter
    def vport(self) -> _builtins.int:
        """
        LoadBalancer port.
        """
        return pulumi.get(self, "vport")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        LoadBalancer zone.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> Optional[_builtins.str]:
        """
        Network type for load balancer.
        """
        return pulumi.get(self, "load_balancer_type")

    @_builtins.property
    @pulumi.getter(name="numericalVpcId")
    def numerical_vpc_id(self) -> Optional[_builtins.int]:
        """
        VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditions.
        """
        return pulumi.get(self, "numerical_vpc_id")


@pulumi.output_type
class CustomRuleJobDateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTZone":
            suggest = "time_t_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomRuleJobDateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomRuleJobDateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomRuleJobDateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crons: Optional[Sequence['outputs.CustomRuleJobDateTimeCron']] = None,
                 time_t_zone: Optional[_builtins.str] = None,
                 timeds: Optional[Sequence['outputs.CustomRuleJobDateTimeTimed']] = None):
        """
        :param Sequence['CustomRuleJobDateTimeCronArgs'] crons: Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str time_t_zone: Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['CustomRuleJobDateTimeTimedArgs'] timeds: Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[Sequence['outputs.CustomRuleJobDateTimeCron']]:
        """
        Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "crons")

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[_builtins.str]:
        """
        Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_t_zone")

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[Sequence['outputs.CustomRuleJobDateTimeTimed']]:
        """
        Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeds")


@pulumi.output_type
class CustomRuleJobDateTimeCron(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "wDays":
            suggest = "w_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomRuleJobDateTimeCron. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomRuleJobDateTimeCron.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomRuleJobDateTimeCron.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 w_days: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence[_builtins.int] days: Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str end_time: End time. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str start_time: Start time. Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence[_builtins.int] w_days: Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "w_days")


@pulumi.output_type
class CustomRuleJobDateTimeTimed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDateTime":
            suggest = "end_date_time"
        elif key == "startDateTime":
            suggest = "start_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomRuleJobDateTimeTimed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomRuleJobDateTimeTimed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomRuleJobDateTimeTimed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date_time: Optional[_builtins.int] = None,
                 start_date_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_date_time: End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int start_date_time: Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[_builtins.int]:
        """
        End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_date_time")

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[_builtins.int]:
        """
        Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_date_time")


@pulumi.output_type
class CustomRuleStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareFunc":
            suggest = "compare_func"
        elif key == "caseNotSensitive":
            suggest = "case_not_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomRuleStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomRuleStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomRuleStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arg: _builtins.str,
                 compare_func: _builtins.str,
                 content: _builtins.str,
                 field: _builtins.str,
                 case_not_sensitive: Optional[_builtins.int] = None):
        """
        :param _builtins.str arg: Matching parameter
               There are two types of configuration parameters: unsupported parameters and supported parameters.
               The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
               GET (GET parameter value)
               POST (POST parameter value)
               ARGS_COOKIE (Cookie parameter value)
               ARGS_HEADER (Header parameter value)
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str compare_func: Logic symbol
               Logical symbols are divided into the following types:
               empty (content is empty)
               null (do not exist)
               eq (equal to)
               neq (not equal to)
               contains (contain)
               ncontains (do not contain)
               strprefix (prefix matching)
               strsuffix (suffix matching)
               len_eq (length equals to)
               len_gt (length is greater than)
               len_lt (length is less than)
               ipmatch (belong to)
               ipnmatch (do not belong to)
               numgt (number greater than)
               numlt (number less than)
               geo_in (IP geo belongs to)
               geo_not_in (IP geo not belongs to)
               rematch (regex match)
               numgt (numerically greater than)
               numlt (numerically less than)
               numeq (numerically equal to)
               numneq (numerically not equal to)
               numle (numerically less than or equal to)
               numge (numerically greater than or equal to)
               Different matching fields correspond to different logical operators. For details, see the matching field table above.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str content: Matching content
               Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str field: Matching field
               Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
               <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int case_not_sensitive: 0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "arg", arg)
        pulumi.set(__self__, "compare_func", compare_func)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)
        if case_not_sensitive is not None:
            pulumi.set(__self__, "case_not_sensitive", case_not_sensitive)

    @_builtins.property
    @pulumi.getter
    def arg(self) -> _builtins.str:
        """
        Matching parameter
        There are two types of configuration parameters: unsupported parameters and supported parameters.
        The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
        GET (GET parameter value)
        POST (POST parameter value)
        ARGS_COOKIE (Cookie parameter value)
        ARGS_HEADER (Header parameter value)
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "arg")

    @_builtins.property
    @pulumi.getter(name="compareFunc")
    def compare_func(self) -> _builtins.str:
        """
        Logic symbol
        Logical symbols are divided into the following types:
        empty (content is empty)
        null (do not exist)
        eq (equal to)
        neq (not equal to)
        contains (contain)
        ncontains (do not contain)
        strprefix (prefix matching)
        strsuffix (suffix matching)
        len_eq (length equals to)
        len_gt (length is greater than)
        len_lt (length is less than)
        ipmatch (belong to)
        ipnmatch (do not belong to)
        numgt (number greater than)
        numlt (number less than)
        geo_in (IP geo belongs to)
        geo_not_in (IP geo not belongs to)
        rematch (regex match)
        numgt (numerically greater than)
        numlt (numerically less than)
        numeq (numerically equal to)
        numneq (numerically not equal to)
        numle (numerically less than or equal to)
        numge (numerically greater than or equal to)
        Different matching fields correspond to different logical operators. For details, see the matching field table above.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "compare_func")

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Matching content
        Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Matching field
        Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
        <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="caseNotSensitive")
    def case_not_sensitive(self) -> Optional[_builtins.int]:
        """
        0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "case_not_sensitive")


@pulumi.output_type
class CustomWhiteRuleJobDateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTZone":
            suggest = "time_t_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomWhiteRuleJobDateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomWhiteRuleJobDateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomWhiteRuleJobDateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crons: Optional[Sequence['outputs.CustomWhiteRuleJobDateTimeCron']] = None,
                 time_t_zone: Optional[_builtins.str] = None,
                 timeds: Optional[Sequence['outputs.CustomWhiteRuleJobDateTimeTimed']] = None):
        """
        :param Sequence['CustomWhiteRuleJobDateTimeCronArgs'] crons: Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str time_t_zone: Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['CustomWhiteRuleJobDateTimeTimedArgs'] timeds: Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[Sequence['outputs.CustomWhiteRuleJobDateTimeCron']]:
        """
        Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "crons")

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[_builtins.str]:
        """
        Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_t_zone")

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[Sequence['outputs.CustomWhiteRuleJobDateTimeTimed']]:
        """
        Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeds")


@pulumi.output_type
class CustomWhiteRuleJobDateTimeCron(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "wDays":
            suggest = "w_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomWhiteRuleJobDateTimeCron. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomWhiteRuleJobDateTimeCron.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomWhiteRuleJobDateTimeCron.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 w_days: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence[_builtins.int] days: Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str end_time: End time. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str start_time: Start time. Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence[_builtins.int] w_days: Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "w_days")


@pulumi.output_type
class CustomWhiteRuleJobDateTimeTimed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDateTime":
            suggest = "end_date_time"
        elif key == "startDateTime":
            suggest = "start_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomWhiteRuleJobDateTimeTimed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomWhiteRuleJobDateTimeTimed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomWhiteRuleJobDateTimeTimed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date_time: Optional[_builtins.int] = None,
                 start_date_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_date_time: End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int start_date_time: Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[_builtins.int]:
        """
        End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_date_time")

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[_builtins.int]:
        """
        Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_date_time")


@pulumi.output_type
class CustomWhiteRuleStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareFunc":
            suggest = "compare_func"
        elif key == "caseNotSensitive":
            suggest = "case_not_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomWhiteRuleStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomWhiteRuleStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomWhiteRuleStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arg: _builtins.str,
                 compare_func: _builtins.str,
                 content: _builtins.str,
                 field: _builtins.str,
                 case_not_sensitive: Optional[_builtins.int] = None):
        """
        :param _builtins.str arg: Matching parameter
               There are two types of configuration parameters: unsupported parameters and supported parameters.
               The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
               GET (GET parameter value)
               POST (POST parameter value)
               ARGS_COOKIE (Cookie parameter value)
               ARGS_HEADER (Header parameter value)
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str compare_func: Logic symbol
               Logical symbols are divided into the following types:
               empty (content is empty)
               null (do not exist)
               eq (equal to)
               neq (not equal to)
               contains (contain)
               ncontains (do not contain)
               strprefix (prefix matching)
               strsuffix (suffix matching)
               len_eq (length equals to)
               len_gt (length is greater than)
               len_lt (length is less than)
               ipmatch (belong to)
               ipnmatch (do not belong to)
               numgt (number greater than)
               numlt (number less than)
               geo_in (IP geo belongs to)
               geo_not_in (IP geo not belongs to)
               rematch (regex match)
               numgt (numerically greater than)
               numlt (numerically less than)
               numeq (numerically equal to)
               numneq (numerically not equal to)
               numle (numerically less than or equal to)
               numge (numerically greater than or equal to)
               Different matching fields correspond to different logical operators. For details, see the matching field table above.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str content: Matching content
               Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str field: Matching field
               Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
               <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int case_not_sensitive: 0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "arg", arg)
        pulumi.set(__self__, "compare_func", compare_func)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)
        if case_not_sensitive is not None:
            pulumi.set(__self__, "case_not_sensitive", case_not_sensitive)

    @_builtins.property
    @pulumi.getter
    def arg(self) -> _builtins.str:
        """
        Matching parameter
        There are two types of configuration parameters: unsupported parameters and supported parameters.
        The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
        GET (GET parameter value)
        POST (POST parameter value)
        ARGS_COOKIE (Cookie parameter value)
        ARGS_HEADER (Header parameter value)
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "arg")

    @_builtins.property
    @pulumi.getter(name="compareFunc")
    def compare_func(self) -> _builtins.str:
        """
        Logic symbol
        Logical symbols are divided into the following types:
        empty (content is empty)
        null (do not exist)
        eq (equal to)
        neq (not equal to)
        contains (contain)
        ncontains (do not contain)
        strprefix (prefix matching)
        strsuffix (suffix matching)
        len_eq (length equals to)
        len_gt (length is greater than)
        len_lt (length is less than)
        ipmatch (belong to)
        ipnmatch (do not belong to)
        numgt (number greater than)
        numlt (number less than)
        geo_in (IP geo belongs to)
        geo_not_in (IP geo not belongs to)
        rematch (regex match)
        numgt (numerically greater than)
        numlt (numerically less than)
        numeq (numerically equal to)
        numneq (numerically not equal to)
        numle (numerically less than or equal to)
        numge (numerically greater than or equal to)
        Different matching fields correspond to different logical operators. For details, see the matching field table above.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "compare_func")

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Matching content
        Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Matching field
        Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
        <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="caseNotSensitive")
    def case_not_sensitive(self) -> Optional[_builtins.int]:
        """
        0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "case_not_sensitive")


@pulumi.output_type
class IpAccessControlItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validTs":
            suggest = "valid_ts"
        elif key == "validStatus":
            suggest = "valid_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAccessControlItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAccessControlItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAccessControlItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.int,
                 ip: _builtins.str,
                 note: _builtins.str,
                 valid_ts: _builtins.int,
                 id: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 valid_status: Optional[_builtins.int] = None):
        """
        :param _builtins.int action: Action value 40 is whitelist, 42 is blacklist.
        :param _builtins.str ip: IP address.
        :param _builtins.str note: Note info.
        :param _builtins.int valid_ts: Effective date, with a second level timestamp value. For example, 1680570420 represents 2023-04-04 09:07:00; 2019571199 means permanently effective.
        :param _builtins.str id: ID of the resource.
        :param _builtins.str source: Source.
        :param _builtins.int valid_status: Valid status.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "note", note)
        pulumi.set(__self__, "valid_ts", valid_ts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if valid_status is not None:
            pulumi.set(__self__, "valid_status", valid_status)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.int:
        """
        Action value 40 is whitelist, 42 is blacklist.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def note(self) -> _builtins.str:
        """
        Note info.
        """
        return pulumi.get(self, "note")

    @_builtins.property
    @pulumi.getter(name="validTs")
    def valid_ts(self) -> _builtins.int:
        """
        Effective date, with a second level timestamp value. For example, 1680570420 represents 2023-04-04 09:07:00; 2019571199 means permanently effective.
        """
        return pulumi.get(self, "valid_ts")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Source.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="validStatus")
    def valid_status(self) -> Optional[_builtins.int]:
        """
        Valid status.
        """
        return pulumi.get(self, "valid_status")


@pulumi.output_type
class IpAccessControlV2JobDateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTZone":
            suggest = "time_t_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAccessControlV2JobDateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAccessControlV2JobDateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAccessControlV2JobDateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crons: Optional[Sequence['outputs.IpAccessControlV2JobDateTimeCron']] = None,
                 time_t_zone: Optional[_builtins.str] = None,
                 timeds: Optional[Sequence['outputs.IpAccessControlV2JobDateTimeTimed']] = None):
        """
        :param Sequence['IpAccessControlV2JobDateTimeCronArgs'] crons: Time parameters for periodic execution
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str time_t_zone: Time zone
               Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence['IpAccessControlV2JobDateTimeTimedArgs'] timeds: Time parameters for scheduled execution
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[Sequence['outputs.IpAccessControlV2JobDateTimeCron']]:
        """
        Time parameters for periodic execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "crons")

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[_builtins.str]:
        """
        Time zone
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_t_zone")

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[Sequence['outputs.IpAccessControlV2JobDateTimeTimed']]:
        """
        Time parameters for scheduled execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeds")


@pulumi.output_type
class IpAccessControlV2JobDateTimeCron(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "wDays":
            suggest = "w_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAccessControlV2JobDateTimeCron. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAccessControlV2JobDateTimeCron.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAccessControlV2JobDateTimeCron.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 w_days: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence[_builtins.int] days: Days in each month for execution
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str end_time: End time
               
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.str start_time: Start time
               
               Note: This field may return null, indicating that no valid values can be obtained.
        :param Sequence[_builtins.int] w_days: Days of each week for execution
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Days in each month for execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time

        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time

        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Days of each week for execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "w_days")


@pulumi.output_type
class IpAccessControlV2JobDateTimeTimed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDateTime":
            suggest = "end_date_time"
        elif key == "startDateTime":
            suggest = "start_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAccessControlV2JobDateTimeTimed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAccessControlV2JobDateTimeTimed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAccessControlV2JobDateTimeTimed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date_time: Optional[_builtins.int] = None,
                 start_date_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_date_time: End timestamp, in seconds
               Note: This field may return null, indicating that no valid values can be obtained.
        :param _builtins.int start_date_time: Start timestamp, in seconds
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[_builtins.int]:
        """
        End timestamp, in seconds
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_date_time")

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[_builtins.int]:
        """
        Start timestamp, in seconds
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_date_time")


@pulumi.output_type
class LogPostCkafkaFlowWriteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableBody":
            suggest = "enable_body"
        elif key == "enableBot":
            suggest = "enable_bot"
        elif key == "enableHeaders":
            suggest = "enable_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogPostCkafkaFlowWriteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogPostCkafkaFlowWriteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogPostCkafkaFlowWriteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_body: Optional[_builtins.int] = None,
                 enable_bot: Optional[_builtins.int] = None,
                 enable_headers: Optional[_builtins.int] = None):
        """
        :param _builtins.int enable_body: 1: Enable 0: Do not enable.
        :param _builtins.int enable_bot: 1: Enable 0: Do not enable.
        :param _builtins.int enable_headers: 1: Enable 0: Do not enable.
        """
        if enable_body is not None:
            pulumi.set(__self__, "enable_body", enable_body)
        if enable_bot is not None:
            pulumi.set(__self__, "enable_bot", enable_bot)
        if enable_headers is not None:
            pulumi.set(__self__, "enable_headers", enable_headers)

    @_builtins.property
    @pulumi.getter(name="enableBody")
    def enable_body(self) -> Optional[_builtins.int]:
        """
        1: Enable 0: Do not enable.
        """
        return pulumi.get(self, "enable_body")

    @_builtins.property
    @pulumi.getter(name="enableBot")
    def enable_bot(self) -> Optional[_builtins.int]:
        """
        1: Enable 0: Do not enable.
        """
        return pulumi.get(self, "enable_bot")

    @_builtins.property
    @pulumi.getter(name="enableHeaders")
    def enable_headers(self) -> Optional[_builtins.int]:
        """
        1: Enable 0: Do not enable.
        """
        return pulumi.get(self, "enable_headers")


@pulumi.output_type
class OwaspWhiteRuleJobDateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTZone":
            suggest = "time_t_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwaspWhiteRuleJobDateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwaspWhiteRuleJobDateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwaspWhiteRuleJobDateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crons: Optional[Sequence['outputs.OwaspWhiteRuleJobDateTimeCron']] = None,
                 time_t_zone: Optional[_builtins.str] = None,
                 timeds: Optional[Sequence['outputs.OwaspWhiteRuleJobDateTimeTimed']] = None):
        """
        :param Sequence['OwaspWhiteRuleJobDateTimeCronArgs'] crons: Time parameter for periodic execution.
        :param _builtins.str time_t_zone: Specifies the time zone.
        :param Sequence['OwaspWhiteRuleJobDateTimeTimedArgs'] timeds: Time parameter for scheduled execution.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[Sequence['outputs.OwaspWhiteRuleJobDateTimeCron']]:
        """
        Time parameter for periodic execution.
        """
        return pulumi.get(self, "crons")

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[_builtins.str]:
        """
        Specifies the time zone.
        """
        return pulumi.get(self, "time_t_zone")

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[Sequence['outputs.OwaspWhiteRuleJobDateTimeTimed']]:
        """
        Time parameter for scheduled execution.
        """
        return pulumi.get(self, "timeds")


@pulumi.output_type
class OwaspWhiteRuleJobDateTimeCron(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "wDays":
            suggest = "w_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwaspWhiteRuleJobDateTimeCron. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwaspWhiteRuleJobDateTimeCron.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwaspWhiteRuleJobDateTimeCron.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 w_days: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence[_builtins.int] days: Execution day of each month.
        :param _builtins.str end_time: End time.
        :param _builtins.str start_time: Start time.
        :param Sequence[_builtins.int] w_days: Execution day of each week.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Execution day of each month.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        Execution day of each week.
        """
        return pulumi.get(self, "w_days")


@pulumi.output_type
class OwaspWhiteRuleJobDateTimeTimed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDateTime":
            suggest = "end_date_time"
        elif key == "startDateTime":
            suggest = "start_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwaspWhiteRuleJobDateTimeTimed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwaspWhiteRuleJobDateTimeTimed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwaspWhiteRuleJobDateTimeTimed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date_time: Optional[_builtins.int] = None,
                 start_date_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_date_time: End timestamp, in seconds.
        :param _builtins.int start_date_time: Start timestamp, in seconds.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[_builtins.int]:
        """
        End timestamp, in seconds.
        """
        return pulumi.get(self, "end_date_time")

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[_builtins.int]:
        """
        Start timestamp, in seconds.
        """
        return pulumi.get(self, "start_date_time")


@pulumi.output_type
class OwaspWhiteRuleStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareFunc":
            suggest = "compare_func"
        elif key == "caseNotSensitive":
            suggest = "case_not_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwaspWhiteRuleStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwaspWhiteRuleStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwaspWhiteRuleStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arg: _builtins.str,
                 compare_func: _builtins.str,
                 content: _builtins.str,
                 field: _builtins.str,
                 case_not_sensitive: Optional[_builtins.int] = None):
        """
        :param _builtins.str arg: Specifies the matching parameter.
               
               Configuration parameters are divided into two data types: parameter not supported and support parameters.
               When the match field is one of the following four, the matching parameter can be entered, otherwise not supported.
               GET (get parameter value).
               POST (post parameter value).
               ARGS_COOKIE (COOKIE parameter value).
               ARGS_HEADER (HEADER parameter value).
        :param _builtins.str compare_func: Specifies the logic symbol. 
               
               Logical symbols are divided into the following types:.
               Empty (content is empty).
               null (not found).
               Eq (equal to).
               neq (not equal to).
               contains (contain).
               ncontains (do not contain).
               strprefix (prefix matching).
               strsuffix (suffix matching).
               Len_eq (length equals to).
               Len_gt (length greater than).
               Len_lt (length less than).
               ipmatch (belong).
               ipnmatch (not_in).
               numgt (value greater than).
               NumValue smaller than].
               Value equal to.
               numneq (value not equal to).
               numle (less than or equal to).
               numge (value is greater than or equal to).
               geo_in (IP geographic belong).
               geo_not_in (IP geographic not_in).
               Specifies different logical operators for matching fields. for details, see the matching field table above.
        :param _builtins.str content: Specifies the match content.
               
               Currently, when the match field is COOKIE (COOKIE), match content is not required. all others are needed.
        :param _builtins.str field: Specifies the matching field.
               
               Different matching fields result in different matching parameters, logical operators, and matching contents. the details are as follows:.
               <table><thead><tr><th>Matching Field</th> <th>Matching Parameter</th> <th>Logical Symbol</th> <th>Matching Content</th></tr></thead> <tbody><tr><td>IP (source IP)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr> <tr><td>IPv6 (source IPv6)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>A single IPv6 address is supported.</td></tr> <tr><td>Referer (referer)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content, with a maximum of 512 characters.</td></tr> <tr><td>URL (request path)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is
               less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content starting with /, with a maximum of 512 characters.</td></tr> <tr><td>UserAgent (UserAgent)</td> <td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>HTTP_METHOD (HTTP request method)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)</td> <td>Enter the method name. The uppercase is recommended.</td></tr> <tr><td>QUERY_STRING (request string)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET (GET parameter value)</td> <td>Parameter entry is supported.</td> <td>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_PARAMS_NAMES (GET parameter name)</td> <td>Parameters are not supported.</td> <td>exist (Parameter exists.)<br/>nexist (Parameter does not exist.)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST (POST parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_POST_NAMES (POST parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST_BODY (complete body)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr> <tr><td>COOKIE (cookie)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>rematch (regular expression matching)</td> <td><font color="Red">Unsupported currently</font></td></tr> <tr><td>GET_COOKIES_NAMES (cookie parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>ARGS_COOKIE (cookie parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content512 characters limit</td></tr><tr><td>GET_HEADERS_NAMES (Header parameter name)</td><td>parameter not supported</td><td>exsit (parameter exists)<br/>nexsit (parameter does not exist)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, lowercase is recommended, up to 512 characters</td></tr><tr><td>ARGS_Header (Header parameter value)</td><td>support parameter entry</td><td>contains (include)<br/>ncontains (does not include)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, up to 512 characters</td></tr><tr><td>CONTENT_LENGTH (CONTENT-LENGTH)</td><td>support parameter entry</td><td>numgt (value greater than)<br/>numlt (value smaller than)<br/>numeq (value equal to)<br/></td><td>enter an integer between 0-9999999999999</td></tr><tr><td>IP_GEO (source IP geolocation)</td><td>support parameter entry</td><td>GEO_in (belong)<br/>GEO_not_in (not_in)<br/></td><td>enter CONTENT, up to 10240 characters, format: serialized JSON, format: [{"Country":"china","Region":"guangdong","City":"shenzhen"}]</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter RISK level value, value range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA DEVICE RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter DEVICE RISK code, valid values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA RISK assessment SCORE)</td><td>parameter not supported</td><td>numeq (value equal to)<br/>numgt (value greater than)<br/>numlt (value smaller than)<br/>numle (less than or equal to)<br/>numge (value is greater than or equal to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter assessment SCORE, value range 0-100</td></tr>.
               </tbody></table>.
        :param _builtins.int case_not_sensitive: Case-Sensitive.
               Case-Insensitive.
        """
        pulumi.set(__self__, "arg", arg)
        pulumi.set(__self__, "compare_func", compare_func)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)
        if case_not_sensitive is not None:
            pulumi.set(__self__, "case_not_sensitive", case_not_sensitive)

    @_builtins.property
    @pulumi.getter
    def arg(self) -> _builtins.str:
        """
        Specifies the matching parameter.

        Configuration parameters are divided into two data types: parameter not supported and support parameters.
        When the match field is one of the following four, the matching parameter can be entered, otherwise not supported.
        GET (get parameter value).
        POST (post parameter value).
        ARGS_COOKIE (COOKIE parameter value).
        ARGS_HEADER (HEADER parameter value).
        """
        return pulumi.get(self, "arg")

    @_builtins.property
    @pulumi.getter(name="compareFunc")
    def compare_func(self) -> _builtins.str:
        """
        Specifies the logic symbol. 

        Logical symbols are divided into the following types:.
        Empty (content is empty).
        null (not found).
        Eq (equal to).
        neq (not equal to).
        contains (contain).
        ncontains (do not contain).
        strprefix (prefix matching).
        strsuffix (suffix matching).
        Len_eq (length equals to).
        Len_gt (length greater than).
        Len_lt (length less than).
        ipmatch (belong).
        ipnmatch (not_in).
        numgt (value greater than).
        NumValue smaller than].
        Value equal to.
        numneq (value not equal to).
        numle (less than or equal to).
        numge (value is greater than or equal to).
        geo_in (IP geographic belong).
        geo_not_in (IP geographic not_in).
        Specifies different logical operators for matching fields. for details, see the matching field table above.
        """
        return pulumi.get(self, "compare_func")

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Specifies the match content.

        Currently, when the match field is COOKIE (COOKIE), match content is not required. all others are needed.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Specifies the matching field.

        Different matching fields result in different matching parameters, logical operators, and matching contents. the details are as follows:.
        <table><thead><tr><th>Matching Field</th> <th>Matching Parameter</th> <th>Logical Symbol</th> <th>Matching Content</th></tr></thead> <tbody><tr><td>IP (source IP)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr> <tr><td>IPv6 (source IPv6)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>A single IPv6 address is supported.</td></tr> <tr><td>Referer (referer)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content, with a maximum of 512 characters.</td></tr> <tr><td>URL (request path)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is
        less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content starting with /, with a maximum of 512 characters.</td></tr> <tr><td>UserAgent (UserAgent)</td> <td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>HTTP_METHOD (HTTP request method)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)</td> <td>Enter the method name. The uppercase is recommended.</td></tr> <tr><td>QUERY_STRING (request string)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET (GET parameter value)</td> <td>Parameter entry is supported.</td> <td>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_PARAMS_NAMES (GET parameter name)</td> <td>Parameters are not supported.</td> <td>exist (Parameter exists.)<br/>nexist (Parameter does not exist.)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST (POST parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_POST_NAMES (POST parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST_BODY (complete body)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr> <tr><td>COOKIE (cookie)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>rematch (regular expression matching)</td> <td><font color="Red">Unsupported currently</font></td></tr> <tr><td>GET_COOKIES_NAMES (cookie parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>ARGS_COOKIE (cookie parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content512 characters limit</td></tr><tr><td>GET_HEADERS_NAMES (Header parameter name)</td><td>parameter not supported</td><td>exsit (parameter exists)<br/>nexsit (parameter does not exist)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, lowercase is recommended, up to 512 characters</td></tr><tr><td>ARGS_Header (Header parameter value)</td><td>support parameter entry</td><td>contains (include)<br/>ncontains (does not include)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, up to 512 characters</td></tr><tr><td>CONTENT_LENGTH (CONTENT-LENGTH)</td><td>support parameter entry</td><td>numgt (value greater than)<br/>numlt (value smaller than)<br/>numeq (value equal to)<br/></td><td>enter an integer between 0-9999999999999</td></tr><tr><td>IP_GEO (source IP geolocation)</td><td>support parameter entry</td><td>GEO_in (belong)<br/>GEO_not_in (not_in)<br/></td><td>enter CONTENT, up to 10240 characters, format: serialized JSON, format: [{"Country":"china","Region":"guangdong","City":"shenzhen"}]</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter RISK level value, value range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA DEVICE RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter DEVICE RISK code, valid values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA RISK assessment SCORE)</td><td>parameter not supported</td><td>numeq (value equal to)<br/>numgt (value greater than)<br/>numlt (value smaller than)<br/>numle (less than or equal to)<br/>numge (value is greater than or equal to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter assessment SCORE, value range 0-100</td></tr>.
        </tbody></table>.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="caseNotSensitive")
    def case_not_sensitive(self) -> Optional[_builtins.int]:
        """
        Case-Sensitive.
        Case-Insensitive.
        """
        return pulumi.get(self, "case_not_sensitive")


@pulumi.output_type
class SaasDomainPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upstreamPort":
            suggest = "upstream_port"
        elif key == "upstreamProtocol":
            suggest = "upstream_protocol"
        elif key == "nginxServerId":
            suggest = "nginx_server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SaasDomainPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SaasDomainPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SaasDomainPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: _builtins.str,
                 protocol: _builtins.str,
                 upstream_port: _builtins.str,
                 upstream_protocol: _builtins.str,
                 nginx_server_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str port: Listening port.
        :param _builtins.str protocol: The listening protocol of listening port.
        :param _builtins.str upstream_port: The upstream port for listening port.
        :param _builtins.str upstream_protocol: The upstream protocol for listening port.
        :param _builtins.str nginx_server_id: Nginx server ID.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "upstream_port", upstream_port)
        pulumi.set(__self__, "upstream_protocol", upstream_protocol)
        if nginx_server_id is not None:
            pulumi.set(__self__, "nginx_server_id", nginx_server_id)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        Listening port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The listening protocol of listening port.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="upstreamPort")
    def upstream_port(self) -> _builtins.str:
        """
        The upstream port for listening port.
        """
        return pulumi.get(self, "upstream_port")

    @_builtins.property
    @pulumi.getter(name="upstreamProtocol")
    def upstream_protocol(self) -> _builtins.str:
        """
        The upstream protocol for listening port.
        """
        return pulumi.get(self, "upstream_protocol")

    @_builtins.property
    @pulumi.getter(name="nginxServerId")
    def nginx_server_id(self) -> Optional[_builtins.str]:
        """
        Nginx server ID.
        """
        return pulumi.get(self, "nginx_server_id")


@pulumi.output_type
class GetAttackLogHistogramDataResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 time_stamp: _builtins.int):
        """
        :param _builtins.int count: The count of logs.
        :param _builtins.int time_stamp: Timestamp.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "time_stamp", time_stamp)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The count of logs.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="timeStamp")
    def time_stamp(self) -> _builtins.int:
        """
        Timestamp.
        """
        return pulumi.get(self, "time_stamp")


@pulumi.output_type
class GetAttackLogListDataResult(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 file_name: _builtins.str,
                 source: _builtins.str,
                 time_stamp: _builtins.str):
        """
        :param _builtins.str content: The detail of attack log.
        :param _builtins.str file_name: Useless.
        :param _builtins.str source: Useless.
        :param _builtins.str time_stamp: Time string.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "time_stamp", time_stamp)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The detail of attack log.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        """
        Useless.
        """
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Useless.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="timeStamp")
    def time_stamp(self) -> _builtins.str:
        """
        Time string.
        """
        return pulumi.get(self, "time_stamp")


@pulumi.output_type
class GetCiphersCipherResult(dict):
    def __init__(__self__, *,
                 cipher_id: _builtins.int,
                 cipher_name: _builtins.str,
                 version_id: _builtins.int):
        """
        :param _builtins.int cipher_id: Encryption Suite IDNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str cipher_name: Encryption Suite NameNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int version_id: TLS version IDNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        pulumi.set(__self__, "cipher_id", cipher_id)
        pulumi.set(__self__, "cipher_name", cipher_name)
        pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter(name="cipherId")
    def cipher_id(self) -> _builtins.int:
        """
        Encryption Suite IDNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "cipher_id")

    @_builtins.property
    @pulumi.getter(name="cipherName")
    def cipher_name(self) -> _builtins.str:
        """
        Encryption Suite NameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "cipher_name")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.int:
        """
        TLS version IDNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class GetDomainsDomainResult(dict):
    def __init__(__self__, *,
                 alb_type: _builtins.str,
                 api_status: _builtins.int,
                 app_id: _builtins.int,
                 bot_status: _builtins.int,
                 cc_lists: Sequence[_builtins.str],
                 cdc_clusters: _builtins.str,
                 cls_status: _builtins.int,
                 cname: _builtins.str,
                 create_time: _builtins.str,
                 domain: _builtins.str,
                 domain_id: _builtins.str,
                 edition: _builtins.str,
                 engine: _builtins.int,
                 flow_mode: _builtins.int,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str,
                 ipv6_status: _builtins.int,
                 level: _builtins.int,
                 load_balancer_sets: Sequence['outputs.GetDomainsDomainLoadBalancerSetResult'],
                 mode: _builtins.int,
                 ports: Sequence['outputs.GetDomainsDomainPortResult'],
                 post_ckafka_status: _builtins.int,
                 post_cls_status: _builtins.int,
                 region: _builtins.str,
                 rs_lists: Sequence[_builtins.str],
                 sg_detail: _builtins.str,
                 sg_state: _builtins.int,
                 state: _builtins.int,
                 status: _builtins.int):
        """
        :param _builtins.str alb_type: Traffic Source: clb represents Tencent Cloud clb, apisix represents apisix gateway, tsegw represents Tencent Cloud API gateway, default clbNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int api_status: API security switch status, 0 off, 1 onNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int app_id: User appid.
        :param _builtins.int bot_status: BOT switch status, 0 off, 1 on.
        :param Sequence[_builtins.str] cc_lists: Waf sandbox export addresses, should be added to the whitelist by the upstreams.
        :param _builtins.str cdc_clusters: Cdc clustersNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int cls_status: Whether to enable access logs, 1 enable, 0 disable.
        :param _builtins.str cname: Cname address, used for dns access.
        :param _builtins.str create_time: Create time.
        :param _builtins.str domain: Domain name.
        :param _builtins.str domain_id: Domain unique ID.
        :param _builtins.str edition: Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
        :param _builtins.int engine: Rule and AI Defense Mode, 10 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Shutdown Mode 11 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Observation Mode 12 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Interception Mode 20 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Shutdown Mode 21 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Observation Mode 22 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Interception Mode.
        :param _builtins.int flow_mode: CLBWAF traffic mode, 1 cleaning mode, 0 mirroring mode.
        :param _builtins.str instance_id: Unique ID of Instance.
        :param _builtins.str instance_name: Instance name.
        :param _builtins.int ipv6_status: Ipv6 switch status, 0 off, 1 on.
        :param _builtins.int level: Instance level.
        :param Sequence['GetDomainsDomainLoadBalancerSetArgs'] load_balancer_sets: List of bound LB.
        :param _builtins.int mode: Rule defense mode, 0 observation mode, 1 interception mode.
        :param Sequence['GetDomainsDomainPortArgs'] ports: Listening ports.
        :param _builtins.int post_ckafka_status: Whether to enable the delivery of CKafka function, 0 off, 1 on.
        :param _builtins.int post_cls_status: Whether to enable the delivery CLS function, 0 off, 1 on.
        :param _builtins.str region: Region.
        :param Sequence[_builtins.str] rs_lists: Waf engine export addresses, should be added to the whitelist by the upstreams.
        :param _builtins.str sg_detail: Detailed explanation of security group statusNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int sg_state: Security group status, 0 does not display, 1 non Tencent cloud source site, 2 security group binding failed, 3 security group changedNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int state: Clbwaf domain name listener status, 0 operation successful, 4 binding LB, 6 unbinding LB, 7 unbinding LB failed, 8 binding LB failed, 10 internal error.
        :param _builtins.int status: Waf switch,0 off 1 on.
        """
        pulumi.set(__self__, "alb_type", alb_type)
        pulumi.set(__self__, "api_status", api_status)
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "bot_status", bot_status)
        pulumi.set(__self__, "cc_lists", cc_lists)
        pulumi.set(__self__, "cdc_clusters", cdc_clusters)
        pulumi.set(__self__, "cls_status", cls_status)
        pulumi.set(__self__, "cname", cname)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "edition", edition)
        pulumi.set(__self__, "engine", engine)
        pulumi.set(__self__, "flow_mode", flow_mode)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "ipv6_status", ipv6_status)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "load_balancer_sets", load_balancer_sets)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "post_ckafka_status", post_ckafka_status)
        pulumi.set(__self__, "post_cls_status", post_cls_status)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "rs_lists", rs_lists)
        pulumi.set(__self__, "sg_detail", sg_detail)
        pulumi.set(__self__, "sg_state", sg_state)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="albType")
    def alb_type(self) -> _builtins.str:
        """
        Traffic Source: clb represents Tencent Cloud clb, apisix represents apisix gateway, tsegw represents Tencent Cloud API gateway, default clbNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "alb_type")

    @_builtins.property
    @pulumi.getter(name="apiStatus")
    def api_status(self) -> _builtins.int:
        """
        API security switch status, 0 off, 1 onNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "api_status")

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.int:
        """
        User appid.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="botStatus")
    def bot_status(self) -> _builtins.int:
        """
        BOT switch status, 0 off, 1 on.
        """
        return pulumi.get(self, "bot_status")

    @_builtins.property
    @pulumi.getter(name="ccLists")
    def cc_lists(self) -> Sequence[_builtins.str]:
        """
        Waf sandbox export addresses, should be added to the whitelist by the upstreams.
        """
        return pulumi.get(self, "cc_lists")

    @_builtins.property
    @pulumi.getter(name="cdcClusters")
    def cdc_clusters(self) -> _builtins.str:
        """
        Cdc clustersNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "cdc_clusters")

    @_builtins.property
    @pulumi.getter(name="clsStatus")
    def cls_status(self) -> _builtins.int:
        """
        Whether to enable access logs, 1 enable, 0 disable.
        """
        return pulumi.get(self, "cls_status")

    @_builtins.property
    @pulumi.getter
    def cname(self) -> _builtins.str:
        """
        Cname address, used for dns access.
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        """
        Domain unique ID.
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter
    def edition(self) -> _builtins.str:
        """
        Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
        """
        return pulumi.get(self, "edition")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> _builtins.int:
        """
        Rule and AI Defense Mode, 10 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Shutdown Mode 11 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Observation Mode 12 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Interception Mode 20 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Shutdown Mode 21 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Observation Mode 22 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Interception Mode.
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter(name="flowMode")
    def flow_mode(self) -> _builtins.int:
        """
        CLBWAF traffic mode, 1 cleaning mode, 0 mirroring mode.
        """
        return pulumi.get(self, "flow_mode")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Unique ID of Instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        Instance name.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="ipv6Status")
    def ipv6_status(self) -> _builtins.int:
        """
        Ipv6 switch status, 0 off, 1 on.
        """
        return pulumi.get(self, "ipv6_status")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.int:
        """
        Instance level.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSets")
    def load_balancer_sets(self) -> Sequence['outputs.GetDomainsDomainLoadBalancerSetResult']:
        """
        List of bound LB.
        """
        return pulumi.get(self, "load_balancer_sets")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.int:
        """
        Rule defense mode, 0 observation mode, 1 interception mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.GetDomainsDomainPortResult']:
        """
        Listening ports.
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter(name="postCkafkaStatus")
    def post_ckafka_status(self) -> _builtins.int:
        """
        Whether to enable the delivery of CKafka function, 0 off, 1 on.
        """
        return pulumi.get(self, "post_ckafka_status")

    @_builtins.property
    @pulumi.getter(name="postClsStatus")
    def post_cls_status(self) -> _builtins.int:
        """
        Whether to enable the delivery CLS function, 0 off, 1 on.
        """
        return pulumi.get(self, "post_cls_status")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="rsLists")
    def rs_lists(self) -> Sequence[_builtins.str]:
        """
        Waf engine export addresses, should be added to the whitelist by the upstreams.
        """
        return pulumi.get(self, "rs_lists")

    @_builtins.property
    @pulumi.getter(name="sgDetail")
    def sg_detail(self) -> _builtins.str:
        """
        Detailed explanation of security group statusNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "sg_detail")

    @_builtins.property
    @pulumi.getter(name="sgState")
    def sg_state(self) -> _builtins.int:
        """
        Security group status, 0 does not display, 1 non Tencent cloud source site, 2 security group binding failed, 3 security group changedNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "sg_state")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.int:
        """
        Clbwaf domain name listener status, 0 operation successful, 4 binding LB, 6 unbinding LB, 7 unbinding LB failed, 8 binding LB failed, 10 internal error.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Waf switch,0 off 1 on.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDomainsDomainLoadBalancerSetResult(dict):
    def __init__(__self__, *,
                 listener_id: _builtins.str,
                 listener_name: _builtins.str,
                 load_balancer_id: _builtins.str,
                 load_balancer_name: _builtins.str,
                 load_balancer_type: _builtins.str,
                 numerical_vpc_id: _builtins.int,
                 protocol: _builtins.str,
                 region: _builtins.str,
                 vip: _builtins.str,
                 vport: _builtins.int,
                 zone: _builtins.str):
        """
        :param _builtins.str listener_id: Listener unique IDNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str listener_name: Listener nameNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str load_balancer_id: LoadBalancer IDNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str load_balancer_name: LoadBalancer nameNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str load_balancer_type: Loadbalancer typeNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int numerical_vpc_id: VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditionsNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str protocol: The listening protocol of listening port.
        :param _builtins.str region: Region.
        :param _builtins.str vip: LoadBalancer ipNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.int vport: Listener portNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str zone: Loadbalancer zoneNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "listener_name", listener_name)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        pulumi.set(__self__, "numerical_vpc_id", numerical_vpc_id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vport", vport)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        Listener unique IDNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="listenerName")
    def listener_name(self) -> _builtins.str:
        """
        Listener nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "listener_name")

    @_builtins.property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> _builtins.str:
        """
        LoadBalancer IDNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "load_balancer_id")

    @_builtins.property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> _builtins.str:
        """
        LoadBalancer nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "load_balancer_name")

    @_builtins.property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> _builtins.str:
        """
        Loadbalancer typeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "load_balancer_type")

    @_builtins.property
    @pulumi.getter(name="numericalVpcId")
    def numerical_vpc_id(self) -> _builtins.int:
        """
        VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditionsNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "numerical_vpc_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The listening protocol of listening port.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> _builtins.str:
        """
        LoadBalancer ipNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter
    def vport(self) -> _builtins.int:
        """
        Listener portNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "vport")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        Loadbalancer zoneNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetDomainsDomainPortResult(dict):
    def __init__(__self__, *,
                 nginx_server_id: _builtins.int,
                 port: _builtins.str,
                 protocol: _builtins.str,
                 upstream_port: _builtins.str,
                 upstream_protocol: _builtins.str):
        """
        :param _builtins.int nginx_server_id: Nginx server ID.
        :param _builtins.str port: Listening port.
        :param _builtins.str protocol: The listening protocol of listening port.
        :param _builtins.str upstream_port: The upstream port for listening port.
        :param _builtins.str upstream_protocol: The upstream protocol for listening port.
        """
        pulumi.set(__self__, "nginx_server_id", nginx_server_id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "upstream_port", upstream_port)
        pulumi.set(__self__, "upstream_protocol", upstream_protocol)

    @_builtins.property
    @pulumi.getter(name="nginxServerId")
    def nginx_server_id(self) -> _builtins.int:
        """
        Nginx server ID.
        """
        return pulumi.get(self, "nginx_server_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        Listening port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The listening protocol of listening port.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="upstreamPort")
    def upstream_port(self) -> _builtins.str:
        """
        The upstream port for listening port.
        """
        return pulumi.get(self, "upstream_port")

    @_builtins.property
    @pulumi.getter(name="upstreamProtocol")
    def upstream_protocol(self) -> _builtins.str:
        """
        The upstream protocol for listening port.
        """
        return pulumi.get(self, "upstream_protocol")


@pulumi.output_type
class GetFindDomainsListResult(dict):
    def __init__(__self__, *,
                 appid: _builtins.int,
                 domain: _builtins.str,
                 domain_id: _builtins.str,
                 edition: _builtins.str,
                 find_time: _builtins.str,
                 instance_id: _builtins.str,
                 ips: Sequence[_builtins.str],
                 is_waf_domain: _builtins.int):
        """
        :param _builtins.int appid: User appid.
        :param _builtins.str domain: Domain name.
        :param _builtins.str domain_id: Domain unique id.
        :param _builtins.str edition: Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
        :param _builtins.str find_time: Find time.
        :param _builtins.str instance_id: Instance unique id.
        :param Sequence[_builtins.str] ips: Domain ip.
        :param _builtins.int is_waf_domain: Whether access to waf or not.
        """
        pulumi.set(__self__, "appid", appid)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "edition", edition)
        pulumi.set(__self__, "find_time", find_time)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "is_waf_domain", is_waf_domain)

    @_builtins.property
    @pulumi.getter
    def appid(self) -> _builtins.int:
        """
        User appid.
        """
        return pulumi.get(self, "appid")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        """
        Domain unique id.
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter
    def edition(self) -> _builtins.str:
        """
        Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
        """
        return pulumi.get(self, "edition")

    @_builtins.property
    @pulumi.getter(name="findTime")
    def find_time(self) -> _builtins.str:
        """
        Find time.
        """
        return pulumi.get(self, "find_time")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Instance unique id.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        Domain ip.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="isWafDomain")
    def is_waf_domain(self) -> _builtins.int:
        """
        Whether access to waf or not.
        """
        return pulumi.get(self, "is_waf_domain")


@pulumi.output_type
class GetInstanceQpsLimitQpsDataResult(dict):
    def __init__(__self__, *,
                 elastic_billing_default: _builtins.int,
                 elastic_billing_max: _builtins.int,
                 elastic_billing_min: _builtins.int,
                 qps_extend_intl_max: _builtins.int,
                 qps_extend_max: _builtins.int):
        """
        :param _builtins.int elastic_billing_default: Elastic qps default value.
        :param _builtins.int elastic_billing_max: Maximum elastic qps.
        :param _builtins.int elastic_billing_min: Minimum elastic qps.
        :param _builtins.int qps_extend_intl_max: Maximum qps of extend package for overseas.
        :param _builtins.int qps_extend_max: Maximum qps of extend package.
        """
        pulumi.set(__self__, "elastic_billing_default", elastic_billing_default)
        pulumi.set(__self__, "elastic_billing_max", elastic_billing_max)
        pulumi.set(__self__, "elastic_billing_min", elastic_billing_min)
        pulumi.set(__self__, "qps_extend_intl_max", qps_extend_intl_max)
        pulumi.set(__self__, "qps_extend_max", qps_extend_max)

    @_builtins.property
    @pulumi.getter(name="elasticBillingDefault")
    def elastic_billing_default(self) -> _builtins.int:
        """
        Elastic qps default value.
        """
        return pulumi.get(self, "elastic_billing_default")

    @_builtins.property
    @pulumi.getter(name="elasticBillingMax")
    def elastic_billing_max(self) -> _builtins.int:
        """
        Maximum elastic qps.
        """
        return pulumi.get(self, "elastic_billing_max")

    @_builtins.property
    @pulumi.getter(name="elasticBillingMin")
    def elastic_billing_min(self) -> _builtins.int:
        """
        Minimum elastic qps.
        """
        return pulumi.get(self, "elastic_billing_min")

    @_builtins.property
    @pulumi.getter(name="qpsExtendIntlMax")
    def qps_extend_intl_max(self) -> _builtins.int:
        """
        Maximum qps of extend package for overseas.
        """
        return pulumi.get(self, "qps_extend_intl_max")

    @_builtins.property
    @pulumi.getter(name="qpsExtendMax")
    def qps_extend_max(self) -> _builtins.int:
        """
        Maximum qps of extend package.
        """
        return pulumi.get(self, "qps_extend_max")


@pulumi.output_type
class GetOwaspRuleTypesFilterResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.bool,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.bool exact_match: Exact search or not.
        :param _builtins.str name: Field name, used for filtering
               Filter the sub-order number (value) by DealName.
        :param Sequence[_builtins.str] values: Values after filtering.
        """
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.bool:
        """
        Exact search or not.
        """
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field name, used for filtering
        Filter the sub-order number (value) by DealName.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Values after filtering.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetOwaspRuleTypesListResult(dict):
    def __init__(__self__, *,
                 action: _builtins.int,
                 active_rule: _builtins.int,
                 classification: _builtins.str,
                 description: _builtins.str,
                 level: _builtins.int,
                 status: _builtins.int,
                 total_rule: _builtins.int,
                 type_id: _builtins.int,
                 type_name: _builtins.str):
        """
        :param _builtins.int action: Protection mode of the rule type. valid values: 0 (observation), 1 (intercept).
        :param _builtins.int active_rule: Indicates the total number of rules enabled under the rule type.
        :param _builtins.str classification: Data type category.
        :param _builtins.str description: Type description.
        :param _builtins.int level: Protection level of the rule type. valid values: 100 (loose), 200 (normal), 300 (strict), 400 (ultra-strict).
        :param _builtins.int status: The switch status of the rule type. valid values: 0 (disabled), 1 (enabled).
        :param _builtins.int total_rule: Specifies all rules under the rule type. always.
        :param _builtins.int type_id: Type ID.
        :param _builtins.str type_name: Type name.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "active_rule", active_rule)
        pulumi.set(__self__, "classification", classification)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_rule", total_rule)
        pulumi.set(__self__, "type_id", type_id)
        pulumi.set(__self__, "type_name", type_name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.int:
        """
        Protection mode of the rule type. valid values: 0 (observation), 1 (intercept).
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="activeRule")
    def active_rule(self) -> _builtins.int:
        """
        Indicates the total number of rules enabled under the rule type.
        """
        return pulumi.get(self, "active_rule")

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        """
        Data type category.
        """
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Type description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.int:
        """
        Protection level of the rule type. valid values: 100 (loose), 200 (normal), 300 (strict), 400 (ultra-strict).
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        The switch status of the rule type. valid values: 0 (disabled), 1 (enabled).
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalRule")
    def total_rule(self) -> _builtins.int:
        """
        Specifies all rules under the rule type. always.
        """
        return pulumi.get(self, "total_rule")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> _builtins.int:
        """
        Type ID.
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> _builtins.str:
        """
        Type name.
        """
        return pulumi.get(self, "type_name")


@pulumi.output_type
class GetOwaspRulesFilterResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.bool,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.bool exact_match: Exact search or not.
        :param _builtins.str name: Field name, used for filtering
               Filter the sub-order number (value) by DealName.
        :param Sequence[_builtins.str] values: Values after filtering.
        """
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.bool:
        """
        Exact search or not.
        """
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field name, used for filtering
        Filter the sub-order number (value) by DealName.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Values after filtering.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetOwaspRulesListResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 cve_id: _builtins.str,
                 description: _builtins.str,
                 level: _builtins.int,
                 locked: _builtins.int,
                 modify_time: _builtins.str,
                 reason: _builtins.int,
                 rule_id: _builtins.int,
                 status: _builtins.int,
                 type_id: _builtins.int,
                 vul_level: _builtins.int):
        """
        :param _builtins.str create_time: Creation time.
        :param _builtins.str cve_id: CVE ID.
        :param _builtins.str description: Rule description.
        :param _builtins.int level: Protection level of the rule. valid values: 100 (loose), 200 (normal), 300 (strict), 400 (ultra-strict).
        :param _builtins.int locked: Whether the user is locked.
        :param _builtins.str modify_time: Update time.
        :param _builtins.int reason: Reason for modification
        :param _builtins.int rule_id: Rule ID.
        :param _builtins.int status: Rule switch. valid values: 0 (disabled), 1 (enabled), 2 (observation only).
        :param _builtins.int type_id: Specifies the rule type ID.
        :param _builtins.int vul_level: Threat level. valid values: 0 (unknown), 100 (low risk), 200 (medium risk), 300 (high risk), 400 (critical).
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "cve_id", cve_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "locked", locked)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type_id", type_id)
        pulumi.set(__self__, "vul_level", vul_level)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="cveId")
    def cve_id(self) -> _builtins.str:
        """
        CVE ID.
        """
        return pulumi.get(self, "cve_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Rule description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.int:
        """
        Protection level of the rule. valid values: 100 (loose), 200 (normal), 300 (strict), 400 (ultra-strict).
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> _builtins.int:
        """
        Whether the user is locked.
        """
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> _builtins.int:
        """
        Reason for modification
        """
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.int:
        """
        Rule ID.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Rule switch. valid values: 0 (disabled), 1 (enabled), 2 (observation only).
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> _builtins.int:
        """
        Specifies the rule type ID.
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="vulLevel")
    def vul_level(self) -> _builtins.int:
        """
        Threat level. valid values: 0 (unknown), 100 (low risk), 200 (medium risk), 300 (high risk), 400 (critical).
        """
        return pulumi.get(self, "vul_level")


@pulumi.output_type
class GetPeakPointsPointResult(dict):
    def __init__(__self__, *,
                 access: _builtins.int,
                 attack: _builtins.int,
                 bot_access: _builtins.int,
                 cc: _builtins.int,
                 down: _builtins.int,
                 status_client_error: _builtins.int,
                 status_ok: _builtins.int,
                 status_redirect: _builtins.int,
                 status_server_error: _builtins.int,
                 time: _builtins.int,
                 up: _builtins.int,
                 upstream_client_error: _builtins.int,
                 upstream_redirect: _builtins.int,
                 upstream_server_error: _builtins.int):
        """
        :param _builtins.int access: qps.
        :param _builtins.int attack: Number of web attacks.
        :param _builtins.int bot_access: Bot qps.
        :param _builtins.int cc: Number of cc attacks.
        :param _builtins.int down: Peak downlink bandwidth, unit B.
        :param _builtins.int status_client_error: Trend chart of the number of status codes returned by WAF to the client.
        :param _builtins.int status_ok: Trend chart of the number of status codes returned by WAF to the client.
        :param _builtins.int status_redirect: Trend chart of the number of status codes returned by WAF to the client.
        :param _builtins.int status_server_error: Trend chart of the number of status codes returned by WAF to the server.
        :param _builtins.int time: Second level timestamp.
        :param _builtins.int up: Peak uplink bandwidth, unit B.
        :param _builtins.int upstream_client_error: Trend chart of the number of status codes returned to WAF by the origin site.
        :param _builtins.int upstream_redirect: Trend chart of the number of status codes returned to WAF by the origin site.
        :param _builtins.int upstream_server_error: Trend chart of the number of status codes returned to WAF by the origin site.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "attack", attack)
        pulumi.set(__self__, "bot_access", bot_access)
        pulumi.set(__self__, "cc", cc)
        pulumi.set(__self__, "down", down)
        pulumi.set(__self__, "status_client_error", status_client_error)
        pulumi.set(__self__, "status_ok", status_ok)
        pulumi.set(__self__, "status_redirect", status_redirect)
        pulumi.set(__self__, "status_server_error", status_server_error)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "upstream_client_error", upstream_client_error)
        pulumi.set(__self__, "upstream_redirect", upstream_redirect)
        pulumi.set(__self__, "upstream_server_error", upstream_server_error)

    @_builtins.property
    @pulumi.getter
    def access(self) -> _builtins.int:
        """
        qps.
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter
    def attack(self) -> _builtins.int:
        """
        Number of web attacks.
        """
        return pulumi.get(self, "attack")

    @_builtins.property
    @pulumi.getter(name="botAccess")
    def bot_access(self) -> _builtins.int:
        """
        Bot qps.
        """
        return pulumi.get(self, "bot_access")

    @_builtins.property
    @pulumi.getter
    def cc(self) -> _builtins.int:
        """
        Number of cc attacks.
        """
        return pulumi.get(self, "cc")

    @_builtins.property
    @pulumi.getter
    def down(self) -> _builtins.int:
        """
        Peak downlink bandwidth, unit B.
        """
        return pulumi.get(self, "down")

    @_builtins.property
    @pulumi.getter(name="statusClientError")
    def status_client_error(self) -> _builtins.int:
        """
        Trend chart of the number of status codes returned by WAF to the client.
        """
        return pulumi.get(self, "status_client_error")

    @_builtins.property
    @pulumi.getter(name="statusOk")
    def status_ok(self) -> _builtins.int:
        """
        Trend chart of the number of status codes returned by WAF to the client.
        """
        return pulumi.get(self, "status_ok")

    @_builtins.property
    @pulumi.getter(name="statusRedirect")
    def status_redirect(self) -> _builtins.int:
        """
        Trend chart of the number of status codes returned by WAF to the client.
        """
        return pulumi.get(self, "status_redirect")

    @_builtins.property
    @pulumi.getter(name="statusServerError")
    def status_server_error(self) -> _builtins.int:
        """
        Trend chart of the number of status codes returned by WAF to the server.
        """
        return pulumi.get(self, "status_server_error")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.int:
        """
        Second level timestamp.
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.int:
        """
        Peak uplink bandwidth, unit B.
        """
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter(name="upstreamClientError")
    def upstream_client_error(self) -> _builtins.int:
        """
        Trend chart of the number of status codes returned to WAF by the origin site.
        """
        return pulumi.get(self, "upstream_client_error")

    @_builtins.property
    @pulumi.getter(name="upstreamRedirect")
    def upstream_redirect(self) -> _builtins.int:
        """
        Trend chart of the number of status codes returned to WAF by the origin site.
        """
        return pulumi.get(self, "upstream_redirect")

    @_builtins.property
    @pulumi.getter(name="upstreamServerError")
    def upstream_server_error(self) -> _builtins.int:
        """
        Trend chart of the number of status codes returned to WAF by the origin site.
        """
        return pulumi.get(self, "upstream_server_error")


@pulumi.output_type
class GetTlsVersionsTlResult(dict):
    def __init__(__self__, *,
                 version_id: _builtins.int,
                 version_name: _builtins.str):
        """
        :param _builtins.int version_id: TLS version IDNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str version_name: Tls version nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        pulumi.set(__self__, "version_id", version_id)
        pulumi.set(__self__, "version_name", version_name)

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.int:
        """
        TLS version IDNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "version_id")

    @_builtins.property
    @pulumi.getter(name="versionName")
    def version_name(self) -> _builtins.str:
        """
        Tls version nameNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "version_name")


@pulumi.output_type
class GetUserClbRegionsRichDataResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 id: _builtins.str,
                 text: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str code: Region code.
        :param _builtins.str id: Region ID.
        :param _builtins.str text: Chinese description for region.
        :param _builtins.str value: English description for region.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "text", text)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Region code.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Region ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Chinese description for region.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        English description for region.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetUserDomainsUsersInfoResult(dict):
    def __init__(__self__, *,
                 appid: _builtins.int,
                 cls: _builtins.int,
                 domain: _builtins.str,
                 domain_id: _builtins.str,
                 edition: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str,
                 level: _builtins.str,
                 write_config: _builtins.str):
        """
        :param _builtins.int appid: User appid.
        :param _builtins.int cls: CLS switch 1: write, 0: do not writeNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str domain: Domain name.
        :param _builtins.str domain_id: Domain unique id.
        :param _builtins.str edition: Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
        :param _builtins.str instance_id: Instance unique id.
        :param _builtins.str instance_name: Instance name.
        :param _builtins.str level: Instance level infoNote: This field may return null, indicating that a valid value cannot be obtained.
        :param _builtins.str write_config: Switch for accessing log fieldsNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        pulumi.set(__self__, "appid", appid)
        pulumi.set(__self__, "cls", cls)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "edition", edition)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "write_config", write_config)

    @_builtins.property
    @pulumi.getter
    def appid(self) -> _builtins.int:
        """
        User appid.
        """
        return pulumi.get(self, "appid")

    @_builtins.property
    @pulumi.getter
    def cls(self) -> _builtins.int:
        """
        CLS switch 1: write, 0: do not writeNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "cls")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        """
        Domain unique id.
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter
    def edition(self) -> _builtins.str:
        """
        Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
        """
        return pulumi.get(self, "edition")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Instance unique id.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        Instance name.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        Instance level infoNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="writeConfig")
    def write_config(self) -> _builtins.str:
        """
        Switch for accessing log fieldsNote: This field may return null, indicating that a valid value cannot be obtained.
        """
        return pulumi.get(self, "write_config")


