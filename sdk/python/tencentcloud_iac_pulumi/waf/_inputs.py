# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AntiInfoLeakStrategyArgs',
    'AntiInfoLeakStrategyArgsDict',
    'AttackWhiteRuleRuleArgs',
    'AttackWhiteRuleRuleArgsDict',
    'BotSceneUcbRuleRuleArgs',
    'BotSceneUcbRuleRuleArgsDict',
    'BotSceneUcbRuleRuleActionListArgs',
    'BotSceneUcbRuleRuleActionListArgsDict',
    'BotSceneUcbRuleRuleJobDateTimeArgs',
    'BotSceneUcbRuleRuleJobDateTimeArgsDict',
    'BotSceneUcbRuleRuleJobDateTimeCronArgs',
    'BotSceneUcbRuleRuleJobDateTimeCronArgsDict',
    'BotSceneUcbRuleRuleJobDateTimeTimedArgs',
    'BotSceneUcbRuleRuleJobDateTimeTimedArgsDict',
    'BotSceneUcbRuleRuleRuleArgs',
    'BotSceneUcbRuleRuleRuleArgsDict',
    'BotSceneUcbRuleRuleRuleAreaArgs',
    'BotSceneUcbRuleRuleRuleAreaArgsDict',
    'BotSceneUcbRuleRuleRuleValueArgs',
    'BotSceneUcbRuleRuleRuleValueArgsDict',
    'BotStatusConfigCurrentGlobalSceneArgs',
    'BotStatusConfigCurrentGlobalSceneArgsDict',
    'ClbDomainLoadBalancerSetArgs',
    'ClbDomainLoadBalancerSetArgsDict',
    'CustomRuleJobDateTimeArgs',
    'CustomRuleJobDateTimeArgsDict',
    'CustomRuleJobDateTimeCronArgs',
    'CustomRuleJobDateTimeCronArgsDict',
    'CustomRuleJobDateTimeTimedArgs',
    'CustomRuleJobDateTimeTimedArgsDict',
    'CustomRuleStrategyArgs',
    'CustomRuleStrategyArgsDict',
    'CustomWhiteRuleJobDateTimeArgs',
    'CustomWhiteRuleJobDateTimeArgsDict',
    'CustomWhiteRuleJobDateTimeCronArgs',
    'CustomWhiteRuleJobDateTimeCronArgsDict',
    'CustomWhiteRuleJobDateTimeTimedArgs',
    'CustomWhiteRuleJobDateTimeTimedArgsDict',
    'CustomWhiteRuleStrategyArgs',
    'CustomWhiteRuleStrategyArgsDict',
    'IpAccessControlItemArgs',
    'IpAccessControlItemArgsDict',
    'IpAccessControlV2JobDateTimeArgs',
    'IpAccessControlV2JobDateTimeArgsDict',
    'IpAccessControlV2JobDateTimeCronArgs',
    'IpAccessControlV2JobDateTimeCronArgsDict',
    'IpAccessControlV2JobDateTimeTimedArgs',
    'IpAccessControlV2JobDateTimeTimedArgsDict',
    'LogPostCkafkaFlowWriteConfigArgs',
    'LogPostCkafkaFlowWriteConfigArgsDict',
    'OwaspWhiteRuleJobDateTimeArgs',
    'OwaspWhiteRuleJobDateTimeArgsDict',
    'OwaspWhiteRuleJobDateTimeCronArgs',
    'OwaspWhiteRuleJobDateTimeCronArgsDict',
    'OwaspWhiteRuleJobDateTimeTimedArgs',
    'OwaspWhiteRuleJobDateTimeTimedArgsDict',
    'OwaspWhiteRuleStrategyArgs',
    'OwaspWhiteRuleStrategyArgsDict',
    'SaasDomainPortArgs',
    'SaasDomainPortArgsDict',
    'GetOwaspRuleTypesFilterArgs',
    'GetOwaspRuleTypesFilterArgsDict',
    'GetOwaspRulesFilterArgs',
    'GetOwaspRulesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AntiInfoLeakStrategyArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        Matching content
        The following options are available when Field is set to information:
        idcard (ID card), phone (phone number), and bankcard (bank card).
        The following options are available when Field is set to returncode:
        400 (status code 400), 403 (status code 403), 404 (status code 404), 4xx (other 4xx status codes), 500 (status code 500), 501 (status code 501), 502 (status code 502), 504 (status code 504), and 5xx (other 5xx status codes).
        When Field is set to keywords, users need to input the matching content themselves.
        """
        field: pulumi.Input[_builtins.str]
        """
        Matching Criteria, returncode (Response Code), keywords (Keywords), information (Sensitive Information).
        """
elif False:
    AntiInfoLeakStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiInfoLeakStrategyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] content: Matching content
               The following options are available when Field is set to information:
               idcard (ID card), phone (phone number), and bankcard (bank card).
               The following options are available when Field is set to returncode:
               400 (status code 400), 403 (status code 403), 404 (status code 404), 4xx (other 4xx status codes), 500 (status code 500), 501 (status code 501), 502 (status code 502), 504 (status code 504), and 5xx (other 5xx status codes).
               When Field is set to keywords, users need to input the matching content themselves.
        :param pulumi.Input[_builtins.str] field: Matching Criteria, returncode (Response Code), keywords (Keywords), information (Sensitive Information).
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Matching content
        The following options are available when Field is set to information:
        idcard (ID card), phone (phone number), and bankcard (bank card).
        The following options are available when Field is set to returncode:
        400 (status code 400), 403 (status code 403), 404 (status code 404), 4xx (other 4xx status codes), 500 (status code 500), 501 (status code 501), 502 (status code 502), 504 (status code 504), and 5xx (other 5xx status codes).
        When Field is set to keywords, users need to input the matching content themselves.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Matching Criteria, returncode (Response Code), keywords (Keywords), information (Sensitive Information).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)


if not MYPY:
    class AttackWhiteRuleRuleArgsDict(TypedDict):
        match_content: pulumi.Input[_builtins.str]
        """
        Matching content.
        """
        match_field: pulumi.Input[_builtins.str]
        """
        Matching domains.
        """
        match_method: pulumi.Input[_builtins.str]
        """
        Matching method.
        """
        match_params: NotRequired[pulumi.Input[_builtins.str]]
        """
        Matching params.
        """
elif False:
    AttackWhiteRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttackWhiteRuleRuleArgs:
    def __init__(__self__, *,
                 match_content: pulumi.Input[_builtins.str],
                 match_field: pulumi.Input[_builtins.str],
                 match_method: pulumi.Input[_builtins.str],
                 match_params: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] match_content: Matching content.
        :param pulumi.Input[_builtins.str] match_field: Matching domains.
        :param pulumi.Input[_builtins.str] match_method: Matching method.
        :param pulumi.Input[_builtins.str] match_params: Matching params.
        """
        pulumi.set(__self__, "match_content", match_content)
        pulumi.set(__self__, "match_field", match_field)
        pulumi.set(__self__, "match_method", match_method)
        if match_params is not None:
            pulumi.set(__self__, "match_params", match_params)

    @_builtins.property
    @pulumi.getter(name="matchContent")
    def match_content(self) -> pulumi.Input[_builtins.str]:
        """
        Matching content.
        """
        return pulumi.get(self, "match_content")

    @match_content.setter
    def match_content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_content", value)

    @_builtins.property
    @pulumi.getter(name="matchField")
    def match_field(self) -> pulumi.Input[_builtins.str]:
        """
        Matching domains.
        """
        return pulumi.get(self, "match_field")

    @match_field.setter
    def match_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_field", value)

    @_builtins.property
    @pulumi.getter(name="matchMethod")
    def match_method(self) -> pulumi.Input[_builtins.str]:
        """
        Matching method.
        """
        return pulumi.get(self, "match_method")

    @match_method.setter
    def match_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_method", value)

    @_builtins.property
    @pulumi.getter(name="matchParams")
    def match_params(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Matching params.
        """
        return pulumi.get(self, "match_params")

    @match_params.setter
    def match_params(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_params", value)


if not MYPY:
    class BotSceneUcbRuleRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Disposal action.
        """
        domain: pulumi.Input[_builtins.str]
        """
        Domain.
        """
        label: pulumi.Input[_builtins.str]
        """
        Label.
        """
        name: pulumi.Input[_builtins.str]
        """
        Rule name.
        """
        on_off: pulumi.Input[_builtins.str]
        """
        Rule switch.
        """
        prior: pulumi.Input[_builtins.int]
        """
        Rule priority.
        """
        rule_type: pulumi.Input[_builtins.int]
        """
        Rule type.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleArgsDict']]]
        """
        Specific rule items of UCB.
        """
        action_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleActionListArgsDict']]]]
        """
        When Action=intercept, this field is mandatory.
        """
        addition_arg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional parameters.
        """
        appid: NotRequired[pulumi.Input[_builtins.int]]
        """
        Appid.
        """
        block_page_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Customize interception page ID.
        """
        desc: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule description.
        """
        expire_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Effective deadline.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Entry ID.
        """
        job_date_time: NotRequired[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeArgsDict']]
        """
        Scheduled task configuration.
        """
        job_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduled task type.
        """
        pre_define: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True - System preset rules False - Custom rules.
        """
        scene_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scene ID.
        """
        valid_status: NotRequired[pulumi.Input[_builtins.int]]
        """
        Effective -1, Invalid -0.
        """
        valid_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Valid time.
        """
elif False:
    BotSceneUcbRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 domain: pulumi.Input[_builtins.str],
                 label: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 on_off: pulumi.Input[_builtins.str],
                 prior: pulumi.Input[_builtins.int],
                 rule_type: pulumi.Input[_builtins.int],
                 rules: pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleArgs']]],
                 action_lists: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleActionListArgs']]]] = None,
                 addition_arg: Optional[pulumi.Input[_builtins.str]] = None,
                 appid: Optional[pulumi.Input[_builtins.int]] = None,
                 block_page_id: Optional[pulumi.Input[_builtins.int]] = None,
                 desc: Optional[pulumi.Input[_builtins.str]] = None,
                 expire_time: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 job_date_time: Optional[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeArgs']] = None,
                 job_type: Optional[pulumi.Input[_builtins.str]] = None,
                 pre_define: Optional[pulumi.Input[_builtins.bool]] = None,
                 scene_id: Optional[pulumi.Input[_builtins.str]] = None,
                 valid_status: Optional[pulumi.Input[_builtins.int]] = None,
                 valid_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Disposal action.
        :param pulumi.Input[_builtins.str] domain: Domain.
        :param pulumi.Input[_builtins.str] label: Label.
        :param pulumi.Input[_builtins.str] name: Rule name.
        :param pulumi.Input[_builtins.str] on_off: Rule switch.
        :param pulumi.Input[_builtins.int] prior: Rule priority.
        :param pulumi.Input[_builtins.int] rule_type: Rule type.
        :param pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleArgs']]] rules: Specific rule items of UCB.
        :param pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleActionListArgs']]] action_lists: When Action=intercept, this field is mandatory.
        :param pulumi.Input[_builtins.str] addition_arg: Additional parameters.
        :param pulumi.Input[_builtins.int] appid: Appid.
        :param pulumi.Input[_builtins.int] block_page_id: Customize interception page ID.
        :param pulumi.Input[_builtins.str] desc: Rule description.
        :param pulumi.Input[_builtins.int] expire_time: Effective deadline.
        :param pulumi.Input[_builtins.str] id: Entry ID.
        :param pulumi.Input['BotSceneUcbRuleRuleJobDateTimeArgs'] job_date_time: Scheduled task configuration.
        :param pulumi.Input[_builtins.str] job_type: Scheduled task type.
        :param pulumi.Input[_builtins.bool] pre_define: True - System preset rules False - Custom rules.
        :param pulumi.Input[_builtins.str] scene_id: Scene ID.
        :param pulumi.Input[_builtins.int] valid_status: Effective -1, Invalid -0.
        :param pulumi.Input[_builtins.int] valid_time: Valid time.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "on_off", on_off)
        pulumi.set(__self__, "prior", prior)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "rules", rules)
        if action_lists is not None:
            pulumi.set(__self__, "action_lists", action_lists)
        if addition_arg is not None:
            pulumi.set(__self__, "addition_arg", addition_arg)
        if appid is not None:
            pulumi.set(__self__, "appid", appid)
        if block_page_id is not None:
            pulumi.set(__self__, "block_page_id", block_page_id)
        if desc is not None:
            pulumi.set(__self__, "desc", desc)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if job_date_time is not None:
            pulumi.set(__self__, "job_date_time", job_date_time)
        if job_type is not None:
            pulumi.set(__self__, "job_type", job_type)
        if pre_define is not None:
            pulumi.set(__self__, "pre_define", pre_define)
        if scene_id is not None:
            pulumi.set(__self__, "scene_id", scene_id)
        if valid_status is not None:
            pulumi.set(__self__, "valid_status", valid_status)
        if valid_time is not None:
            pulumi.set(__self__, "valid_time", valid_time)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Disposal action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        Label.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="onOff")
    def on_off(self) -> pulumi.Input[_builtins.str]:
        """
        Rule switch.
        """
        return pulumi.get(self, "on_off")

    @on_off.setter
    def on_off(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "on_off", value)

    @_builtins.property
    @pulumi.getter
    def prior(self) -> pulumi.Input[_builtins.int]:
        """
        Rule priority.
        """
        return pulumi.get(self, "prior")

    @prior.setter
    def prior(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "prior", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[_builtins.int]:
        """
        Rule type.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleArgs']]]:
        """
        Specific rule items of UCB.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter(name="actionLists")
    def action_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleActionListArgs']]]]:
        """
        When Action=intercept, this field is mandatory.
        """
        return pulumi.get(self, "action_lists")

    @action_lists.setter
    def action_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleActionListArgs']]]]):
        pulumi.set(self, "action_lists", value)

    @_builtins.property
    @pulumi.getter(name="additionArg")
    def addition_arg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional parameters.
        """
        return pulumi.get(self, "addition_arg")

    @addition_arg.setter
    def addition_arg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "addition_arg", value)

    @_builtins.property
    @pulumi.getter
    def appid(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Appid.
        """
        return pulumi.get(self, "appid")

    @appid.setter
    def appid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "appid", value)

    @_builtins.property
    @pulumi.getter(name="blockPageId")
    def block_page_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Customize interception page ID.
        """
        return pulumi.get(self, "block_page_id")

    @block_page_id.setter
    def block_page_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_page_id", value)

    @_builtins.property
    @pulumi.getter
    def desc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule description.
        """
        return pulumi.get(self, "desc")

    @desc.setter
    def desc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "desc", value)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Effective deadline.
        """
        return pulumi.get(self, "expire_time")

    @expire_time.setter
    def expire_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expire_time", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Entry ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="jobDateTime")
    def job_date_time(self) -> Optional[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeArgs']]:
        """
        Scheduled task configuration.
        """
        return pulumi.get(self, "job_date_time")

    @job_date_time.setter
    def job_date_time(self, value: Optional[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeArgs']]):
        pulumi.set(self, "job_date_time", value)

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduled task type.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_type", value)

    @_builtins.property
    @pulumi.getter(name="preDefine")
    def pre_define(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True - System preset rules False - Custom rules.
        """
        return pulumi.get(self, "pre_define")

    @pre_define.setter
    def pre_define(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pre_define", value)

    @_builtins.property
    @pulumi.getter(name="sceneId")
    def scene_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scene ID.
        """
        return pulumi.get(self, "scene_id")

    @scene_id.setter
    def scene_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scene_id", value)

    @_builtins.property
    @pulumi.getter(name="validStatus")
    def valid_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Effective -1, Invalid -0.
        """
        return pulumi.get(self, "valid_status")

    @valid_status.setter
    def valid_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "valid_status", value)

    @_builtins.property
    @pulumi.getter(name="validTime")
    def valid_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Valid time.
        """
        return pulumi.get(self, "valid_time")

    @valid_time.setter
    def valid_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "valid_time", value)


if not MYPY:
    class BotSceneUcbRuleRuleActionListArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action.
        """
        proportion: NotRequired[pulumi.Input[_builtins.float]]
        """
        Proportion.
        """
elif False:
    BotSceneUcbRuleRuleActionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleActionListArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 proportion: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action.
        :param pulumi.Input[_builtins.float] proportion: Proportion.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if proportion is not None:
            pulumi.set(__self__, "proportion", proportion)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def proportion(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Proportion.
        """
        return pulumi.get(self, "proportion")

    @proportion.setter
    def proportion(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "proportion", value)


if not MYPY:
    class BotSceneUcbRuleRuleJobDateTimeArgsDict(TypedDict):
        crons: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeCronArgsDict']]]]
        """
        Time parameter for cycle execution.
        """
        time_t_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time zone.
        """
        timeds: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeTimedArgsDict']]]]
        """
        Time parameter for timed execution.
        """
elif False:
    BotSceneUcbRuleRuleJobDateTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleJobDateTimeArgs:
    def __init__(__self__, *,
                 crons: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeCronArgs']]]] = None,
                 time_t_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 timeds: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeTimedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeCronArgs']]] crons: Time parameter for cycle execution.
        :param pulumi.Input[_builtins.str] time_t_zone: Time zone.
        :param pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeTimedArgs']]] timeds: Time parameter for timed execution.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeCronArgs']]]]:
        """
        Time parameter for cycle execution.
        """
        return pulumi.get(self, "crons")

    @crons.setter
    def crons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeCronArgs']]]]):
        pulumi.set(self, "crons", value)

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_t_zone")

    @time_t_zone.setter
    def time_t_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_t_zone", value)

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeTimedArgs']]]]:
        """
        Time parameter for timed execution.
        """
        return pulumi.get(self, "timeds")

    @timeds.setter
    def timeds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleJobDateTimeTimedArgs']]]]):
        pulumi.set(self, "timeds", value)


if not MYPY:
    class BotSceneUcbRuleRuleJobDateTimeCronArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        On what day of each month is it executed.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time.
        """
        w_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        What day of the week is executed each week.
        """
elif False:
    BotSceneUcbRuleRuleJobDateTimeCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleJobDateTimeCronArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 w_days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days: On what day of each month is it executed.
        :param pulumi.Input[_builtins.str] end_time: End time.
        :param pulumi.Input[_builtins.str] start_time: Start time.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] w_days: What day of the week is executed each week.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        On what day of each month is it executed.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        What day of the week is executed each week.
        """
        return pulumi.get(self, "w_days")

    @w_days.setter
    def w_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "w_days", value)


if not MYPY:
    class BotSceneUcbRuleRuleJobDateTimeTimedArgsDict(TypedDict):
        end_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        End timestamp, in seconds.
        """
        start_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Start timestamp, in seconds.
        """
elif False:
    BotSceneUcbRuleRuleJobDateTimeTimedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleJobDateTimeTimedArgs:
    def __init__(__self__, *,
                 end_date_time: Optional[pulumi.Input[_builtins.int]] = None,
                 start_date_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end_date_time: End timestamp, in seconds.
        :param pulumi.Input[_builtins.int] start_date_time: Start timestamp, in seconds.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        End timestamp, in seconds.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_date_time", value)

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Start timestamp, in seconds.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_date_time", value)


if not MYPY:
    class BotSceneUcbRuleRuleRuleArgsDict(TypedDict):
        areas: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleAreaArgsDict']]]]
        """
        Regional selection.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key.
        """
        lang: NotRequired[pulumi.Input[_builtins.str]]
        """
        Language environment.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule name.
        """
        op: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator.
        """
        op_args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Optional supplementary parameters.
        """
        op_op: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional Supplementary Operators.
        """
        op_value: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional supplementary values.
        """
        value: NotRequired[pulumi.Input['BotSceneUcbRuleRuleRuleValueArgsDict']]
        """
        Value.
        """
elif False:
    BotSceneUcbRuleRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleRuleArgs:
    def __init__(__self__, *,
                 areas: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleAreaArgs']]]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 lang: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 op: Optional[pulumi.Input[_builtins.str]] = None,
                 op_args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 op_op: Optional[pulumi.Input[_builtins.str]] = None,
                 op_value: Optional[pulumi.Input[_builtins.float]] = None,
                 value: Optional[pulumi.Input['BotSceneUcbRuleRuleRuleValueArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleAreaArgs']]] areas: Regional selection.
        :param pulumi.Input[_builtins.str] key: Key.
        :param pulumi.Input[_builtins.str] lang: Language environment.
        :param pulumi.Input[_builtins.str] name: Rule name.
        :param pulumi.Input[_builtins.str] op: Operator.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] op_args: Optional supplementary parameters.
        :param pulumi.Input[_builtins.str] op_op: Optional Supplementary Operators.
        :param pulumi.Input[_builtins.float] op_value: Optional supplementary values.
        :param pulumi.Input['BotSceneUcbRuleRuleRuleValueArgs'] value: Value.
        """
        if areas is not None:
            pulumi.set(__self__, "areas", areas)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if op_args is not None:
            pulumi.set(__self__, "op_args", op_args)
        if op_op is not None:
            pulumi.set(__self__, "op_op", op_op)
        if op_value is not None:
            pulumi.set(__self__, "op_value", op_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleAreaArgs']]]]:
        """
        Regional selection.
        """
        return pulumi.get(self, "areas")

    @areas.setter
    def areas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSceneUcbRuleRuleRuleAreaArgs']]]]):
        pulumi.set(self, "areas", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Language environment.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lang", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter(name="opArgs")
    def op_args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Optional supplementary parameters.
        """
        return pulumi.get(self, "op_args")

    @op_args.setter
    def op_args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "op_args", value)

    @_builtins.property
    @pulumi.getter(name="opOp")
    def op_op(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional Supplementary Operators.
        """
        return pulumi.get(self, "op_op")

    @op_op.setter
    def op_op(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "op_op", value)

    @_builtins.property
    @pulumi.getter(name="opValue")
    def op_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional supplementary values.
        """
        return pulumi.get(self, "op_value")

    @op_value.setter
    def op_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "op_value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['BotSceneUcbRuleRuleRuleValueArgs']]:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['BotSceneUcbRuleRuleRuleValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotSceneUcbRuleRuleRuleAreaArgsDict(TypedDict):
        country: pulumi.Input[_builtins.str]
        """
        In addition to standard countries, the country also supports two special identifiers: domestic and foreign.
        """
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        City.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Province.
        """
elif False:
    BotSceneUcbRuleRuleRuleAreaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleRuleAreaArgs:
    def __init__(__self__, *,
                 country: pulumi.Input[_builtins.str],
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] country: In addition to standard countries, the country also supports two special identifiers: domestic and foreign.
        :param pulumi.Input[_builtins.str] city: City.
        :param pulumi.Input[_builtins.str] region: Province.
        """
        pulumi.set(__self__, "country", country)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def country(self) -> pulumi.Input[_builtins.str]:
        """
        In addition to standard countries, the country also supports two special identifiers: domestic and foreign.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Province.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class BotSceneUcbRuleRuleRuleValueArgsDict(TypedDict):
        basic_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String type value.
        """
        belong_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        String array type value.
        """
        logic_value: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Bool type value.
        """
        multi_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        String array type value.
        """
        valid_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicate valid fields.
        """
elif False:
    BotSceneUcbRuleRuleRuleValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSceneUcbRuleRuleRuleValueArgs:
    def __init__(__self__, *,
                 basic_value: Optional[pulumi.Input[_builtins.str]] = None,
                 belong_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 logic_value: Optional[pulumi.Input[_builtins.bool]] = None,
                 multi_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 valid_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] basic_value: String type value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] belong_values: String array type value.
        :param pulumi.Input[_builtins.bool] logic_value: Bool type value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] multi_values: String array type value.
        :param pulumi.Input[_builtins.str] valid_key: Indicate valid fields.
        """
        if basic_value is not None:
            pulumi.set(__self__, "basic_value", basic_value)
        if belong_values is not None:
            pulumi.set(__self__, "belong_values", belong_values)
        if logic_value is not None:
            pulumi.set(__self__, "logic_value", logic_value)
        if multi_values is not None:
            pulumi.set(__self__, "multi_values", multi_values)
        if valid_key is not None:
            pulumi.set(__self__, "valid_key", valid_key)

    @_builtins.property
    @pulumi.getter(name="basicValue")
    def basic_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String type value.
        """
        return pulumi.get(self, "basic_value")

    @basic_value.setter
    def basic_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_value", value)

    @_builtins.property
    @pulumi.getter(name="belongValues")
    def belong_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        String array type value.
        """
        return pulumi.get(self, "belong_values")

    @belong_values.setter
    def belong_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "belong_values", value)

    @_builtins.property
    @pulumi.getter(name="logicValue")
    def logic_value(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Bool type value.
        """
        return pulumi.get(self, "logic_value")

    @logic_value.setter
    def logic_value(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "logic_value", value)

    @_builtins.property
    @pulumi.getter(name="multiValues")
    def multi_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        String array type value.
        """
        return pulumi.get(self, "multi_values")

    @multi_values.setter
    def multi_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "multi_values", value)

    @_builtins.property
    @pulumi.getter(name="validKey")
    def valid_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicate valid fields.
        """
        return pulumi.get(self, "valid_key")

    @valid_key.setter
    def valid_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "valid_key", value)


if not MYPY:
    class BotStatusConfigCurrentGlobalSceneArgsDict(TypedDict):
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority.
        """
        scene_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scene ID.
        """
        scene_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scene name.
        """
        update_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Update time.
        """
elif False:
    BotStatusConfigCurrentGlobalSceneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotStatusConfigCurrentGlobalSceneArgs:
    def __init__(__self__, *,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 scene_id: Optional[pulumi.Input[_builtins.str]] = None,
                 scene_name: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] priority: Priority.
        :param pulumi.Input[_builtins.str] scene_id: Scene ID.
        :param pulumi.Input[_builtins.str] scene_name: Scene name.
        :param pulumi.Input[_builtins.int] update_time: Update time.
        """
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scene_id is not None:
            pulumi.set(__self__, "scene_id", scene_id)
        if scene_name is not None:
            pulumi.set(__self__, "scene_name", scene_name)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="sceneId")
    def scene_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scene ID.
        """
        return pulumi.get(self, "scene_id")

    @scene_id.setter
    def scene_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scene_id", value)

    @_builtins.property
    @pulumi.getter(name="sceneName")
    def scene_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scene name.
        """
        return pulumi.get(self, "scene_name")

    @scene_name.setter
    def scene_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scene_name", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class ClbDomainLoadBalancerSetArgsDict(TypedDict):
        listener_id: pulumi.Input[_builtins.str]
        """
        Unique ID of listener in LB.
        """
        listener_name: pulumi.Input[_builtins.str]
        """
        Listener name.
        """
        load_balancer_id: pulumi.Input[_builtins.str]
        """
        LoadBalancer unique ID.
        """
        load_balancer_name: pulumi.Input[_builtins.str]
        """
        LoadBalancer name.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol of listener, http or https.
        """
        region: pulumi.Input[_builtins.str]
        """
        LoadBalancer region.
        """
        vip: pulumi.Input[_builtins.str]
        """
        LoadBalancer IP.
        """
        vport: pulumi.Input[_builtins.int]
        """
        LoadBalancer port.
        """
        zone: pulumi.Input[_builtins.str]
        """
        LoadBalancer zone.
        """
        load_balancer_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network type for load balancer.
        """
        numerical_vpc_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditions.
        """
elif False:
    ClbDomainLoadBalancerSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClbDomainLoadBalancerSetArgs:
    def __init__(__self__, *,
                 listener_id: pulumi.Input[_builtins.str],
                 listener_name: pulumi.Input[_builtins.str],
                 load_balancer_id: pulumi.Input[_builtins.str],
                 load_balancer_name: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 vip: pulumi.Input[_builtins.str],
                 vport: pulumi.Input[_builtins.int],
                 zone: pulumi.Input[_builtins.str],
                 load_balancer_type: Optional[pulumi.Input[_builtins.str]] = None,
                 numerical_vpc_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] listener_id: Unique ID of listener in LB.
        :param pulumi.Input[_builtins.str] listener_name: Listener name.
        :param pulumi.Input[_builtins.str] load_balancer_id: LoadBalancer unique ID.
        :param pulumi.Input[_builtins.str] load_balancer_name: LoadBalancer name.
        :param pulumi.Input[_builtins.str] protocol: Protocol of listener, http or https.
        :param pulumi.Input[_builtins.str] region: LoadBalancer region.
        :param pulumi.Input[_builtins.str] vip: LoadBalancer IP.
        :param pulumi.Input[_builtins.int] vport: LoadBalancer port.
        :param pulumi.Input[_builtins.str] zone: LoadBalancer zone.
        :param pulumi.Input[_builtins.str] load_balancer_type: Network type for load balancer.
        :param pulumi.Input[_builtins.int] numerical_vpc_id: VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditions.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "listener_name", listener_name)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vport", vport)
        pulumi.set(__self__, "zone", zone)
        if load_balancer_type is not None:
            pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        if numerical_vpc_id is not None:
            pulumi.set(__self__, "numerical_vpc_id", numerical_vpc_id)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique ID of listener in LB.
        """
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="listenerName")
    def listener_name(self) -> pulumi.Input[_builtins.str]:
        """
        Listener name.
        """
        return pulumi.get(self, "listener_name")

    @listener_name.setter
    def listener_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "listener_name", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> pulumi.Input[_builtins.str]:
        """
        LoadBalancer unique ID.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "load_balancer_id", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> pulumi.Input[_builtins.str]:
        """
        LoadBalancer name.
        """
        return pulumi.get(self, "load_balancer_name")

    @load_balancer_name.setter
    def load_balancer_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "load_balancer_name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol of listener, http or https.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        LoadBalancer region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def vip(self) -> pulumi.Input[_builtins.str]:
        """
        LoadBalancer IP.
        """
        return pulumi.get(self, "vip")

    @vip.setter
    def vip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vip", value)

    @_builtins.property
    @pulumi.getter
    def vport(self) -> pulumi.Input[_builtins.int]:
        """
        LoadBalancer port.
        """
        return pulumi.get(self, "vport")

    @vport.setter
    def vport(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "vport", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        LoadBalancer zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network type for load balancer.
        """
        return pulumi.get(self, "load_balancer_type")

    @load_balancer_type.setter
    def load_balancer_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_balancer_type", value)

    @_builtins.property
    @pulumi.getter(name="numericalVpcId")
    def numerical_vpc_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditions.
        """
        return pulumi.get(self, "numerical_vpc_id")

    @numerical_vpc_id.setter
    def numerical_vpc_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "numerical_vpc_id", value)


if not MYPY:
    class CustomRuleJobDateTimeArgsDict(TypedDict):
        crons: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeCronArgsDict']]]]
        """
        Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        time_t_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        """
        timeds: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeTimedArgsDict']]]]
        """
        Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomRuleJobDateTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomRuleJobDateTimeArgs:
    def __init__(__self__, *,
                 crons: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeCronArgs']]]] = None,
                 time_t_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 timeds: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeTimedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeCronArgs']]] crons: Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] time_t_zone: Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeTimedArgs']]] timeds: Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeCronArgs']]]]:
        """
        Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "crons")

    @crons.setter
    def crons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeCronArgs']]]]):
        pulumi.set(self, "crons", value)

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_t_zone")

    @time_t_zone.setter
    def time_t_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_t_zone", value)

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeTimedArgs']]]]:
        """
        Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeds")

    @timeds.setter
    def timeds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleJobDateTimeTimedArgs']]]]):
        pulumi.set(self, "timeds", value)


if not MYPY:
    class CustomRuleJobDateTimeCronArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        w_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomRuleJobDateTimeCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomRuleJobDateTimeCronArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 w_days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days: Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] end_time: End time. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] start_time: Start time. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] w_days: Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "w_days")

    @w_days.setter
    def w_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "w_days", value)


if not MYPY:
    class CustomRuleJobDateTimeTimedArgsDict(TypedDict):
        end_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        start_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomRuleJobDateTimeTimedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomRuleJobDateTimeTimedArgs:
    def __init__(__self__, *,
                 end_date_time: Optional[pulumi.Input[_builtins.int]] = None,
                 start_date_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end_date_time: End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] start_date_time: Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_date_time", value)

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_date_time", value)


if not MYPY:
    class CustomRuleStrategyArgsDict(TypedDict):
        arg: pulumi.Input[_builtins.str]
        """
        Matching parameter
        There are two types of configuration parameters: unsupported parameters and supported parameters.
        The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
        GET (GET parameter value)
        POST (POST parameter value)
        ARGS_COOKIE (Cookie parameter value)
        ARGS_HEADER (Header parameter value)
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        compare_func: pulumi.Input[_builtins.str]
        """
        Logic symbol
        Logical symbols are divided into the following types:
        empty (content is empty)
        null (do not exist)
        eq (equal to)
        neq (not equal to)
        contains (contain)
        ncontains (do not contain)
        strprefix (prefix matching)
        strsuffix (suffix matching)
        len_eq (length equals to)
        len_gt (length is greater than)
        len_lt (length is less than)
        ipmatch (belong to)
        ipnmatch (do not belong to)
        numgt (number greater than)
        numlt (number less than)
        geo_in (IP geo belongs to)
        geo_not_in (IP geo not belongs to)
        rematch (regex match)
        numgt (numerically greater than)
        numlt (numerically less than)
        numeq (numerically equal to)
        numneq (numerically not equal to)
        numle (numerically less than or equal to)
        numge (numerically greater than or equal to)
        Different matching fields correspond to different logical operators. For details, see the matching field table above.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        content: pulumi.Input[_builtins.str]
        """
        Matching content
        Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        field: pulumi.Input[_builtins.str]
        """
        Matching field
        Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
        <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        case_not_sensitive: NotRequired[pulumi.Input[_builtins.int]]
        """
        0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomRuleStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomRuleStrategyArgs:
    def __init__(__self__, *,
                 arg: pulumi.Input[_builtins.str],
                 compare_func: pulumi.Input[_builtins.str],
                 content: pulumi.Input[_builtins.str],
                 field: pulumi.Input[_builtins.str],
                 case_not_sensitive: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] arg: Matching parameter
               There are two types of configuration parameters: unsupported parameters and supported parameters.
               The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
               GET (GET parameter value)
               POST (POST parameter value)
               ARGS_COOKIE (Cookie parameter value)
               ARGS_HEADER (Header parameter value)
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] compare_func: Logic symbol
               Logical symbols are divided into the following types:
               empty (content is empty)
               null (do not exist)
               eq (equal to)
               neq (not equal to)
               contains (contain)
               ncontains (do not contain)
               strprefix (prefix matching)
               strsuffix (suffix matching)
               len_eq (length equals to)
               len_gt (length is greater than)
               len_lt (length is less than)
               ipmatch (belong to)
               ipnmatch (do not belong to)
               numgt (number greater than)
               numlt (number less than)
               geo_in (IP geo belongs to)
               geo_not_in (IP geo not belongs to)
               rematch (regex match)
               numgt (numerically greater than)
               numlt (numerically less than)
               numeq (numerically equal to)
               numneq (numerically not equal to)
               numle (numerically less than or equal to)
               numge (numerically greater than or equal to)
               Different matching fields correspond to different logical operators. For details, see the matching field table above.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] content: Matching content
               Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] field: Matching field
               Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
               <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] case_not_sensitive: 0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "arg", arg)
        pulumi.set(__self__, "compare_func", compare_func)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)
        if case_not_sensitive is not None:
            pulumi.set(__self__, "case_not_sensitive", case_not_sensitive)

    @_builtins.property
    @pulumi.getter
    def arg(self) -> pulumi.Input[_builtins.str]:
        """
        Matching parameter
        There are two types of configuration parameters: unsupported parameters and supported parameters.
        The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
        GET (GET parameter value)
        POST (POST parameter value)
        ARGS_COOKIE (Cookie parameter value)
        ARGS_HEADER (Header parameter value)
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "arg")

    @arg.setter
    def arg(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arg", value)

    @_builtins.property
    @pulumi.getter(name="compareFunc")
    def compare_func(self) -> pulumi.Input[_builtins.str]:
        """
        Logic symbol
        Logical symbols are divided into the following types:
        empty (content is empty)
        null (do not exist)
        eq (equal to)
        neq (not equal to)
        contains (contain)
        ncontains (do not contain)
        strprefix (prefix matching)
        strsuffix (suffix matching)
        len_eq (length equals to)
        len_gt (length is greater than)
        len_lt (length is less than)
        ipmatch (belong to)
        ipnmatch (do not belong to)
        numgt (number greater than)
        numlt (number less than)
        geo_in (IP geo belongs to)
        geo_not_in (IP geo not belongs to)
        rematch (regex match)
        numgt (numerically greater than)
        numlt (numerically less than)
        numeq (numerically equal to)
        numneq (numerically not equal to)
        numle (numerically less than or equal to)
        numge (numerically greater than or equal to)
        Different matching fields correspond to different logical operators. For details, see the matching field table above.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "compare_func")

    @compare_func.setter
    def compare_func(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compare_func", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Matching content
        Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Matching field
        Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
        <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="caseNotSensitive")
    def case_not_sensitive(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "case_not_sensitive")

    @case_not_sensitive.setter
    def case_not_sensitive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "case_not_sensitive", value)


if not MYPY:
    class CustomWhiteRuleJobDateTimeArgsDict(TypedDict):
        crons: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeCronArgsDict']]]]
        """
        Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        time_t_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        """
        timeds: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeTimedArgsDict']]]]
        """
        Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomWhiteRuleJobDateTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomWhiteRuleJobDateTimeArgs:
    def __init__(__self__, *,
                 crons: Optional[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeCronArgs']]]] = None,
                 time_t_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 timeds: Optional[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeTimedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeCronArgs']]] crons: Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] time_t_zone: Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeTimedArgs']]] timeds: Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeCronArgs']]]]:
        """
        Time parameters for periodic execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "crons")

    @crons.setter
    def crons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeCronArgs']]]]):
        pulumi.set(self, "crons", value)

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time zone. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_t_zone")

    @time_t_zone.setter
    def time_t_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_t_zone", value)

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeTimedArgs']]]]:
        """
        Time parameters for scheduled execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeds")

    @timeds.setter
    def timeds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomWhiteRuleJobDateTimeTimedArgs']]]]):
        pulumi.set(self, "timeds", value)


if not MYPY:
    class CustomWhiteRuleJobDateTimeCronArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        w_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomWhiteRuleJobDateTimeCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomWhiteRuleJobDateTimeCronArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 w_days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days: Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] end_time: End time. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] start_time: Start time. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] w_days: Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Days in each month for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Days of each week for execution. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "w_days")

    @w_days.setter
    def w_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "w_days", value)


if not MYPY:
    class CustomWhiteRuleJobDateTimeTimedArgsDict(TypedDict):
        end_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        start_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomWhiteRuleJobDateTimeTimedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomWhiteRuleJobDateTimeTimedArgs:
    def __init__(__self__, *,
                 end_date_time: Optional[pulumi.Input[_builtins.int]] = None,
                 start_date_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end_date_time: End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] start_date_time: Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        End timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_date_time", value)

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Start timestamp, in seconds. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_date_time", value)


if not MYPY:
    class CustomWhiteRuleStrategyArgsDict(TypedDict):
        arg: pulumi.Input[_builtins.str]
        """
        Matching parameter
        There are two types of configuration parameters: unsupported parameters and supported parameters.
        The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
        GET (GET parameter value)
        POST (POST parameter value)
        ARGS_COOKIE (Cookie parameter value)
        ARGS_HEADER (Header parameter value)
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        compare_func: pulumi.Input[_builtins.str]
        """
        Logic symbol
        Logical symbols are divided into the following types:
        empty (content is empty)
        null (do not exist)
        eq (equal to)
        neq (not equal to)
        contains (contain)
        ncontains (do not contain)
        strprefix (prefix matching)
        strsuffix (suffix matching)
        len_eq (length equals to)
        len_gt (length is greater than)
        len_lt (length is less than)
        ipmatch (belong to)
        ipnmatch (do not belong to)
        numgt (number greater than)
        numlt (number less than)
        geo_in (IP geo belongs to)
        geo_not_in (IP geo not belongs to)
        rematch (regex match)
        numgt (numerically greater than)
        numlt (numerically less than)
        numeq (numerically equal to)
        numneq (numerically not equal to)
        numle (numerically less than or equal to)
        numge (numerically greater than or equal to)
        Different matching fields correspond to different logical operators. For details, see the matching field table above.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        content: pulumi.Input[_builtins.str]
        """
        Matching content
        Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        field: pulumi.Input[_builtins.str]
        """
        Matching field
        Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
        <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        case_not_sensitive: NotRequired[pulumi.Input[_builtins.int]]
        """
        0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    CustomWhiteRuleStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomWhiteRuleStrategyArgs:
    def __init__(__self__, *,
                 arg: pulumi.Input[_builtins.str],
                 compare_func: pulumi.Input[_builtins.str],
                 content: pulumi.Input[_builtins.str],
                 field: pulumi.Input[_builtins.str],
                 case_not_sensitive: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] arg: Matching parameter
               There are two types of configuration parameters: unsupported parameters and supported parameters.
               The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
               GET (GET parameter value)
               POST (POST parameter value)
               ARGS_COOKIE (Cookie parameter value)
               ARGS_HEADER (Header parameter value)
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] compare_func: Logic symbol
               Logical symbols are divided into the following types:
               empty (content is empty)
               null (do not exist)
               eq (equal to)
               neq (not equal to)
               contains (contain)
               ncontains (do not contain)
               strprefix (prefix matching)
               strsuffix (suffix matching)
               len_eq (length equals to)
               len_gt (length is greater than)
               len_lt (length is less than)
               ipmatch (belong to)
               ipnmatch (do not belong to)
               numgt (number greater than)
               numlt (number less than)
               geo_in (IP geo belongs to)
               geo_not_in (IP geo not belongs to)
               rematch (regex match)
               numgt (numerically greater than)
               numlt (numerically less than)
               numeq (numerically equal to)
               numneq (numerically not equal to)
               numle (numerically less than or equal to)
               numge (numerically greater than or equal to)
               Different matching fields correspond to different logical operators. For details, see the matching field table above.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] content: Matching content
               Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] field: Matching field
               Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
               <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] case_not_sensitive: 0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "arg", arg)
        pulumi.set(__self__, "compare_func", compare_func)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)
        if case_not_sensitive is not None:
            pulumi.set(__self__, "case_not_sensitive", case_not_sensitive)

    @_builtins.property
    @pulumi.getter
    def arg(self) -> pulumi.Input[_builtins.str]:
        """
        Matching parameter
        There are two types of configuration parameters: unsupported parameters and supported parameters.
        The matching parameter can be entered only when the matching field is one of the following four. Otherwise, the parameter is not supported.
        GET (GET parameter value)
        POST (POST parameter value)
        ARGS_COOKIE (Cookie parameter value)
        ARGS_HEADER (Header parameter value)
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "arg")

    @arg.setter
    def arg(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arg", value)

    @_builtins.property
    @pulumi.getter(name="compareFunc")
    def compare_func(self) -> pulumi.Input[_builtins.str]:
        """
        Logic symbol
        Logical symbols are divided into the following types:
        empty (content is empty)
        null (do not exist)
        eq (equal to)
        neq (not equal to)
        contains (contain)
        ncontains (do not contain)
        strprefix (prefix matching)
        strsuffix (suffix matching)
        len_eq (length equals to)
        len_gt (length is greater than)
        len_lt (length is less than)
        ipmatch (belong to)
        ipnmatch (do not belong to)
        numgt (number greater than)
        numlt (number less than)
        geo_in (IP geo belongs to)
        geo_not_in (IP geo not belongs to)
        rematch (regex match)
        numgt (numerically greater than)
        numlt (numerically less than)
        numeq (numerically equal to)
        numneq (numerically not equal to)
        numle (numerically less than or equal to)
        numge (numerically greater than or equal to)
        Different matching fields correspond to different logical operators. For details, see the matching field table above.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "compare_func")

    @compare_func.setter
    def compare_func(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compare_func", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Matching content
        Currently, when the matching field is COOKIE (cookie), the matching content is not required. In other scenes, the matching content is required.
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Matching field
        Different matching fields result in different matching parameters, logical operators, and matching contents. The details are as follows:
        <table><thead><tr><th>Matching Field</th><th>Matching Parameter</th><th>Logical Symbol</th><th>Matching Content</th></tr></thead><tbody><tr><td>IP (source IP)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr><tr><td>IPv6 (source IPv6)</td><td>Parameters are not supported.</td><td>ipmatch (match)<br>ipnmatch (mismatch)</td><td>A single IPv6 address is supported.</td></tr><tr><td>Referer (referer)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content, with a maximum of 512 characters.</td></tr><tr><td>URL (request path)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content starting with /, with a maximum of 512 characters.</td></tr><tr><td>UserAgent (UserAgent)</td><td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>HTTP_METHOD (HTTP request method)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)</td><td>Enter the method name. The uppercase is recommended.</td></tr><tr><td>QUERY_STRING (request string)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET (GET parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_PARAMS_NAMES (GET parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST (POST parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>GET_POST_NAMES (POST parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>POST_BODY (complete body)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr><tr><td>COOKIE (cookie)</td><td>Parameters are not supported.</td><td>empty (Content is empty.)<br>null (do not exist)<br>rematch (regular expression matching)</td><td><font color="Red">Unsupported currently</font></td></tr><tr><td>GET_COOKIES_NAMES (cookie parameter name)</td><td>Parameters are not supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>ARGS_COOKIE (cookie parameter value)</td><td>Parameter entry is supported.</td><td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td><td>Enter the contentwith a maximum of 512 characters.</td></tr><tr><td>GET_HEADERS_NAMES (header parameter name)</td><td>Parameters are not supported.</td><td>exist (Parameter exists.)<br>nexist (Parameter does not exist.)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters. The lowercase is recommended.</td></tr><tr><td>ARGS_HEADER (header parameter value)</td><td>Parameter entry is supported.</td><td>contains (contain)<br>ncontains (do not contain)<br>len_eq (length equals to)<br>len_gt (length is greater than)<br>len_lt (length is less than)<br>strprefix (prefix matching)<br>strsuffix (suffix matching)<br>rematch (regular expression matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter risk level value, supporting numerical range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA device risk)</td><td>Parameters are not supported.</td><td>eq (equal to)<br>neq (not equal to)<br>belong (belongs to)<br>not_belong (does not belong to)<br>null (does not exist)<br>exist (exists)</td><td>Enter device risk code, supporting values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA risk assessment score)</td><td>Parameters are not supported.</td><td>numeq (numerically equal to)<br>numgt (numerically greater than)<br>numlt (numerically less than)<br>numle (numerically less than or equal to)<br>numge (numerically greater than or equal to)<br>null (does not exist)<br>exist (exists)</td><td>Enter assessment score, supporting numerical range 0-100</td></tr></tbody></table>
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="caseNotSensitive")
    def case_not_sensitive(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        0: case-sensitive, 1: case-insensitive. Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "case_not_sensitive")

    @case_not_sensitive.setter
    def case_not_sensitive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "case_not_sensitive", value)


if not MYPY:
    class IpAccessControlItemArgsDict(TypedDict):
        action: pulumi.Input[_builtins.int]
        """
        Action value 40 is whitelist, 42 is blacklist.
        """
        ip: pulumi.Input[_builtins.str]
        """
        IP address.
        """
        note: pulumi.Input[_builtins.str]
        """
        Note info.
        """
        valid_ts: pulumi.Input[_builtins.int]
        """
        Effective date, with a second level timestamp value. For example, 1680570420 represents 2023-04-04 09:07:00; 2019571199 means permanently effective.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the resource.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source.
        """
        valid_status: NotRequired[pulumi.Input[_builtins.int]]
        """
        Valid status.
        """
elif False:
    IpAccessControlItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpAccessControlItemArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.int],
                 ip: pulumi.Input[_builtins.str],
                 note: pulumi.Input[_builtins.str],
                 valid_ts: pulumi.Input[_builtins.int],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 valid_status: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] action: Action value 40 is whitelist, 42 is blacklist.
        :param pulumi.Input[_builtins.str] ip: IP address.
        :param pulumi.Input[_builtins.str] note: Note info.
        :param pulumi.Input[_builtins.int] valid_ts: Effective date, with a second level timestamp value. For example, 1680570420 represents 2023-04-04 09:07:00; 2019571199 means permanently effective.
        :param pulumi.Input[_builtins.str] id: ID of the resource.
        :param pulumi.Input[_builtins.str] source: Source.
        :param pulumi.Input[_builtins.int] valid_status: Valid status.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "note", note)
        pulumi.set(__self__, "valid_ts", valid_ts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if valid_status is not None:
            pulumi.set(__self__, "valid_status", valid_status)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.int]:
        """
        Action value 40 is whitelist, 42 is blacklist.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def note(self) -> pulumi.Input[_builtins.str]:
        """
        Note info.
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "note", value)

    @_builtins.property
    @pulumi.getter(name="validTs")
    def valid_ts(self) -> pulumi.Input[_builtins.int]:
        """
        Effective date, with a second level timestamp value. For example, 1680570420 represents 2023-04-04 09:07:00; 2019571199 means permanently effective.
        """
        return pulumi.get(self, "valid_ts")

    @valid_ts.setter
    def valid_ts(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "valid_ts", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="validStatus")
    def valid_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Valid status.
        """
        return pulumi.get(self, "valid_status")

    @valid_status.setter
    def valid_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "valid_status", value)


if not MYPY:
    class IpAccessControlV2JobDateTimeArgsDict(TypedDict):
        crons: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeCronArgsDict']]]]
        """
        Time parameters for periodic execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        time_t_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time zone
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        timeds: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeTimedArgsDict']]]]
        """
        Time parameters for scheduled execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    IpAccessControlV2JobDateTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpAccessControlV2JobDateTimeArgs:
    def __init__(__self__, *,
                 crons: Optional[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeCronArgs']]]] = None,
                 time_t_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 timeds: Optional[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeTimedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeCronArgs']]] crons: Time parameters for periodic execution
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] time_t_zone: Time zone
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeTimedArgs']]] timeds: Time parameters for scheduled execution
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeCronArgs']]]]:
        """
        Time parameters for periodic execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "crons")

    @crons.setter
    def crons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeCronArgs']]]]):
        pulumi.set(self, "crons", value)

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time zone
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_t_zone")

    @time_t_zone.setter
    def time_t_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_t_zone", value)

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeTimedArgs']]]]:
        """
        Time parameters for scheduled execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "timeds")

    @timeds.setter
    def timeds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpAccessControlV2JobDateTimeTimedArgs']]]]):
        pulumi.set(self, "timeds", value)


if not MYPY:
    class IpAccessControlV2JobDateTimeCronArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Days in each month for execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time

        Note: This field may return null, indicating that no valid values can be obtained.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time

        Note: This field may return null, indicating that no valid values can be obtained.
        """
        w_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Days of each week for execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    IpAccessControlV2JobDateTimeCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpAccessControlV2JobDateTimeCronArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 w_days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days: Days in each month for execution
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] end_time: End time
               
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.str] start_time: Start time
               
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] w_days: Days of each week for execution
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Days in each month for execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time

        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time

        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Days of each week for execution
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "w_days")

    @w_days.setter
    def w_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "w_days", value)


if not MYPY:
    class IpAccessControlV2JobDateTimeTimedArgsDict(TypedDict):
        end_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        End timestamp, in seconds
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        start_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Start timestamp, in seconds
        Note: This field may return null, indicating that no valid values can be obtained.
        """
elif False:
    IpAccessControlV2JobDateTimeTimedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpAccessControlV2JobDateTimeTimedArgs:
    def __init__(__self__, *,
                 end_date_time: Optional[pulumi.Input[_builtins.int]] = None,
                 start_date_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end_date_time: End timestamp, in seconds
               Note: This field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[_builtins.int] start_date_time: Start timestamp, in seconds
               Note: This field may return null, indicating that no valid values can be obtained.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        End timestamp, in seconds
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_date_time", value)

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Start timestamp, in seconds
        Note: This field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_date_time", value)


if not MYPY:
    class LogPostCkafkaFlowWriteConfigArgsDict(TypedDict):
        enable_body: NotRequired[pulumi.Input[_builtins.int]]
        """
        1: Enable 0: Do not enable.
        """
        enable_bot: NotRequired[pulumi.Input[_builtins.int]]
        """
        1: Enable 0: Do not enable.
        """
        enable_headers: NotRequired[pulumi.Input[_builtins.int]]
        """
        1: Enable 0: Do not enable.
        """
elif False:
    LogPostCkafkaFlowWriteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogPostCkafkaFlowWriteConfigArgs:
    def __init__(__self__, *,
                 enable_body: Optional[pulumi.Input[_builtins.int]] = None,
                 enable_bot: Optional[pulumi.Input[_builtins.int]] = None,
                 enable_headers: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] enable_body: 1: Enable 0: Do not enable.
        :param pulumi.Input[_builtins.int] enable_bot: 1: Enable 0: Do not enable.
        :param pulumi.Input[_builtins.int] enable_headers: 1: Enable 0: Do not enable.
        """
        if enable_body is not None:
            pulumi.set(__self__, "enable_body", enable_body)
        if enable_bot is not None:
            pulumi.set(__self__, "enable_bot", enable_bot)
        if enable_headers is not None:
            pulumi.set(__self__, "enable_headers", enable_headers)

    @_builtins.property
    @pulumi.getter(name="enableBody")
    def enable_body(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        1: Enable 0: Do not enable.
        """
        return pulumi.get(self, "enable_body")

    @enable_body.setter
    def enable_body(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "enable_body", value)

    @_builtins.property
    @pulumi.getter(name="enableBot")
    def enable_bot(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        1: Enable 0: Do not enable.
        """
        return pulumi.get(self, "enable_bot")

    @enable_bot.setter
    def enable_bot(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "enable_bot", value)

    @_builtins.property
    @pulumi.getter(name="enableHeaders")
    def enable_headers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        1: Enable 0: Do not enable.
        """
        return pulumi.get(self, "enable_headers")

    @enable_headers.setter
    def enable_headers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "enable_headers", value)


if not MYPY:
    class OwaspWhiteRuleJobDateTimeArgsDict(TypedDict):
        crons: NotRequired[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeCronArgsDict']]]]
        """
        Time parameter for periodic execution.
        """
        time_t_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time zone.
        """
        timeds: NotRequired[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeTimedArgsDict']]]]
        """
        Time parameter for scheduled execution.
        """
elif False:
    OwaspWhiteRuleJobDateTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OwaspWhiteRuleJobDateTimeArgs:
    def __init__(__self__, *,
                 crons: Optional[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeCronArgs']]]] = None,
                 time_t_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 timeds: Optional[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeTimedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeCronArgs']]] crons: Time parameter for periodic execution.
        :param pulumi.Input[_builtins.str] time_t_zone: Specifies the time zone.
        :param pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeTimedArgs']]] timeds: Time parameter for scheduled execution.
        """
        if crons is not None:
            pulumi.set(__self__, "crons", crons)
        if time_t_zone is not None:
            pulumi.set(__self__, "time_t_zone", time_t_zone)
        if timeds is not None:
            pulumi.set(__self__, "timeds", timeds)

    @_builtins.property
    @pulumi.getter
    def crons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeCronArgs']]]]:
        """
        Time parameter for periodic execution.
        """
        return pulumi.get(self, "crons")

    @crons.setter
    def crons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeCronArgs']]]]):
        pulumi.set(self, "crons", value)

    @_builtins.property
    @pulumi.getter(name="timeTZone")
    def time_t_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time zone.
        """
        return pulumi.get(self, "time_t_zone")

    @time_t_zone.setter
    def time_t_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_t_zone", value)

    @_builtins.property
    @pulumi.getter
    def timeds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeTimedArgs']]]]:
        """
        Time parameter for scheduled execution.
        """
        return pulumi.get(self, "timeds")

    @timeds.setter
    def timeds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OwaspWhiteRuleJobDateTimeTimedArgs']]]]):
        pulumi.set(self, "timeds", value)


if not MYPY:
    class OwaspWhiteRuleJobDateTimeCronArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Execution day of each month.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time.
        """
        w_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Execution day of each week.
        """
elif False:
    OwaspWhiteRuleJobDateTimeCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OwaspWhiteRuleJobDateTimeCronArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 w_days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] days: Execution day of each month.
        :param pulumi.Input[_builtins.str] end_time: End time.
        :param pulumi.Input[_builtins.str] start_time: Start time.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] w_days: Execution day of each week.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if w_days is not None:
            pulumi.set(__self__, "w_days", w_days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Execution day of each month.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="wDays")
    def w_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Execution day of each week.
        """
        return pulumi.get(self, "w_days")

    @w_days.setter
    def w_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "w_days", value)


if not MYPY:
    class OwaspWhiteRuleJobDateTimeTimedArgsDict(TypedDict):
        end_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        End timestamp, in seconds.
        """
        start_date_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Start timestamp, in seconds.
        """
elif False:
    OwaspWhiteRuleJobDateTimeTimedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OwaspWhiteRuleJobDateTimeTimedArgs:
    def __init__(__self__, *,
                 end_date_time: Optional[pulumi.Input[_builtins.int]] = None,
                 start_date_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end_date_time: End timestamp, in seconds.
        :param pulumi.Input[_builtins.int] start_date_time: Start timestamp, in seconds.
        """
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @_builtins.property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        End timestamp, in seconds.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_date_time", value)

    @_builtins.property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Start timestamp, in seconds.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_date_time", value)


if not MYPY:
    class OwaspWhiteRuleStrategyArgsDict(TypedDict):
        arg: pulumi.Input[_builtins.str]
        """
        Specifies the matching parameter.

        Configuration parameters are divided into two data types: parameter not supported and support parameters.
        When the match field is one of the following four, the matching parameter can be entered, otherwise not supported.
        GET (get parameter value).
        POST (post parameter value).
        ARGS_COOKIE (COOKIE parameter value).
        ARGS_HEADER (HEADER parameter value).
        """
        compare_func: pulumi.Input[_builtins.str]
        """
        Specifies the logic symbol. 

        Logical symbols are divided into the following types:.
        Empty (content is empty).
        null (not found).
        Eq (equal to).
        neq (not equal to).
        contains (contain).
        ncontains (do not contain).
        strprefix (prefix matching).
        strsuffix (suffix matching).
        Len_eq (length equals to).
        Len_gt (length greater than).
        Len_lt (length less than).
        ipmatch (belong).
        ipnmatch (not_in).
        numgt (value greater than).
        NumValue smaller than].
        Value equal to.
        numneq (value not equal to).
        numle (less than or equal to).
        numge (value is greater than or equal to).
        geo_in (IP geographic belong).
        geo_not_in (IP geographic not_in).
        Specifies different logical operators for matching fields. for details, see the matching field table above.
        """
        content: pulumi.Input[_builtins.str]
        """
        Specifies the match content.

        Currently, when the match field is COOKIE (COOKIE), match content is not required. all others are needed.
        """
        field: pulumi.Input[_builtins.str]
        """
        Specifies the matching field.

        Different matching fields result in different matching parameters, logical operators, and matching contents. the details are as follows:.
        <table><thead><tr><th>Matching Field</th> <th>Matching Parameter</th> <th>Logical Symbol</th> <th>Matching Content</th></tr></thead> <tbody><tr><td>IP (source IP)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr> <tr><td>IPv6 (source IPv6)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>A single IPv6 address is supported.</td></tr> <tr><td>Referer (referer)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content, with a maximum of 512 characters.</td></tr> <tr><td>URL (request path)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is
        less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content starting with /, with a maximum of 512 characters.</td></tr> <tr><td>UserAgent (UserAgent)</td> <td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>HTTP_METHOD (HTTP request method)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)</td> <td>Enter the method name. The uppercase is recommended.</td></tr> <tr><td>QUERY_STRING (request string)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET (GET parameter value)</td> <td>Parameter entry is supported.</td> <td>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_PARAMS_NAMES (GET parameter name)</td> <td>Parameters are not supported.</td> <td>exist (Parameter exists.)<br/>nexist (Parameter does not exist.)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST (POST parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_POST_NAMES (POST parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST_BODY (complete body)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr> <tr><td>COOKIE (cookie)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>rematch (regular expression matching)</td> <td><font color="Red">Unsupported currently</font></td></tr> <tr><td>GET_COOKIES_NAMES (cookie parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>ARGS_COOKIE (cookie parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content512 characters limit</td></tr><tr><td>GET_HEADERS_NAMES (Header parameter name)</td><td>parameter not supported</td><td>exsit (parameter exists)<br/>nexsit (parameter does not exist)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, lowercase is recommended, up to 512 characters</td></tr><tr><td>ARGS_Header (Header parameter value)</td><td>support parameter entry</td><td>contains (include)<br/>ncontains (does not include)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, up to 512 characters</td></tr><tr><td>CONTENT_LENGTH (CONTENT-LENGTH)</td><td>support parameter entry</td><td>numgt (value greater than)<br/>numlt (value smaller than)<br/>numeq (value equal to)<br/></td><td>enter an integer between 0-9999999999999</td></tr><tr><td>IP_GEO (source IP geolocation)</td><td>support parameter entry</td><td>GEO_in (belong)<br/>GEO_not_in (not_in)<br/></td><td>enter CONTENT, up to 10240 characters, format: serialized JSON, format: [{"Country":"china","Region":"guangdong","City":"shenzhen"}]</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter RISK level value, value range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA DEVICE RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter DEVICE RISK code, valid values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA RISK assessment SCORE)</td><td>parameter not supported</td><td>numeq (value equal to)<br/>numgt (value greater than)<br/>numlt (value smaller than)<br/>numle (less than or equal to)<br/>numge (value is greater than or equal to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter assessment SCORE, value range 0-100</td></tr>.
        </tbody></table>.
        """
        case_not_sensitive: NotRequired[pulumi.Input[_builtins.int]]
        """
        Case-Sensitive.
        Case-Insensitive.
        """
elif False:
    OwaspWhiteRuleStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OwaspWhiteRuleStrategyArgs:
    def __init__(__self__, *,
                 arg: pulumi.Input[_builtins.str],
                 compare_func: pulumi.Input[_builtins.str],
                 content: pulumi.Input[_builtins.str],
                 field: pulumi.Input[_builtins.str],
                 case_not_sensitive: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] arg: Specifies the matching parameter.
               
               Configuration parameters are divided into two data types: parameter not supported and support parameters.
               When the match field is one of the following four, the matching parameter can be entered, otherwise not supported.
               GET (get parameter value).
               POST (post parameter value).
               ARGS_COOKIE (COOKIE parameter value).
               ARGS_HEADER (HEADER parameter value).
        :param pulumi.Input[_builtins.str] compare_func: Specifies the logic symbol. 
               
               Logical symbols are divided into the following types:.
               Empty (content is empty).
               null (not found).
               Eq (equal to).
               neq (not equal to).
               contains (contain).
               ncontains (do not contain).
               strprefix (prefix matching).
               strsuffix (suffix matching).
               Len_eq (length equals to).
               Len_gt (length greater than).
               Len_lt (length less than).
               ipmatch (belong).
               ipnmatch (not_in).
               numgt (value greater than).
               NumValue smaller than].
               Value equal to.
               numneq (value not equal to).
               numle (less than or equal to).
               numge (value is greater than or equal to).
               geo_in (IP geographic belong).
               geo_not_in (IP geographic not_in).
               Specifies different logical operators for matching fields. for details, see the matching field table above.
        :param pulumi.Input[_builtins.str] content: Specifies the match content.
               
               Currently, when the match field is COOKIE (COOKIE), match content is not required. all others are needed.
        :param pulumi.Input[_builtins.str] field: Specifies the matching field.
               
               Different matching fields result in different matching parameters, logical operators, and matching contents. the details are as follows:.
               <table><thead><tr><th>Matching Field</th> <th>Matching Parameter</th> <th>Logical Symbol</th> <th>Matching Content</th></tr></thead> <tbody><tr><td>IP (source IP)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr> <tr><td>IPv6 (source IPv6)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>A single IPv6 address is supported.</td></tr> <tr><td>Referer (referer)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content, with a maximum of 512 characters.</td></tr> <tr><td>URL (request path)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is
               less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content starting with /, with a maximum of 512 characters.</td></tr> <tr><td>UserAgent (UserAgent)</td> <td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>HTTP_METHOD (HTTP request method)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)</td> <td>Enter the method name. The uppercase is recommended.</td></tr> <tr><td>QUERY_STRING (request string)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET (GET parameter value)</td> <td>Parameter entry is supported.</td> <td>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_PARAMS_NAMES (GET parameter name)</td> <td>Parameters are not supported.</td> <td>exist (Parameter exists.)<br/>nexist (Parameter does not exist.)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST (POST parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_POST_NAMES (POST parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST_BODY (complete body)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr> <tr><td>COOKIE (cookie)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>rematch (regular expression matching)</td> <td><font color="Red">Unsupported currently</font></td></tr> <tr><td>GET_COOKIES_NAMES (cookie parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>ARGS_COOKIE (cookie parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content512 characters limit</td></tr><tr><td>GET_HEADERS_NAMES (Header parameter name)</td><td>parameter not supported</td><td>exsit (parameter exists)<br/>nexsit (parameter does not exist)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, lowercase is recommended, up to 512 characters</td></tr><tr><td>ARGS_Header (Header parameter value)</td><td>support parameter entry</td><td>contains (include)<br/>ncontains (does not include)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, up to 512 characters</td></tr><tr><td>CONTENT_LENGTH (CONTENT-LENGTH)</td><td>support parameter entry</td><td>numgt (value greater than)<br/>numlt (value smaller than)<br/>numeq (value equal to)<br/></td><td>enter an integer between 0-9999999999999</td></tr><tr><td>IP_GEO (source IP geolocation)</td><td>support parameter entry</td><td>GEO_in (belong)<br/>GEO_not_in (not_in)<br/></td><td>enter CONTENT, up to 10240 characters, format: serialized JSON, format: [{"Country":"china","Region":"guangdong","City":"shenzhen"}]</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter RISK level value, value range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA DEVICE RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter DEVICE RISK code, valid values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA RISK assessment SCORE)</td><td>parameter not supported</td><td>numeq (value equal to)<br/>numgt (value greater than)<br/>numlt (value smaller than)<br/>numle (less than or equal to)<br/>numge (value is greater than or equal to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter assessment SCORE, value range 0-100</td></tr>.
               </tbody></table>.
        :param pulumi.Input[_builtins.int] case_not_sensitive: Case-Sensitive.
               Case-Insensitive.
        """
        pulumi.set(__self__, "arg", arg)
        pulumi.set(__self__, "compare_func", compare_func)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)
        if case_not_sensitive is not None:
            pulumi.set(__self__, "case_not_sensitive", case_not_sensitive)

    @_builtins.property
    @pulumi.getter
    def arg(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the matching parameter.

        Configuration parameters are divided into two data types: parameter not supported and support parameters.
        When the match field is one of the following four, the matching parameter can be entered, otherwise not supported.
        GET (get parameter value).
        POST (post parameter value).
        ARGS_COOKIE (COOKIE parameter value).
        ARGS_HEADER (HEADER parameter value).
        """
        return pulumi.get(self, "arg")

    @arg.setter
    def arg(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arg", value)

    @_builtins.property
    @pulumi.getter(name="compareFunc")
    def compare_func(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the logic symbol. 

        Logical symbols are divided into the following types:.
        Empty (content is empty).
        null (not found).
        Eq (equal to).
        neq (not equal to).
        contains (contain).
        ncontains (do not contain).
        strprefix (prefix matching).
        strsuffix (suffix matching).
        Len_eq (length equals to).
        Len_gt (length greater than).
        Len_lt (length less than).
        ipmatch (belong).
        ipnmatch (not_in).
        numgt (value greater than).
        NumValue smaller than].
        Value equal to.
        numneq (value not equal to).
        numle (less than or equal to).
        numge (value is greater than or equal to).
        geo_in (IP geographic belong).
        geo_not_in (IP geographic not_in).
        Specifies different logical operators for matching fields. for details, see the matching field table above.
        """
        return pulumi.get(self, "compare_func")

    @compare_func.setter
    def compare_func(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compare_func", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match content.

        Currently, when the match field is COOKIE (COOKIE), match content is not required. all others are needed.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the matching field.

        Different matching fields result in different matching parameters, logical operators, and matching contents. the details are as follows:.
        <table><thead><tr><th>Matching Field</th> <th>Matching Parameter</th> <th>Logical Symbol</th> <th>Matching Content</th></tr></thead> <tbody><tr><td>IP (source IP)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>Multiple IP addresses are separated by commas. A maximum of 20 IP addresses are allowed.</td></tr> <tr><td>IPv6 (source IPv6)</td> <td>Parameters are not supported.</td> <td>ipmatch (match)<br/>ipnmatch (mismatch)</td> <td>A single IPv6 address is supported.</td></tr> <tr><td>Referer (referer)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content, with a maximum of 512 characters.</td></tr> <tr><td>URL (request path)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)<br/>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is
        less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td> <td>Enter the content starting with /, with a maximum of 512 characters.</td></tr> <tr><td>UserAgent (UserAgent)</td> <td>Parameters are not supported.</td><td>Same logical symbols as the matching field <font color="Red">Referer</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>HTTP_METHOD (HTTP request method)</td> <td>Parameters are not supported.</td> <td>eq (equal to)<br/>neq (not equal to)</td> <td>Enter the method name. The uppercase is recommended.</td></tr> <tr><td>QUERY_STRING (request string)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET (GET parameter value)</td> <td>Parameter entry is supported.</td> <td>contains (contain)<br/>ncontains (do not contain)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_PARAMS_NAMES (GET parameter name)</td> <td>Parameters are not supported.</td> <td>exist (Parameter exists.)<br/>nexist (Parameter does not exist.)<br/>len_eq (length equals to)<br/>len_gt (length is greater than)<br/>len_lt (length is less than)<br/>strprefix (prefix matching)<br/>strsuffix (suffix matching)</td><td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST (POST parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>GET_POST_NAMES (POST parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>POST_BODY (complete body)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">Request Path</font></td><td>Enter the body content with a maximum of 512 characters.</td></tr> <tr><td>COOKIE (cookie)</td> <td>Parameters are not supported.</td> <td>empty (Content is empty.)<br/>null (do not exist)<br/>rematch (regular expression matching)</td> <td><font color="Red">Unsupported currently</font></td></tr> <tr><td>GET_COOKIES_NAMES (cookie parameter name)</td> <td>Parameters are not supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Name</font></td> <td>Enter the content with a maximum of 512 characters.</td></tr> <tr><td>ARGS_COOKIE (cookie parameter value)</td> <td>Parameter entry is supported.</td> <td>Same logical symbol as the matching field <font color="Red">GET Parameter Value</font></td> <td>Enter the content512 characters limit</td></tr><tr><td>GET_HEADERS_NAMES (Header parameter name)</td><td>parameter not supported</td><td>exsit (parameter exists)<br/>nexsit (parameter does not exist)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, lowercase is recommended, up to 512 characters</td></tr><tr><td>ARGS_Header (Header parameter value)</td><td>support parameter entry</td><td>contains (include)<br/>ncontains (does not include)<br/>len_eq (LENGTH equal)<br/>len_gt (LENGTH greater than)<br/>len_lt (LENGTH less than)<br/>strprefix (prefix match)<br/>strsuffix (suffix matching)<br/>rematch (regular expression matching)</td><td>enter CONTENT, up to 512 characters</td></tr><tr><td>CONTENT_LENGTH (CONTENT-LENGTH)</td><td>support parameter entry</td><td>numgt (value greater than)<br/>numlt (value smaller than)<br/>numeq (value equal to)<br/></td><td>enter an integer between 0-9999999999999</td></tr><tr><td>IP_GEO (source IP geolocation)</td><td>support parameter entry</td><td>GEO_in (belong)<br/>GEO_not_in (not_in)<br/></td><td>enter CONTENT, up to 10240 characters, format: serialized JSON, format: [{"Country":"china","Region":"guangdong","City":"shenzhen"}]</td></tr><tr><td>CAPTCHA_RISK (CAPTCHA RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter RISK level value, value range 0-255</td></tr><tr><td>CAPTCHA_DEVICE_RISK (CAPTCHA DEVICE RISK)</td><td>parameter not supported</td><td>eq (equal)<br/>neq (not equal to)<br/>belong (belong)<br/>not_belong (not belong to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter DEVICE RISK code, valid values: 101, 201, 301, 401, 501, 601, 701</td></tr><tr><td>CAPTCHAR_SCORE (CAPTCHA RISK assessment SCORE)</td><td>parameter not supported</td><td>numeq (value equal to)<br/>numgt (value greater than)<br/>numlt (value smaller than)<br/>numle (less than or equal to)<br/>numge (value is greater than or equal to)<br/>null (nonexistent)<br/>exist (exist)</td><td>enter assessment SCORE, value range 0-100</td></tr>.
        </tbody></table>.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="caseNotSensitive")
    def case_not_sensitive(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Case-Sensitive.
        Case-Insensitive.
        """
        return pulumi.get(self, "case_not_sensitive")

    @case_not_sensitive.setter
    def case_not_sensitive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "case_not_sensitive", value)


if not MYPY:
    class SaasDomainPortArgsDict(TypedDict):
        port: pulumi.Input[_builtins.str]
        """
        Listening port.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The listening protocol of listening port.
        """
        upstream_port: pulumi.Input[_builtins.str]
        """
        The upstream port for listening port.
        """
        upstream_protocol: pulumi.Input[_builtins.str]
        """
        The upstream protocol for listening port.
        """
        nginx_server_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Nginx server ID.
        """
elif False:
    SaasDomainPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SaasDomainPortArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str],
                 upstream_port: pulumi.Input[_builtins.str],
                 upstream_protocol: pulumi.Input[_builtins.str],
                 nginx_server_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] port: Listening port.
        :param pulumi.Input[_builtins.str] protocol: The listening protocol of listening port.
        :param pulumi.Input[_builtins.str] upstream_port: The upstream port for listening port.
        :param pulumi.Input[_builtins.str] upstream_protocol: The upstream protocol for listening port.
        :param pulumi.Input[_builtins.str] nginx_server_id: Nginx server ID.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "upstream_port", upstream_port)
        pulumi.set(__self__, "upstream_protocol", upstream_protocol)
        if nginx_server_id is not None:
            pulumi.set(__self__, "nginx_server_id", nginx_server_id)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.str]:
        """
        Listening port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The listening protocol of listening port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="upstreamPort")
    def upstream_port(self) -> pulumi.Input[_builtins.str]:
        """
        The upstream port for listening port.
        """
        return pulumi.get(self, "upstream_port")

    @upstream_port.setter
    def upstream_port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "upstream_port", value)

    @_builtins.property
    @pulumi.getter(name="upstreamProtocol")
    def upstream_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The upstream protocol for listening port.
        """
        return pulumi.get(self, "upstream_protocol")

    @upstream_protocol.setter
    def upstream_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "upstream_protocol", value)

    @_builtins.property
    @pulumi.getter(name="nginxServerId")
    def nginx_server_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Nginx server ID.
        """
        return pulumi.get(self, "nginx_server_id")

    @nginx_server_id.setter
    def nginx_server_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nginx_server_id", value)


if not MYPY:
    class GetOwaspRuleTypesFilterArgsDict(TypedDict):
        exact_match: _builtins.bool
        """
        Exact search or not.
        """
        name: _builtins.str
        """
        Field name, used for filtering
        Filter the sub-order number (value) by DealName.
        """
        values: Sequence[_builtins.str]
        """
        Values after filtering.
        """
elif False:
    GetOwaspRuleTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOwaspRuleTypesFilterArgs:
    def __init__(__self__, *,
                 exact_match: _builtins.bool,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.bool exact_match: Exact search or not.
        :param _builtins.str name: Field name, used for filtering
               Filter the sub-order number (value) by DealName.
        :param Sequence[_builtins.str] values: Values after filtering.
        """
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.bool:
        """
        Exact search or not.
        """
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: _builtins.bool):
        pulumi.set(self, "exact_match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field name, used for filtering
        Filter the sub-order number (value) by DealName.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Values after filtering.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetOwaspRulesFilterArgsDict(TypedDict):
        exact_match: _builtins.bool
        """
        Exact search or not.
        """
        name: _builtins.str
        """
        Field name, used for filtering
        Filter the sub-order number (value) by DealName.
        """
        values: Sequence[_builtins.str]
        """
        Values after filtering.
        """
elif False:
    GetOwaspRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOwaspRulesFilterArgs:
    def __init__(__self__, *,
                 exact_match: _builtins.bool,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.bool exact_match: Exact search or not.
        :param _builtins.str name: Field name, used for filtering
               Filter the sub-order number (value) by DealName.
        :param Sequence[_builtins.str] values: Values after filtering.
        """
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.bool:
        """
        Exact search or not.
        """
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: _builtins.bool):
        pulumi.set(self, "exact_match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field name, used for filtering
        Filter the sub-order number (value) by DealName.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Values after filtering.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


