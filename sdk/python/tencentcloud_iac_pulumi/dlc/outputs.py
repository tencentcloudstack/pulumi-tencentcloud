# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AddUsersToWorkGroupAttachmentAddInfo',
    'AttachUserPolicyOperationPolicySet',
    'AttachWorkGroupPolicyOperationPolicySet',
    'BindWorkGroupsToUserAttachmentAddInfo',
    'DataEngineCrontabResumeSuspendStrategy',
    'DataEngineDataEngineConfigPair',
    'DataEngineSessionResourceTemplate',
    'DetachUserPolicyOperationPolicySet',
    'DetachWorkGroupPolicyOperationPolicySet',
    'UpdateRowFilterOperationPolicy',
    'UserDataEngineConfigDataEngineConfigPair',
    'UserDataEngineConfigSessionResourceTemplate',
    'GetCheckDataEngineConfigPairsValidityDataEngineConfigPairResult',
    'GetDescribeDataEngineDataEngineResult',
    'GetDescribeDataEngineDataEngineCrontabResumeSuspendStrategyResult',
    'GetDescribeDataEngineDataEngineNetworkConnectionSetResult',
    'GetDescribeDataEngineDataEngineSessionResourceTemplateResult',
    'GetDescribeDataEngineDataEngineTagListResult',
    'GetDescribeDataEngineEventsEventResult',
    'GetDescribeDataEngineImageVersionsImageParentVersionResult',
    'GetDescribeDataEnginePythonSparkImagesPythonSparkImageResult',
    'GetDescribeUpdatableDataEnginesDataEngineBasicInfoResult',
    'GetDescribeUserInfoFilterResult',
    'GetDescribeUserInfoUserInfoResult',
    'GetDescribeUserInfoUserInfoDataPolicyInfoResult',
    'GetDescribeUserInfoUserInfoDataPolicyInfoPolicySetResult',
    'GetDescribeUserInfoUserInfoEnginePolicyInfoResult',
    'GetDescribeUserInfoUserInfoEnginePolicyInfoPolicySetResult',
    'GetDescribeUserInfoUserInfoRowFilterInfoResult',
    'GetDescribeUserInfoUserInfoRowFilterInfoPolicySetResult',
    'GetDescribeUserInfoUserInfoWorkGroupInfoResult',
    'GetDescribeUserInfoUserInfoWorkGroupInfoWorkGroupSetResult',
    'GetDescribeUserRolesUserRoleResult',
    'GetDescribeUserRolesUserRoleCosPermissionListResult',
    'GetDescribeWorkGroupInfoFilterResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoPolicySetResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoPolicySetResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoPolicySetResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoUserInfoResult',
    'GetDescribeWorkGroupInfoWorkGroupInfoUserInfoUserSetResult',
]

@pulumi.output_type
class AddUsersToWorkGroupAttachmentAddInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userIds":
            suggest = "user_ids"
        elif key == "workGroupId":
            suggest = "work_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddUsersToWorkGroupAttachmentAddInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddUsersToWorkGroupAttachmentAddInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddUsersToWorkGroupAttachmentAddInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_ids: Sequence[str],
                 work_group_id: int):
        """
        :param Sequence[str] user_ids: User id set, matched with CAM side uin.
        :param int work_group_id: Work group id.
        """
        pulumi.set(__self__, "user_ids", user_ids)
        pulumi.set(__self__, "work_group_id", work_group_id)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Sequence[str]:
        """
        User id set, matched with CAM side uin.
        """
        return pulumi.get(self, "user_ids")

    @property
    @pulumi.getter(name="workGroupId")
    def work_group_id(self) -> int:
        """
        Work group id.
        """
        return pulumi.get(self, "work_group_id")


@pulumi.output_type
class AttachUserPolicyOperationPolicySet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "dataEngine":
            suggest = "data_engine"
        elif key == "policyType":
            suggest = "policy_type"
        elif key == "reAuth":
            suggest = "re_auth"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceName":
            suggest = "source_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttachUserPolicyOperationPolicySet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttachUserPolicyOperationPolicySet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttachUserPolicyOperationPolicySet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog: str,
                 database: str,
                 operation: str,
                 table: str,
                 column: Optional[str] = None,
                 create_time: Optional[str] = None,
                 data_engine: Optional[str] = None,
                 function: Optional[str] = None,
                 id: Optional[int] = None,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 policy_type: Optional[str] = None,
                 re_auth: Optional[bool] = None,
                 source: Optional[str] = None,
                 source_id: Optional[int] = None,
                 source_name: Optional[str] = None,
                 view: Optional[str] = None):
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "table", table)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_engine is not None:
            pulumi.set(__self__, "data_engine", data_engine)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if re_auth is not None:
            pulumi.set(__self__, "re_auth", re_auth)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def table(self) -> str:
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> Optional[str]:
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> Optional[bool]:
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[int]:
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[str]:
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class AttachWorkGroupPolicyOperationPolicySet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "dataEngine":
            suggest = "data_engine"
        elif key == "policyType":
            suggest = "policy_type"
        elif key == "reAuth":
            suggest = "re_auth"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceName":
            suggest = "source_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttachWorkGroupPolicyOperationPolicySet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttachWorkGroupPolicyOperationPolicySet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttachWorkGroupPolicyOperationPolicySet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog: str,
                 database: str,
                 operation: str,
                 table: str,
                 column: Optional[str] = None,
                 create_time: Optional[str] = None,
                 data_engine: Optional[str] = None,
                 function: Optional[str] = None,
                 id: Optional[int] = None,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 policy_type: Optional[str] = None,
                 re_auth: Optional[bool] = None,
                 source: Optional[str] = None,
                 source_id: Optional[int] = None,
                 source_name: Optional[str] = None,
                 view: Optional[str] = None):
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "table", table)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_engine is not None:
            pulumi.set(__self__, "data_engine", data_engine)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if re_auth is not None:
            pulumi.set(__self__, "re_auth", re_auth)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def table(self) -> str:
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> Optional[str]:
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> Optional[bool]:
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[int]:
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[str]:
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class BindWorkGroupsToUserAttachmentAddInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userId":
            suggest = "user_id"
        elif key == "workGroupIds":
            suggest = "work_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BindWorkGroupsToUserAttachmentAddInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BindWorkGroupsToUserAttachmentAddInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BindWorkGroupsToUserAttachmentAddInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_id: str,
                 work_group_ids: Sequence[int]):
        """
        :param str user_id: User id, matched with CAM side uin.
        :param Sequence[int] work_group_ids: Work group id set.
        """
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "work_group_ids", work_group_ids)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        User id, matched with CAM side uin.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="workGroupIds")
    def work_group_ids(self) -> Sequence[int]:
        """
        Work group id set.
        """
        return pulumi.get(self, "work_group_ids")


@pulumi.output_type
class DataEngineCrontabResumeSuspendStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resumeTime":
            suggest = "resume_time"
        elif key == "suspendStrategy":
            suggest = "suspend_strategy"
        elif key == "suspendTime":
            suggest = "suspend_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataEngineCrontabResumeSuspendStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataEngineCrontabResumeSuspendStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataEngineCrontabResumeSuspendStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resume_time: Optional[str] = None,
                 suspend_strategy: Optional[int] = None,
                 suspend_time: Optional[str] = None):
        """
        :param str resume_time: Scheduled pull-up time: For example: 8 o&amp;#39;clock on Monday is expressed as 1000000-08:00:00.
        :param int suspend_strategy: Suspend configuration: 0 (default): wait for the task to end before suspending, 1: force suspend.
        :param str suspend_time: Scheduled suspension time: For example: 20 o&amp;#39;clock on Monday is expressed as 1000000-20:00:00.
        """
        if resume_time is not None:
            pulumi.set(__self__, "resume_time", resume_time)
        if suspend_strategy is not None:
            pulumi.set(__self__, "suspend_strategy", suspend_strategy)
        if suspend_time is not None:
            pulumi.set(__self__, "suspend_time", suspend_time)

    @property
    @pulumi.getter(name="resumeTime")
    def resume_time(self) -> Optional[str]:
        """
        Scheduled pull-up time: For example: 8 o&amp;#39;clock on Monday is expressed as 1000000-08:00:00.
        """
        return pulumi.get(self, "resume_time")

    @property
    @pulumi.getter(name="suspendStrategy")
    def suspend_strategy(self) -> Optional[int]:
        """
        Suspend configuration: 0 (default): wait for the task to end before suspending, 1: force suspend.
        """
        return pulumi.get(self, "suspend_strategy")

    @property
    @pulumi.getter(name="suspendTime")
    def suspend_time(self) -> Optional[str]:
        """
        Scheduled suspension time: For example: 20 o&amp;#39;clock on Monday is expressed as 1000000-20:00:00.
        """
        return pulumi.get(self, "suspend_time")


@pulumi.output_type
class DataEngineDataEngineConfigPair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configItem":
            suggest = "config_item"
        elif key == "configValue":
            suggest = "config_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataEngineDataEngineConfigPair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataEngineDataEngineConfigPair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataEngineDataEngineConfigPair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_item: str,
                 config_value: str):
        """
        :param str config_item: Configuration items.
        :param str config_value: Configuration value.
        """
        pulumi.set(__self__, "config_item", config_item)
        pulumi.set(__self__, "config_value", config_value)

    @property
    @pulumi.getter(name="configItem")
    def config_item(self) -> str:
        """
        Configuration items.
        """
        return pulumi.get(self, "config_item")

    @property
    @pulumi.getter(name="configValue")
    def config_value(self) -> str:
        """
        Configuration value.
        """
        return pulumi.get(self, "config_value")


@pulumi.output_type
class DataEngineSessionResourceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driverSize":
            suggest = "driver_size"
        elif key == "executorMaxNumbers":
            suggest = "executor_max_numbers"
        elif key == "executorNums":
            suggest = "executor_nums"
        elif key == "executorSize":
            suggest = "executor_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataEngineSessionResourceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataEngineSessionResourceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataEngineSessionResourceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver_size: Optional[str] = None,
                 executor_max_numbers: Optional[int] = None,
                 executor_nums: Optional[int] = None,
                 executor_size: Optional[str] = None):
        """
        :param str driver_size: Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        :param int executor_max_numbers: Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
        :param int executor_nums: Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
        :param str executor_size: Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        if driver_size is not None:
            pulumi.set(__self__, "driver_size", driver_size)
        if executor_max_numbers is not None:
            pulumi.set(__self__, "executor_max_numbers", executor_max_numbers)
        if executor_nums is not None:
            pulumi.set(__self__, "executor_nums", executor_nums)
        if executor_size is not None:
            pulumi.set(__self__, "executor_size", executor_size)

    @property
    @pulumi.getter(name="driverSize")
    def driver_size(self) -> Optional[str]:
        """
        Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        return pulumi.get(self, "driver_size")

    @property
    @pulumi.getter(name="executorMaxNumbers")
    def executor_max_numbers(self) -> Optional[int]:
        """
        Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
        """
        return pulumi.get(self, "executor_max_numbers")

    @property
    @pulumi.getter(name="executorNums")
    def executor_nums(self) -> Optional[int]:
        """
        Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
        """
        return pulumi.get(self, "executor_nums")

    @property
    @pulumi.getter(name="executorSize")
    def executor_size(self) -> Optional[str]:
        """
        Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        return pulumi.get(self, "executor_size")


@pulumi.output_type
class DetachUserPolicyOperationPolicySet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "dataEngine":
            suggest = "data_engine"
        elif key == "policyType":
            suggest = "policy_type"
        elif key == "reAuth":
            suggest = "re_auth"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceName":
            suggest = "source_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetachUserPolicyOperationPolicySet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetachUserPolicyOperationPolicySet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetachUserPolicyOperationPolicySet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog: str,
                 database: str,
                 operation: str,
                 table: str,
                 column: Optional[str] = None,
                 create_time: Optional[str] = None,
                 data_engine: Optional[str] = None,
                 function: Optional[str] = None,
                 id: Optional[int] = None,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 policy_type: Optional[str] = None,
                 re_auth: Optional[bool] = None,
                 source: Optional[str] = None,
                 source_id: Optional[int] = None,
                 source_name: Optional[str] = None,
                 view: Optional[str] = None):
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "table", table)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_engine is not None:
            pulumi.set(__self__, "data_engine", data_engine)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if re_auth is not None:
            pulumi.set(__self__, "re_auth", re_auth)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def table(self) -> str:
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> Optional[str]:
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> Optional[bool]:
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[int]:
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[str]:
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class DetachWorkGroupPolicyOperationPolicySet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "dataEngine":
            suggest = "data_engine"
        elif key == "policyType":
            suggest = "policy_type"
        elif key == "reAuth":
            suggest = "re_auth"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceName":
            suggest = "source_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetachWorkGroupPolicyOperationPolicySet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetachWorkGroupPolicyOperationPolicySet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetachWorkGroupPolicyOperationPolicySet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog: str,
                 database: str,
                 operation: str,
                 table: str,
                 column: Optional[str] = None,
                 create_time: Optional[str] = None,
                 data_engine: Optional[str] = None,
                 function: Optional[str] = None,
                 id: Optional[int] = None,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 policy_type: Optional[str] = None,
                 re_auth: Optional[bool] = None,
                 source: Optional[str] = None,
                 source_id: Optional[int] = None,
                 source_name: Optional[str] = None,
                 view: Optional[str] = None):
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "table", table)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_engine is not None:
            pulumi.set(__self__, "data_engine", data_engine)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if re_auth is not None:
            pulumi.set(__self__, "re_auth", re_auth)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def table(self) -> str:
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> Optional[str]:
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> Optional[bool]:
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[int]:
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[str]:
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class UpdateRowFilterOperationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "dataEngine":
            suggest = "data_engine"
        elif key == "policyType":
            suggest = "policy_type"
        elif key == "reAuth":
            suggest = "re_auth"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceName":
            suggest = "source_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateRowFilterOperationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateRowFilterOperationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateRowFilterOperationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog: str,
                 database: str,
                 operation: str,
                 table: str,
                 column: Optional[str] = None,
                 create_time: Optional[str] = None,
                 data_engine: Optional[str] = None,
                 function: Optional[str] = None,
                 id: Optional[int] = None,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 policy_type: Optional[str] = None,
                 re_auth: Optional[bool] = None,
                 source: Optional[str] = None,
                 source_id: Optional[int] = None,
                 source_name: Optional[str] = None,
                 view: Optional[str] = None):
        """
        :param str catalog: For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        :param str database: Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        :param str operation: Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        :param str table: For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        :param str column: For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        :param str create_time: The time when the permission was created. Leave the input parameter blank.
        :param str data_engine: Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        :param str function: For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        :param int id: Policy id.
        :param str mode: Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        :param str operator: Operator, do not fill in the input parameters.
        :param str policy_type: Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        :param bool re_auth: Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        :param str source: Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        :param int source_id: The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        :param str source_name: The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        :param str view: For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "table", table)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_engine is not None:
            pulumi.set(__self__, "data_engine", data_engine)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if re_auth is not None:
            pulumi.set(__self__, "re_auth", re_auth)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        """
        The time when the permission was created. Leave the input parameter blank.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> Optional[str]:
        """
        Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        """
        For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Policy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator, do not fill in the input parameters.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        """
        Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> Optional[bool]:
        """
        Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        """
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[int]:
        """
        The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[str]:
        """
        The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        """
        For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class UserDataEngineConfigDataEngineConfigPair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configItem":
            suggest = "config_item"
        elif key == "configValue":
            suggest = "config_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDataEngineConfigDataEngineConfigPair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDataEngineConfigDataEngineConfigPair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDataEngineConfigDataEngineConfigPair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_item: str,
                 config_value: str):
        """
        :param str config_item: Config key.
        :param str config_value: Config value.
        """
        pulumi.set(__self__, "config_item", config_item)
        pulumi.set(__self__, "config_value", config_value)

    @property
    @pulumi.getter(name="configItem")
    def config_item(self) -> str:
        """
        Config key.
        """
        return pulumi.get(self, "config_item")

    @property
    @pulumi.getter(name="configValue")
    def config_value(self) -> str:
        """
        Config value.
        """
        return pulumi.get(self, "config_value")


@pulumi.output_type
class UserDataEngineConfigSessionResourceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driverSize":
            suggest = "driver_size"
        elif key == "executorMaxNumbers":
            suggest = "executor_max_numbers"
        elif key == "executorNums":
            suggest = "executor_nums"
        elif key == "executorSize":
            suggest = "executor_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDataEngineConfigSessionResourceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDataEngineConfigSessionResourceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDataEngineConfigSessionResourceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver_size: Optional[str] = None,
                 executor_max_numbers: Optional[int] = None,
                 executor_nums: Optional[int] = None,
                 executor_size: Optional[str] = None):
        """
        :param str driver_size: Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        :param int executor_max_numbers: Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
        :param int executor_nums: Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
        :param str executor_size: Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        if driver_size is not None:
            pulumi.set(__self__, "driver_size", driver_size)
        if executor_max_numbers is not None:
            pulumi.set(__self__, "executor_max_numbers", executor_max_numbers)
        if executor_nums is not None:
            pulumi.set(__self__, "executor_nums", executor_nums)
        if executor_size is not None:
            pulumi.set(__self__, "executor_size", executor_size)

    @property
    @pulumi.getter(name="driverSize")
    def driver_size(self) -> Optional[str]:
        """
        Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        return pulumi.get(self, "driver_size")

    @property
    @pulumi.getter(name="executorMaxNumbers")
    def executor_max_numbers(self) -> Optional[int]:
        """
        Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
        """
        return pulumi.get(self, "executor_max_numbers")

    @property
    @pulumi.getter(name="executorNums")
    def executor_nums(self) -> Optional[int]:
        """
        Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
        """
        return pulumi.get(self, "executor_nums")

    @property
    @pulumi.getter(name="executorSize")
    def executor_size(self) -> Optional[str]:
        """
        Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        return pulumi.get(self, "executor_size")


@pulumi.output_type
class GetCheckDataEngineConfigPairsValidityDataEngineConfigPairResult(dict):
    def __init__(__self__, *,
                 config_item: str,
                 config_value: str):
        """
        :param str config_item: Configuration item.
        :param str config_value: Configuration value.
        """
        pulumi.set(__self__, "config_item", config_item)
        pulumi.set(__self__, "config_value", config_value)

    @property
    @pulumi.getter(name="configItem")
    def config_item(self) -> str:
        """
        Configuration item.
        """
        return pulumi.get(self, "config_item")

    @property
    @pulumi.getter(name="configValue")
    def config_value(self) -> str:
        """
        Configuration value.
        """
        return pulumi.get(self, "config_value")


@pulumi.output_type
class GetDescribeDataEngineDataEngineResult(dict):
    def __init__(__self__, *,
                 auto_resume: bool,
                 auto_suspend: bool,
                 auto_suspend_time: int,
                 child_image_version_id: str,
                 cidr_block: str,
                 cluster_type: str,
                 create_time: int,
                 crontab_resume_suspend: int,
                 crontab_resume_suspend_strategies: Sequence['outputs.GetDescribeDataEngineDataEngineCrontabResumeSuspendStrategyResult'],
                 data_engine_id: str,
                 data_engine_name: str,
                 default_data_engine: bool,
                 default_house: bool,
                 elastic_limit: int,
                 elastic_switch: bool,
                 engine_exec_type: str,
                 engine_type: str,
                 expire_time: str,
                 image_version_id: str,
                 image_version_name: str,
                 isolated_time: str,
                 max_clusters: int,
                 max_concurrency: int,
                 message: str,
                 min_clusters: int,
                 mode: int,
                 network_connection_sets: Sequence['outputs.GetDescribeDataEngineDataEngineNetworkConnectionSetResult'],
                 permissions: Sequence[str],
                 quota_id: str,
                 renew_flag: int,
                 resource_type: str,
                 reversal_time: str,
                 session_resource_templates: Sequence['outputs.GetDescribeDataEngineDataEngineSessionResourceTemplateResult'],
                 size: int,
                 spend_after: int,
                 start_standby_cluster: bool,
                 state: int,
                 sub_account_uin: str,
                 tag_lists: Sequence['outputs.GetDescribeDataEngineDataEngineTagListResult'],
                 tolerable_queue_time: int,
                 ui_url: str,
                 update_time: int,
                 user_alias: str,
                 user_app_id: int,
                 user_uin: str):
        """
        :param bool auto_resume: Whether to automatically start the cluster, prepay not support.
        :param bool auto_suspend: Whether to automatically suspend the cluster, prepay not support.
        :param int auto_suspend_time: Cluster automatic suspension time, default 10 minutes.
        :param str child_image_version_id: Engine Image version id.
        :param str cidr_block: Engine VPC network segment, just like 192.0.2.1/24.
        :param str cluster_type: Engine cluster type, only support: spark_cu/presto_cu.
        :param int create_time: Create time.
        :param int crontab_resume_suspend: Engine crontab resume or suspend strategy, only support: 0: Wait(default), 1: Kill.
        :param Sequence['GetDescribeDataEngineDataEngineCrontabResumeSuspendStrategyArgs'] crontab_resume_suspend_strategies: Engine auto suspend strategy, when AutoSuspend is true, CrontabResumeSuspend must stop.
        :param str data_engine_id: Engine unique id.
        :param str data_engine_name: Engine name.
        :param bool default_data_engine: Whether it is the default virtual cluster.
        :param bool default_house: Is it the default engine?.
        :param int elastic_limit: For spark Batch ExecType, yearly and monthly cluster elastic limit.
        :param bool elastic_switch: For spark Batch ExecType, yearly and monthly cluster whether to enable elasticity.
        :param str engine_exec_type: Engine exec type, only support SQL(default) or BATCH.
        :param str engine_type: Engine type, only support: spark/presto.
        :param str expire_time: Expire time.
        :param str image_version_id: Engine major version id.
        :param str image_version_name: Engine image version name.
        :param str isolated_time: Isolated time.
        :param int max_clusters: Engine max cluster size,  MaxClusters less than or equal to 10 and MaxClusters bigger than MinClusters.
        :param int max_concurrency: Maximum number of concurrent tasks in a single cluster, default 5.
        :param str message: Engine description information.
        :param int min_clusters: Engine min size, greater than or equal to 1 and MaxClusters bigger than MinClusters.
        :param int mode: Engine mode, only support 1: ByAmount, 2: YearlyAndMonthly.
        :param Sequence['GetDescribeDataEngineDataEngineNetworkConnectionSetArgs'] network_connection_sets: Network connection configuration.
        :param Sequence[str] permissions: Engine permissions.
        :param str quota_id: Reference ID.
        :param int renew_flag: Automatic renewal flag, 0, initial state, automatic renewal is not performed by default. If the user has prepaid non-stop service privileges, automatic renewal will occur. 1: Automatic renewal. 2: Make it clear that there will be no automatic renewal.
        :param str resource_type: Engine resource type not match, only support: Standard_CU/Memory_CU(only BATCH ExecType).
        :param str reversal_time: Reversal time.
        :param Sequence['GetDescribeDataEngineDataEngineSessionResourceTemplateArgs'] session_resource_templates: For spark Batch ExecType, cluster session resource configuration template.
        :param int size: Engine size.
        :param int spend_after: Automatic recovery time, prepay not support.
        :param bool start_standby_cluster: Whether to enable the backup cluster.
        :param int state: Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
        :param str sub_account_uin: Operator.
        :param Sequence['GetDescribeDataEngineDataEngineTagListArgs'] tag_lists: Tag list.
        :param int tolerable_queue_time: Tolerable queuing time, default 0. scaling may be triggered when tasks are queued for longer than the tolerable time. if this parameter is 0, it means that capacity expansion may be triggered immediately once a task is queued.
        :param str ui_url: Jump address of ui.
        :param int update_time: Update time.
        :param str user_alias: User&amp;#39;s nickname.
        :param int user_app_id: User appid.
        :param str user_uin: User uin.
        """
        pulumi.set(__self__, "auto_resume", auto_resume)
        pulumi.set(__self__, "auto_suspend", auto_suspend)
        pulumi.set(__self__, "auto_suspend_time", auto_suspend_time)
        pulumi.set(__self__, "child_image_version_id", child_image_version_id)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "crontab_resume_suspend", crontab_resume_suspend)
        pulumi.set(__self__, "crontab_resume_suspend_strategies", crontab_resume_suspend_strategies)
        pulumi.set(__self__, "data_engine_id", data_engine_id)
        pulumi.set(__self__, "data_engine_name", data_engine_name)
        pulumi.set(__self__, "default_data_engine", default_data_engine)
        pulumi.set(__self__, "default_house", default_house)
        pulumi.set(__self__, "elastic_limit", elastic_limit)
        pulumi.set(__self__, "elastic_switch", elastic_switch)
        pulumi.set(__self__, "engine_exec_type", engine_exec_type)
        pulumi.set(__self__, "engine_type", engine_type)
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "image_version_id", image_version_id)
        pulumi.set(__self__, "image_version_name", image_version_name)
        pulumi.set(__self__, "isolated_time", isolated_time)
        pulumi.set(__self__, "max_clusters", max_clusters)
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "min_clusters", min_clusters)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "network_connection_sets", network_connection_sets)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "quota_id", quota_id)
        pulumi.set(__self__, "renew_flag", renew_flag)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "reversal_time", reversal_time)
        pulumi.set(__self__, "session_resource_templates", session_resource_templates)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "spend_after", spend_after)
        pulumi.set(__self__, "start_standby_cluster", start_standby_cluster)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "sub_account_uin", sub_account_uin)
        pulumi.set(__self__, "tag_lists", tag_lists)
        pulumi.set(__self__, "tolerable_queue_time", tolerable_queue_time)
        pulumi.set(__self__, "ui_url", ui_url)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "user_alias", user_alias)
        pulumi.set(__self__, "user_app_id", user_app_id)
        pulumi.set(__self__, "user_uin", user_uin)

    @property
    @pulumi.getter(name="autoResume")
    def auto_resume(self) -> bool:
        """
        Whether to automatically start the cluster, prepay not support.
        """
        return pulumi.get(self, "auto_resume")

    @property
    @pulumi.getter(name="autoSuspend")
    def auto_suspend(self) -> bool:
        """
        Whether to automatically suspend the cluster, prepay not support.
        """
        return pulumi.get(self, "auto_suspend")

    @property
    @pulumi.getter(name="autoSuspendTime")
    def auto_suspend_time(self) -> int:
        """
        Cluster automatic suspension time, default 10 minutes.
        """
        return pulumi.get(self, "auto_suspend_time")

    @property
    @pulumi.getter(name="childImageVersionId")
    def child_image_version_id(self) -> str:
        """
        Engine Image version id.
        """
        return pulumi.get(self, "child_image_version_id")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        Engine VPC network segment, just like 192.0.2.1/24.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Engine cluster type, only support: spark_cu/presto_cu.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> int:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="crontabResumeSuspend")
    def crontab_resume_suspend(self) -> int:
        """
        Engine crontab resume or suspend strategy, only support: 0: Wait(default), 1: Kill.
        """
        return pulumi.get(self, "crontab_resume_suspend")

    @property
    @pulumi.getter(name="crontabResumeSuspendStrategies")
    def crontab_resume_suspend_strategies(self) -> Sequence['outputs.GetDescribeDataEngineDataEngineCrontabResumeSuspendStrategyResult']:
        """
        Engine auto suspend strategy, when AutoSuspend is true, CrontabResumeSuspend must stop.
        """
        return pulumi.get(self, "crontab_resume_suspend_strategies")

    @property
    @pulumi.getter(name="dataEngineId")
    def data_engine_id(self) -> str:
        """
        Engine unique id.
        """
        return pulumi.get(self, "data_engine_id")

    @property
    @pulumi.getter(name="dataEngineName")
    def data_engine_name(self) -> str:
        """
        Engine name.
        """
        return pulumi.get(self, "data_engine_name")

    @property
    @pulumi.getter(name="defaultDataEngine")
    def default_data_engine(self) -> bool:
        """
        Whether it is the default virtual cluster.
        """
        return pulumi.get(self, "default_data_engine")

    @property
    @pulumi.getter(name="defaultHouse")
    def default_house(self) -> bool:
        """
        Is it the default engine?.
        """
        return pulumi.get(self, "default_house")

    @property
    @pulumi.getter(name="elasticLimit")
    def elastic_limit(self) -> int:
        """
        For spark Batch ExecType, yearly and monthly cluster elastic limit.
        """
        return pulumi.get(self, "elastic_limit")

    @property
    @pulumi.getter(name="elasticSwitch")
    def elastic_switch(self) -> bool:
        """
        For spark Batch ExecType, yearly and monthly cluster whether to enable elasticity.
        """
        return pulumi.get(self, "elastic_switch")

    @property
    @pulumi.getter(name="engineExecType")
    def engine_exec_type(self) -> str:
        """
        Engine exec type, only support SQL(default) or BATCH.
        """
        return pulumi.get(self, "engine_exec_type")

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> str:
        """
        Engine type, only support: spark/presto.
        """
        return pulumi.get(self, "engine_type")

    @property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> str:
        """
        Expire time.
        """
        return pulumi.get(self, "expire_time")

    @property
    @pulumi.getter(name="imageVersionId")
    def image_version_id(self) -> str:
        """
        Engine major version id.
        """
        return pulumi.get(self, "image_version_id")

    @property
    @pulumi.getter(name="imageVersionName")
    def image_version_name(self) -> str:
        """
        Engine image version name.
        """
        return pulumi.get(self, "image_version_name")

    @property
    @pulumi.getter(name="isolatedTime")
    def isolated_time(self) -> str:
        """
        Isolated time.
        """
        return pulumi.get(self, "isolated_time")

    @property
    @pulumi.getter(name="maxClusters")
    def max_clusters(self) -> int:
        """
        Engine max cluster size,  MaxClusters less than or equal to 10 and MaxClusters bigger than MinClusters.
        """
        return pulumi.get(self, "max_clusters")

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> int:
        """
        Maximum number of concurrent tasks in a single cluster, default 5.
        """
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Engine description information.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="minClusters")
    def min_clusters(self) -> int:
        """
        Engine min size, greater than or equal to 1 and MaxClusters bigger than MinClusters.
        """
        return pulumi.get(self, "min_clusters")

    @property
    @pulumi.getter
    def mode(self) -> int:
        """
        Engine mode, only support 1: ByAmount, 2: YearlyAndMonthly.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="networkConnectionSets")
    def network_connection_sets(self) -> Sequence['outputs.GetDescribeDataEngineDataEngineNetworkConnectionSetResult']:
        """
        Network connection configuration.
        """
        return pulumi.get(self, "network_connection_sets")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        """
        Engine permissions.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="quotaId")
    def quota_id(self) -> str:
        """
        Reference ID.
        """
        return pulumi.get(self, "quota_id")

    @property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> int:
        """
        Automatic renewal flag, 0, initial state, automatic renewal is not performed by default. If the user has prepaid non-stop service privileges, automatic renewal will occur. 1: Automatic renewal. 2: Make it clear that there will be no automatic renewal.
        """
        return pulumi.get(self, "renew_flag")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Engine resource type not match, only support: Standard_CU/Memory_CU(only BATCH ExecType).
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="reversalTime")
    def reversal_time(self) -> str:
        """
        Reversal time.
        """
        return pulumi.get(self, "reversal_time")

    @property
    @pulumi.getter(name="sessionResourceTemplates")
    def session_resource_templates(self) -> Sequence['outputs.GetDescribeDataEngineDataEngineSessionResourceTemplateResult']:
        """
        For spark Batch ExecType, cluster session resource configuration template.
        """
        return pulumi.get(self, "session_resource_templates")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Engine size.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="spendAfter")
    def spend_after(self) -> int:
        """
        Automatic recovery time, prepay not support.
        """
        return pulumi.get(self, "spend_after")

    @property
    @pulumi.getter(name="startStandbyCluster")
    def start_standby_cluster(self) -> bool:
        """
        Whether to enable the backup cluster.
        """
        return pulumi.get(self, "start_standby_cluster")

    @property
    @pulumi.getter
    def state(self) -> int:
        """
        Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subAccountUin")
    def sub_account_uin(self) -> str:
        """
        Operator.
        """
        return pulumi.get(self, "sub_account_uin")

    @property
    @pulumi.getter(name="tagLists")
    def tag_lists(self) -> Sequence['outputs.GetDescribeDataEngineDataEngineTagListResult']:
        """
        Tag list.
        """
        return pulumi.get(self, "tag_lists")

    @property
    @pulumi.getter(name="tolerableQueueTime")
    def tolerable_queue_time(self) -> int:
        """
        Tolerable queuing time, default 0. scaling may be triggered when tasks are queued for longer than the tolerable time. if this parameter is 0, it means that capacity expansion may be triggered immediately once a task is queued.
        """
        return pulumi.get(self, "tolerable_queue_time")

    @property
    @pulumi.getter(name="uiURL")
    def ui_url(self) -> str:
        """
        Jump address of ui.
        """
        return pulumi.get(self, "ui_url")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> int:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @property
    @pulumi.getter(name="userAlias")
    def user_alias(self) -> str:
        """
        User&amp;#39;s nickname.
        """
        return pulumi.get(self, "user_alias")

    @property
    @pulumi.getter(name="userAppId")
    def user_app_id(self) -> int:
        """
        User appid.
        """
        return pulumi.get(self, "user_app_id")

    @property
    @pulumi.getter(name="userUin")
    def user_uin(self) -> str:
        """
        User uin.
        """
        return pulumi.get(self, "user_uin")


@pulumi.output_type
class GetDescribeDataEngineDataEngineCrontabResumeSuspendStrategyResult(dict):
    def __init__(__self__, *,
                 resume_time: str,
                 suspend_strategy: int,
                 suspend_time: str):
        """
        :param str resume_time: Scheduled pull-up time: For example: 8 o&amp;#39;clock on Monday is expressed as 1000000-08:00:00.
        :param int suspend_strategy: Suspend configuration: 0 (default): wait for the task to end before suspending, 1: force suspend.
        :param str suspend_time: Scheduled suspension time: For example: 20 o&amp;#39;clock on Monday is expressed as 1000000-20:00:00.
        """
        pulumi.set(__self__, "resume_time", resume_time)
        pulumi.set(__self__, "suspend_strategy", suspend_strategy)
        pulumi.set(__self__, "suspend_time", suspend_time)

    @property
    @pulumi.getter(name="resumeTime")
    def resume_time(self) -> str:
        """
        Scheduled pull-up time: For example: 8 o&amp;#39;clock on Monday is expressed as 1000000-08:00:00.
        """
        return pulumi.get(self, "resume_time")

    @property
    @pulumi.getter(name="suspendStrategy")
    def suspend_strategy(self) -> int:
        """
        Suspend configuration: 0 (default): wait for the task to end before suspending, 1: force suspend.
        """
        return pulumi.get(self, "suspend_strategy")

    @property
    @pulumi.getter(name="suspendTime")
    def suspend_time(self) -> str:
        """
        Scheduled suspension time: For example: 20 o&amp;#39;clock on Monday is expressed as 1000000-20:00:00.
        """
        return pulumi.get(self, "suspend_time")


@pulumi.output_type
class GetDescribeDataEngineDataEngineNetworkConnectionSetResult(dict):
    def __init__(__self__, *,
                 appid: int,
                 associate_id: str,
                 create_time: int,
                 datasource_connection_cidr_block: str,
                 datasource_connection_id: str,
                 datasource_connection_name: str,
                 datasource_connection_subnet_cidr_block: str,
                 datasource_connection_subnet_id: str,
                 datasource_connection_vpc_id: str,
                 house_id: str,
                 house_name: str,
                 id: int,
                 network_connection_desc: str,
                 network_connection_type: int,
                 state: int,
                 sub_account_uin: str,
                 uin: str,
                 update_time: int):
        """
        :param int appid: User appid.
        :param str associate_id: Network configuration unique identifier.
        :param int create_time: Create time.
        :param str datasource_connection_cidr_block: Datasource connection cidr block.
        :param str datasource_connection_id: Data source id (obsolete).
        :param str datasource_connection_name: Network configuration name.
        :param str datasource_connection_subnet_cidr_block: Datasource connection subnet cidr block.
        :param str datasource_connection_subnet_id: Datasource subnetId.
        :param str datasource_connection_vpc_id: Datasource vpcid.
        :param str house_id: Data engine id.
        :param str house_name: Data engine name.
        :param int id: Network configuration id.
        :param str network_connection_desc: Network configuration description.
        :param int network_connection_type: Network configuration type.
        :param int state: Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
        :param str sub_account_uin: Operator.
        :param str uin: User uin.
        :param int update_time: Update time.
        """
        pulumi.set(__self__, "appid", appid)
        pulumi.set(__self__, "associate_id", associate_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "datasource_connection_cidr_block", datasource_connection_cidr_block)
        pulumi.set(__self__, "datasource_connection_id", datasource_connection_id)
        pulumi.set(__self__, "datasource_connection_name", datasource_connection_name)
        pulumi.set(__self__, "datasource_connection_subnet_cidr_block", datasource_connection_subnet_cidr_block)
        pulumi.set(__self__, "datasource_connection_subnet_id", datasource_connection_subnet_id)
        pulumi.set(__self__, "datasource_connection_vpc_id", datasource_connection_vpc_id)
        pulumi.set(__self__, "house_id", house_id)
        pulumi.set(__self__, "house_name", house_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "network_connection_desc", network_connection_desc)
        pulumi.set(__self__, "network_connection_type", network_connection_type)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "sub_account_uin", sub_account_uin)
        pulumi.set(__self__, "uin", uin)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def appid(self) -> int:
        """
        User appid.
        """
        return pulumi.get(self, "appid")

    @property
    @pulumi.getter(name="associateId")
    def associate_id(self) -> str:
        """
        Network configuration unique identifier.
        """
        return pulumi.get(self, "associate_id")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> int:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="datasourceConnectionCidrBlock")
    def datasource_connection_cidr_block(self) -> str:
        """
        Datasource connection cidr block.
        """
        return pulumi.get(self, "datasource_connection_cidr_block")

    @property
    @pulumi.getter(name="datasourceConnectionId")
    def datasource_connection_id(self) -> str:
        """
        Data source id (obsolete).
        """
        return pulumi.get(self, "datasource_connection_id")

    @property
    @pulumi.getter(name="datasourceConnectionName")
    def datasource_connection_name(self) -> str:
        """
        Network configuration name.
        """
        return pulumi.get(self, "datasource_connection_name")

    @property
    @pulumi.getter(name="datasourceConnectionSubnetCidrBlock")
    def datasource_connection_subnet_cidr_block(self) -> str:
        """
        Datasource connection subnet cidr block.
        """
        return pulumi.get(self, "datasource_connection_subnet_cidr_block")

    @property
    @pulumi.getter(name="datasourceConnectionSubnetId")
    def datasource_connection_subnet_id(self) -> str:
        """
        Datasource subnetId.
        """
        return pulumi.get(self, "datasource_connection_subnet_id")

    @property
    @pulumi.getter(name="datasourceConnectionVpcId")
    def datasource_connection_vpc_id(self) -> str:
        """
        Datasource vpcid.
        """
        return pulumi.get(self, "datasource_connection_vpc_id")

    @property
    @pulumi.getter(name="houseId")
    def house_id(self) -> str:
        """
        Data engine id.
        """
        return pulumi.get(self, "house_id")

    @property
    @pulumi.getter(name="houseName")
    def house_name(self) -> str:
        """
        Data engine name.
        """
        return pulumi.get(self, "house_name")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Network configuration id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkConnectionDesc")
    def network_connection_desc(self) -> str:
        """
        Network configuration description.
        """
        return pulumi.get(self, "network_connection_desc")

    @property
    @pulumi.getter(name="networkConnectionType")
    def network_connection_type(self) -> int:
        """
        Network configuration type.
        """
        return pulumi.get(self, "network_connection_type")

    @property
    @pulumi.getter
    def state(self) -> int:
        """
        Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subAccountUin")
    def sub_account_uin(self) -> str:
        """
        Operator.
        """
        return pulumi.get(self, "sub_account_uin")

    @property
    @pulumi.getter
    def uin(self) -> str:
        """
        User uin.
        """
        return pulumi.get(self, "uin")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> int:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetDescribeDataEngineDataEngineSessionResourceTemplateResult(dict):
    def __init__(__self__, *,
                 driver_size: str,
                 executor_max_numbers: int,
                 executor_nums: int,
                 executor_size: str):
        """
        :param str driver_size: Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        :param int executor_max_numbers: Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
        :param int executor_nums: Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
        :param str executor_size: Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        pulumi.set(__self__, "driver_size", driver_size)
        pulumi.set(__self__, "executor_max_numbers", executor_max_numbers)
        pulumi.set(__self__, "executor_nums", executor_nums)
        pulumi.set(__self__, "executor_size", executor_size)

    @property
    @pulumi.getter(name="driverSize")
    def driver_size(self) -> str:
        """
        Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        return pulumi.get(self, "driver_size")

    @property
    @pulumi.getter(name="executorMaxNumbers")
    def executor_max_numbers(self) -> int:
        """
        Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
        """
        return pulumi.get(self, "executor_max_numbers")

    @property
    @pulumi.getter(name="executorNums")
    def executor_nums(self) -> int:
        """
        Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
        """
        return pulumi.get(self, "executor_nums")

    @property
    @pulumi.getter(name="executorSize")
    def executor_size(self) -> str:
        """
        Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
        """
        return pulumi.get(self, "executor_size")


@pulumi.output_type
class GetDescribeDataEngineDataEngineTagListResult(dict):
    def __init__(__self__, *,
                 tag_key: str,
                 tag_value: str):
        """
        :param str tag_key: Tag key.
        :param str tag_value: Tag value.
        """
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        Tag key.
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> str:
        """
        Tag value.
        """
        return pulumi.get(self, "tag_value")


@pulumi.output_type
class GetDescribeDataEngineEventsEventResult(dict):
    def __init__(__self__, *,
                 cluster_infos: Sequence[str],
                 events_actions: Sequence[str],
                 times: Sequence[str]):
        """
        :param Sequence[str] cluster_infos: Cluster information.
        :param Sequence[str] events_actions: Event action.
        :param Sequence[str] times: Event time.
        """
        pulumi.set(__self__, "cluster_infos", cluster_infos)
        pulumi.set(__self__, "events_actions", events_actions)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="clusterInfos")
    def cluster_infos(self) -> Sequence[str]:
        """
        Cluster information.
        """
        return pulumi.get(self, "cluster_infos")

    @property
    @pulumi.getter(name="eventsActions")
    def events_actions(self) -> Sequence[str]:
        """
        Event action.
        """
        return pulumi.get(self, "events_actions")

    @property
    @pulumi.getter
    def times(self) -> Sequence[str]:
        """
        Event time.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetDescribeDataEngineImageVersionsImageParentVersionResult(dict):
    def __init__(__self__, *,
                 description: str,
                 engine_type: str,
                 image_version: str,
                 image_version_id: str,
                 insert_time: str,
                 is_public: int,
                 is_shared_engine: int,
                 state: int,
                 update_time: str):
        """
        :param str description: Image major version description.
        :param str engine_type: Engine type only support: SparkSQL/PrestoSQL/SparkBatch.
        :param str image_version: Engine major version name.
        :param str image_version_id: Engine major version id.
        :param str insert_time: Create time.
        :param int is_public: Whether it is a public version, only support: 1: public;/2: private.
        :param int is_shared_engine: Is shared engine, only support: 1:yes/2:no.
        :param int state: Version status, only support: 1: initialized/2: online/3: offline.
        :param str update_time: Update time.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "engine_type", engine_type)
        pulumi.set(__self__, "image_version", image_version)
        pulumi.set(__self__, "image_version_id", image_version_id)
        pulumi.set(__self__, "insert_time", insert_time)
        pulumi.set(__self__, "is_public", is_public)
        pulumi.set(__self__, "is_shared_engine", is_shared_engine)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Image major version description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> str:
        """
        Engine type only support: SparkSQL/PrestoSQL/SparkBatch.
        """
        return pulumi.get(self, "engine_type")

    @property
    @pulumi.getter(name="imageVersion")
    def image_version(self) -> str:
        """
        Engine major version name.
        """
        return pulumi.get(self, "image_version")

    @property
    @pulumi.getter(name="imageVersionId")
    def image_version_id(self) -> str:
        """
        Engine major version id.
        """
        return pulumi.get(self, "image_version_id")

    @property
    @pulumi.getter(name="insertTime")
    def insert_time(self) -> str:
        """
        Create time.
        """
        return pulumi.get(self, "insert_time")

    @property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> int:
        """
        Whether it is a public version, only support: 1: public;/2: private.
        """
        return pulumi.get(self, "is_public")

    @property
    @pulumi.getter(name="isSharedEngine")
    def is_shared_engine(self) -> int:
        """
        Is shared engine, only support: 1:yes/2:no.
        """
        return pulumi.get(self, "is_shared_engine")

    @property
    @pulumi.getter
    def state(self) -> int:
        """
        Version status, only support: 1: initialized/2: online/3: offline.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetDescribeDataEnginePythonSparkImagesPythonSparkImageResult(dict):
    def __init__(__self__, *,
                 child_image_version_id: str,
                 create_time: str,
                 description: str,
                 spark_image_id: str,
                 spark_image_version: str,
                 update_time: str):
        """
        :param str child_image_version_id: Engine Image version id.
        :param str create_time: Spark image create time.
        :param str description: Spark image description information.
        :param str spark_image_id: Spark image unique id.
        :param str spark_image_version: Spark image name.
        :param str update_time: Spark image update time.
        """
        pulumi.set(__self__, "child_image_version_id", child_image_version_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "spark_image_id", spark_image_id)
        pulumi.set(__self__, "spark_image_version", spark_image_version)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="childImageVersionId")
    def child_image_version_id(self) -> str:
        """
        Engine Image version id.
        """
        return pulumi.get(self, "child_image_version_id")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Spark image create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Spark image description information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="sparkImageId")
    def spark_image_id(self) -> str:
        """
        Spark image unique id.
        """
        return pulumi.get(self, "spark_image_id")

    @property
    @pulumi.getter(name="sparkImageVersion")
    def spark_image_version(self) -> str:
        """
        Spark image name.
        """
        return pulumi.get(self, "spark_image_version")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Spark image update time.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetDescribeUpdatableDataEnginesDataEngineBasicInfoResult(dict):
    def __init__(__self__, *,
                 app_id: int,
                 create_time: int,
                 data_engine_id: str,
                 data_engine_name: str,
                 data_engine_type: str,
                 message: str,
                 state: int,
                 update_time: int,
                 user_uin: str):
        """
        :param int app_id: User unique ID.
        :param int create_time: Create time.
        :param str data_engine_id: Engine unique id.
        :param str data_engine_name: Engine name.
        :param str data_engine_type: Engine type, valid values: PrestoSQL/SparkSQL/SparkBatch.
        :param str message: Returned messages.
        :param int state: Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
        :param int update_time: Update time.
        :param str user_uin: User unique uin.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_engine_id", data_engine_id)
        pulumi.set(__self__, "data_engine_name", data_engine_name)
        pulumi.set(__self__, "data_engine_type", data_engine_type)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "user_uin", user_uin)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> int:
        """
        User unique ID.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> int:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngineId")
    def data_engine_id(self) -> str:
        """
        Engine unique id.
        """
        return pulumi.get(self, "data_engine_id")

    @property
    @pulumi.getter(name="dataEngineName")
    def data_engine_name(self) -> str:
        """
        Engine name.
        """
        return pulumi.get(self, "data_engine_name")

    @property
    @pulumi.getter(name="dataEngineType")
    def data_engine_type(self) -> str:
        """
        Engine type, valid values: PrestoSQL/SparkSQL/SparkBatch.
        """
        return pulumi.get(self, "data_engine_type")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Returned messages.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def state(self) -> int:
        """
        Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> int:
        """
        Update time.
        """
        return pulumi.get(self, "update_time")

    @property
    @pulumi.getter(name="userUin")
    def user_uin(self) -> str:
        """
        User unique uin.
        """
        return pulumi.get(self, "user_uin")


@pulumi.output_type
class GetDescribeUserInfoFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name. If there are multiple Filters, the relationship between Filters is a logical OR (OR) relationship.
        :param Sequence[str] values: Attribute value, if there are multiple Values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name. If there are multiple Filters, the relationship between Filters is a logical OR (OR) relationship.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Attribute value, if there are multiple Values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDescribeUserInfoUserInfoResult(dict):
    def __init__(__self__, *,
                 data_policy_infos: Sequence['outputs.GetDescribeUserInfoUserInfoDataPolicyInfoResult'],
                 engine_policy_infos: Sequence['outputs.GetDescribeUserInfoUserInfoEnginePolicyInfoResult'],
                 row_filter_infos: Sequence['outputs.GetDescribeUserInfoUserInfoRowFilterInfoResult'],
                 type: str,
                 user_alias: str,
                 user_description: str,
                 user_id: str,
                 user_type: str,
                 work_group_infos: Sequence['outputs.GetDescribeUserInfoUserInfoWorkGroupInfoResult']):
        """
        :param Sequence['GetDescribeUserInfoUserInfoDataPolicyInfoArgs'] data_policy_infos: Data permission information collection.
        :param Sequence['GetDescribeUserInfoUserInfoEnginePolicyInfoArgs'] engine_policy_infos: Engine permission collection.
        :param Sequence['GetDescribeUserInfoUserInfoRowFilterInfoArgs'] row_filter_infos: Row filter collection.
        :param str type: Query information type, Group: work group DataAuth: data permission EngineAuth: engine permission.
        :param str user_alias: User alias.
        :param str user_description: User description.
        :param str user_id: User id, the same as the sub-user uin.
        :param str user_type: User type: ADMIN: Administrator COMMON: General user.
        :param Sequence['GetDescribeUserInfoUserInfoWorkGroupInfoArgs'] work_group_infos: Workgroup collection information bound to this user.
        """
        pulumi.set(__self__, "data_policy_infos", data_policy_infos)
        pulumi.set(__self__, "engine_policy_infos", engine_policy_infos)
        pulumi.set(__self__, "row_filter_infos", row_filter_infos)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_alias", user_alias)
        pulumi.set(__self__, "user_description", user_description)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_type", user_type)
        pulumi.set(__self__, "work_group_infos", work_group_infos)

    @property
    @pulumi.getter(name="dataPolicyInfos")
    def data_policy_infos(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoDataPolicyInfoResult']:
        """
        Data permission information collection.
        """
        return pulumi.get(self, "data_policy_infos")

    @property
    @pulumi.getter(name="enginePolicyInfos")
    def engine_policy_infos(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoEnginePolicyInfoResult']:
        """
        Engine permission collection.
        """
        return pulumi.get(self, "engine_policy_infos")

    @property
    @pulumi.getter(name="rowFilterInfos")
    def row_filter_infos(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoRowFilterInfoResult']:
        """
        Row filter collection.
        """
        return pulumi.get(self, "row_filter_infos")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Query information type, Group: work group DataAuth: data permission EngineAuth: engine permission.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAlias")
    def user_alias(self) -> str:
        """
        User alias.
        """
        return pulumi.get(self, "user_alias")

    @property
    @pulumi.getter(name="userDescription")
    def user_description(self) -> str:
        """
        User description.
        """
        return pulumi.get(self, "user_description")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        User id, the same as the sub-user uin.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userType")
    def user_type(self) -> str:
        """
        User type: ADMIN: Administrator COMMON: General user.
        """
        return pulumi.get(self, "user_type")

    @property
    @pulumi.getter(name="workGroupInfos")
    def work_group_infos(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoWorkGroupInfoResult']:
        """
        Workgroup collection information bound to this user.
        """
        return pulumi.get(self, "work_group_infos")


@pulumi.output_type
class GetDescribeUserInfoUserInfoDataPolicyInfoResult(dict):
    def __init__(__self__, *,
                 policy_sets: Sequence['outputs.GetDescribeUserInfoUserInfoDataPolicyInfoPolicySetResult'],
                 total_count: int):
        """
        :param Sequence['GetDescribeUserInfoUserInfoDataPolicyInfoPolicySetArgs'] policy_sets: Policy set.
        :param int total_count: Total count.
        """
        pulumi.set(__self__, "policy_sets", policy_sets)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="policySets")
    def policy_sets(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoDataPolicyInfoPolicySetResult']:
        """
        Policy set.
        """
        return pulumi.get(self, "policy_sets")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetDescribeUserInfoUserInfoDataPolicyInfoPolicySetResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 column: str,
                 create_time: str,
                 data_engine: str,
                 database: str,
                 function: str,
                 id: int,
                 mode: str,
                 operation: str,
                 operator: str,
                 policy_type: str,
                 re_auth: bool,
                 source: str,
                 source_id: int,
                 source_name: str,
                 table: str,
                 view: str):
        """
        :param str catalog: For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        :param str column: For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        :param str create_time: The time the workgroup was created.
        :param str data_engine: Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        :param str database: Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        :param str function: For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        :param int id: Policy id.
        :param str mode: Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        :param str operation: Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        :param str operator: Operator, do not fill in the input parameters.
        :param str policy_type: Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        :param bool re_auth: Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        :param str source: Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        :param int source_id: The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        :param str source_name: The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        :param str table: For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        :param str view: For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_engine", data_engine)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "re_auth", re_auth)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time the workgroup was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> str:
        """
        Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Policy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator, do not fill in the input parameters.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """
        Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> bool:
        """
        Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        """
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> int:
        """
        The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def view(self) -> str:
        """
        For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class GetDescribeUserInfoUserInfoEnginePolicyInfoResult(dict):
    def __init__(__self__, *,
                 policy_sets: Sequence['outputs.GetDescribeUserInfoUserInfoEnginePolicyInfoPolicySetResult'],
                 total_count: int):
        """
        :param Sequence['GetDescribeUserInfoUserInfoEnginePolicyInfoPolicySetArgs'] policy_sets: Policy set.
        :param int total_count: Total count.
        """
        pulumi.set(__self__, "policy_sets", policy_sets)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="policySets")
    def policy_sets(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoEnginePolicyInfoPolicySetResult']:
        """
        Policy set.
        """
        return pulumi.get(self, "policy_sets")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetDescribeUserInfoUserInfoEnginePolicyInfoPolicySetResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 column: str,
                 create_time: str,
                 data_engine: str,
                 database: str,
                 function: str,
                 id: int,
                 mode: str,
                 operation: str,
                 operator: str,
                 policy_type: str,
                 re_auth: bool,
                 source: str,
                 source_id: int,
                 source_name: str,
                 table: str,
                 view: str):
        """
        :param str catalog: For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        :param str column: For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        :param str create_time: The time the workgroup was created.
        :param str data_engine: Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        :param str database: Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        :param str function: For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        :param int id: Policy id.
        :param str mode: Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        :param str operation: Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        :param str operator: Operator, do not fill in the input parameters.
        :param str policy_type: Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        :param bool re_auth: Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        :param str source: Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        :param int source_id: The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        :param str source_name: The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        :param str table: For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        :param str view: For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_engine", data_engine)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "re_auth", re_auth)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time the workgroup was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> str:
        """
        Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Policy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator, do not fill in the input parameters.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """
        Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> bool:
        """
        Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        """
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> int:
        """
        The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def view(self) -> str:
        """
        For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class GetDescribeUserInfoUserInfoRowFilterInfoResult(dict):
    def __init__(__self__, *,
                 policy_sets: Sequence['outputs.GetDescribeUserInfoUserInfoRowFilterInfoPolicySetResult'],
                 total_count: int):
        """
        :param Sequence['GetDescribeUserInfoUserInfoRowFilterInfoPolicySetArgs'] policy_sets: Policy set.
        :param int total_count: Total count.
        """
        pulumi.set(__self__, "policy_sets", policy_sets)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="policySets")
    def policy_sets(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoRowFilterInfoPolicySetResult']:
        """
        Policy set.
        """
        return pulumi.get(self, "policy_sets")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetDescribeUserInfoUserInfoRowFilterInfoPolicySetResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 column: str,
                 create_time: str,
                 data_engine: str,
                 database: str,
                 function: str,
                 id: int,
                 mode: str,
                 operation: str,
                 operator: str,
                 policy_type: str,
                 re_auth: bool,
                 source: str,
                 source_id: int,
                 source_name: str,
                 table: str,
                 view: str):
        """
        :param str catalog: For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        :param str column: For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        :param str create_time: The time the workgroup was created.
        :param str data_engine: Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        :param str database: Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        :param str function: For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        :param int id: Policy id.
        :param str mode: Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        :param str operation: Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        :param str operator: Operator, do not fill in the input parameters.
        :param str policy_type: Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        :param bool re_auth: Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        :param str source: Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        :param int source_id: The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        :param str source_name: The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        :param str table: For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        :param str view: For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_engine", data_engine)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "re_auth", re_auth)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time the workgroup was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> str:
        """
        Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Policy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator, do not fill in the input parameters.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """
        Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> bool:
        """
        Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        """
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> int:
        """
        The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def view(self) -> str:
        """
        For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class GetDescribeUserInfoUserInfoWorkGroupInfoResult(dict):
    def __init__(__self__, *,
                 total_count: int,
                 work_group_sets: Sequence['outputs.GetDescribeUserInfoUserInfoWorkGroupInfoWorkGroupSetResult']):
        """
        :param int total_count: Total count.
        :param Sequence['GetDescribeUserInfoUserInfoWorkGroupInfoWorkGroupSetArgs'] work_group_sets: Work group set.
        """
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "work_group_sets", work_group_sets)

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")

    @property
    @pulumi.getter(name="workGroupSets")
    def work_group_sets(self) -> Sequence['outputs.GetDescribeUserInfoUserInfoWorkGroupInfoWorkGroupSetResult']:
        """
        Work group set.
        """
        return pulumi.get(self, "work_group_sets")


@pulumi.output_type
class GetDescribeUserInfoUserInfoWorkGroupInfoWorkGroupSetResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 creator: str,
                 work_group_description: str,
                 work_group_id: int,
                 work_group_name: str):
        """
        :param str create_time: The time the workgroup was created.
        :param str creator: Creator.
        :param str work_group_description: Work group description.
        :param int work_group_id: Work group unique id.
        :param str work_group_name: Work group name.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "work_group_description", work_group_description)
        pulumi.set(__self__, "work_group_id", work_group_id)
        pulumi.set(__self__, "work_group_name", work_group_name)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time the workgroup was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def creator(self) -> str:
        """
        Creator.
        """
        return pulumi.get(self, "creator")

    @property
    @pulumi.getter(name="workGroupDescription")
    def work_group_description(self) -> str:
        """
        Work group description.
        """
        return pulumi.get(self, "work_group_description")

    @property
    @pulumi.getter(name="workGroupId")
    def work_group_id(self) -> int:
        """
        Work group unique id.
        """
        return pulumi.get(self, "work_group_id")

    @property
    @pulumi.getter(name="workGroupName")
    def work_group_name(self) -> str:
        """
        Work group name.
        """
        return pulumi.get(self, "work_group_name")


@pulumi.output_type
class GetDescribeUserRolesUserRoleResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 arn: str,
                 cos_permission_lists: Sequence['outputs.GetDescribeUserRolesUserRoleCosPermissionListResult'],
                 creator: str,
                 desc: str,
                 modify_time: int,
                 permission_json: str,
                 role_id: int,
                 role_name: str,
                 uin: str):
        """
        :param str app_id: User app ID.
        :param str arn: Role Permissions.
        :param Sequence['GetDescribeUserRolesUserRoleCosPermissionListArgs'] cos_permission_lists: COS authorization path listNote: This field may return NULL, indicating that the valid value cannot be obtained.
        :param str creator: Creator UinNote: This field may return NULL, indicating that the valid value cannot be obtained.
        :param str desc: Character description information.
        :param int modify_time: Recently modify the time stamp.
        :param str permission_json: CAM strategy jsonNote: This field may return NULL, indicating that the valid value cannot be obtained.
        :param int role_id: Character ID.
        :param str role_name: Role NameNote: This field may return NULL, indicating that the valid value cannot be obtained.
        :param str uin: User ID.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "cos_permission_lists", cos_permission_lists)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "desc", desc)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "permission_json", permission_json)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "role_name", role_name)
        pulumi.set(__self__, "uin", uin)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        User app ID.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        Role Permissions.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="cosPermissionLists")
    def cos_permission_lists(self) -> Sequence['outputs.GetDescribeUserRolesUserRoleCosPermissionListResult']:
        """
        COS authorization path listNote: This field may return NULL, indicating that the valid value cannot be obtained.
        """
        return pulumi.get(self, "cos_permission_lists")

    @property
    @pulumi.getter
    def creator(self) -> str:
        """
        Creator UinNote: This field may return NULL, indicating that the valid value cannot be obtained.
        """
        return pulumi.get(self, "creator")

    @property
    @pulumi.getter
    def desc(self) -> str:
        """
        Character description information.
        """
        return pulumi.get(self, "desc")

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> int:
        """
        Recently modify the time stamp.
        """
        return pulumi.get(self, "modify_time")

    @property
    @pulumi.getter(name="permissionJson")
    def permission_json(self) -> str:
        """
        CAM strategy jsonNote: This field may return NULL, indicating that the valid value cannot be obtained.
        """
        return pulumi.get(self, "permission_json")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> int:
        """
        Character ID.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Role NameNote: This field may return NULL, indicating that the valid value cannot be obtained.
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter
    def uin(self) -> str:
        """
        User ID.
        """
        return pulumi.get(self, "uin")


@pulumi.output_type
class GetDescribeUserRolesUserRoleCosPermissionListResult(dict):
    def __init__(__self__, *,
                 cos_path: str,
                 permissions: Sequence[str]):
        """
        :param str cos_path: COS pathNote: This field may return NULL, indicating that the valid value cannot be obtained.
        :param Sequence[str] permissions: Permissions [Read, WRITE]Note: This field may return NULL, indicating that the valid value cannot be obtained.
        """
        pulumi.set(__self__, "cos_path", cos_path)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter(name="cosPath")
    def cos_path(self) -> str:
        """
        COS pathNote: This field may return NULL, indicating that the valid value cannot be obtained.
        """
        return pulumi.get(self, "cos_path")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        """
        Permissions [Read, WRITE]Note: This field may return NULL, indicating that the valid value cannot be obtained.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetDescribeWorkGroupInfoFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name. If there are multiple Filters, the relationship between filters is a logical or (OR) relationship.
        :param Sequence[str] values: Attribute value, if there are multiple values in the same filter, the relationship between values under the same filter is a logical or relationship.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name. If there are multiple Filters, the relationship between filters is a logical or (OR) relationship.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Attribute value, if there are multiple values in the same filter, the relationship between values under the same filter is a logical or relationship.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoResult(dict):
    def __init__(__self__, *,
                 data_policy_infos: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoResult'],
                 engine_policy_infos: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoResult'],
                 row_filter_infos: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoResult'],
                 type: str,
                 user_infos: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoUserInfoResult'],
                 work_group_description: str,
                 work_group_id: int,
                 work_group_name: str):
        """
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoArgs'] data_policy_infos: Data permission collection.
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoArgs'] engine_policy_infos: Engine permission collection.
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoArgs'] row_filter_infos: Row filter information collection.
        :param str type: Query information type, only support: User: user information/DataAuth: data permission/EngineAuth: engine permission.
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoUserInfoArgs'] user_infos: A collection of users bound to the workgroup.
        :param str work_group_description: Workgroup description information.
        :param int work_group_id: Work group id.
        :param str work_group_name: Work group name.
        """
        pulumi.set(__self__, "data_policy_infos", data_policy_infos)
        pulumi.set(__self__, "engine_policy_infos", engine_policy_infos)
        pulumi.set(__self__, "row_filter_infos", row_filter_infos)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_infos", user_infos)
        pulumi.set(__self__, "work_group_description", work_group_description)
        pulumi.set(__self__, "work_group_id", work_group_id)
        pulumi.set(__self__, "work_group_name", work_group_name)

    @property
    @pulumi.getter(name="dataPolicyInfos")
    def data_policy_infos(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoResult']:
        """
        Data permission collection.
        """
        return pulumi.get(self, "data_policy_infos")

    @property
    @pulumi.getter(name="enginePolicyInfos")
    def engine_policy_infos(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoResult']:
        """
        Engine permission collection.
        """
        return pulumi.get(self, "engine_policy_infos")

    @property
    @pulumi.getter(name="rowFilterInfos")
    def row_filter_infos(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoResult']:
        """
        Row filter information collection.
        """
        return pulumi.get(self, "row_filter_infos")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Query information type, only support: User: user information/DataAuth: data permission/EngineAuth: engine permission.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userInfos")
    def user_infos(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoUserInfoResult']:
        """
        A collection of users bound to the workgroup.
        """
        return pulumi.get(self, "user_infos")

    @property
    @pulumi.getter(name="workGroupDescription")
    def work_group_description(self) -> str:
        """
        Workgroup description information.
        """
        return pulumi.get(self, "work_group_description")

    @property
    @pulumi.getter(name="workGroupId")
    def work_group_id(self) -> int:
        """
        Work group id.
        """
        return pulumi.get(self, "work_group_id")

    @property
    @pulumi.getter(name="workGroupName")
    def work_group_name(self) -> str:
        """
        Work group name.
        """
        return pulumi.get(self, "work_group_name")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoResult(dict):
    def __init__(__self__, *,
                 policy_sets: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoPolicySetResult'],
                 total_count: int):
        """
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoPolicySetArgs'] policy_sets: Policy set.
        :param int total_count: Total count.
        """
        pulumi.set(__self__, "policy_sets", policy_sets)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="policySets")
    def policy_sets(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoPolicySetResult']:
        """
        Policy set.
        """
        return pulumi.get(self, "policy_sets")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoPolicySetResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 column: str,
                 create_time: str,
                 data_engine: str,
                 database: str,
                 function: str,
                 id: int,
                 mode: str,
                 operation: str,
                 operator: str,
                 policy_type: str,
                 re_auth: bool,
                 source: str,
                 source_id: int,
                 source_name: str,
                 table: str,
                 view: str):
        """
        :param str catalog: For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        :param str column: For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        :param str create_time: Create time.
        :param str data_engine: Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        :param str database: Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        :param str function: For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        :param int id: Policy id.
        :param str mode: Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        :param str operation: Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        :param str operator: Operator, do not fill in the input parameters.
        :param str policy_type: Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        :param bool re_auth: Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        :param str source: Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        :param int source_id: The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        :param str source_name: The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        :param str table: For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        :param str view: For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_engine", data_engine)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "re_auth", re_auth)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> str:
        """
        Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Policy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator, do not fill in the input parameters.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """
        Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> bool:
        """
        Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        """
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> int:
        """
        The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def view(self) -> str:
        """
        For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoResult(dict):
    def __init__(__self__, *,
                 policy_sets: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoPolicySetResult'],
                 total_count: int):
        """
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoPolicySetArgs'] policy_sets: Policy set.
        :param int total_count: Total count.
        """
        pulumi.set(__self__, "policy_sets", policy_sets)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="policySets")
    def policy_sets(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoPolicySetResult']:
        """
        Policy set.
        """
        return pulumi.get(self, "policy_sets")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoPolicySetResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 column: str,
                 create_time: str,
                 data_engine: str,
                 database: str,
                 function: str,
                 id: int,
                 mode: str,
                 operation: str,
                 operator: str,
                 policy_type: str,
                 re_auth: bool,
                 source: str,
                 source_id: int,
                 source_name: str,
                 table: str,
                 view: str):
        """
        :param str catalog: For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        :param str column: For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        :param str create_time: Create time.
        :param str data_engine: Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        :param str database: Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        :param str function: For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        :param int id: Policy id.
        :param str mode: Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        :param str operation: Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        :param str operator: Operator, do not fill in the input parameters.
        :param str policy_type: Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        :param bool re_auth: Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        :param str source: Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        :param int source_id: The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        :param str source_name: The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        :param str table: For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        :param str view: For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_engine", data_engine)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "re_auth", re_auth)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> str:
        """
        Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Policy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator, do not fill in the input parameters.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """
        Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> bool:
        """
        Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        """
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> int:
        """
        The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def view(self) -> str:
        """
        For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoResult(dict):
    def __init__(__self__, *,
                 policy_sets: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoPolicySetResult'],
                 total_count: int):
        """
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoPolicySetArgs'] policy_sets: Policy set.
        :param int total_count: Total count.
        """
        pulumi.set(__self__, "policy_sets", policy_sets)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="policySets")
    def policy_sets(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoPolicySetResult']:
        """
        Policy set.
        """
        return pulumi.get(self, "policy_sets")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoPolicySetResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 column: str,
                 create_time: str,
                 data_engine: str,
                 database: str,
                 function: str,
                 id: int,
                 mode: str,
                 operation: str,
                 operator: str,
                 policy_type: str,
                 re_auth: bool,
                 source: str,
                 source_id: int,
                 source_name: str,
                 table: str,
                 view: str):
        """
        :param str catalog: For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        :param str column: For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        :param str create_time: Create time.
        :param str data_engine: Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        :param str database: Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        :param str function: For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        :param int id: Policy id.
        :param str mode: Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        :param str operation: Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        :param str operator: Operator, do not fill in the input parameters.
        :param str policy_type: Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        :param bool re_auth: Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        :param str source: Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        :param int source_id: The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        :param str source_name: The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        :param str table: For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        :param str view: For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_engine", data_engine)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "re_auth", re_auth)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataEngine")
    def data_engine(self) -> str:
        """
        Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
        """
        return pulumi.get(self, "data_engine")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Policy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator, do not fill in the input parameters.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """
        Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="reAuth")
    def re_auth(self) -> bool:
        """
        Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
        """
        return pulumi.get(self, "re_auth")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> int:
        """
        The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def view(self) -> str:
        """
        For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoUserInfoResult(dict):
    def __init__(__self__, *,
                 total_count: int,
                 user_sets: Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoUserInfoUserSetResult']):
        """
        :param int total_count: Total count.
        :param Sequence['GetDescribeWorkGroupInfoWorkGroupInfoUserInfoUserSetArgs'] user_sets: User information collection.
        """
        pulumi.set(__self__, "total_count", total_count)
        pulumi.set(__self__, "user_sets", user_sets)

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        Total count.
        """
        return pulumi.get(self, "total_count")

    @property
    @pulumi.getter(name="userSets")
    def user_sets(self) -> Sequence['outputs.GetDescribeWorkGroupInfoWorkGroupInfoUserInfoUserSetResult']:
        """
        User information collection.
        """
        return pulumi.get(self, "user_sets")


@pulumi.output_type
class GetDescribeWorkGroupInfoWorkGroupInfoUserInfoUserSetResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 creator: str,
                 user_alias: str,
                 user_description: str,
                 user_id: str):
        """
        :param str create_time: Create time.
        :param str creator: The creator of the current user.
        :param str user_alias: User alias.
        :param str user_description: User description.
        :param str user_id: User id, matches the CAM side sub-user uin.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "user_alias", user_alias)
        pulumi.set(__self__, "user_description", user_description)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def creator(self) -> str:
        """
        The creator of the current user.
        """
        return pulumi.get(self, "creator")

    @property
    @pulumi.getter(name="userAlias")
    def user_alias(self) -> str:
        """
        User alias.
        """
        return pulumi.get(self, "user_alias")

    @property
    @pulumi.getter(name="userDescription")
    def user_description(self) -> str:
        """
        User description.
        """
        return pulumi.get(self, "user_description")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        User id, matches the CAM side sub-user uin.
        """
        return pulumi.get(self, "user_id")


