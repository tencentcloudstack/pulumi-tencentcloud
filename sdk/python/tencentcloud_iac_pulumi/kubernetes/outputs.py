# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ClusterAttachmentWorkerConfig',
    'ClusterAttachmentWorkerConfigDataDisk',
    'ClusterAttachmentWorkerConfigGpuArgs',
    'ClusterAttachmentWorkerConfigOverrides',
    'ClusterAttachmentWorkerConfigOverridesDataDisk',
    'ClusterAttachmentWorkerConfigOverridesGpuArgs',
    'ClusterAttachmentWorkerConfigTaint',
    'ClusterAuthOptions',
    'ClusterClusterAudit',
    'ClusterClusterExtraArgs',
    'ClusterEventPersistence',
    'ClusterExistInstance',
    'ClusterExistInstanceInstancesPara',
    'ClusterExistInstanceInstancesParaMasterConfig',
    'ClusterExistInstanceInstancesParaMasterConfigDataDisk',
    'ClusterExistInstanceInstancesParaMasterConfigExtraArgs',
    'ClusterExistInstanceInstancesParaMasterConfigGpuArgs',
    'ClusterExistInstanceInstancesParaMasterConfigLabel',
    'ClusterExistInstanceInstancesParaMasterConfigTaint',
    'ClusterExtensionAddon',
    'ClusterLogAgent',
    'ClusterMasterAttachmentExtraArgs',
    'ClusterMasterAttachmentMasterConfig',
    'ClusterMasterAttachmentMasterConfigDataDisk',
    'ClusterMasterAttachmentMasterConfigExtraArgs',
    'ClusterMasterAttachmentMasterConfigGpuArgs',
    'ClusterMasterAttachmentMasterConfigLabel',
    'ClusterMasterAttachmentMasterConfigTaint',
    'ClusterMasterConfig',
    'ClusterMasterConfigDataDisk',
    'ClusterNodePoolGlobalConfig',
    'ClusterReleaseValues',
    'ClusterResourceDeleteOption',
    'ClusterWorkerConfig',
    'ClusterWorkerConfigDataDisk',
    'ClusterWorkerInstancesList',
    'EncryptionProtectionKmsConfiguration',
    'HealthCheckPolicyRule',
    'NativeNodePoolAnnotation',
    'NativeNodePoolLabel',
    'NativeNodePoolNative',
    'NativeNodePoolNativeDataDisk',
    'NativeNodePoolNativeInstanceChargePrepaid',
    'NativeNodePoolNativeInternetAccessible',
    'NativeNodePoolNativeLifecycle',
    'NativeNodePoolNativeManagement',
    'NativeNodePoolNativeScaling',
    'NativeNodePoolNativeSystemDisk',
    'NativeNodePoolTag',
    'NativeNodePoolTagTag',
    'NativeNodePoolTaint',
    'NodePoolAnnotation',
    'NodePoolAutoScalingConfig',
    'NodePoolAutoScalingConfigDataDisk',
    'NodePoolNodeConfig',
    'NodePoolNodeConfigDataDisk',
    'NodePoolNodeConfigGpuArgs',
    'NodePoolTaint',
    'ScaleWorkerDataDisk',
    'ScaleWorkerGpuArgs',
    'ScaleWorkerTaint',
    'ScaleWorkerWorkerConfig',
    'ScaleWorkerWorkerConfigDataDisk',
    'ScaleWorkerWorkerConfigTag',
    'ScaleWorkerWorkerInstancesList',
    'ServerlessNodePoolServerlessNode',
    'ServerlessNodePoolTaint',
    'GetAddonsAddonResult',
    'GetAvailableClusterVersionsClusterResult',
    'GetChartsChartListResult',
    'GetClusterAuthenticationOptionsOidcConfigResult',
    'GetClusterAuthenticationOptionsServiceAccountResult',
    'GetClusterCommonNamesListResult',
    'GetClusterInstancesFilterResult',
    'GetClusterInstancesInstanceSetResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingDataDiskResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingExtraArgResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudaResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudnnResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCustomDriverResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgDriverResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingLabelResult',
    'GetClusterInstancesInstanceSetInstanceAdvancedSettingTaintResult',
    'GetClusterLevelsListResult',
    'GetClusterNativeNodePoolsFilterResult',
    'GetClusterNativeNodePoolsNodePoolResult',
    'GetClusterNativeNodePoolsNodePoolAnnotationResult',
    'GetClusterNativeNodePoolsNodePoolLabelResult',
    'GetClusterNativeNodePoolsNodePoolNativeResult',
    'GetClusterNativeNodePoolsNodePoolNativeDataDiskResult',
    'GetClusterNativeNodePoolsNodePoolNativeInstanceChargePrepaidResult',
    'GetClusterNativeNodePoolsNodePoolNativeInternetAccessibleResult',
    'GetClusterNativeNodePoolsNodePoolNativeLifecycleResult',
    'GetClusterNativeNodePoolsNodePoolNativeManagementResult',
    'GetClusterNativeNodePoolsNodePoolNativeScalingResult',
    'GetClusterNativeNodePoolsNodePoolNativeSystemDiskResult',
    'GetClusterNativeNodePoolsNodePoolTagResult',
    'GetClusterNativeNodePoolsNodePoolTagTagResult',
    'GetClusterNativeNodePoolsNodePoolTaintResult',
    'GetClusterNodePoolsFilterResult',
    'GetClusterNodePoolsNodePoolSetResult',
    'GetClusterNodePoolsNodePoolSetDataDiskResult',
    'GetClusterNodePoolsNodePoolSetExtraArgResult',
    'GetClusterNodePoolsNodePoolSetGpuArgResult',
    'GetClusterNodePoolsNodePoolSetGpuArgCudaResult',
    'GetClusterNodePoolsNodePoolSetGpuArgCudnnResult',
    'GetClusterNodePoolsNodePoolSetGpuArgCustomDriverResult',
    'GetClusterNodePoolsNodePoolSetGpuArgDriverResult',
    'GetClusterNodePoolsNodePoolSetLabelResult',
    'GetClusterNodePoolsNodePoolSetNodeCountSummaryResult',
    'GetClusterNodePoolsNodePoolSetNodeCountSummaryAutoscalingAddedResult',
    'GetClusterNodePoolsNodePoolSetNodeCountSummaryManuallyAddedResult',
    'GetClusterNodePoolsNodePoolSetTagResult',
    'GetClusterNodePoolsNodePoolSetTaintResult',
    'GetClustersListResult',
    'GetClustersListClusterExtraArgResult',
    'GetClustersListWorkerInstancesListResult',
]

@pulumi.output_type
class ClusterAttachmentWorkerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDisks":
            suggest = "data_disks"
        elif key == "desiredPodNum":
            suggest = "desired_pod_num"
        elif key == "dockerGraphPath":
            suggest = "docker_graph_path"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "gpuArgs":
            suggest = "gpu_args"
        elif key == "isSchedule":
            suggest = "is_schedule"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "preStartUserScript":
            suggest = "pre_start_user_script"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentWorkerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentWorkerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentWorkerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disks: Optional[Sequence['outputs.ClusterAttachmentWorkerConfigDataDisk']] = None,
                 desired_pod_num: Optional[_builtins.int] = None,
                 docker_graph_path: Optional[_builtins.str] = None,
                 extra_args: Optional[Sequence[_builtins.str]] = None,
                 gpu_args: Optional['outputs.ClusterAttachmentWorkerConfigGpuArgs'] = None,
                 is_schedule: Optional[_builtins.bool] = None,
                 mount_target: Optional[_builtins.str] = None,
                 pre_start_user_script: Optional[_builtins.str] = None,
                 taints: Optional[Sequence['outputs.ClusterAttachmentWorkerConfigTaint']] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param Sequence['ClusterAttachmentWorkerConfigDataDiskArgs'] data_disks: Configurations of data disk.
        :param _builtins.int desired_pod_num: Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        :param _builtins.str docker_graph_path: Docker graph path. Default is `/var/lib/docker`.
        :param Sequence[_builtins.str] extra_args: Custom parameter information related to the node. This is a white-list parameter.
        :param 'ClusterAttachmentWorkerConfigGpuArgsArgs' gpu_args: GPU driver parameters.
        :param _builtins.bool is_schedule: This argument was deprecated, use `unschedulable` instead. Indicate to schedule the adding node or not. Default is true.
        :param _builtins.str mount_target: Mount target. Default is not mounting.
        :param _builtins.str pre_start_user_script: Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        :param Sequence['ClusterAttachmentWorkerConfigTaintArgs'] taints: Node taint.
        :param _builtins.str user_data: Base64-encoded User Data text, the length limit is 16KB.
        """
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if desired_pod_num is not None:
            pulumi.set(__self__, "desired_pod_num", desired_pod_num)
        if docker_graph_path is not None:
            pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if gpu_args is not None:
            pulumi.set(__self__, "gpu_args", gpu_args)
        if is_schedule is not None:
            pulumi.set(__self__, "is_schedule", is_schedule)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if pre_start_user_script is not None:
            pulumi.set(__self__, "pre_start_user_script", pre_start_user_script)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.ClusterAttachmentWorkerConfigDataDisk']]:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="desiredPodNum")
    def desired_pod_num(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        """
        return pulumi.get(self, "desired_pod_num")

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    def docker_graph_path(self) -> Optional[_builtins.str]:
        """
        Docker graph path. Default is `/var/lib/docker`.
        """
        return pulumi.get(self, "docker_graph_path")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom parameter information related to the node. This is a white-list parameter.
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="gpuArgs")
    def gpu_args(self) -> Optional['outputs.ClusterAttachmentWorkerConfigGpuArgs']:
        """
        GPU driver parameters.
        """
        return pulumi.get(self, "gpu_args")

    @_builtins.property
    @pulumi.getter(name="isSchedule")
    @_utilities.deprecated("""This argument was deprecated, use `unschedulable` instead.""")
    def is_schedule(self) -> Optional[_builtins.bool]:
        """
        This argument was deprecated, use `unschedulable` instead. Indicate to schedule the adding node or not. Default is true.
        """
        return pulumi.get(self, "is_schedule")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target. Default is not mounting.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="preStartUserScript")
    def pre_start_user_script(self) -> Optional[_builtins.str]:
        """
        Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        """
        return pulumi.get(self, "pre_start_user_script")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.ClusterAttachmentWorkerConfigTaint']]:
        """
        Node taint.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        Base64-encoded User Data text, the length limit is 16KB.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class ClusterAttachmentWorkerConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "mountTarget":
            suggest = "mount_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentWorkerConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentWorkerConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentWorkerConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 file_system: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str mount_target: Mount target.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class ClusterAttachmentWorkerConfigGpuArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDriver":
            suggest = "custom_driver"
        elif key == "migEnable":
            suggest = "mig_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentWorkerConfigGpuArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentWorkerConfigGpuArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentWorkerConfigGpuArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cuda: Optional[Mapping[str, _builtins.str]] = None,
                 cudnn: Optional[Mapping[str, _builtins.str]] = None,
                 custom_driver: Optional[Mapping[str, _builtins.str]] = None,
                 driver: Optional[Mapping[str, _builtins.str]] = None,
                 mig_enable: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] cuda: CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param Mapping[str, _builtins.str] cudnn: cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        :param Mapping[str, _builtins.str] custom_driver: Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        :param Mapping[str, _builtins.str] driver: GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param _builtins.bool mig_enable: Whether to enable MIG.
        """
        if cuda is not None:
            pulumi.set(__self__, "cuda", cuda)
        if cudnn is not None:
            pulumi.set(__self__, "cudnn", cudnn)
        if custom_driver is not None:
            pulumi.set(__self__, "custom_driver", custom_driver)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if mig_enable is not None:
            pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cuda(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "cuda")

    @_builtins.property
    @pulumi.getter
    def cudnn(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        """
        return pulumi.get(self, "cudnn")

    @_builtins.property
    @pulumi.getter(name="customDriver")
    def custom_driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        """
        return pulumi.get(self, "custom_driver")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable MIG.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class ClusterAttachmentWorkerConfigOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDisks":
            suggest = "data_disks"
        elif key == "desiredPodNum":
            suggest = "desired_pod_num"
        elif key == "dockerGraphPath":
            suggest = "docker_graph_path"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "gpuArgs":
            suggest = "gpu_args"
        elif key == "isSchedule":
            suggest = "is_schedule"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "preStartUserScript":
            suggest = "pre_start_user_script"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentWorkerConfigOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentWorkerConfigOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentWorkerConfigOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disks: Optional[Sequence['outputs.ClusterAttachmentWorkerConfigOverridesDataDisk']] = None,
                 desired_pod_num: Optional[_builtins.int] = None,
                 docker_graph_path: Optional[_builtins.str] = None,
                 extra_args: Optional[Sequence[_builtins.str]] = None,
                 gpu_args: Optional['outputs.ClusterAttachmentWorkerConfigOverridesGpuArgs'] = None,
                 is_schedule: Optional[_builtins.bool] = None,
                 mount_target: Optional[_builtins.str] = None,
                 pre_start_user_script: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param Sequence['ClusterAttachmentWorkerConfigOverridesDataDiskArgs'] data_disks: Configurations of data disk.
        :param _builtins.int desired_pod_num: Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        :param _builtins.str docker_graph_path: This argument was no longer supported by TencentCloud TKE. Docker graph path. Default is `/var/lib/docker`.
        :param Sequence[_builtins.str] extra_args: This argument was no longer supported by TencentCloud TKE. Custom parameter information related to the node. This is a white-list parameter.
        :param 'ClusterAttachmentWorkerConfigOverridesGpuArgsArgs' gpu_args: GPU driver parameters.
        :param _builtins.bool is_schedule: This argument was deprecated, use `unschedulable` instead. Indicate to schedule the adding node or not. Default is true.
        :param _builtins.str mount_target: This argument was no longer supported by TencentCloud TKE. Mount target. Default is not mounting.
        :param _builtins.str pre_start_user_script: This argument was no longer supported by TencentCloud TKE. Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        :param _builtins.str user_data: This argument was no longer supported by TencentCloud TKE. Base64-encoded User Data text, the length limit is 16KB.
        """
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if desired_pod_num is not None:
            pulumi.set(__self__, "desired_pod_num", desired_pod_num)
        if docker_graph_path is not None:
            pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if gpu_args is not None:
            pulumi.set(__self__, "gpu_args", gpu_args)
        if is_schedule is not None:
            pulumi.set(__self__, "is_schedule", is_schedule)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if pre_start_user_script is not None:
            pulumi.set(__self__, "pre_start_user_script", pre_start_user_script)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.ClusterAttachmentWorkerConfigOverridesDataDisk']]:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="desiredPodNum")
    def desired_pod_num(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        """
        return pulumi.get(self, "desired_pod_num")

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    @_utilities.deprecated("""This argument was no longer supported by TencentCloud TKE.""")
    def docker_graph_path(self) -> Optional[_builtins.str]:
        """
        This argument was no longer supported by TencentCloud TKE. Docker graph path. Default is `/var/lib/docker`.
        """
        return pulumi.get(self, "docker_graph_path")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    @_utilities.deprecated("""This argument was no longer supported by TencentCloud TKE.""")
    def extra_args(self) -> Optional[Sequence[_builtins.str]]:
        """
        This argument was no longer supported by TencentCloud TKE. Custom parameter information related to the node. This is a white-list parameter.
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="gpuArgs")
    def gpu_args(self) -> Optional['outputs.ClusterAttachmentWorkerConfigOverridesGpuArgs']:
        """
        GPU driver parameters.
        """
        return pulumi.get(self, "gpu_args")

    @_builtins.property
    @pulumi.getter(name="isSchedule")
    @_utilities.deprecated("""This argument was deprecated, use `unschedulable` instead.""")
    def is_schedule(self) -> Optional[_builtins.bool]:
        """
        This argument was deprecated, use `unschedulable` instead. Indicate to schedule the adding node or not. Default is true.
        """
        return pulumi.get(self, "is_schedule")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    @_utilities.deprecated("""This argument was no longer supported by TencentCloud TKE.""")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        This argument was no longer supported by TencentCloud TKE. Mount target. Default is not mounting.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="preStartUserScript")
    @_utilities.deprecated("""This argument was no longer supported by TencentCloud TKE.""")
    def pre_start_user_script(self) -> Optional[_builtins.str]:
        """
        This argument was no longer supported by TencentCloud TKE. Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        """
        return pulumi.get(self, "pre_start_user_script")

    @_builtins.property
    @pulumi.getter(name="userData")
    @_utilities.deprecated("""This argument was no longer supported by TencentCloud TKE.""")
    def user_data(self) -> Optional[_builtins.str]:
        """
        This argument was no longer supported by TencentCloud TKE. Base64-encoded User Data text, the length limit is 16KB.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class ClusterAttachmentWorkerConfigOverridesDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "mountTarget":
            suggest = "mount_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentWorkerConfigOverridesDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentWorkerConfigOverridesDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentWorkerConfigOverridesDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 file_system: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str mount_target: Mount target.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class ClusterAttachmentWorkerConfigOverridesGpuArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDriver":
            suggest = "custom_driver"
        elif key == "migEnable":
            suggest = "mig_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentWorkerConfigOverridesGpuArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentWorkerConfigOverridesGpuArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentWorkerConfigOverridesGpuArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cuda: Optional[Mapping[str, _builtins.str]] = None,
                 cudnn: Optional[Mapping[str, _builtins.str]] = None,
                 custom_driver: Optional[Mapping[str, _builtins.str]] = None,
                 driver: Optional[Mapping[str, _builtins.str]] = None,
                 mig_enable: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] cuda: CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param Mapping[str, _builtins.str] cudnn: cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        :param Mapping[str, _builtins.str] custom_driver: Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        :param Mapping[str, _builtins.str] driver: GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param _builtins.bool mig_enable: Whether to enable MIG.
        """
        if cuda is not None:
            pulumi.set(__self__, "cuda", cuda)
        if cudnn is not None:
            pulumi.set(__self__, "cudnn", cudnn)
        if custom_driver is not None:
            pulumi.set(__self__, "custom_driver", custom_driver)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if mig_enable is not None:
            pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cuda(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "cuda")

    @_builtins.property
    @pulumi.getter
    def cudnn(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        """
        return pulumi.get(self, "cudnn")

    @_builtins.property
    @pulumi.getter(name="customDriver")
    def custom_driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        """
        return pulumi.get(self, "custom_driver")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable MIG.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class ClusterAttachmentWorkerConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Effect of the taint.
        :param _builtins.str key: Key of the taint.
        :param _builtins.str value: Value of the taint.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterAuthOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoCreateDiscoveryAnonymousAuth":
            suggest = "auto_create_discovery_anonymous_auth"
        elif key == "jwksUri":
            suggest = "jwks_uri"
        elif key == "useTkeDefault":
            suggest = "use_tke_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAuthOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAuthOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAuthOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_create_discovery_anonymous_auth: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 use_tke_default: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool auto_create_discovery_anonymous_auth: If set to `true`, the rbac rule will be created automatically which allow anonymous user to access '/.well-known/openid-configuration' and '/openid/v1/jwks'.
        :param _builtins.str issuer: Specify service-account-issuer. If use_tke_default is set to `true`, please do not set this field, it will be ignored anyway.
        :param _builtins.str jwks_uri: Specify service-account-jwks-uri. If use_tke_default is set to `true`, please do not set this field, it will be ignored anyway.
        :param _builtins.bool use_tke_default: If set to `true`, the issuer and jwks_uri will be generated automatically by tke, please do not set issuer and jwks_uri, and they will be ignored.
        """
        if auto_create_discovery_anonymous_auth is not None:
            pulumi.set(__self__, "auto_create_discovery_anonymous_auth", auto_create_discovery_anonymous_auth)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if use_tke_default is not None:
            pulumi.set(__self__, "use_tke_default", use_tke_default)

    @_builtins.property
    @pulumi.getter(name="autoCreateDiscoveryAnonymousAuth")
    def auto_create_discovery_anonymous_auth(self) -> Optional[_builtins.bool]:
        """
        If set to `true`, the rbac rule will be created automatically which allow anonymous user to access '/.well-known/openid-configuration' and '/openid/v1/jwks'.
        """
        return pulumi.get(self, "auto_create_discovery_anonymous_auth")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        Specify service-account-issuer. If use_tke_default is set to `true`, please do not set this field, it will be ignored anyway.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        Specify service-account-jwks-uri. If use_tke_default is set to `true`, please do not set this field, it will be ignored anyway.
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter(name="useTkeDefault")
    def use_tke_default(self) -> Optional[_builtins.bool]:
        """
        If set to `true`, the issuer and jwks_uri will be generated automatically by tke, please do not set issuer and jwks_uri, and they will be ignored.
        """
        return pulumi.get(self, "use_tke_default")


@pulumi.output_type
class ClusterClusterAudit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteAuditLogAndTopic":
            suggest = "delete_audit_log_and_topic"
        elif key == "logSetId":
            suggest = "log_set_id"
        elif key == "topicId":
            suggest = "topic_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAudit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAudit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAudit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 delete_audit_log_and_topic: Optional[_builtins.bool] = None,
                 log_set_id: Optional[_builtins.str] = None,
                 topic_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specify weather the Cluster Audit enabled. NOTE: Enable Cluster Audit will also auto install Log Agent.
        :param _builtins.bool delete_audit_log_and_topic: when you want to close the cluster audit log or delete the cluster, you can use this parameter to determine whether the audit log set and topic created by default will be deleted.
        :param _builtins.str log_set_id: Specify id of existing CLS log set, or auto create a new set by leave it empty.
        :param _builtins.str topic_id: Specify id of existing CLS log topic, or auto create a new topic by leave it empty.
        """
        pulumi.set(__self__, "enabled", enabled)
        if delete_audit_log_and_topic is not None:
            pulumi.set(__self__, "delete_audit_log_and_topic", delete_audit_log_and_topic)
        if log_set_id is not None:
            pulumi.set(__self__, "log_set_id", log_set_id)
        if topic_id is not None:
            pulumi.set(__self__, "topic_id", topic_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specify weather the Cluster Audit enabled. NOTE: Enable Cluster Audit will also auto install Log Agent.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="deleteAuditLogAndTopic")
    def delete_audit_log_and_topic(self) -> Optional[_builtins.bool]:
        """
        when you want to close the cluster audit log or delete the cluster, you can use this parameter to determine whether the audit log set and topic created by default will be deleted.
        """
        return pulumi.get(self, "delete_audit_log_and_topic")

    @_builtins.property
    @pulumi.getter(name="logSetId")
    def log_set_id(self) -> Optional[_builtins.str]:
        """
        Specify id of existing CLS log set, or auto create a new set by leave it empty.
        """
        return pulumi.get(self, "log_set_id")

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> Optional[_builtins.str]:
        """
        Specify id of existing CLS log topic, or auto create a new topic by leave it empty.
        """
        return pulumi.get(self, "topic_id")


@pulumi.output_type
class ClusterClusterExtraArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeApiservers":
            suggest = "kube_apiservers"
        elif key == "kubeControllerManagers":
            suggest = "kube_controller_managers"
        elif key == "kubeSchedulers":
            suggest = "kube_schedulers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterExtraArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterExtraArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterExtraArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kube_apiservers: Optional[Sequence[_builtins.str]] = None,
                 kube_controller_managers: Optional[Sequence[_builtins.str]] = None,
                 kube_schedulers: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] kube_apiservers: The customized parameters for kube-apiserver.
        :param Sequence[_builtins.str] kube_controller_managers: The customized parameters for kube-controller-manager.
        :param Sequence[_builtins.str] kube_schedulers: The customized parameters for kube-scheduler.
        """
        if kube_apiservers is not None:
            pulumi.set(__self__, "kube_apiservers", kube_apiservers)
        if kube_controller_managers is not None:
            pulumi.set(__self__, "kube_controller_managers", kube_controller_managers)
        if kube_schedulers is not None:
            pulumi.set(__self__, "kube_schedulers", kube_schedulers)

    @_builtins.property
    @pulumi.getter(name="kubeApiservers")
    def kube_apiservers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The customized parameters for kube-apiserver.
        """
        return pulumi.get(self, "kube_apiservers")

    @_builtins.property
    @pulumi.getter(name="kubeControllerManagers")
    def kube_controller_managers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The customized parameters for kube-controller-manager.
        """
        return pulumi.get(self, "kube_controller_managers")

    @_builtins.property
    @pulumi.getter(name="kubeSchedulers")
    def kube_schedulers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The customized parameters for kube-scheduler.
        """
        return pulumi.get(self, "kube_schedulers")


@pulumi.output_type
class ClusterEventPersistence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteEventLogAndTopic":
            suggest = "delete_event_log_and_topic"
        elif key == "logSetId":
            suggest = "log_set_id"
        elif key == "topicId":
            suggest = "topic_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEventPersistence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEventPersistence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEventPersistence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 delete_event_log_and_topic: Optional[_builtins.bool] = None,
                 log_set_id: Optional[_builtins.str] = None,
                 topic_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specify weather the Event Persistence enabled.
        :param _builtins.bool delete_event_log_and_topic: when you want to close the cluster event persistence or delete the cluster, you can use this parameter to determine whether the event persistence log set and topic created by default will be deleted.
        :param _builtins.str log_set_id: Specify id of existing CLS log set, or auto create a new set by leave it empty.
        :param _builtins.str topic_id: Specify id of existing CLS log topic, or auto create a new topic by leave it empty.
        """
        pulumi.set(__self__, "enabled", enabled)
        if delete_event_log_and_topic is not None:
            pulumi.set(__self__, "delete_event_log_and_topic", delete_event_log_and_topic)
        if log_set_id is not None:
            pulumi.set(__self__, "log_set_id", log_set_id)
        if topic_id is not None:
            pulumi.set(__self__, "topic_id", topic_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specify weather the Event Persistence enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="deleteEventLogAndTopic")
    def delete_event_log_and_topic(self) -> Optional[_builtins.bool]:
        """
        when you want to close the cluster event persistence or delete the cluster, you can use this parameter to determine whether the event persistence log set and topic created by default will be deleted.
        """
        return pulumi.get(self, "delete_event_log_and_topic")

    @_builtins.property
    @pulumi.getter(name="logSetId")
    def log_set_id(self) -> Optional[_builtins.str]:
        """
        Specify id of existing CLS log set, or auto create a new set by leave it empty.
        """
        return pulumi.get(self, "log_set_id")

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> Optional[_builtins.str]:
        """
        Specify id of existing CLS log topic, or auto create a new topic by leave it empty.
        """
        return pulumi.get(self, "topic_id")


@pulumi.output_type
class ClusterExistInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredPodNumbers":
            suggest = "desired_pod_numbers"
        elif key == "instancesPara":
            suggest = "instances_para"
        elif key == "nodeRole":
            suggest = "node_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExistInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExistInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExistInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired_pod_numbers: Optional[Sequence[_builtins.int]] = None,
                 instances_para: Optional['outputs.ClusterExistInstanceInstancesPara'] = None,
                 node_role: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.int] desired_pod_numbers: Custom mode cluster, you can specify the number of pods for each node. corresponding to the existed_instances_para.instance_ids parameter.
        :param 'ClusterExistInstanceInstancesParaArgs' instances_para: Reinstallation parameters of an existing instance.
        :param _builtins.str node_role: Role of existed node. Value: MASTER_ETCD or WORKER.
        """
        if desired_pod_numbers is not None:
            pulumi.set(__self__, "desired_pod_numbers", desired_pod_numbers)
        if instances_para is not None:
            pulumi.set(__self__, "instances_para", instances_para)
        if node_role is not None:
            pulumi.set(__self__, "node_role", node_role)

    @_builtins.property
    @pulumi.getter(name="desiredPodNumbers")
    def desired_pod_numbers(self) -> Optional[Sequence[_builtins.int]]:
        """
        Custom mode cluster, you can specify the number of pods for each node. corresponding to the existed_instances_para.instance_ids parameter.
        """
        return pulumi.get(self, "desired_pod_numbers")

    @_builtins.property
    @pulumi.getter(name="instancesPara")
    def instances_para(self) -> Optional['outputs.ClusterExistInstanceInstancesPara']:
        """
        Reinstallation parameters of an existing instance.
        """
        return pulumi.get(self, "instances_para")

    @_builtins.property
    @pulumi.getter(name="nodeRole")
    def node_role(self) -> Optional[_builtins.str]:
        """
        Role of existed node. Value: MASTER_ETCD or WORKER.
        """
        return pulumi.get(self, "node_role")


@pulumi.output_type
class ClusterExistInstanceInstancesPara(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceIds":
            suggest = "instance_ids"
        elif key == "enhancedMonitorService":
            suggest = "enhanced_monitor_service"
        elif key == "enhancedSecurityService":
            suggest = "enhanced_security_service"
        elif key == "keyIds":
            suggest = "key_ids"
        elif key == "masterConfig":
            suggest = "master_config"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExistInstanceInstancesPara. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExistInstanceInstancesPara.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExistInstanceInstancesPara.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_ids: Sequence[_builtins.str],
                 enhanced_monitor_service: Optional[_builtins.bool] = None,
                 enhanced_security_service: Optional[_builtins.bool] = None,
                 key_ids: Optional[Sequence[_builtins.str]] = None,
                 master_config: Optional['outputs.ClusterExistInstanceInstancesParaMasterConfig'] = None,
                 password: Optional[_builtins.str] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] instance_ids: Cluster IDs.
        :param _builtins.bool enhanced_monitor_service: To specify whether to enable cloud monitor service. Default is TRUE.
        :param _builtins.bool enhanced_security_service: To specify whether to enable cloud security service. Default is TRUE.
        :param Sequence[_builtins.str] key_ids: ID list of keys, should be set if `password` not set.
        :param 'ClusterExistInstanceInstancesParaMasterConfigArgs' master_config: Advanced Node Settings. commonly used to attach existing instances.
        :param _builtins.str password: Password to access, should be set if `key_ids` not set.
        :param Sequence[_builtins.str] security_group_ids: Security groups to which a CVM instance belongs.
        """
        pulumi.set(__self__, "instance_ids", instance_ids)
        if enhanced_monitor_service is not None:
            pulumi.set(__self__, "enhanced_monitor_service", enhanced_monitor_service)
        if enhanced_security_service is not None:
            pulumi.set(__self__, "enhanced_security_service", enhanced_security_service)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if master_config is not None:
            pulumi.set(__self__, "master_config", master_config)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Sequence[_builtins.str]:
        """
        Cluster IDs.
        """
        return pulumi.get(self, "instance_ids")

    @_builtins.property
    @pulumi.getter(name="enhancedMonitorService")
    def enhanced_monitor_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud monitor service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_monitor_service")

    @_builtins.property
    @pulumi.getter(name="enhancedSecurityService")
    def enhanced_security_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud security service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_security_service")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        ID list of keys, should be set if `password` not set.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter(name="masterConfig")
    def master_config(self) -> Optional['outputs.ClusterExistInstanceInstancesParaMasterConfig']:
        """
        Advanced Node Settings. commonly used to attach existing instances.
        """
        return pulumi.get(self, "master_config")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password to access, should be set if `key_ids` not set.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security groups to which a CVM instance belongs.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class ClusterExistInstanceInstancesParaMasterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDisk":
            suggest = "data_disk"
        elif key == "desiredPodNumber":
            suggest = "desired_pod_number"
        elif key == "dockerGraphPath":
            suggest = "docker_graph_path"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "gpuArgs":
            suggest = "gpu_args"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "userScript":
            suggest = "user_script"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExistInstanceInstancesParaMasterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExistInstanceInstancesParaMasterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExistInstanceInstancesParaMasterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk: Optional['outputs.ClusterExistInstanceInstancesParaMasterConfigDataDisk'] = None,
                 desired_pod_number: Optional[_builtins.int] = None,
                 docker_graph_path: Optional[_builtins.str] = None,
                 extra_args: Optional['outputs.ClusterExistInstanceInstancesParaMasterConfigExtraArgs'] = None,
                 gpu_args: Optional['outputs.ClusterExistInstanceInstancesParaMasterConfigGpuArgs'] = None,
                 labels: Optional[Sequence['outputs.ClusterExistInstanceInstancesParaMasterConfigLabel']] = None,
                 mount_target: Optional[_builtins.str] = None,
                 taints: Optional[Sequence['outputs.ClusterExistInstanceInstancesParaMasterConfigTaint']] = None,
                 unschedulable: Optional[_builtins.int] = None,
                 user_script: Optional[_builtins.str] = None):
        """
        :param 'ClusterExistInstanceInstancesParaMasterConfigDataDiskArgs' data_disk: Configurations of data disk.
        :param _builtins.int desired_pod_number: Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        :param _builtins.str docker_graph_path: Docker graph path. Default is `/var/lib/docker`.
        :param 'ClusterExistInstanceInstancesParaMasterConfigExtraArgsArgs' extra_args: Custom parameter information related to the node. This is a white-list parameter.
        :param 'ClusterExistInstanceInstancesParaMasterConfigGpuArgsArgs' gpu_args: GPU driver parameters.
        :param Sequence['ClusterExistInstanceInstancesParaMasterConfigLabelArgs'] labels: Node label list.
        :param _builtins.str mount_target: Mount target. Default is not mounting.
        :param Sequence['ClusterExistInstanceInstancesParaMasterConfigTaintArgs'] taints: Node taint.
        :param _builtins.int unschedulable: Set whether the joined nodes participate in scheduling, with a default value of 0, indicating participation in scheduling; Non 0 means not participating in scheduling.
        :param _builtins.str user_script: User script encoded in base64, which will be executed after the k8s component runs. The user needs to ensure the script's reentrant and retry logic. The script and its generated log files can be viewed in the node path /data/ccs_userscript/. If the node needs to be initialized before joining the schedule, it can be used in conjunction with the `unschedulable` parameter. After the final initialization of the userScript is completed, add the command "kubectl uncordon nodename --kubeconfig=/root/.kube/config" to add the node to the schedule.
        """
        if data_disk is not None:
            pulumi.set(__self__, "data_disk", data_disk)
        if desired_pod_number is not None:
            pulumi.set(__self__, "desired_pod_number", desired_pod_number)
        if docker_graph_path is not None:
            pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if gpu_args is not None:
            pulumi.set(__self__, "gpu_args", gpu_args)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if unschedulable is not None:
            pulumi.set(__self__, "unschedulable", unschedulable)
        if user_script is not None:
            pulumi.set(__self__, "user_script", user_script)

    @_builtins.property
    @pulumi.getter(name="dataDisk")
    def data_disk(self) -> Optional['outputs.ClusterExistInstanceInstancesParaMasterConfigDataDisk']:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disk")

    @_builtins.property
    @pulumi.getter(name="desiredPodNumber")
    def desired_pod_number(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        """
        return pulumi.get(self, "desired_pod_number")

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    def docker_graph_path(self) -> Optional[_builtins.str]:
        """
        Docker graph path. Default is `/var/lib/docker`.
        """
        return pulumi.get(self, "docker_graph_path")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional['outputs.ClusterExistInstanceInstancesParaMasterConfigExtraArgs']:
        """
        Custom parameter information related to the node. This is a white-list parameter.
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="gpuArgs")
    def gpu_args(self) -> Optional['outputs.ClusterExistInstanceInstancesParaMasterConfigGpuArgs']:
        """
        GPU driver parameters.
        """
        return pulumi.get(self, "gpu_args")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.ClusterExistInstanceInstancesParaMasterConfigLabel']]:
        """
        Node label list.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target. Default is not mounting.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.ClusterExistInstanceInstancesParaMasterConfigTaint']]:
        """
        Node taint.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter
    def unschedulable(self) -> Optional[_builtins.int]:
        """
        Set whether the joined nodes participate in scheduling, with a default value of 0, indicating participation in scheduling; Non 0 means not participating in scheduling.
        """
        return pulumi.get(self, "unschedulable")

    @_builtins.property
    @pulumi.getter(name="userScript")
    def user_script(self) -> Optional[_builtins.str]:
        """
        User script encoded in base64, which will be executed after the k8s component runs. The user needs to ensure the script's reentrant and retry logic. The script and its generated log files can be viewed in the node path /data/ccs_userscript/. If the node needs to be initialized before joining the schedule, it can be used in conjunction with the `unschedulable` parameter. After the final initialization of the userScript is completed, add the command "kubectl uncordon nodename --kubeconfig=/root/.kube/config" to add the node to the schedule.
        """
        return pulumi.get(self, "user_script")


@pulumi.output_type
class ClusterExistInstanceInstancesParaMasterConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "mountTarget":
            suggest = "mount_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExistInstanceInstancesParaMasterConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExistInstanceInstancesParaMasterConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExistInstanceInstancesParaMasterConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 file_system: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str mount_target: Mount target.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class ClusterExistInstanceInstancesParaMasterConfigExtraArgs(dict):
    def __init__(__self__, *,
                 kubelets: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] kubelets: Kubelet custom parameter. The parameter format is ["k1=v1", "k1=v2"].
        """
        if kubelets is not None:
            pulumi.set(__self__, "kubelets", kubelets)

    @_builtins.property
    @pulumi.getter
    def kubelets(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kubelet custom parameter. The parameter format is ["k1=v1", "k1=v2"].
        """
        return pulumi.get(self, "kubelets")


@pulumi.output_type
class ClusterExistInstanceInstancesParaMasterConfigGpuArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDriver":
            suggest = "custom_driver"
        elif key == "migEnable":
            suggest = "mig_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExistInstanceInstancesParaMasterConfigGpuArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExistInstanceInstancesParaMasterConfigGpuArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExistInstanceInstancesParaMasterConfigGpuArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cuda: Optional[Mapping[str, _builtins.str]] = None,
                 cudnn: Optional[Mapping[str, _builtins.str]] = None,
                 custom_driver: Optional[Mapping[str, _builtins.str]] = None,
                 driver: Optional[Mapping[str, _builtins.str]] = None,
                 mig_enable: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] cuda: CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param Mapping[str, _builtins.str] cudnn: cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        :param Mapping[str, _builtins.str] custom_driver: Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        :param Mapping[str, _builtins.str] driver: GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param _builtins.bool mig_enable: Whether to enable MIG.
        """
        if cuda is not None:
            pulumi.set(__self__, "cuda", cuda)
        if cudnn is not None:
            pulumi.set(__self__, "cudnn", cudnn)
        if custom_driver is not None:
            pulumi.set(__self__, "custom_driver", custom_driver)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if mig_enable is not None:
            pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cuda(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "cuda")

    @_builtins.property
    @pulumi.getter
    def cudnn(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        """
        return pulumi.get(self, "cudnn")

    @_builtins.property
    @pulumi.getter(name="customDriver")
    def custom_driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        """
        return pulumi.get(self, "custom_driver")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable MIG.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class ClusterExistInstanceInstancesParaMasterConfigLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of map.
        :param _builtins.str value: Value of map.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of map.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of map.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterExistInstanceInstancesParaMasterConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Effect of the taint.
        :param _builtins.str key: Key of the taint.
        :param _builtins.str value: Value of the taint.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterExtensionAddon(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 param: _builtins.str):
        """
        :param _builtins.str name: Add-on name.
        :param _builtins.str param: Parameter of the add-on resource object in JSON string format, please check the example at the top of page for reference.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "param", param)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Add-on name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def param(self) -> _builtins.str:
        """
        Parameter of the add-on resource object in JSON string format, please check the example at the top of page for reference.
        """
        return pulumi.get(self, "param")


@pulumi.output_type
class ClusterLogAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeletRootDir":
            suggest = "kubelet_root_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLogAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLogAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLogAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 kubelet_root_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Whether the log agent enabled.
        :param _builtins.str kubelet_root_dir: Kubelet root directory as the literal.
        """
        pulumi.set(__self__, "enabled", enabled)
        if kubelet_root_dir is not None:
            pulumi.set(__self__, "kubelet_root_dir", kubelet_root_dir)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the log agent enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="kubeletRootDir")
    def kubelet_root_dir(self) -> Optional[_builtins.str]:
        """
        Kubelet root directory as the literal.
        """
        return pulumi.get(self, "kubelet_root_dir")


@pulumi.output_type
class ClusterMasterAttachmentExtraArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeApiServers":
            suggest = "kube_api_servers"
        elif key == "kubeControllerManagers":
            suggest = "kube_controller_managers"
        elif key == "kubeSchedulers":
            suggest = "kube_schedulers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterAttachmentExtraArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterAttachmentExtraArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterAttachmentExtraArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etcds: Optional[Sequence[_builtins.str]] = None,
                 kube_api_servers: Optional[Sequence[_builtins.str]] = None,
                 kube_controller_managers: Optional[Sequence[_builtins.str]] = None,
                 kube_schedulers: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] etcds: etcd custom parameters. Only supports independent clusters.
        :param Sequence[_builtins.str] kube_api_servers: Kube apiserver custom parameters. The parameter format is ["k1=v1", "k1=v2"].
        :param Sequence[_builtins.str] kube_controller_managers: Kube controller manager custom parameters.
        :param Sequence[_builtins.str] kube_schedulers: kube scheduler custom parameters.
        """
        if etcds is not None:
            pulumi.set(__self__, "etcds", etcds)
        if kube_api_servers is not None:
            pulumi.set(__self__, "kube_api_servers", kube_api_servers)
        if kube_controller_managers is not None:
            pulumi.set(__self__, "kube_controller_managers", kube_controller_managers)
        if kube_schedulers is not None:
            pulumi.set(__self__, "kube_schedulers", kube_schedulers)

    @_builtins.property
    @pulumi.getter
    def etcds(self) -> Optional[Sequence[_builtins.str]]:
        """
        etcd custom parameters. Only supports independent clusters.
        """
        return pulumi.get(self, "etcds")

    @_builtins.property
    @pulumi.getter(name="kubeApiServers")
    def kube_api_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kube apiserver custom parameters. The parameter format is ["k1=v1", "k1=v2"].
        """
        return pulumi.get(self, "kube_api_servers")

    @_builtins.property
    @pulumi.getter(name="kubeControllerManagers")
    def kube_controller_managers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kube controller manager custom parameters.
        """
        return pulumi.get(self, "kube_controller_managers")

    @_builtins.property
    @pulumi.getter(name="kubeSchedulers")
    def kube_schedulers(self) -> Optional[Sequence[_builtins.str]]:
        """
        kube scheduler custom parameters.
        """
        return pulumi.get(self, "kube_schedulers")


@pulumi.output_type
class ClusterMasterAttachmentMasterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDisk":
            suggest = "data_disk"
        elif key == "desiredPodNumber":
            suggest = "desired_pod_number"
        elif key == "dockerGraphPath":
            suggest = "docker_graph_path"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "gpuArgs":
            suggest = "gpu_args"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "userScript":
            suggest = "user_script"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterAttachmentMasterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterAttachmentMasterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterAttachmentMasterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk: Optional['outputs.ClusterMasterAttachmentMasterConfigDataDisk'] = None,
                 desired_pod_number: Optional[_builtins.int] = None,
                 docker_graph_path: Optional[_builtins.str] = None,
                 extra_args: Optional['outputs.ClusterMasterAttachmentMasterConfigExtraArgs'] = None,
                 gpu_args: Optional['outputs.ClusterMasterAttachmentMasterConfigGpuArgs'] = None,
                 labels: Optional[Sequence['outputs.ClusterMasterAttachmentMasterConfigLabel']] = None,
                 mount_target: Optional[_builtins.str] = None,
                 taints: Optional[Sequence['outputs.ClusterMasterAttachmentMasterConfigTaint']] = None,
                 unschedulable: Optional[_builtins.int] = None,
                 user_script: Optional[_builtins.str] = None):
        """
        :param 'ClusterMasterAttachmentMasterConfigDataDiskArgs' data_disk: Configurations of data disk.
        :param _builtins.int desired_pod_number: Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        :param _builtins.str docker_graph_path: Docker graph path. Default is `/var/lib/docker`.
        :param 'ClusterMasterAttachmentMasterConfigExtraArgsArgs' extra_args: Custom parameter information related to the node. This is a white-list parameter.
        :param 'ClusterMasterAttachmentMasterConfigGpuArgsArgs' gpu_args: GPU driver parameters.
        :param Sequence['ClusterMasterAttachmentMasterConfigLabelArgs'] labels: Node label list.
        :param _builtins.str mount_target: Mount target. Default is not mounting.
        :param Sequence['ClusterMasterAttachmentMasterConfigTaintArgs'] taints: Node taint.
        :param _builtins.int unschedulable: Set whether the joined nodes participate in scheduling, with a default value of 0, indicating participation in scheduling; Non 0 means not participating in scheduling.
        :param _builtins.str user_script: User script encoded in base64, which will be executed after the k8s component runs. The user needs to ensure the script's reentrant and retry logic. The script and its generated log files can be viewed in the node path /data/ccs_userscript/. If the node needs to be initialized before joining the schedule, it can be used in conjunction with the `unschedulable` parameter. After the final initialization of the userScript is completed, add the command "kubectl uncordon nodename --kubeconfig=/root/.kube/config" to add the node to the schedule.
        """
        if data_disk is not None:
            pulumi.set(__self__, "data_disk", data_disk)
        if desired_pod_number is not None:
            pulumi.set(__self__, "desired_pod_number", desired_pod_number)
        if docker_graph_path is not None:
            pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if gpu_args is not None:
            pulumi.set(__self__, "gpu_args", gpu_args)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if unschedulable is not None:
            pulumi.set(__self__, "unschedulable", unschedulable)
        if user_script is not None:
            pulumi.set(__self__, "user_script", user_script)

    @_builtins.property
    @pulumi.getter(name="dataDisk")
    def data_disk(self) -> Optional['outputs.ClusterMasterAttachmentMasterConfigDataDisk']:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disk")

    @_builtins.property
    @pulumi.getter(name="desiredPodNumber")
    def desired_pod_number(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        """
        return pulumi.get(self, "desired_pod_number")

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    def docker_graph_path(self) -> Optional[_builtins.str]:
        """
        Docker graph path. Default is `/var/lib/docker`.
        """
        return pulumi.get(self, "docker_graph_path")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional['outputs.ClusterMasterAttachmentMasterConfigExtraArgs']:
        """
        Custom parameter information related to the node. This is a white-list parameter.
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="gpuArgs")
    def gpu_args(self) -> Optional['outputs.ClusterMasterAttachmentMasterConfigGpuArgs']:
        """
        GPU driver parameters.
        """
        return pulumi.get(self, "gpu_args")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.ClusterMasterAttachmentMasterConfigLabel']]:
        """
        Node label list.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target. Default is not mounting.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.ClusterMasterAttachmentMasterConfigTaint']]:
        """
        Node taint.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter
    def unschedulable(self) -> Optional[_builtins.int]:
        """
        Set whether the joined nodes participate in scheduling, with a default value of 0, indicating participation in scheduling; Non 0 means not participating in scheduling.
        """
        return pulumi.get(self, "unschedulable")

    @_builtins.property
    @pulumi.getter(name="userScript")
    def user_script(self) -> Optional[_builtins.str]:
        """
        User script encoded in base64, which will be executed after the k8s component runs. The user needs to ensure the script's reentrant and retry logic. The script and its generated log files can be viewed in the node path /data/ccs_userscript/. If the node needs to be initialized before joining the schedule, it can be used in conjunction with the `unschedulable` parameter. After the final initialization of the userScript is completed, add the command "kubectl uncordon nodename --kubeconfig=/root/.kube/config" to add the node to the schedule.
        """
        return pulumi.get(self, "user_script")


@pulumi.output_type
class ClusterMasterAttachmentMasterConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "mountTarget":
            suggest = "mount_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterAttachmentMasterConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterAttachmentMasterConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterAttachmentMasterConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 file_system: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str mount_target: Mount target.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class ClusterMasterAttachmentMasterConfigExtraArgs(dict):
    def __init__(__self__, *,
                 kubelets: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] kubelets: Kubelet custom parameter. The parameter format is ["k1=v1", "k1=v2"].
        """
        if kubelets is not None:
            pulumi.set(__self__, "kubelets", kubelets)

    @_builtins.property
    @pulumi.getter
    def kubelets(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kubelet custom parameter. The parameter format is ["k1=v1", "k1=v2"].
        """
        return pulumi.get(self, "kubelets")


@pulumi.output_type
class ClusterMasterAttachmentMasterConfigGpuArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDriver":
            suggest = "custom_driver"
        elif key == "migEnable":
            suggest = "mig_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterAttachmentMasterConfigGpuArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterAttachmentMasterConfigGpuArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterAttachmentMasterConfigGpuArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cuda: Optional[Mapping[str, _builtins.str]] = None,
                 cudnn: Optional[Mapping[str, _builtins.str]] = None,
                 custom_driver: Optional[Mapping[str, _builtins.str]] = None,
                 driver: Optional[Mapping[str, _builtins.str]] = None,
                 mig_enable: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] cuda: CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param Mapping[str, _builtins.str] cudnn: cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        :param Mapping[str, _builtins.str] custom_driver: Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        :param Mapping[str, _builtins.str] driver: GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param _builtins.bool mig_enable: Whether to enable MIG.
        """
        if cuda is not None:
            pulumi.set(__self__, "cuda", cuda)
        if cudnn is not None:
            pulumi.set(__self__, "cudnn", cudnn)
        if custom_driver is not None:
            pulumi.set(__self__, "custom_driver", custom_driver)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if mig_enable is not None:
            pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cuda(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "cuda")

    @_builtins.property
    @pulumi.getter
    def cudnn(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        """
        return pulumi.get(self, "cudnn")

    @_builtins.property
    @pulumi.getter(name="customDriver")
    def custom_driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        """
        return pulumi.get(self, "custom_driver")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable MIG.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class ClusterMasterAttachmentMasterConfigLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of map.
        :param _builtins.str value: Value of map.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of map.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of map.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterMasterAttachmentMasterConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Effect of the taint.
        :param _builtins.str key: Key of the taint.
        :param _builtins.str value: Value of the taint.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterMasterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "bandwidthPackageId":
            suggest = "bandwidth_package_id"
        elif key == "camRoleName":
            suggest = "cam_role_name"
        elif key == "dataDisks":
            suggest = "data_disks"
        elif key == "desiredPodNum":
            suggest = "desired_pod_num"
        elif key == "disasterRecoverGroupIds":
            suggest = "disaster_recover_group_ids"
        elif key == "enhancedMonitorService":
            suggest = "enhanced_monitor_service"
        elif key == "enhancedSecurityService":
            suggest = "enhanced_security_service"
        elif key == "hpcClusterId":
            suggest = "hpc_cluster_id"
        elif key == "imgId":
            suggest = "img_id"
        elif key == "instanceChargeType":
            suggest = "instance_charge_type"
        elif key == "instanceChargeTypePrepaidPeriod":
            suggest = "instance_charge_type_prepaid_period"
        elif key == "instanceChargeTypePrepaidRenewFlag":
            suggest = "instance_charge_type_prepaid_renew_flag"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "internetChargeType":
            suggest = "internet_charge_type"
        elif key == "internetMaxBandwidthOut":
            suggest = "internet_max_bandwidth_out"
        elif key == "keyIds":
            suggest = "key_ids"
        elif key == "publicIpAssigned":
            suggest = "public_ip_assigned"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "systemDiskSize":
            suggest = "system_disk_size"
        elif key == "systemDiskType":
            suggest = "system_disk_type"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: _builtins.str,
                 subnet_id: _builtins.str,
                 availability_zone: Optional[_builtins.str] = None,
                 bandwidth_package_id: Optional[_builtins.str] = None,
                 cam_role_name: Optional[_builtins.str] = None,
                 count: Optional[_builtins.int] = None,
                 data_disks: Optional[Sequence['outputs.ClusterMasterConfigDataDisk']] = None,
                 desired_pod_num: Optional[_builtins.int] = None,
                 disaster_recover_group_ids: Optional[_builtins.str] = None,
                 enhanced_monitor_service: Optional[_builtins.bool] = None,
                 enhanced_security_service: Optional[_builtins.bool] = None,
                 hostname: Optional[_builtins.str] = None,
                 hpc_cluster_id: Optional[_builtins.str] = None,
                 img_id: Optional[_builtins.str] = None,
                 instance_charge_type: Optional[_builtins.str] = None,
                 instance_charge_type_prepaid_period: Optional[_builtins.int] = None,
                 instance_charge_type_prepaid_renew_flag: Optional[_builtins.str] = None,
                 instance_name: Optional[_builtins.str] = None,
                 internet_charge_type: Optional[_builtins.str] = None,
                 internet_max_bandwidth_out: Optional[_builtins.int] = None,
                 key_ids: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 public_ip_assigned: Optional[_builtins.bool] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 system_disk_size: Optional[_builtins.int] = None,
                 system_disk_type: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_type: Specified types of CVM instance.
        :param _builtins.str subnet_id: Private network ID.
        :param _builtins.str availability_zone: Indicates which availability zone will be used.
        :param _builtins.str bandwidth_package_id: bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        :param _builtins.str cam_role_name: CAM role name authorized to access.
        :param _builtins.int count: Number of cvm.
        :param Sequence['ClusterMasterConfigDataDiskArgs'] data_disks: Configurations of data disk.
        :param _builtins.int desired_pod_num: Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desired_pod_num` or none.
        :param _builtins.str disaster_recover_group_ids: Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
        :param _builtins.bool enhanced_monitor_service: To specify whether to enable cloud monitor service. Default is TRUE.
        :param _builtins.bool enhanced_security_service: To specify whether to enable cloud security service. Default is TRUE.
        :param _builtins.str hostname: The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
        :param _builtins.str hpc_cluster_id: Id of cvm hpc cluster.
        :param _builtins.str img_id: The valid image id, format of img-xxx. Note: `img_id` will be replaced with the image corresponding to TKE `cluster_os`.
        :param _builtins.str instance_charge_type: The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
        :param _builtins.int instance_charge_type_prepaid_period: The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        :param _builtins.str instance_charge_type_prepaid_renew_flag: Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        :param _builtins.str instance_name: Name of the CVMs.
        :param _builtins.str internet_charge_type: Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
        :param _builtins.int internet_max_bandwidth_out: Max bandwidth of Internet access in Mbps. Default is 0.
        :param _builtins.str key_ids: ID list of keys, should be set if `password` not set.
        :param _builtins.str password: Password to access, should be set if `key_ids` not set.
        :param _builtins.bool public_ip_assigned: Specify whether to assign an Internet IP address.
        :param Sequence[_builtins.str] security_group_ids: Security groups to which a CVM instance belongs.
        :param _builtins.int system_disk_size: Volume of system disk in GB. Default is `50`.
        :param _builtins.str system_disk_type: System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
        :param _builtins.str user_data: ase64-encoded User Data text, the length limit is 16KB.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if cam_role_name is not None:
            pulumi.set(__self__, "cam_role_name", cam_role_name)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if desired_pod_num is not None:
            pulumi.set(__self__, "desired_pod_num", desired_pod_num)
        if disaster_recover_group_ids is not None:
            pulumi.set(__self__, "disaster_recover_group_ids", disaster_recover_group_ids)
        if enhanced_monitor_service is not None:
            pulumi.set(__self__, "enhanced_monitor_service", enhanced_monitor_service)
        if enhanced_security_service is not None:
            pulumi.set(__self__, "enhanced_security_service", enhanced_security_service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hpc_cluster_id is not None:
            pulumi.set(__self__, "hpc_cluster_id", hpc_cluster_id)
        if img_id is not None:
            pulumi.set(__self__, "img_id", img_id)
        if instance_charge_type is not None:
            pulumi.set(__self__, "instance_charge_type", instance_charge_type)
        if instance_charge_type_prepaid_period is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_period", instance_charge_type_prepaid_period)
        if instance_charge_type_prepaid_renew_flag is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_renew_flag", instance_charge_type_prepaid_renew_flag)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if system_disk_size is not None:
            pulumi.set(__self__, "system_disk_size", system_disk_size)
        if system_disk_type is not None:
            pulumi.set(__self__, "system_disk_type", system_disk_type)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        """
        Specified types of CVM instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Private network ID.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        Indicates which availability zone will be used.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[_builtins.str]:
        """
        bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="camRoleName")
    def cam_role_name(self) -> Optional[_builtins.str]:
        """
        CAM role name authorized to access.
        """
        return pulumi.get(self, "cam_role_name")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of cvm.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.ClusterMasterConfigDataDisk']]:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="desiredPodNum")
    def desired_pod_num(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desired_pod_num` or none.
        """
        return pulumi.get(self, "desired_pod_num")

    @_builtins.property
    @pulumi.getter(name="disasterRecoverGroupIds")
    def disaster_recover_group_ids(self) -> Optional[_builtins.str]:
        """
        Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
        """
        return pulumi.get(self, "disaster_recover_group_ids")

    @_builtins.property
    @pulumi.getter(name="enhancedMonitorService")
    def enhanced_monitor_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud monitor service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_monitor_service")

    @_builtins.property
    @pulumi.getter(name="enhancedSecurityService")
    def enhanced_security_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud security service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_security_service")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="hpcClusterId")
    def hpc_cluster_id(self) -> Optional[_builtins.str]:
        """
        Id of cvm hpc cluster.
        """
        return pulumi.get(self, "hpc_cluster_id")

    @_builtins.property
    @pulumi.getter(name="imgId")
    def img_id(self) -> Optional[_builtins.str]:
        """
        The valid image id, format of img-xxx. Note: `img_id` will be replaced with the image corresponding to TKE `cluster_os`.
        """
        return pulumi.get(self, "img_id")

    @_builtins.property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> Optional[_builtins.str]:
        """
        The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
        """
        return pulumi.get(self, "instance_charge_type")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidPeriod")
    def instance_charge_type_prepaid_period(self) -> Optional[_builtins.int]:
        """
        The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_period")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidRenewFlag")
    def instance_charge_type_prepaid_renew_flag(self) -> Optional[_builtins.str]:
        """
        Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_renew_flag")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[_builtins.str]:
        """
        Name of the CVMs.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[_builtins.str]:
        """
        Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
        """
        return pulumi.get(self, "internet_charge_type")

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[_builtins.int]:
        """
        Max bandwidth of Internet access in Mbps. Default is 0.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[_builtins.str]:
        """
        ID list of keys, should be set if `password` not set.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password to access, should be set if `key_ids` not set.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[_builtins.bool]:
        """
        Specify whether to assign an Internet IP address.
        """
        return pulumi.get(self, "public_ip_assigned")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security groups to which a CVM instance belongs.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="systemDiskSize")
    def system_disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of system disk in GB. Default is `50`.
        """
        return pulumi.get(self, "system_disk_size")

    @_builtins.property
    @pulumi.getter(name="systemDiskType")
    def system_disk_type(self) -> Optional[_builtins.str]:
        """
        System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
        """
        return pulumi.get(self, "system_disk_type")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        ase64-encoded User Data text, the length limit is 16KB.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class ClusterMasterConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.bool] = None,
                 file_system: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        :param _builtins.bool encrypt: Indicates whether to encrypt data disk, default `false`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str kms_key_id: ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
        :param _builtins.str mount_target: Mount target.
        :param _builtins.str snapshot_id: Data disk snapshot ID.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to encrypt data disk, default `false`.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Data disk snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class ClusterNodePoolGlobalConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDaemonSetsUtilization":
            suggest = "ignore_daemon_sets_utilization"
        elif key == "isScaleInEnabled":
            suggest = "is_scale_in_enabled"
        elif key == "maxConcurrentScaleIn":
            suggest = "max_concurrent_scale_in"
        elif key == "scaleInDelay":
            suggest = "scale_in_delay"
        elif key == "scaleInUnneededTime":
            suggest = "scale_in_unneeded_time"
        elif key == "scaleInUtilizationThreshold":
            suggest = "scale_in_utilization_threshold"
        elif key == "skipNodesWithLocalStorage":
            suggest = "skip_nodes_with_local_storage"
        elif key == "skipNodesWithSystemPods":
            suggest = "skip_nodes_with_system_pods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodePoolGlobalConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodePoolGlobalConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodePoolGlobalConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expander: Optional[_builtins.str] = None,
                 ignore_daemon_sets_utilization: Optional[_builtins.bool] = None,
                 is_scale_in_enabled: Optional[_builtins.bool] = None,
                 max_concurrent_scale_in: Optional[_builtins.int] = None,
                 scale_in_delay: Optional[_builtins.int] = None,
                 scale_in_unneeded_time: Optional[_builtins.int] = None,
                 scale_in_utilization_threshold: Optional[_builtins.int] = None,
                 skip_nodes_with_local_storage: Optional[_builtins.bool] = None,
                 skip_nodes_with_system_pods: Optional[_builtins.bool] = None):
        """
        :param _builtins.str expander: Indicates which scale-out method will be used when there are multiple scaling groups. Valid values: `random` - select a random scaling group, `most-pods` - select the scaling group that can schedule the most pods, `least-waste` - select the scaling group that can ensure the fewest remaining resources after Pod scheduling.
        :param _builtins.bool ignore_daemon_sets_utilization: Whether to ignore DaemonSet pods by default when calculating resource usage.
        :param _builtins.bool is_scale_in_enabled: Indicates whether to enable scale-in.
        :param _builtins.int max_concurrent_scale_in: Max concurrent scale-in volume.
        :param _builtins.int scale_in_delay: Number of minutes after cluster scale-out when the system starts judging whether to perform scale-in.
        :param _builtins.int scale_in_unneeded_time: Number of consecutive minutes of idleness after which the node is subject to scale-in.
        :param _builtins.int scale_in_utilization_threshold: Percentage of node resource usage below which the node is considered to be idle.
        :param _builtins.bool skip_nodes_with_local_storage: During scale-in, ignore nodes with local storage pods.
        :param _builtins.bool skip_nodes_with_system_pods: During scale-in, ignore nodes with pods in the kube-system namespace that are not managed by DaemonSet.
        """
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if ignore_daemon_sets_utilization is not None:
            pulumi.set(__self__, "ignore_daemon_sets_utilization", ignore_daemon_sets_utilization)
        if is_scale_in_enabled is not None:
            pulumi.set(__self__, "is_scale_in_enabled", is_scale_in_enabled)
        if max_concurrent_scale_in is not None:
            pulumi.set(__self__, "max_concurrent_scale_in", max_concurrent_scale_in)
        if scale_in_delay is not None:
            pulumi.set(__self__, "scale_in_delay", scale_in_delay)
        if scale_in_unneeded_time is not None:
            pulumi.set(__self__, "scale_in_unneeded_time", scale_in_unneeded_time)
        if scale_in_utilization_threshold is not None:
            pulumi.set(__self__, "scale_in_utilization_threshold", scale_in_utilization_threshold)
        if skip_nodes_with_local_storage is not None:
            pulumi.set(__self__, "skip_nodes_with_local_storage", skip_nodes_with_local_storage)
        if skip_nodes_with_system_pods is not None:
            pulumi.set(__self__, "skip_nodes_with_system_pods", skip_nodes_with_system_pods)

    @_builtins.property
    @pulumi.getter
    def expander(self) -> Optional[_builtins.str]:
        """
        Indicates which scale-out method will be used when there are multiple scaling groups. Valid values: `random` - select a random scaling group, `most-pods` - select the scaling group that can schedule the most pods, `least-waste` - select the scaling group that can ensure the fewest remaining resources after Pod scheduling.
        """
        return pulumi.get(self, "expander")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSetsUtilization")
    def ignore_daemon_sets_utilization(self) -> Optional[_builtins.bool]:
        """
        Whether to ignore DaemonSet pods by default when calculating resource usage.
        """
        return pulumi.get(self, "ignore_daemon_sets_utilization")

    @_builtins.property
    @pulumi.getter(name="isScaleInEnabled")
    def is_scale_in_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to enable scale-in.
        """
        return pulumi.get(self, "is_scale_in_enabled")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentScaleIn")
    def max_concurrent_scale_in(self) -> Optional[_builtins.int]:
        """
        Max concurrent scale-in volume.
        """
        return pulumi.get(self, "max_concurrent_scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleInDelay")
    def scale_in_delay(self) -> Optional[_builtins.int]:
        """
        Number of minutes after cluster scale-out when the system starts judging whether to perform scale-in.
        """
        return pulumi.get(self, "scale_in_delay")

    @_builtins.property
    @pulumi.getter(name="scaleInUnneededTime")
    def scale_in_unneeded_time(self) -> Optional[_builtins.int]:
        """
        Number of consecutive minutes of idleness after which the node is subject to scale-in.
        """
        return pulumi.get(self, "scale_in_unneeded_time")

    @_builtins.property
    @pulumi.getter(name="scaleInUtilizationThreshold")
    def scale_in_utilization_threshold(self) -> Optional[_builtins.int]:
        """
        Percentage of node resource usage below which the node is considered to be idle.
        """
        return pulumi.get(self, "scale_in_utilization_threshold")

    @_builtins.property
    @pulumi.getter(name="skipNodesWithLocalStorage")
    def skip_nodes_with_local_storage(self) -> Optional[_builtins.bool]:
        """
        During scale-in, ignore nodes with local storage pods.
        """
        return pulumi.get(self, "skip_nodes_with_local_storage")

    @_builtins.property
    @pulumi.getter(name="skipNodesWithSystemPods")
    def skip_nodes_with_system_pods(self) -> Optional[_builtins.bool]:
        """
        During scale-in, ignore nodes with pods in the kube-system namespace that are not managed by DaemonSet.
        """
        return pulumi.get(self, "skip_nodes_with_system_pods")


@pulumi.output_type
class ClusterReleaseValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rawOriginal":
            suggest = "raw_original"
        elif key == "valuesType":
            suggest = "values_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReleaseValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReleaseValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReleaseValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 raw_original: _builtins.str,
                 values_type: _builtins.str):
        """
        :param _builtins.str raw_original: Custom parameter original value.
        :param _builtins.str values_type: Custom parameter value type.
        """
        pulumi.set(__self__, "raw_original", raw_original)
        pulumi.set(__self__, "values_type", values_type)

    @_builtins.property
    @pulumi.getter(name="rawOriginal")
    def raw_original(self) -> _builtins.str:
        """
        Custom parameter original value.
        """
        return pulumi.get(self, "raw_original")

    @_builtins.property
    @pulumi.getter(name="valuesType")
    def values_type(self) -> _builtins.str:
        """
        Custom parameter value type.
        """
        return pulumi.get(self, "values_type")


@pulumi.output_type
class ClusterResourceDeleteOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteMode":
            suggest = "delete_mode"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "skipDeletionProtection":
            suggest = "skip_deletion_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterResourceDeleteOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterResourceDeleteOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterResourceDeleteOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_mode: _builtins.str,
                 resource_type: _builtins.str,
                 skip_deletion_protection: Optional[_builtins.bool] = None):
        """
        :param _builtins.str delete_mode: The deletion mode of CBS resources when the cluster is deleted, `terminate` (destroy), `retain` (retain). Other resources are deleted by default.
        :param _builtins.str resource_type: Resource type, valid values are `CBS`, `CLB`, and `CVM`.
        :param _builtins.bool skip_deletion_protection: Whether to skip resources with deletion protection enabled, the default is false.
        """
        pulumi.set(__self__, "delete_mode", delete_mode)
        pulumi.set(__self__, "resource_type", resource_type)
        if skip_deletion_protection is not None:
            pulumi.set(__self__, "skip_deletion_protection", skip_deletion_protection)

    @_builtins.property
    @pulumi.getter(name="deleteMode")
    def delete_mode(self) -> _builtins.str:
        """
        The deletion mode of CBS resources when the cluster is deleted, `terminate` (destroy), `retain` (retain). Other resources are deleted by default.
        """
        return pulumi.get(self, "delete_mode")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type, valid values are `CBS`, `CLB`, and `CVM`.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="skipDeletionProtection")
    def skip_deletion_protection(self) -> Optional[_builtins.bool]:
        """
        Whether to skip resources with deletion protection enabled, the default is false.
        """
        return pulumi.get(self, "skip_deletion_protection")


@pulumi.output_type
class ClusterWorkerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "bandwidthPackageId":
            suggest = "bandwidth_package_id"
        elif key == "camRoleName":
            suggest = "cam_role_name"
        elif key == "dataDisks":
            suggest = "data_disks"
        elif key == "desiredPodNum":
            suggest = "desired_pod_num"
        elif key == "disasterRecoverGroupIds":
            suggest = "disaster_recover_group_ids"
        elif key == "enhancedMonitorService":
            suggest = "enhanced_monitor_service"
        elif key == "enhancedSecurityService":
            suggest = "enhanced_security_service"
        elif key == "hpcClusterId":
            suggest = "hpc_cluster_id"
        elif key == "imgId":
            suggest = "img_id"
        elif key == "instanceChargeType":
            suggest = "instance_charge_type"
        elif key == "instanceChargeTypePrepaidPeriod":
            suggest = "instance_charge_type_prepaid_period"
        elif key == "instanceChargeTypePrepaidRenewFlag":
            suggest = "instance_charge_type_prepaid_renew_flag"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "internetChargeType":
            suggest = "internet_charge_type"
        elif key == "internetMaxBandwidthOut":
            suggest = "internet_max_bandwidth_out"
        elif key == "keyIds":
            suggest = "key_ids"
        elif key == "publicIpAssigned":
            suggest = "public_ip_assigned"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "systemDiskSize":
            suggest = "system_disk_size"
        elif key == "systemDiskType":
            suggest = "system_disk_type"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterWorkerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterWorkerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterWorkerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: _builtins.str,
                 subnet_id: _builtins.str,
                 availability_zone: Optional[_builtins.str] = None,
                 bandwidth_package_id: Optional[_builtins.str] = None,
                 cam_role_name: Optional[_builtins.str] = None,
                 count: Optional[_builtins.int] = None,
                 data_disks: Optional[Sequence['outputs.ClusterWorkerConfigDataDisk']] = None,
                 desired_pod_num: Optional[_builtins.int] = None,
                 disaster_recover_group_ids: Optional[_builtins.str] = None,
                 enhanced_monitor_service: Optional[_builtins.bool] = None,
                 enhanced_security_service: Optional[_builtins.bool] = None,
                 hostname: Optional[_builtins.str] = None,
                 hpc_cluster_id: Optional[_builtins.str] = None,
                 img_id: Optional[_builtins.str] = None,
                 instance_charge_type: Optional[_builtins.str] = None,
                 instance_charge_type_prepaid_period: Optional[_builtins.int] = None,
                 instance_charge_type_prepaid_renew_flag: Optional[_builtins.str] = None,
                 instance_name: Optional[_builtins.str] = None,
                 internet_charge_type: Optional[_builtins.str] = None,
                 internet_max_bandwidth_out: Optional[_builtins.int] = None,
                 key_ids: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 public_ip_assigned: Optional[_builtins.bool] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 system_disk_size: Optional[_builtins.int] = None,
                 system_disk_type: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_type: Specified types of CVM instance.
        :param _builtins.str subnet_id: Private network ID.
        :param _builtins.str availability_zone: Indicates which availability zone will be used.
        :param _builtins.str bandwidth_package_id: bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        :param _builtins.str cam_role_name: CAM role name authorized to access.
        :param _builtins.int count: Number of cvm.
        :param Sequence['ClusterWorkerConfigDataDiskArgs'] data_disks: Configurations of data disk.
        :param _builtins.int desired_pod_num: Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desired_pod_num` or none.
        :param _builtins.str disaster_recover_group_ids: Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
        :param _builtins.bool enhanced_monitor_service: To specify whether to enable cloud monitor service. Default is TRUE.
        :param _builtins.bool enhanced_security_service: To specify whether to enable cloud security service. Default is TRUE.
        :param _builtins.str hostname: The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
        :param _builtins.str hpc_cluster_id: Id of cvm hpc cluster.
        :param _builtins.str img_id: The valid image id, format of img-xxx. Note: `img_id` will be replaced with the image corresponding to TKE `cluster_os`.
        :param _builtins.str instance_charge_type: The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
        :param _builtins.int instance_charge_type_prepaid_period: The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        :param _builtins.str instance_charge_type_prepaid_renew_flag: Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        :param _builtins.str instance_name: Name of the CVMs.
        :param _builtins.str internet_charge_type: Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
        :param _builtins.int internet_max_bandwidth_out: Max bandwidth of Internet access in Mbps. Default is 0.
        :param _builtins.str key_ids: ID list of keys, should be set if `password` not set.
        :param _builtins.str password: Password to access, should be set if `key_ids` not set.
        :param _builtins.bool public_ip_assigned: Specify whether to assign an Internet IP address.
        :param Sequence[_builtins.str] security_group_ids: Security groups to which a CVM instance belongs.
        :param _builtins.int system_disk_size: Volume of system disk in GB. Default is `50`.
        :param _builtins.str system_disk_type: System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
        :param _builtins.str user_data: ase64-encoded User Data text, the length limit is 16KB.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if cam_role_name is not None:
            pulumi.set(__self__, "cam_role_name", cam_role_name)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if desired_pod_num is not None:
            pulumi.set(__self__, "desired_pod_num", desired_pod_num)
        if disaster_recover_group_ids is not None:
            pulumi.set(__self__, "disaster_recover_group_ids", disaster_recover_group_ids)
        if enhanced_monitor_service is not None:
            pulumi.set(__self__, "enhanced_monitor_service", enhanced_monitor_service)
        if enhanced_security_service is not None:
            pulumi.set(__self__, "enhanced_security_service", enhanced_security_service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hpc_cluster_id is not None:
            pulumi.set(__self__, "hpc_cluster_id", hpc_cluster_id)
        if img_id is not None:
            pulumi.set(__self__, "img_id", img_id)
        if instance_charge_type is not None:
            pulumi.set(__self__, "instance_charge_type", instance_charge_type)
        if instance_charge_type_prepaid_period is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_period", instance_charge_type_prepaid_period)
        if instance_charge_type_prepaid_renew_flag is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_renew_flag", instance_charge_type_prepaid_renew_flag)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if system_disk_size is not None:
            pulumi.set(__self__, "system_disk_size", system_disk_size)
        if system_disk_type is not None:
            pulumi.set(__self__, "system_disk_type", system_disk_type)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        """
        Specified types of CVM instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Private network ID.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        Indicates which availability zone will be used.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[_builtins.str]:
        """
        bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="camRoleName")
    def cam_role_name(self) -> Optional[_builtins.str]:
        """
        CAM role name authorized to access.
        """
        return pulumi.get(self, "cam_role_name")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of cvm.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.ClusterWorkerConfigDataDisk']]:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="desiredPodNum")
    def desired_pod_num(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desired_pod_num` or none.
        """
        return pulumi.get(self, "desired_pod_num")

    @_builtins.property
    @pulumi.getter(name="disasterRecoverGroupIds")
    def disaster_recover_group_ids(self) -> Optional[_builtins.str]:
        """
        Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
        """
        return pulumi.get(self, "disaster_recover_group_ids")

    @_builtins.property
    @pulumi.getter(name="enhancedMonitorService")
    def enhanced_monitor_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud monitor service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_monitor_service")

    @_builtins.property
    @pulumi.getter(name="enhancedSecurityService")
    def enhanced_security_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud security service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_security_service")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="hpcClusterId")
    def hpc_cluster_id(self) -> Optional[_builtins.str]:
        """
        Id of cvm hpc cluster.
        """
        return pulumi.get(self, "hpc_cluster_id")

    @_builtins.property
    @pulumi.getter(name="imgId")
    def img_id(self) -> Optional[_builtins.str]:
        """
        The valid image id, format of img-xxx. Note: `img_id` will be replaced with the image corresponding to TKE `cluster_os`.
        """
        return pulumi.get(self, "img_id")

    @_builtins.property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> Optional[_builtins.str]:
        """
        The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
        """
        return pulumi.get(self, "instance_charge_type")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidPeriod")
    def instance_charge_type_prepaid_period(self) -> Optional[_builtins.int]:
        """
        The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_period")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidRenewFlag")
    def instance_charge_type_prepaid_renew_flag(self) -> Optional[_builtins.str]:
        """
        Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_renew_flag")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[_builtins.str]:
        """
        Name of the CVMs.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[_builtins.str]:
        """
        Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
        """
        return pulumi.get(self, "internet_charge_type")

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[_builtins.int]:
        """
        Max bandwidth of Internet access in Mbps. Default is 0.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[_builtins.str]:
        """
        ID list of keys, should be set if `password` not set.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password to access, should be set if `key_ids` not set.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[_builtins.bool]:
        """
        Specify whether to assign an Internet IP address.
        """
        return pulumi.get(self, "public_ip_assigned")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security groups to which a CVM instance belongs.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="systemDiskSize")
    def system_disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of system disk in GB. Default is `50`.
        """
        return pulumi.get(self, "system_disk_size")

    @_builtins.property
    @pulumi.getter(name="systemDiskType")
    def system_disk_type(self) -> Optional[_builtins.str]:
        """
        System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
        """
        return pulumi.get(self, "system_disk_type")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        ase64-encoded User Data text, the length limit is 16KB.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class ClusterWorkerConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterWorkerConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterWorkerConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterWorkerConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.bool] = None,
                 file_system: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        :param _builtins.bool encrypt: Indicates whether to encrypt data disk, default `false`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str kms_key_id: ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
        :param _builtins.str mount_target: Mount target.
        :param _builtins.str snapshot_id: Data disk snapshot ID.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to encrypt data disk, default `false`.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Data disk snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class ClusterWorkerInstancesList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedReason":
            suggest = "failed_reason"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceRole":
            suggest = "instance_role"
        elif key == "instanceState":
            suggest = "instance_state"
        elif key == "lanIp":
            suggest = "lan_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterWorkerInstancesList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterWorkerInstancesList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterWorkerInstancesList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_reason: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 instance_role: Optional[_builtins.str] = None,
                 instance_state: Optional[_builtins.str] = None,
                 lan_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str failed_reason: Information of the cvm when it is failed.
        :param _builtins.str instance_id: ID of the cvm.
        :param _builtins.str instance_role: Role of the cvm.
        :param _builtins.str instance_state: State of the cvm.
        :param _builtins.str lan_ip: LAN IP of the cvm.
        """
        if failed_reason is not None:
            pulumi.set(__self__, "failed_reason", failed_reason)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_role is not None:
            pulumi.set(__self__, "instance_role", instance_role)
        if instance_state is not None:
            pulumi.set(__self__, "instance_state", instance_state)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> Optional[_builtins.str]:
        """
        Information of the cvm when it is failed.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        ID of the cvm.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> Optional[_builtins.str]:
        """
        Role of the cvm.
        """
        return pulumi.get(self, "instance_role")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> Optional[_builtins.str]:
        """
        State of the cvm.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[_builtins.str]:
        """
        LAN IP of the cvm.
        """
        return pulumi.get(self, "lan_ip")


@pulumi.output_type
class EncryptionProtectionKmsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "kmsRegion":
            suggest = "kms_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionProtectionKmsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionProtectionKmsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionProtectionKmsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: Optional[_builtins.str] = None,
                 kms_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_id: kms id.
        :param _builtins.str kms_region: kms region.
        """
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if kms_region is not None:
            pulumi.set(__self__, "kms_region", kms_region)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        kms id.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="kmsRegion")
    def kms_region(self) -> Optional[_builtins.str]:
        """
        kms region.
        """
        return pulumi.get(self, "kms_region")


@pulumi.output_type
class HealthCheckPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRepairEnabled":
            suggest = "auto_repair_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_repair_enabled: _builtins.bool,
                 enabled: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.bool auto_repair_enabled: Enable repair or not.
        :param _builtins.bool enabled: Enable detection of this project or not.
        :param _builtins.str name: Health check rule details.
        """
        pulumi.set(__self__, "auto_repair_enabled", auto_repair_enabled)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="autoRepairEnabled")
    def auto_repair_enabled(self) -> _builtins.bool:
        """
        Enable repair or not.
        """
        return pulumi.get(self, "auto_repair_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable detection of this project or not.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Health check rule details.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NativeNodePoolAnnotation(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name in the map table.
        :param _builtins.str value: Value in the map table.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name in the map table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value in the map table.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NativeNodePoolLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name in the map table.
        :param _builtins.str value: Value in map table.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name in the map table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value in map table.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NativeNodePoolNative(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceChargeType":
            suggest = "instance_charge_type"
        elif key == "instanceTypes":
            suggest = "instance_types"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "systemDisk":
            suggest = "system_disk"
        elif key == "autoRepair":
            suggest = "auto_repair"
        elif key == "dataDisks":
            suggest = "data_disks"
        elif key == "enableAutoscaling":
            suggest = "enable_autoscaling"
        elif key == "healthCheckPolicyName":
            suggest = "health_check_policy_name"
        elif key == "hostNamePattern":
            suggest = "host_name_pattern"
        elif key == "instanceChargePrepaid":
            suggest = "instance_charge_prepaid"
        elif key == "internetAccessible":
            suggest = "internet_accessible"
        elif key == "keyIds":
            suggest = "key_ids"
        elif key == "kubeletArgs":
            suggest = "kubelet_args"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "runtimeRootDir":
            suggest = "runtime_root_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNative. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNative.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNative.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_charge_type: _builtins.str,
                 instance_types: Sequence[_builtins.str],
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 system_disk: 'outputs.NativeNodePoolNativeSystemDisk',
                 auto_repair: Optional[_builtins.bool] = None,
                 data_disks: Optional[Sequence['outputs.NativeNodePoolNativeDataDisk']] = None,
                 enable_autoscaling: Optional[_builtins.bool] = None,
                 health_check_policy_name: Optional[_builtins.str] = None,
                 host_name_pattern: Optional[_builtins.str] = None,
                 instance_charge_prepaid: Optional['outputs.NativeNodePoolNativeInstanceChargePrepaid'] = None,
                 internet_accessible: Optional['outputs.NativeNodePoolNativeInternetAccessible'] = None,
                 key_ids: Optional[Sequence[_builtins.str]] = None,
                 kubelet_args: Optional[Sequence[_builtins.str]] = None,
                 lifecycle: Optional['outputs.NativeNodePoolNativeLifecycle'] = None,
                 machine_type: Optional[_builtins.str] = None,
                 management: Optional['outputs.NativeNodePoolNativeManagement'] = None,
                 replicas: Optional[_builtins.int] = None,
                 runtime_root_dir: Optional[_builtins.str] = None,
                 scaling: Optional['outputs.NativeNodePoolNativeScaling'] = None):
        """
        :param _builtins.str instance_charge_type: Node billing type. `PREPAID` is a yearly and monthly subscription, `POSTPAID_BY_HOUR` is a pay-as-you-go plan. The default is `POSTPAID_BY_HOUR`.
        :param Sequence[_builtins.str] instance_types: Model list.
        :param Sequence[_builtins.str] security_group_ids: Security group list.
        :param Sequence[_builtins.str] subnet_ids: Subnet list.
        :param 'NativeNodePoolNativeSystemDiskArgs' system_disk: System disk configuration.
        :param _builtins.bool auto_repair: Whether to enable self-healing ability.
        :param Sequence['NativeNodePoolNativeDataDiskArgs'] data_disks: Native node pool data disk list.
        :param _builtins.bool enable_autoscaling: Whether to enable elastic scaling.
        :param _builtins.str health_check_policy_name: Fault self-healing rule name.
        :param _builtins.str host_name_pattern: Native node pool hostName pattern string.
        :param 'NativeNodePoolNativeInstanceChargePrepaidArgs' instance_charge_prepaid: Billing configuration for yearly and monthly models.
        :param 'NativeNodePoolNativeInternetAccessibleArgs' internet_accessible: Public network bandwidth settings.
        :param Sequence[_builtins.str] key_ids: Node pool ssh public key id array.
        :param Sequence[_builtins.str] kubelet_args: Kubelet custom parameters.
        :param 'NativeNodePoolNativeLifecycleArgs' lifecycle: Predefined scripts.
        :param _builtins.str machine_type: Node pool type. Example value: `NativeCVM` or `Native`. Default is `Native`.
        :param 'NativeNodePoolNativeManagementArgs' management: Node pool management parameter settings.
        :param _builtins.int replicas: Desired number of nodes.
        :param _builtins.str runtime_root_dir: Runtime root directory.
        :param 'NativeNodePoolNativeScalingArgs' scaling: Node pool scaling configuration.
        """
        pulumi.set(__self__, "instance_charge_type", instance_charge_type)
        pulumi.set(__self__, "instance_types", instance_types)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "system_disk", system_disk)
        if auto_repair is not None:
            pulumi.set(__self__, "auto_repair", auto_repair)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if enable_autoscaling is not None:
            pulumi.set(__self__, "enable_autoscaling", enable_autoscaling)
        if health_check_policy_name is not None:
            pulumi.set(__self__, "health_check_policy_name", health_check_policy_name)
        if host_name_pattern is not None:
            pulumi.set(__self__, "host_name_pattern", host_name_pattern)
        if instance_charge_prepaid is not None:
            pulumi.set(__self__, "instance_charge_prepaid", instance_charge_prepaid)
        if internet_accessible is not None:
            pulumi.set(__self__, "internet_accessible", internet_accessible)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if kubelet_args is not None:
            pulumi.set(__self__, "kubelet_args", kubelet_args)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if management is not None:
            pulumi.set(__self__, "management", management)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if runtime_root_dir is not None:
            pulumi.set(__self__, "runtime_root_dir", runtime_root_dir)
        if scaling is not None:
            pulumi.set(__self__, "scaling", scaling)

    @_builtins.property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> _builtins.str:
        """
        Node billing type. `PREPAID` is a yearly and monthly subscription, `POSTPAID_BY_HOUR` is a pay-as-you-go plan. The default is `POSTPAID_BY_HOUR`.
        """
        return pulumi.get(self, "instance_charge_type")

    @_builtins.property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Sequence[_builtins.str]:
        """
        Model list.
        """
        return pulumi.get(self, "instance_types")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Security group list.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        Subnet list.
        """
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="systemDisk")
    def system_disk(self) -> 'outputs.NativeNodePoolNativeSystemDisk':
        """
        System disk configuration.
        """
        return pulumi.get(self, "system_disk")

    @_builtins.property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> Optional[_builtins.bool]:
        """
        Whether to enable self-healing ability.
        """
        return pulumi.get(self, "auto_repair")

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.NativeNodePoolNativeDataDisk']]:
        """
        Native node pool data disk list.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="enableAutoscaling")
    def enable_autoscaling(self) -> Optional[_builtins.bool]:
        """
        Whether to enable elastic scaling.
        """
        return pulumi.get(self, "enable_autoscaling")

    @_builtins.property
    @pulumi.getter(name="healthCheckPolicyName")
    def health_check_policy_name(self) -> Optional[_builtins.str]:
        """
        Fault self-healing rule name.
        """
        return pulumi.get(self, "health_check_policy_name")

    @_builtins.property
    @pulumi.getter(name="hostNamePattern")
    def host_name_pattern(self) -> Optional[_builtins.str]:
        """
        Native node pool hostName pattern string.
        """
        return pulumi.get(self, "host_name_pattern")

    @_builtins.property
    @pulumi.getter(name="instanceChargePrepaid")
    def instance_charge_prepaid(self) -> Optional['outputs.NativeNodePoolNativeInstanceChargePrepaid']:
        """
        Billing configuration for yearly and monthly models.
        """
        return pulumi.get(self, "instance_charge_prepaid")

    @_builtins.property
    @pulumi.getter(name="internetAccessible")
    def internet_accessible(self) -> Optional['outputs.NativeNodePoolNativeInternetAccessible']:
        """
        Public network bandwidth settings.
        """
        return pulumi.get(self, "internet_accessible")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Node pool ssh public key id array.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter(name="kubeletArgs")
    def kubelet_args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kubelet custom parameters.
        """
        return pulumi.get(self, "kubelet_args")

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.NativeNodePoolNativeLifecycle']:
        """
        Predefined scripts.
        """
        return pulumi.get(self, "lifecycle")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[_builtins.str]:
        """
        Node pool type. Example value: `NativeCVM` or `Native`. Default is `Native`.
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter
    def management(self) -> Optional['outputs.NativeNodePoolNativeManagement']:
        """
        Node pool management parameter settings.
        """
        return pulumi.get(self, "management")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[_builtins.int]:
        """
        Desired number of nodes.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter(name="runtimeRootDir")
    def runtime_root_dir(self) -> Optional[_builtins.str]:
        """
        Runtime root directory.
        """
        return pulumi.get(self, "runtime_root_dir")

    @_builtins.property
    @pulumi.getter
    def scaling(self) -> Optional['outputs.NativeNodePoolNativeScaling']:
        """
        Node pool scaling configuration.
        """
        return pulumi.get(self, "scaling")


@pulumi.output_type
class NativeNodePoolNativeDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputPerformance":
            suggest = "throughput_performance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNativeDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNativeDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNativeDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: _builtins.bool,
                 disk_size: _builtins.int,
                 disk_type: _builtins.str,
                 disk_partition: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.str] = None,
                 file_system: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput_performance: Optional[_builtins.int] = None):
        """
        :param _builtins.bool auto_format_and_mount: Whether to automatically format the disk and mount it.
        :param _builtins.int disk_size: Cloud disk size (G).
        :param _builtins.str disk_type: Cloud disk type. Valid values: `CLOUD_PREMIUM`: Premium Cloud Storage, `CLOUD_SSD`: cloud SSD disk, `CLOUD_BSSD`: Basic SSD, `CLOUD_HSSD`: Enhanced SSD, `CLOUD_TSSD`: Tremendous SSD, `LOCAL_NVME`: local NVME disk.
        :param _builtins.str disk_partition: Mount device name or partition name.
        :param _builtins.str encrypt: Pass in this parameter to create an encrypted cloud disk. The value is fixed to `ENCRYPT`.
        :param _builtins.str file_system: File system (ext3/ext4/xfs).
        :param _builtins.str kms_key_id: Customize the key when purchasing an encrypted disk. When this parameter is passed in, the Encrypt parameter is not empty.
        :param _builtins.str mount_target: Mount directory.
        :param _builtins.str snapshot_id: Snapshot ID. If passed in, the cloud disk will be created based on this snapshot. The snapshot type must be a data disk snapshot.
        :param _builtins.int throughput_performance: Cloud disk performance, unit: MB/s. Use this parameter to purchase additional performance for the cloud disk.
        """
        pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type", disk_type)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> _builtins.bool:
        """
        Whether to automatically format the disk and mount it.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Cloud disk size (G).
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        Cloud disk type. Valid values: `CLOUD_PREMIUM`: Premium Cloud Storage, `CLOUD_SSD`: cloud SSD disk, `CLOUD_BSSD`: Basic SSD, `CLOUD_HSSD`: Enhanced SSD, `CLOUD_TSSD`: Tremendous SSD, `LOCAL_NVME`: local NVME disk.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        Mount device name or partition name.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.str]:
        """
        Pass in this parameter to create an encrypted cloud disk. The value is fixed to `ENCRYPT`.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system (ext3/ext4/xfs).
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Customize the key when purchasing an encrypted disk. When this parameter is passed in, the Encrypt parameter is not empty.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount directory.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Snapshot ID. If passed in, the cloud disk will be created based on this snapshot. The snapshot type must be a data disk snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[_builtins.int]:
        """
        Cloud disk performance, unit: MB/s. Use this parameter to purchase additional performance for the cloud disk.
        """
        return pulumi.get(self, "throughput_performance")


@pulumi.output_type
class NativeNodePoolNativeInstanceChargePrepaid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewFlag":
            suggest = "renew_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNativeInstanceChargePrepaid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNativeInstanceChargePrepaid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNativeInstanceChargePrepaid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 period: _builtins.int,
                 renew_flag: Optional[_builtins.str] = None):
        """
        :param _builtins.int period: Postpaid billing cycle, unit (month): 1, 2, 3, 4, 5,, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        :param _builtins.str renew_flag: Prepaid renewal method:
               - `NOTIFY_AND_AUTO_RENEW`: Notify users of expiration and automatically renew (default).
               - `NOTIFY_AND_MANUAL_RENEW`: Notify users of expiration, but do not automatically renew.
               - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: Do not notify users of expiration and do not automatically renew.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        Postpaid billing cycle, unit (month): 1, 2, 3, 4, 5,, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[_builtins.str]:
        """
        Prepaid renewal method:
        - `NOTIFY_AND_AUTO_RENEW`: Notify users of expiration and automatically renew (default).
        - `NOTIFY_AND_MANUAL_RENEW`: Notify users of expiration, but do not automatically renew.
        - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: Do not notify users of expiration and do not automatically renew.
        """
        return pulumi.get(self, "renew_flag")


@pulumi.output_type
class NativeNodePoolNativeInternetAccessible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chargeType":
            suggest = "charge_type"
        elif key == "maxBandwidthOut":
            suggest = "max_bandwidth_out"
        elif key == "bandwidthPackageId":
            suggest = "bandwidth_package_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNativeInternetAccessible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNativeInternetAccessible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNativeInternetAccessible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 charge_type: _builtins.str,
                 max_bandwidth_out: _builtins.int,
                 bandwidth_package_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str charge_type: Network billing method. Optional value is `TRAFFIC_POSTPAID_BY_HOUR`, `BANDWIDTH_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
        :param _builtins.int max_bandwidth_out: Maximum bandwidth output. Note: When chargeType is `TRAFFIC_POSTPAID_BY_HOUR` and `BANDWIDTH_POSTPAID_BY_HOUR`, the valid range is 1~100. When chargeType is `BANDWIDTH_PACKAG`, the valid range is 1~2000.
        :param _builtins.str bandwidth_package_id: Bandwidth package ID. Note: When ChargeType is BANDWIDTH_PACKAG, the value cannot be empty; otherwise, the value must be empty.
        """
        pulumi.set(__self__, "charge_type", charge_type)
        pulumi.set(__self__, "max_bandwidth_out", max_bandwidth_out)
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)

    @_builtins.property
    @pulumi.getter(name="chargeType")
    def charge_type(self) -> _builtins.str:
        """
        Network billing method. Optional value is `TRAFFIC_POSTPAID_BY_HOUR`, `BANDWIDTH_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
        """
        return pulumi.get(self, "charge_type")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthOut")
    def max_bandwidth_out(self) -> _builtins.int:
        """
        Maximum bandwidth output. Note: When chargeType is `TRAFFIC_POSTPAID_BY_HOUR` and `BANDWIDTH_POSTPAID_BY_HOUR`, the valid range is 1~100. When chargeType is `BANDWIDTH_PACKAG`, the valid range is 1~2000.
        """
        return pulumi.get(self, "max_bandwidth_out")

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[_builtins.str]:
        """
        Bandwidth package ID. Note: When ChargeType is BANDWIDTH_PACKAG, the value cannot be empty; otherwise, the value must be empty.
        """
        return pulumi.get(self, "bandwidth_package_id")


@pulumi.output_type
class NativeNodePoolNativeLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postInit":
            suggest = "post_init"
        elif key == "preInit":
            suggest = "pre_init"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNativeLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNativeLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNativeLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_init: Optional[_builtins.str] = None,
                 pre_init: Optional[_builtins.str] = None):
        """
        :param _builtins.str post_init: Custom script after node initialization.
        :param _builtins.str pre_init: Custom script before node initialization.
        """
        if post_init is not None:
            pulumi.set(__self__, "post_init", post_init)
        if pre_init is not None:
            pulumi.set(__self__, "pre_init", pre_init)

    @_builtins.property
    @pulumi.getter(name="postInit")
    def post_init(self) -> Optional[_builtins.str]:
        """
        Custom script after node initialization.
        """
        return pulumi.get(self, "post_init")

    @_builtins.property
    @pulumi.getter(name="preInit")
    def pre_init(self) -> Optional[_builtins.str]:
        """
        Custom script before node initialization.
        """
        return pulumi.get(self, "pre_init")


@pulumi.output_type
class NativeNodePoolNativeManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kernelArgs":
            suggest = "kernel_args"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNativeManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNativeManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNativeManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 kernel_args: Optional[Sequence[_builtins.str]] = None,
                 nameservers: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] hosts: Hosts configuration.
        :param Sequence[_builtins.str] kernel_args: Kernel parameter configuration.
        :param Sequence[_builtins.str] nameservers: Dns configuration.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if kernel_args is not None:
            pulumi.set(__self__, "kernel_args", kernel_args)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Hosts configuration.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="kernelArgs")
    def kernel_args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kernel parameter configuration.
        """
        return pulumi.get(self, "kernel_args")

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Dns configuration.
        """
        return pulumi.get(self, "nameservers")


@pulumi.output_type
class NativeNodePoolNativeScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createPolicy":
            suggest = "create_policy"
        elif key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNativeScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNativeScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNativeScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_policy: Optional[_builtins.str] = None,
                 max_replicas: Optional[_builtins.int] = None,
                 min_replicas: Optional[_builtins.int] = None):
        """
        :param _builtins.str create_policy: Node pool expansion strategy. `ZoneEquality`: multiple availability zones are broken up; `ZonePriority`: the preferred availability zone takes precedence.
        :param _builtins.int max_replicas: Maximum number of replicas in node pool.
        :param _builtins.int min_replicas: Minimum number of replicas in node pool.
        """
        if create_policy is not None:
            pulumi.set(__self__, "create_policy", create_policy)
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)

    @_builtins.property
    @pulumi.getter(name="createPolicy")
    def create_policy(self) -> Optional[_builtins.str]:
        """
        Node pool expansion strategy. `ZoneEquality`: multiple availability zones are broken up; `ZonePriority`: the preferred availability zone takes precedence.
        """
        return pulumi.get(self, "create_policy")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[_builtins.int]:
        """
        Maximum number of replicas in node pool.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[_builtins.int]:
        """
        Minimum number of replicas in node pool.
        """
        return pulumi.get(self, "min_replicas")


@pulumi.output_type
class NativeNodePoolNativeSystemDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolNativeSystemDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolNativeSystemDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolNativeSystemDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type: _builtins.str):
        """
        :param _builtins.int disk_size: Cloud disk size (G).
        :param _builtins.str disk_type: Cloud disk type. Valid values: `CLOUD_PREMIUM`: Premium Cloud Storage, `CLOUD_SSD`: cloud SSD disk, `CLOUD_BSSD`: Basic SSD, `CLOUD_HSSD`: Enhanced SSD.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Cloud disk size (G).
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        Cloud disk type. Valid values: `CLOUD_PREMIUM`: Premium Cloud Storage, `CLOUD_SSD`: cloud SSD disk, `CLOUD_BSSD`: Basic SSD, `CLOUD_HSSD`: Enhanced SSD.
        """
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class NativeNodePoolTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NativeNodePoolTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NativeNodePoolTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NativeNodePoolTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[_builtins.str] = None,
                 tags: Optional[Sequence['outputs.NativeNodePoolTagTag']] = None):
        """
        :param _builtins.str resource_type: The resource type bound to the label.
        :param Sequence['NativeNodePoolTagTagArgs'] tags: Tag pair list.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        The resource type bound to the label.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.NativeNodePoolTagTag']]:
        """
        Tag pair list.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class NativeNodePoolTagTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Tag Key.
        :param _builtins.str value: Tag Value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Tag Key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Tag Value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NativeNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Effect of the taint.
        :param _builtins.str key: Key of the taint.
        :param _builtins.str value: Value of the taint.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NodePoolAnnotation(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name in the map table.
        :param _builtins.str value: Value in the map table.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name in the map table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value in the map table.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NodePoolAutoScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "backupInstanceTypes":
            suggest = "backup_instance_types"
        elif key == "bandwidthPackageId":
            suggest = "bandwidth_package_id"
        elif key == "camRoleName":
            suggest = "cam_role_name"
        elif key == "cdcId":
            suggest = "cdc_id"
        elif key == "dataDisks":
            suggest = "data_disks"
        elif key == "enhancedMonitorService":
            suggest = "enhanced_monitor_service"
        elif key == "enhancedSecurityService":
            suggest = "enhanced_security_service"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "hostNameStyle":
            suggest = "host_name_style"
        elif key == "instanceChargeType":
            suggest = "instance_charge_type"
        elif key == "instanceChargeTypePrepaidPeriod":
            suggest = "instance_charge_type_prepaid_period"
        elif key == "instanceChargeTypePrepaidRenewFlag":
            suggest = "instance_charge_type_prepaid_renew_flag"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "instanceNameStyle":
            suggest = "instance_name_style"
        elif key == "internetChargeType":
            suggest = "internet_charge_type"
        elif key == "internetMaxBandwidthOut":
            suggest = "internet_max_bandwidth_out"
        elif key == "ipv4AddressType":
            suggest = "ipv4_address_type"
        elif key == "keyIds":
            suggest = "key_ids"
        elif key == "orderlySecurityGroupIds":
            suggest = "orderly_security_group_ids"
        elif key == "publicIpAssigned":
            suggest = "public_ip_assigned"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "spotMaxPrice":
            suggest = "spot_max_price"
        elif key == "systemDiskSize":
            suggest = "system_disk_size"
        elif key == "systemDiskType":
            suggest = "system_disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolAutoScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolAutoScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolAutoScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: _builtins.str,
                 backup_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bandwidth_package_id: Optional[_builtins.str] = None,
                 cam_role_name: Optional[_builtins.str] = None,
                 cdc_id: Optional[_builtins.str] = None,
                 data_disks: Optional[Sequence['outputs.NodePoolAutoScalingConfigDataDisk']] = None,
                 enhanced_monitor_service: Optional[_builtins.bool] = None,
                 enhanced_security_service: Optional[_builtins.bool] = None,
                 host_name: Optional[_builtins.str] = None,
                 host_name_style: Optional[_builtins.str] = None,
                 instance_charge_type: Optional[_builtins.str] = None,
                 instance_charge_type_prepaid_period: Optional[_builtins.int] = None,
                 instance_charge_type_prepaid_renew_flag: Optional[_builtins.str] = None,
                 instance_name: Optional[_builtins.str] = None,
                 instance_name_style: Optional[_builtins.str] = None,
                 internet_charge_type: Optional[_builtins.str] = None,
                 internet_max_bandwidth_out: Optional[_builtins.int] = None,
                 ipv4_address_type: Optional[_builtins.str] = None,
                 key_ids: Optional[Sequence[_builtins.str]] = None,
                 orderly_security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 password: Optional[_builtins.str] = None,
                 public_ip_assigned: Optional[_builtins.bool] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 spot_instance_type: Optional[_builtins.str] = None,
                 spot_max_price: Optional[_builtins.str] = None,
                 system_disk_size: Optional[_builtins.int] = None,
                 system_disk_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_type: Specified types of CVM instance.
        :param Sequence[_builtins.str] backup_instance_types: Backup CVM instance types if specified instance type sold out or mismatch.
        :param _builtins.str bandwidth_package_id: bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        :param _builtins.str cam_role_name: Name of cam role.
        :param _builtins.str cdc_id: CDC ID.
        :param Sequence['NodePoolAutoScalingConfigDataDiskArgs'] data_disks: Configurations of data disk.
        :param _builtins.bool enhanced_monitor_service: To specify whether to enable cloud monitor service. Default is TRUE.
        :param _builtins.bool enhanced_security_service: To specify whether to enable cloud security service. Default is TRUE.
        :param _builtins.str host_name: The hostname of the cloud server, dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows instances are not supported. Examples of other types (Linux, etc.): The character length is [2, 40], multiple periods are allowed, and there is a paragraph between the dots, and each paragraph is allowed to consist of letters (unlimited case), numbers and dashes (-). Pure numbers are not allowed. For usage, refer to `HostNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        :param _builtins.str host_name_style: The style of the host name of the cloud server, the value range includes ORIGINAL and UNIQUE, and the default is ORIGINAL. For usage, refer to `HostNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        :param _builtins.str instance_charge_type: Charge type of instance. Valid values are `PREPAID`, `POSTPAID_BY_HOUR`, `SPOTPAID`, `CDCPAID`. The default is `POSTPAID_BY_HOUR`. NOTE: `SPOTPAID` instance must set `spot_instance_type` and `spot_max_price` at the same time.
        :param _builtins.int instance_charge_type_prepaid_period: The tenancy (in month) of the prepaid instance, NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        :param _builtins.str instance_charge_type_prepaid_renew_flag: Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        :param _builtins.str instance_name: Instance name, no more than 60 characters. For usage, refer to `InstanceNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        :param _builtins.str instance_name_style: Type of CVM instance name. Valid values: `ORIGINAL` and `UNIQUE`. Default value: `ORIGINAL`. For usage, refer to `InstanceNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        :param _builtins.str internet_charge_type: Charge types for network traffic. Valid value: `BANDWIDTH_PREPAID`, `TRAFFIC_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
        :param _builtins.int internet_max_bandwidth_out: Max bandwidth of Internet access in Mbps. Default is `0`.
        :param _builtins.str ipv4_address_type: Type of public IP address. WanIP: Ordinary public IP address; HighQualityEIP: High Quality EIP is supported only in Singapore and Hong Kong; AntiDDoSEIP: Anti-DDoS IP is supported only in specific regions. For details, see EIP Product Overview. Specify the type of public IPv4 address to assign a public IPv4 address to the resource. HighQualityEIP and AntiDDoSEIP features are gradually released in select regions. For usage, submit a ticket for consultation.
        :param Sequence[_builtins.str] key_ids: ID list of keys.
        :param Sequence[_builtins.str] orderly_security_group_ids: Ordered security groups to which a CVM instance belongs.
        :param _builtins.str password: Password to access.
        :param _builtins.bool public_ip_assigned: Specify whether to assign an Internet IP address.
        :param Sequence[_builtins.str] security_group_ids: The order of elements in this field cannot be guaranteed. Use `orderly_security_group_ids` instead. Security groups to which a CVM instance belongs.
        :param _builtins.str spot_instance_type: Type of spot instance, only support `one-time` now. Note: it only works when instance_charge_type is set to `SPOTPAID`.
        :param _builtins.str spot_max_price: Max price of a spot instance, is the format of decimal string, for example "0.50". Note: it only works when instance_charge_type is set to `SPOTPAID`.
        :param _builtins.int system_disk_size: Volume of system disk in GB. Default is `50`.
        :param _builtins.str system_disk_type: Type of a CVM disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD`, `CLOUD_BSSD` and `LOCAL_NVME`. Default is `CLOUD_PREMIUM`.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        if backup_instance_types is not None:
            pulumi.set(__self__, "backup_instance_types", backup_instance_types)
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if cam_role_name is not None:
            pulumi.set(__self__, "cam_role_name", cam_role_name)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if enhanced_monitor_service is not None:
            pulumi.set(__self__, "enhanced_monitor_service", enhanced_monitor_service)
        if enhanced_security_service is not None:
            pulumi.set(__self__, "enhanced_security_service", enhanced_security_service)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if host_name_style is not None:
            pulumi.set(__self__, "host_name_style", host_name_style)
        if instance_charge_type is not None:
            pulumi.set(__self__, "instance_charge_type", instance_charge_type)
        if instance_charge_type_prepaid_period is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_period", instance_charge_type_prepaid_period)
        if instance_charge_type_prepaid_renew_flag is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_renew_flag", instance_charge_type_prepaid_renew_flag)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if instance_name_style is not None:
            pulumi.set(__self__, "instance_name_style", instance_name_style)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if ipv4_address_type is not None:
            pulumi.set(__self__, "ipv4_address_type", ipv4_address_type)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if orderly_security_group_ids is not None:
            pulumi.set(__self__, "orderly_security_group_ids", orderly_security_group_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if spot_max_price is not None:
            pulumi.set(__self__, "spot_max_price", spot_max_price)
        if system_disk_size is not None:
            pulumi.set(__self__, "system_disk_size", system_disk_size)
        if system_disk_type is not None:
            pulumi.set(__self__, "system_disk_type", system_disk_type)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        """
        Specified types of CVM instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="backupInstanceTypes")
    def backup_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Backup CVM instance types if specified instance type sold out or mismatch.
        """
        return pulumi.get(self, "backup_instance_types")

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[_builtins.str]:
        """
        bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="camRoleName")
    def cam_role_name(self) -> Optional[_builtins.str]:
        """
        Name of cam role.
        """
        return pulumi.get(self, "cam_role_name")

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        CDC ID.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.NodePoolAutoScalingConfigDataDisk']]:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="enhancedMonitorService")
    def enhanced_monitor_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud monitor service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_monitor_service")

    @_builtins.property
    @pulumi.getter(name="enhancedSecurityService")
    def enhanced_security_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud security service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_security_service")

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[_builtins.str]:
        """
        The hostname of the cloud server, dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows instances are not supported. Examples of other types (Linux, etc.): The character length is [2, 40], multiple periods are allowed, and there is a paragraph between the dots, and each paragraph is allowed to consist of letters (unlimited case), numbers and dashes (-). Pure numbers are not allowed. For usage, refer to `HostNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter(name="hostNameStyle")
    def host_name_style(self) -> Optional[_builtins.str]:
        """
        The style of the host name of the cloud server, the value range includes ORIGINAL and UNIQUE, and the default is ORIGINAL. For usage, refer to `HostNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        """
        return pulumi.get(self, "host_name_style")

    @_builtins.property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> Optional[_builtins.str]:
        """
        Charge type of instance. Valid values are `PREPAID`, `POSTPAID_BY_HOUR`, `SPOTPAID`, `CDCPAID`. The default is `POSTPAID_BY_HOUR`. NOTE: `SPOTPAID` instance must set `spot_instance_type` and `spot_max_price` at the same time.
        """
        return pulumi.get(self, "instance_charge_type")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidPeriod")
    def instance_charge_type_prepaid_period(self) -> Optional[_builtins.int]:
        """
        The tenancy (in month) of the prepaid instance, NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_period")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidRenewFlag")
    def instance_charge_type_prepaid_renew_flag(self) -> Optional[_builtins.str]:
        """
        Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_renew_flag")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[_builtins.str]:
        """
        Instance name, no more than 60 characters. For usage, refer to `InstanceNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="instanceNameStyle")
    def instance_name_style(self) -> Optional[_builtins.str]:
        """
        Type of CVM instance name. Valid values: `ORIGINAL` and `UNIQUE`. Default value: `ORIGINAL`. For usage, refer to `InstanceNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
        """
        return pulumi.get(self, "instance_name_style")

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[_builtins.str]:
        """
        Charge types for network traffic. Valid value: `BANDWIDTH_PREPAID`, `TRAFFIC_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
        """
        return pulumi.get(self, "internet_charge_type")

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[_builtins.int]:
        """
        Max bandwidth of Internet access in Mbps. Default is `0`.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @_builtins.property
    @pulumi.getter(name="ipv4AddressType")
    def ipv4_address_type(self) -> Optional[_builtins.str]:
        """
        Type of public IP address. WanIP: Ordinary public IP address; HighQualityEIP: High Quality EIP is supported only in Singapore and Hong Kong; AntiDDoSEIP: Anti-DDoS IP is supported only in specific regions. For details, see EIP Product Overview. Specify the type of public IPv4 address to assign a public IPv4 address to the resource. HighQualityEIP and AntiDDoSEIP features are gradually released in select regions. For usage, submit a ticket for consultation.
        """
        return pulumi.get(self, "ipv4_address_type")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        ID list of keys.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter(name="orderlySecurityGroupIds")
    def orderly_security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Ordered security groups to which a CVM instance belongs.
        """
        return pulumi.get(self, "orderly_security_group_ids")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password to access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[_builtins.bool]:
        """
        Specify whether to assign an Internet IP address.
        """
        return pulumi.get(self, "public_ip_assigned")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    @_utilities.deprecated("""The order of elements in this field cannot be guaranteed. Use `orderly_security_group_ids` instead.""")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The order of elements in this field cannot be guaranteed. Use `orderly_security_group_ids` instead. Security groups to which a CVM instance belongs.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        """
        Type of spot instance, only support `one-time` now. Note: it only works when instance_charge_type is set to `SPOTPAID`.
        """
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> Optional[_builtins.str]:
        """
        Max price of a spot instance, is the format of decimal string, for example "0.50". Note: it only works when instance_charge_type is set to `SPOTPAID`.
        """
        return pulumi.get(self, "spot_max_price")

    @_builtins.property
    @pulumi.getter(name="systemDiskSize")
    def system_disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of system disk in GB. Default is `50`.
        """
        return pulumi.get(self, "system_disk_size")

    @_builtins.property
    @pulumi.getter(name="systemDiskType")
    def system_disk_type(self) -> Optional[_builtins.str]:
        """
        Type of a CVM disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD`, `CLOUD_BSSD` and `LOCAL_NVME`. Default is `CLOUD_PREMIUM`.
        """
        return pulumi.get(self, "system_disk_type")


@pulumi.output_type
class NodePoolAutoScalingConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputPerformance":
            suggest = "throughput_performance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolAutoScalingConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolAutoScalingConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolAutoScalingConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_with_instance: Optional[_builtins.bool] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.bool] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput_performance: Optional[_builtins.int] = None):
        """
        :param _builtins.bool delete_with_instance: Indicates whether the disk remove after instance terminated. Default is `false`.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD`, `CLOUD_BSSD` and `LOCAL_NVME`.
        :param _builtins.bool encrypt: Specify whether to encrypt data disk, default: false. NOTE: Make sure the instance type is offering and the cam role `QcloudKMSAccessForCVMRole` was provided.
        :param _builtins.str snapshot_id: Data disk snapshot ID.
        :param _builtins.int throughput_performance: Add extra performance to the data disk. Only works when disk type is `CLOUD_TSSD` or `CLOUD_HSSD` and `data_size` > 460GB.
        """
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput_performance is not None:
            pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the disk remove after instance terminated. Default is `false`.
        """
        return pulumi.get(self, "delete_with_instance")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD`, `CLOUD_BSSD` and `LOCAL_NVME`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.bool]:
        """
        Specify whether to encrypt data disk, default: false. NOTE: Make sure the instance type is offering and the cam role `QcloudKMSAccessForCVMRole` was provided.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Data disk snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> Optional[_builtins.int]:
        """
        Add extra performance to the data disk. Only works when disk type is `CLOUD_TSSD` or `CLOUD_HSSD` and `data_size` > 460GB.
        """
        return pulumi.get(self, "throughput_performance")


@pulumi.output_type
class NodePoolNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDisks":
            suggest = "data_disks"
        elif key == "desiredPodNum":
            suggest = "desired_pod_num"
        elif key == "dockerGraphPath":
            suggest = "docker_graph_path"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "gpuArgs":
            suggest = "gpu_args"
        elif key == "isSchedule":
            suggest = "is_schedule"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "preStartUserScript":
            suggest = "pre_start_user_script"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disks: Optional[Sequence['outputs.NodePoolNodeConfigDataDisk']] = None,
                 desired_pod_num: Optional[_builtins.int] = None,
                 docker_graph_path: Optional[_builtins.str] = None,
                 extra_args: Optional[Sequence[_builtins.str]] = None,
                 gpu_args: Optional['outputs.NodePoolNodeConfigGpuArgs'] = None,
                 is_schedule: Optional[_builtins.bool] = None,
                 mount_target: Optional[_builtins.str] = None,
                 pre_start_user_script: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param Sequence['NodePoolNodeConfigDataDiskArgs'] data_disks: Configurations of data disk.
        :param _builtins.int desired_pod_num: Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        :param _builtins.str docker_graph_path: Docker graph path. Default is `/var/lib/docker`.
        :param Sequence[_builtins.str] extra_args: Custom parameter information related to the node. This is a white-list parameter.
        :param 'NodePoolNodeConfigGpuArgsArgs' gpu_args: GPU driver parameters.
        :param _builtins.bool is_schedule: Indicate to schedule the adding node or not. Default is true.
        :param _builtins.str mount_target: Mount target. Default is not mounting.
        :param _builtins.str pre_start_user_script: Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        :param _builtins.str user_data: Base64-encoded User Data text, the length limit is 16KB.
        """
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if desired_pod_num is not None:
            pulumi.set(__self__, "desired_pod_num", desired_pod_num)
        if docker_graph_path is not None:
            pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if gpu_args is not None:
            pulumi.set(__self__, "gpu_args", gpu_args)
        if is_schedule is not None:
            pulumi.set(__self__, "is_schedule", is_schedule)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if pre_start_user_script is not None:
            pulumi.set(__self__, "pre_start_user_script", pre_start_user_script)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.NodePoolNodeConfigDataDisk']]:
        """
        Configurations of data disk.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="desiredPodNum")
    def desired_pod_num(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when the cluster is podCIDR.
        """
        return pulumi.get(self, "desired_pod_num")

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    def docker_graph_path(self) -> Optional[_builtins.str]:
        """
        Docker graph path. Default is `/var/lib/docker`.
        """
        return pulumi.get(self, "docker_graph_path")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom parameter information related to the node. This is a white-list parameter.
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="gpuArgs")
    def gpu_args(self) -> Optional['outputs.NodePoolNodeConfigGpuArgs']:
        """
        GPU driver parameters.
        """
        return pulumi.get(self, "gpu_args")

    @_builtins.property
    @pulumi.getter(name="isSchedule")
    def is_schedule(self) -> Optional[_builtins.bool]:
        """
        Indicate to schedule the adding node or not. Default is true.
        """
        return pulumi.get(self, "is_schedule")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target. Default is not mounting.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="preStartUserScript")
    def pre_start_user_script(self) -> Optional[_builtins.str]:
        """
        Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        """
        return pulumi.get(self, "pre_start_user_script")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        Base64-encoded User Data text, the length limit is 16KB.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class NodePoolNodeConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "mountTarget":
            suggest = "mount_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolNodeConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolNodeConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolNodeConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 file_system: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD`, `CLOUD_BSSD` and `LOCAL_NVME`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str mount_target: Mount target.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD`, `CLOUD_BSSD` and `LOCAL_NVME`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class NodePoolNodeConfigGpuArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDriver":
            suggest = "custom_driver"
        elif key == "migEnable":
            suggest = "mig_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolNodeConfigGpuArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolNodeConfigGpuArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolNodeConfigGpuArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cuda: Optional[Mapping[str, _builtins.str]] = None,
                 cudnn: Optional[Mapping[str, _builtins.str]] = None,
                 custom_driver: Optional[Mapping[str, _builtins.str]] = None,
                 driver: Optional[Mapping[str, _builtins.str]] = None,
                 mig_enable: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] cuda: CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param Mapping[str, _builtins.str] cudnn: cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        :param Mapping[str, _builtins.str] custom_driver: Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        :param Mapping[str, _builtins.str] driver: GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param _builtins.bool mig_enable: Whether to enable MIG.
        """
        if cuda is not None:
            pulumi.set(__self__, "cuda", cuda)
        if cudnn is not None:
            pulumi.set(__self__, "cudnn", cudnn)
        if custom_driver is not None:
            pulumi.set(__self__, "custom_driver", custom_driver)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if mig_enable is not None:
            pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cuda(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "cuda")

    @_builtins.property
    @pulumi.getter
    def cudnn(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        """
        return pulumi.get(self, "cudnn")

    @_builtins.property
    @pulumi.getter(name="customDriver")
    def custom_driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        """
        return pulumi.get(self, "custom_driver")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable MIG.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class NodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: Effect of the taint. Valid values are: `NoSchedule`, `PreferNoSchedule`, `NoExecute`.
        :param _builtins.str key: Key of the taint. The taint key name does not exceed 63 characters, only supports English, numbers,'/','-', and does not allow beginning with ('/').
        :param _builtins.str value: Value of the taint.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Effect of the taint. Valid values are: `NoSchedule`, `PreferNoSchedule`, `NoExecute`.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the taint. The taint key name does not exceed 63 characters, only supports English, numbers,'/','-', and does not allow beginning with ('/').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScaleWorkerDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "mountTarget":
            suggest = "mount_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleWorkerDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleWorkerDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleWorkerDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 file_system: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str mount_target: Mount target.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class ScaleWorkerGpuArgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDriver":
            suggest = "custom_driver"
        elif key == "migEnable":
            suggest = "mig_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleWorkerGpuArgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleWorkerGpuArgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleWorkerGpuArgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cuda: Optional[Mapping[str, _builtins.str]] = None,
                 cudnn: Optional[Mapping[str, _builtins.str]] = None,
                 custom_driver: Optional[Mapping[str, _builtins.str]] = None,
                 driver: Optional[Mapping[str, _builtins.str]] = None,
                 mig_enable: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] cuda: CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param Mapping[str, _builtins.str] cudnn: cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        :param Mapping[str, _builtins.str] custom_driver: Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        :param Mapping[str, _builtins.str] driver: GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        :param _builtins.bool mig_enable: Whether to enable MIG.
        """
        if cuda is not None:
            pulumi.set(__self__, "cuda", cuda)
        if cudnn is not None:
            pulumi.set(__self__, "cudnn", cudnn)
        if custom_driver is not None:
            pulumi.set(__self__, "custom_driver", custom_driver)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if mig_enable is not None:
            pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cuda(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "cuda")

    @_builtins.property
    @pulumi.getter
    def cudnn(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `doc_name`: Doc name of cuDNN; `dev_name`: Dev name of cuDNN.
        """
        return pulumi.get(self, "cudnn")

    @_builtins.property
    @pulumi.getter(name="customDriver")
    def custom_driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
        """
        return pulumi.get(self, "custom_driver")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable MIG.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class ScaleWorkerTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Effect of the taint.
        :param _builtins.str key: Key of the taint.
        :param _builtins.str value: Value of the taint.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScaleWorkerWorkerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "bandwidthPackageId":
            suggest = "bandwidth_package_id"
        elif key == "camRoleName":
            suggest = "cam_role_name"
        elif key == "cdcId":
            suggest = "cdc_id"
        elif key == "dataDisks":
            suggest = "data_disks"
        elif key == "desiredPodNum":
            suggest = "desired_pod_num"
        elif key == "disasterRecoverGroupIds":
            suggest = "disaster_recover_group_ids"
        elif key == "enhancedMonitorService":
            suggest = "enhanced_monitor_service"
        elif key == "enhancedSecurityService":
            suggest = "enhanced_security_service"
        elif key == "hpcClusterId":
            suggest = "hpc_cluster_id"
        elif key == "imgId":
            suggest = "img_id"
        elif key == "instanceChargeType":
            suggest = "instance_charge_type"
        elif key == "instanceChargeTypePrepaidPeriod":
            suggest = "instance_charge_type_prepaid_period"
        elif key == "instanceChargeTypePrepaidRenewFlag":
            suggest = "instance_charge_type_prepaid_renew_flag"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "internetChargeType":
            suggest = "internet_charge_type"
        elif key == "internetMaxBandwidthOut":
            suggest = "internet_max_bandwidth_out"
        elif key == "keyIds":
            suggest = "key_ids"
        elif key == "publicIpAssigned":
            suggest = "public_ip_assigned"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "systemDiskSize":
            suggest = "system_disk_size"
        elif key == "systemDiskType":
            suggest = "system_disk_type"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleWorkerWorkerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleWorkerWorkerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleWorkerWorkerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: _builtins.str,
                 subnet_id: _builtins.str,
                 availability_zone: Optional[_builtins.str] = None,
                 bandwidth_package_id: Optional[_builtins.str] = None,
                 cam_role_name: Optional[_builtins.str] = None,
                 cdc_id: Optional[_builtins.str] = None,
                 count: Optional[_builtins.int] = None,
                 data_disks: Optional[Sequence['outputs.ScaleWorkerWorkerConfigDataDisk']] = None,
                 desired_pod_num: Optional[_builtins.int] = None,
                 disaster_recover_group_ids: Optional[_builtins.str] = None,
                 enhanced_monitor_service: Optional[_builtins.bool] = None,
                 enhanced_security_service: Optional[_builtins.bool] = None,
                 hostname: Optional[_builtins.str] = None,
                 hpc_cluster_id: Optional[_builtins.str] = None,
                 img_id: Optional[_builtins.str] = None,
                 instance_charge_type: Optional[_builtins.str] = None,
                 instance_charge_type_prepaid_period: Optional[_builtins.int] = None,
                 instance_charge_type_prepaid_renew_flag: Optional[_builtins.str] = None,
                 instance_name: Optional[_builtins.str] = None,
                 internet_charge_type: Optional[_builtins.str] = None,
                 internet_max_bandwidth_out: Optional[_builtins.int] = None,
                 key_ids: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 public_ip_assigned: Optional[_builtins.bool] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 system_disk_size: Optional[_builtins.int] = None,
                 system_disk_type: Optional[_builtins.str] = None,
                 tags: Optional[Sequence['outputs.ScaleWorkerWorkerConfigTag']] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_type: Specified types of CVM instance.
        :param _builtins.str subnet_id: Private network ID.
        :param _builtins.str availability_zone: Indicates which availability zone will be used.
        :param _builtins.str bandwidth_package_id: bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        :param _builtins.str cam_role_name: CAM role name authorized to access.
        :param _builtins.str cdc_id: CDC ID.
        :param _builtins.int count: Number of cvm.
        :param Sequence['ScaleWorkerWorkerConfigDataDiskArgs'] data_disks: Configurations of cvm data disk.
        :param _builtins.int desired_pod_num: Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desired_pod_num` or none.
        :param _builtins.str disaster_recover_group_ids: Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
        :param _builtins.bool enhanced_monitor_service: To specify whether to enable cloud monitor service. Default is TRUE.
        :param _builtins.bool enhanced_security_service: To specify whether to enable cloud security service. Default is TRUE.
        :param _builtins.str hostname: The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
        :param _builtins.str hpc_cluster_id: Id of cvm hpc cluster.
        :param _builtins.str img_id: The valid image id, format of img-xxx.
        :param _builtins.str instance_charge_type: The charge type of instance. Valid values are `PREPAID`, `POSTPAID_BY_HOUR`, `SPOTPAID`, `CDCPAID`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
        :param _builtins.int instance_charge_type_prepaid_period: The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        :param _builtins.str instance_charge_type_prepaid_renew_flag: Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        :param _builtins.str instance_name: Name of the CVMs.
        :param _builtins.str internet_charge_type: Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
        :param _builtins.int internet_max_bandwidth_out: Max bandwidth of Internet access in Mbps. Default is 0.
        :param _builtins.str key_ids: ID list of keys, should be set if `password` not set.
        :param _builtins.str password: Password to access, should be set if `key_ids` not set.
        :param _builtins.bool public_ip_assigned: Specify whether to assign an Internet IP address.
        :param Sequence[_builtins.str] security_group_ids: Security groups to which a CVM instance belongs.
        :param _builtins.int system_disk_size: Volume of system disk in GB. Default is `50`.
        :param _builtins.str system_disk_type: System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
        :param Sequence['ScaleWorkerWorkerConfigTagArgs'] tags: Tag pairs.
        :param _builtins.str user_data: User data provided to instances, needs to be encoded in base64, and the maximum supported data size is 16KB.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if bandwidth_package_id is not None:
            pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        if cam_role_name is not None:
            pulumi.set(__self__, "cam_role_name", cam_role_name)
        if cdc_id is not None:
            pulumi.set(__self__, "cdc_id", cdc_id)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if desired_pod_num is not None:
            pulumi.set(__self__, "desired_pod_num", desired_pod_num)
        if disaster_recover_group_ids is not None:
            pulumi.set(__self__, "disaster_recover_group_ids", disaster_recover_group_ids)
        if enhanced_monitor_service is not None:
            pulumi.set(__self__, "enhanced_monitor_service", enhanced_monitor_service)
        if enhanced_security_service is not None:
            pulumi.set(__self__, "enhanced_security_service", enhanced_security_service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hpc_cluster_id is not None:
            pulumi.set(__self__, "hpc_cluster_id", hpc_cluster_id)
        if img_id is not None:
            pulumi.set(__self__, "img_id", img_id)
        if instance_charge_type is not None:
            pulumi.set(__self__, "instance_charge_type", instance_charge_type)
        if instance_charge_type_prepaid_period is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_period", instance_charge_type_prepaid_period)
        if instance_charge_type_prepaid_renew_flag is not None:
            pulumi.set(__self__, "instance_charge_type_prepaid_renew_flag", instance_charge_type_prepaid_renew_flag)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if internet_charge_type is not None:
            pulumi.set(__self__, "internet_charge_type", internet_charge_type)
        if internet_max_bandwidth_out is not None:
            pulumi.set(__self__, "internet_max_bandwidth_out", internet_max_bandwidth_out)
        if key_ids is not None:
            pulumi.set(__self__, "key_ids", key_ids)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if public_ip_assigned is not None:
            pulumi.set(__self__, "public_ip_assigned", public_ip_assigned)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if system_disk_size is not None:
            pulumi.set(__self__, "system_disk_size", system_disk_size)
        if system_disk_type is not None:
            pulumi.set(__self__, "system_disk_type", system_disk_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        """
        Specified types of CVM instance.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Private network ID.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        Indicates which availability zone will be used.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> Optional[_builtins.str]:
        """
        bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="camRoleName")
    def cam_role_name(self) -> Optional[_builtins.str]:
        """
        CAM role name authorized to access.
        """
        return pulumi.get(self, "cam_role_name")

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> Optional[_builtins.str]:
        """
        CDC ID.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of cvm.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[Sequence['outputs.ScaleWorkerWorkerConfigDataDisk']]:
        """
        Configurations of cvm data disk.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="desiredPodNum")
    def desired_pod_num(self) -> Optional[_builtins.int]:
        """
        Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desired_pod_num` or none.
        """
        return pulumi.get(self, "desired_pod_num")

    @_builtins.property
    @pulumi.getter(name="disasterRecoverGroupIds")
    def disaster_recover_group_ids(self) -> Optional[_builtins.str]:
        """
        Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
        """
        return pulumi.get(self, "disaster_recover_group_ids")

    @_builtins.property
    @pulumi.getter(name="enhancedMonitorService")
    def enhanced_monitor_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud monitor service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_monitor_service")

    @_builtins.property
    @pulumi.getter(name="enhancedSecurityService")
    def enhanced_security_service(self) -> Optional[_builtins.bool]:
        """
        To specify whether to enable cloud security service. Default is TRUE.
        """
        return pulumi.get(self, "enhanced_security_service")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="hpcClusterId")
    def hpc_cluster_id(self) -> Optional[_builtins.str]:
        """
        Id of cvm hpc cluster.
        """
        return pulumi.get(self, "hpc_cluster_id")

    @_builtins.property
    @pulumi.getter(name="imgId")
    def img_id(self) -> Optional[_builtins.str]:
        """
        The valid image id, format of img-xxx.
        """
        return pulumi.get(self, "img_id")

    @_builtins.property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> Optional[_builtins.str]:
        """
        The charge type of instance. Valid values are `PREPAID`, `POSTPAID_BY_HOUR`, `SPOTPAID`, `CDCPAID`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
        """
        return pulumi.get(self, "instance_charge_type")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidPeriod")
    def instance_charge_type_prepaid_period(self) -> Optional[_builtins.int]:
        """
        The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_period")

    @_builtins.property
    @pulumi.getter(name="instanceChargeTypePrepaidRenewFlag")
    def instance_charge_type_prepaid_renew_flag(self) -> Optional[_builtins.str]:
        """
        Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.
        """
        return pulumi.get(self, "instance_charge_type_prepaid_renew_flag")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[_builtins.str]:
        """
        Name of the CVMs.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> Optional[_builtins.str]:
        """
        Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
        """
        return pulumi.get(self, "internet_charge_type")

    @_builtins.property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> Optional[_builtins.int]:
        """
        Max bandwidth of Internet access in Mbps. Default is 0.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Optional[_builtins.str]:
        """
        ID list of keys, should be set if `password` not set.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password to access, should be set if `key_ids` not set.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="publicIpAssigned")
    def public_ip_assigned(self) -> Optional[_builtins.bool]:
        """
        Specify whether to assign an Internet IP address.
        """
        return pulumi.get(self, "public_ip_assigned")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security groups to which a CVM instance belongs.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="systemDiskSize")
    def system_disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of system disk in GB. Default is `50`.
        """
        return pulumi.get(self, "system_disk_size")

    @_builtins.property
    @pulumi.getter(name="systemDiskType")
    def system_disk_type(self) -> Optional[_builtins.str]:
        """
        System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
        """
        return pulumi.get(self, "system_disk_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ScaleWorkerWorkerConfigTag']]:
        """
        Tag pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        User data provided to instances, needs to be encoded in base64, and the maximum supported data size is 16KB.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class ScaleWorkerWorkerConfigDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoFormatAndMount":
            suggest = "auto_format_and_mount"
        elif key == "diskPartition":
            suggest = "disk_partition"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "mountTarget":
            suggest = "mount_target"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleWorkerWorkerConfigDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleWorkerWorkerConfigDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleWorkerWorkerConfigDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_format_and_mount: Optional[_builtins.bool] = None,
                 disk_partition: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 encrypt: Optional[_builtins.bool] = None,
                 file_system: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 mount_target: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_format_and_mount: Indicate whether to auto format and mount or not. Default is `false`.
        :param _builtins.str disk_partition: The name of the device or partition to mount.
        :param _builtins.int disk_size: Volume of disk in GB. Default is `0`.
        :param _builtins.str disk_type: Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        :param _builtins.bool encrypt: Indicates whether to encrypt data disk, default `false`.
        :param _builtins.str file_system: File system, e.g. `ext3/ext4/xfs`.
        :param _builtins.str kms_key_id: ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
        :param _builtins.str mount_target: Mount target.
        :param _builtins.str snapshot_id: Data disk snapshot ID.
        """
        if auto_format_and_mount is not None:
            pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        if disk_partition is not None:
            pulumi.set(__self__, "disk_partition", disk_partition)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    @_utilities.deprecated("""This argument was deprecated, use `data_disk` instead.""")
    def auto_format_and_mount(self) -> Optional[_builtins.bool]:
        """
        Indicate whether to auto format and mount or not. Default is `false`.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    @_utilities.deprecated("""This argument was deprecated, use `data_disk` instead.""")
    def disk_partition(self) -> Optional[_builtins.str]:
        """
        The name of the device or partition to mount.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to encrypt data disk, default `false`.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    @_utilities.deprecated("""This argument was deprecated, use `data_disk` instead.""")
    def file_system(self) -> Optional[_builtins.str]:
        """
        File system, e.g. `ext3/ext4/xfs`.
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    @_utilities.deprecated("""This argument was deprecated, use `data_disk` instead.""")
    def mount_target(self) -> Optional[_builtins.str]:
        """
        Mount target.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Data disk snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class ScaleWorkerWorkerConfigTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Tag key.
        :param _builtins.str value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScaleWorkerWorkerInstancesList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedReason":
            suggest = "failed_reason"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceRole":
            suggest = "instance_role"
        elif key == "instanceState":
            suggest = "instance_state"
        elif key == "lanIp":
            suggest = "lan_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleWorkerWorkerInstancesList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleWorkerWorkerInstancesList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleWorkerWorkerInstancesList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_reason: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 instance_role: Optional[_builtins.str] = None,
                 instance_state: Optional[_builtins.str] = None,
                 lan_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str failed_reason: Information of the cvm when it is failed.
        :param _builtins.str instance_id: ID of the cvm.
        :param _builtins.str instance_role: Role of the cvm.
        :param _builtins.str instance_state: State of the cvm.
        :param _builtins.str lan_ip: LAN IP of the cvm.
        """
        if failed_reason is not None:
            pulumi.set(__self__, "failed_reason", failed_reason)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_role is not None:
            pulumi.set(__self__, "instance_role", instance_role)
        if instance_state is not None:
            pulumi.set(__self__, "instance_state", instance_state)
        if lan_ip is not None:
            pulumi.set(__self__, "lan_ip", lan_ip)

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> Optional[_builtins.str]:
        """
        Information of the cvm when it is failed.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        ID of the cvm.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> Optional[_builtins.str]:
        """
        Role of the cvm.
        """
        return pulumi.get(self, "instance_role")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> Optional[_builtins.str]:
        """
        State of the cvm.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> Optional[_builtins.str]:
        """
        LAN IP of the cvm.
        """
        return pulumi.get(self, "lan_ip")


@pulumi.output_type
class ServerlessNodePoolServerlessNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessNodePoolServerlessNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessNodePoolServerlessNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessNodePoolServerlessNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: subnet id of serverless node.
        :param _builtins.str display_name: display name of serverless node.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        subnet id of serverless node.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        display name of serverless node.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ServerlessNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: Effect of the taint. Valid values are: `NoSchedule`, `PreferNoSchedule`, `NoExecute`.
        :param _builtins.str key: Key of the taint. The taint key name does not exceed 63 characters, only supports English, numbers,'/','-', and does not allow beginning with ('/').
        :param _builtins.str value: Value of the taint.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Effect of the taint. Valid values are: `NoSchedule`, `PreferNoSchedule`, `NoExecute`.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the taint. The taint key name does not exceed 63 characters, only supports English, numbers,'/','-', and does not allow beginning with ('/').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAddonsAddonResult(dict):
    def __init__(__self__, *,
                 addon_name: _builtins.str,
                 addon_version: _builtins.str,
                 phase: _builtins.str,
                 raw_values: _builtins.str,
                 reason: _builtins.str):
        """
        :param _builtins.str addon_name: Add-on name (all add-ons in the cluster are returned if this parameter is not specified).
        :param _builtins.str addon_version: Add-on version.
        :param _builtins.str phase: Add-on status
               Note: This field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.str raw_values: Add-on parameters, which are base64-encoded strings in JSON/
               Note: This field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.str reason: Reason for add-on failure
               Note: This field may return `null`, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "addon_name", addon_name)
        pulumi.set(__self__, "addon_version", addon_version)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "raw_values", raw_values)
        pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter(name="addonName")
    def addon_name(self) -> _builtins.str:
        """
        Add-on name (all add-ons in the cluster are returned if this parameter is not specified).
        """
        return pulumi.get(self, "addon_name")

    @_builtins.property
    @pulumi.getter(name="addonVersion")
    def addon_version(self) -> _builtins.str:
        """
        Add-on version.
        """
        return pulumi.get(self, "addon_version")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        Add-on status
        Note: This field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="rawValues")
    def raw_values(self) -> _builtins.str:
        """
        Add-on parameters, which are base64-encoded strings in JSON/
        Note: This field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "raw_values")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> _builtins.str:
        """
        Reason for add-on failure
        Note: This field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class GetAvailableClusterVersionsClusterResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 versions: Sequence[_builtins.str]):
        """
        :param _builtins.str cluster_id: Cluster Id.
        :param Sequence[_builtins.str] versions: Upgradable cluster version number. Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        Cluster Id.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Sequence[_builtins.str]:
        """
        Upgradable cluster version number. Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetChartsChartListResult(dict):
    def __init__(__self__, *,
                 label: Mapping[str, _builtins.str],
                 latest_version: _builtins.str,
                 name: _builtins.str):
        """
        :param Mapping[str, _builtins.str] label: Label of chart.
        :param _builtins.str latest_version: Chart latest version.
        :param _builtins.str name: Name of chart.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Mapping[str, _builtins.str]:
        """
        Label of chart.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> _builtins.str:
        """
        Chart latest version.
        """
        return pulumi.get(self, "latest_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of chart.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetClusterAuthenticationOptionsOidcConfigResult(dict):
    def __init__(__self__, *,
                 auto_create_client_ids: Sequence[_builtins.str],
                 auto_create_oidc_config: _builtins.bool,
                 auto_install_pod_identity_webhook_addon: _builtins.bool):
        """
        :param Sequence[_builtins.str] auto_create_client_ids: Creating ClientId of the identity provider. Note: This field may return `null`, indicating that no valid value can be obtained.
        :param _builtins.bool auto_create_oidc_config: Creating an identity provider. Note: This field may return `null`, indicating that no valid value can be obtained.
        :param _builtins.bool auto_install_pod_identity_webhook_addon: Creating the PodIdentityWebhook component. Note: This field may return `null`, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "auto_create_client_ids", auto_create_client_ids)
        pulumi.set(__self__, "auto_create_oidc_config", auto_create_oidc_config)
        pulumi.set(__self__, "auto_install_pod_identity_webhook_addon", auto_install_pod_identity_webhook_addon)

    @_builtins.property
    @pulumi.getter(name="autoCreateClientIds")
    def auto_create_client_ids(self) -> Sequence[_builtins.str]:
        """
        Creating ClientId of the identity provider. Note: This field may return `null`, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "auto_create_client_ids")

    @_builtins.property
    @pulumi.getter(name="autoCreateOidcConfig")
    def auto_create_oidc_config(self) -> _builtins.bool:
        """
        Creating an identity provider. Note: This field may return `null`, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "auto_create_oidc_config")

    @_builtins.property
    @pulumi.getter(name="autoInstallPodIdentityWebhookAddon")
    def auto_install_pod_identity_webhook_addon(self) -> _builtins.bool:
        """
        Creating the PodIdentityWebhook component. Note: This field may return `null`, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "auto_install_pod_identity_webhook_addon")


@pulumi.output_type
class GetClusterAuthenticationOptionsServiceAccountResult(dict):
    def __init__(__self__, *,
                 auto_create_discovery_anonymous_auth: _builtins.bool,
                 issuer: _builtins.str,
                 jwks_uri: _builtins.str,
                 use_tke_default: _builtins.bool):
        """
        :param _builtins.bool auto_create_discovery_anonymous_auth: If it is set to `true`, a RABC rule is automatically created to allow anonymous users to access `/.well-known/openid-configuration` and `/openid/v1/jwks`. Note: this field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.str issuer: service-account-issuer. Note: this field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.str jwks_uri: service-account-jwks-uri. Note: this field may return `null`, indicating that no valid values can be obtained.
        :param _builtins.bool use_tke_default: Use TKE default issuer and jwksuri. Note: This field may return `null`, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "auto_create_discovery_anonymous_auth", auto_create_discovery_anonymous_auth)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "jwks_uri", jwks_uri)
        pulumi.set(__self__, "use_tke_default", use_tke_default)

    @_builtins.property
    @pulumi.getter(name="autoCreateDiscoveryAnonymousAuth")
    def auto_create_discovery_anonymous_auth(self) -> _builtins.bool:
        """
        If it is set to `true`, a RABC rule is automatically created to allow anonymous users to access `/.well-known/openid-configuration` and `/openid/v1/jwks`. Note: this field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "auto_create_discovery_anonymous_auth")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> _builtins.str:
        """
        service-account-issuer. Note: this field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> _builtins.str:
        """
        service-account-jwks-uri. Note: this field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter(name="useTkeDefault")
    def use_tke_default(self) -> _builtins.bool:
        """
        Use TKE default issuer and jwksuri. Note: This field may return `null`, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "use_tke_default")


@pulumi.output_type
class GetClusterCommonNamesListResult(dict):
    def __init__(__self__, *,
                 common_name: _builtins.str,
                 common_names: _builtins.str,
                 subaccount_uin: _builtins.str):
        """
        :param _builtins.str common_name: The CommonName in the certificate of the client corresponding to the sub-account.
        :param _builtins.str common_names: (**Deprecated**) It has been deprecated from version 1.81.140. Please use `common_name`. The CommonName in the certificate of the client corresponding to the sub-account.
        :param _builtins.str subaccount_uin: User UIN.
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "common_names", common_names)
        pulumi.set(__self__, "subaccount_uin", subaccount_uin)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> _builtins.str:
        """
        The CommonName in the certificate of the client corresponding to the sub-account.
        """
        return pulumi.get(self, "common_name")

    @_builtins.property
    @pulumi.getter(name="commonNames")
    @_utilities.deprecated("""It has been deprecated from version 1.81.140. Please use `common_name`.""")
    def common_names(self) -> _builtins.str:
        """
        (**Deprecated**) It has been deprecated from version 1.81.140. Please use `common_name`. The CommonName in the certificate of the client corresponding to the sub-account.
        """
        return pulumi.get(self, "common_names")

    @_builtins.property
    @pulumi.getter(name="subaccountUin")
    def subaccount_uin(self) -> _builtins.str:
        """
        User UIN.
        """
        return pulumi.get(self, "subaccount_uin")


@pulumi.output_type
class GetClusterInstancesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
        :param Sequence[_builtins.str] values: Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterInstancesInstanceSetResult(dict):
    def __init__(__self__, *,
                 autoscaling_group_id: _builtins.str,
                 created_time: _builtins.str,
                 drain_status: _builtins.str,
                 failed_reason: _builtins.str,
                 instance_advanced_settings: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingResult'],
                 instance_id: _builtins.str,
                 instance_role: _builtins.str,
                 instance_state: _builtins.str,
                 lan_ip: _builtins.str,
                 node_pool_id: _builtins.str):
        """
        :param _builtins.str autoscaling_group_id: Auto scaling group ID.
        :param _builtins.str created_time: Add time.
        :param _builtins.str drain_status: Whether the instance is blocked.
        :param _builtins.str failed_reason: Reasons for instance exception (or being initialized).
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingArgs'] instance_advanced_settings: Node configuration.
        :param _builtins.str instance_id: Instance ID.
        :param _builtins.str instance_role: Node role, MASTER, WORKER, ETCD, MASTER_ETCD,ALL, default is WORKER.
        :param _builtins.str instance_state: The status of the instance (running, initializing, failed).
        :param _builtins.str lan_ip: Node intranet IP.
        :param _builtins.str node_pool_id: Resource pool ID.
        """
        pulumi.set(__self__, "autoscaling_group_id", autoscaling_group_id)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "drain_status", drain_status)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "instance_advanced_settings", instance_advanced_settings)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_role", instance_role)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "lan_ip", lan_ip)
        pulumi.set(__self__, "node_pool_id", node_pool_id)

    @_builtins.property
    @pulumi.getter(name="autoscalingGroupId")
    def autoscaling_group_id(self) -> _builtins.str:
        """
        Auto scaling group ID.
        """
        return pulumi.get(self, "autoscaling_group_id")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.str:
        """
        Add time.
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="drainStatus")
    def drain_status(self) -> _builtins.str:
        """
        Whether the instance is blocked.
        """
        return pulumi.get(self, "drain_status")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        Reasons for instance exception (or being initialized).
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceAdvancedSettings")
    def instance_advanced_settings(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingResult']:
        """
        Node configuration.
        """
        return pulumi.get(self, "instance_advanced_settings")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Instance ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> _builtins.str:
        """
        Node role, MASTER, WORKER, ETCD, MASTER_ETCD,ALL, default is WORKER.
        """
        return pulumi.get(self, "instance_role")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        The status of the instance (running, initializing, failed).
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> _builtins.str:
        """
        Node intranet IP.
        """
        return pulumi.get(self, "lan_ip")

    @_builtins.property
    @pulumi.getter(name="nodePoolId")
    def node_pool_id(self) -> _builtins.str:
        """
        Resource pool ID.
        """
        return pulumi.get(self, "node_pool_id")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingResult(dict):
    def __init__(__self__, *,
                 data_disks: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingDataDiskResult'],
                 desired_pod_number: _builtins.int,
                 docker_graph_path: _builtins.str,
                 extra_args: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingExtraArgResult'],
                 gpu_args: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgResult'],
                 labels: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingLabelResult'],
                 mount_target: _builtins.str,
                 pre_start_user_script: _builtins.str,
                 taints: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingTaintResult'],
                 unschedulable: _builtins.int,
                 user_script: _builtins.str):
        """
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingDataDiskArgs'] data_disks: Multi-disk data disk mounting information.
        :param _builtins.int desired_pod_number: When the node belongs to the podCIDR size customization mode, you can specify the upper limit of the number of pods running on the node.
        :param _builtins.str docker_graph_path: Dockerd --graph specifies the value, the default is /var/lib/docker.
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingExtraArgArgs'] extra_args: Node-related custom parameter information.
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgArgs'] gpu_args: GPU driver related parameters, obtain related GPU parameters: https://cloud.tencent.com/document/api/213/15715.
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingLabelArgs'] labels: Node Label array.
        :param _builtins.str mount_target: Data disk mount point, the data disk is not mounted by default. Formatted ext3, ext4, xfs file system data disks will be mounted directly. Other file systems or unformatted data disks will be automatically formatted as ext4 (tlinux system formatted as xfs) and mounted. Please pay attention to backing up the data. This setting does not take effect for cloud hosts that have no data disks or multiple data disks.
        :param _builtins.str pre_start_user_script: Base64 encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingTaintArgs'] taints: Node taint.
        :param _builtins.int unschedulable: Set whether the added node participates in scheduling. The default value is 0, which means participating in scheduling; non-0 means not participating in scheduling. After the node initialization is completed, you can execute kubectl uncordon nodename to join the node in scheduling.
        :param _builtins.str user_script: Base64 encoded userscript.
        """
        pulumi.set(__self__, "data_disks", data_disks)
        pulumi.set(__self__, "desired_pod_number", desired_pod_number)
        pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "gpu_args", gpu_args)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mount_target", mount_target)
        pulumi.set(__self__, "pre_start_user_script", pre_start_user_script)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "unschedulable", unschedulable)
        pulumi.set(__self__, "user_script", user_script)

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingDataDiskResult']:
        """
        Multi-disk data disk mounting information.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="desiredPodNumber")
    def desired_pod_number(self) -> _builtins.int:
        """
        When the node belongs to the podCIDR size customization mode, you can specify the upper limit of the number of pods running on the node.
        """
        return pulumi.get(self, "desired_pod_number")

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    def docker_graph_path(self) -> _builtins.str:
        """
        Dockerd --graph specifies the value, the default is /var/lib/docker.
        """
        return pulumi.get(self, "docker_graph_path")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingExtraArgResult']:
        """
        Node-related custom parameter information.
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="gpuArgs")
    def gpu_args(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgResult']:
        """
        GPU driver related parameters, obtain related GPU parameters: https://cloud.tencent.com/document/api/213/15715.
        """
        return pulumi.get(self, "gpu_args")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingLabelResult']:
        """
        Node Label array.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> _builtins.str:
        """
        Data disk mount point, the data disk is not mounted by default. Formatted ext3, ext4, xfs file system data disks will be mounted directly. Other file systems or unformatted data disks will be automatically formatted as ext4 (tlinux system formatted as xfs) and mounted. Please pay attention to backing up the data. This setting does not take effect for cloud hosts that have no data disks or multiple data disks.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="preStartUserScript")
    def pre_start_user_script(self) -> _builtins.str:
        """
        Base64 encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        """
        return pulumi.get(self, "pre_start_user_script")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingTaintResult']:
        """
        Node taint.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter
    def unschedulable(self) -> _builtins.int:
        """
        Set whether the added node participates in scheduling. The default value is 0, which means participating in scheduling; non-0 means not participating in scheduling. After the node initialization is completed, you can execute kubectl uncordon nodename to join the node in scheduling.
        """
        return pulumi.get(self, "unschedulable")

    @_builtins.property
    @pulumi.getter(name="userScript")
    def user_script(self) -> _builtins.str:
        """
        Base64 encoded userscript.
        """
        return pulumi.get(self, "user_script")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingDataDiskResult(dict):
    def __init__(__self__, *,
                 auto_format_and_mount: _builtins.bool,
                 disk_partition: _builtins.str,
                 disk_size: _builtins.int,
                 disk_type: _builtins.str,
                 file_system: _builtins.str,
                 mount_target: _builtins.str):
        """
        :param _builtins.bool auto_format_and_mount: Whether to automatically format the disk and mount it.
        :param _builtins.str disk_partition: Mount device name or partition name, required when and only when adding an existing node.
        :param _builtins.int disk_size: Cloud disk size (G).
        :param _builtins.str disk_type: Cloud disk type.
        :param _builtins.str file_system: File system (ext3/ext4/xfs).
        :param _builtins.str mount_target: Data disk mount point, the data disk is not mounted by default. Formatted ext3, ext4, xfs file system data disks will be mounted directly. Other file systems or unformatted data disks will be automatically formatted as ext4 (tlinux system formatted as xfs) and mounted. Please pay attention to backing up the data. This setting does not take effect for cloud hosts that have no data disks or multiple data disks.
        """
        pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        pulumi.set(__self__, "disk_partition", disk_partition)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "file_system", file_system)
        pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> _builtins.bool:
        """
        Whether to automatically format the disk and mount it.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> _builtins.str:
        """
        Mount device name or partition name, required when and only when adding an existing node.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Cloud disk size (G).
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        Cloud disk type.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> _builtins.str:
        """
        File system (ext3/ext4/xfs).
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> _builtins.str:
        """
        Data disk mount point, the data disk is not mounted by default. Formatted ext3, ext4, xfs file system data disks will be mounted directly. Other file systems or unformatted data disks will be automatically formatted as ext4 (tlinux system formatted as xfs) and mounted. Please pay attention to backing up the data. This setting does not take effect for cloud hosts that have no data disks or multiple data disks.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingExtraArgResult(dict):
    def __init__(__self__, *,
                 kubelets: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] kubelets: Kubelet custom parameters.
        """
        pulumi.set(__self__, "kubelets", kubelets)

    @_builtins.property
    @pulumi.getter
    def kubelets(self) -> Sequence[_builtins.str]:
        """
        Kubelet custom parameters.
        """
        return pulumi.get(self, "kubelets")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgResult(dict):
    def __init__(__self__, *,
                 cudas: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudaResult'],
                 cudnns: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudnnResult'],
                 custom_drivers: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCustomDriverResult'],
                 drivers: Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgDriverResult'],
                 mig_enable: _builtins.bool):
        """
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudaArgs'] cudas: CUDA version information.
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudnnArgs'] cudnns: CuDNN version information.
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCustomDriverArgs'] custom_drivers: Custom GPU driver information.
        :param Sequence['GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgDriverArgs'] drivers: GPU driver version information.
        :param _builtins.bool mig_enable: Whether to enable MIG features.
        """
        pulumi.set(__self__, "cudas", cudas)
        pulumi.set(__self__, "cudnns", cudnns)
        pulumi.set(__self__, "custom_drivers", custom_drivers)
        pulumi.set(__self__, "drivers", drivers)
        pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cudas(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudaResult']:
        """
        CUDA version information.
        """
        return pulumi.get(self, "cudas")

    @_builtins.property
    @pulumi.getter
    def cudnns(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudnnResult']:
        """
        CuDNN version information.
        """
        return pulumi.get(self, "cudnns")

    @_builtins.property
    @pulumi.getter(name="customDrivers")
    def custom_drivers(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCustomDriverResult']:
        """
        Custom GPU driver information.
        """
        return pulumi.get(self, "custom_drivers")

    @_builtins.property
    @pulumi.getter
    def drivers(self) -> Sequence['outputs.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgDriverResult']:
        """
        GPU driver version information.
        """
        return pulumi.get(self, "drivers")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> _builtins.bool:
        """
        Whether to enable MIG features.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudaResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: Name in the map table.
        :param _builtins.str version: GPU driver or CUDA version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name in the map table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        GPU driver or CUDA version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudnnResult(dict):
    def __init__(__self__, *,
                 dev_name: _builtins.str,
                 doc_name: _builtins.str,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str dev_name: Dev name of cuDNN.
        :param _builtins.str doc_name: Doc name of cuDNN.
        :param _builtins.str name: Name in the map table.
        :param _builtins.str version: GPU driver or CUDA version.
        """
        pulumi.set(__self__, "dev_name", dev_name)
        pulumi.set(__self__, "doc_name", doc_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="devName")
    def dev_name(self) -> _builtins.str:
        """
        Dev name of cuDNN.
        """
        return pulumi.get(self, "dev_name")

    @_builtins.property
    @pulumi.getter(name="docName")
    def doc_name(self) -> _builtins.str:
        """
        Doc name of cuDNN.
        """
        return pulumi.get(self, "doc_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name in the map table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        GPU driver or CUDA version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCustomDriverResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: Custom GPU driver address link.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Custom GPU driver address link.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgDriverResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: Name in the map table.
        :param _builtins.str version: GPU driver or CUDA version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name in the map table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        GPU driver or CUDA version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingLabelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name in the map table.
        :param _builtins.str value: Value of taints mark.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name in the map table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of taints mark.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterInstancesInstanceSetInstanceAdvancedSettingTaintResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: Effect of taints mark.
        :param _builtins.str key: Key of taints mark.
        :param _builtins.str value: Value of taints mark.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Effect of taints mark.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of taints mark.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of taints mark.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterLevelsListResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 config_map_count: _builtins.int,
                 crd_count: _builtins.int,
                 enable: _builtins.bool,
                 name: _builtins.str,
                 node_count: _builtins.int,
                 other_count: _builtins.int,
                 pod_count: _builtins.int):
        """
        :param _builtins.str alias: Alias used for pass to cluster level arguments.
        :param _builtins.int config_map_count: Number of ConfigMaps.
        :param _builtins.int crd_count: Number of CRDs.
        :param _builtins.bool enable: Indicates whether the current level enabled.
        :param _builtins.str name: Level name.
        :param _builtins.int node_count: Number of nodes.
        :param _builtins.int other_count: Number of others.
        :param _builtins.int pod_count: Number of pods.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "config_map_count", config_map_count)
        pulumi.set(__self__, "crd_count", crd_count)
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "other_count", other_count)
        pulumi.set(__self__, "pod_count", pod_count)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        Alias used for pass to cluster level arguments.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="configMapCount")
    def config_map_count(self) -> _builtins.int:
        """
        Number of ConfigMaps.
        """
        return pulumi.get(self, "config_map_count")

    @_builtins.property
    @pulumi.getter(name="crdCount")
    def crd_count(self) -> _builtins.int:
        """
        Number of CRDs.
        """
        return pulumi.get(self, "crd_count")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Indicates whether the current level enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Level name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="otherCount")
    def other_count(self) -> _builtins.int:
        """
        Number of others.
        """
        return pulumi.get(self, "other_count")

    @_builtins.property
    @pulumi.getter(name="podCount")
    def pod_count(self) -> _builtins.int:
        """
        Number of pods.
        """
        return pulumi.get(self, "pod_count")


@pulumi.output_type
class GetClusterNativeNodePoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
        :param Sequence[_builtins.str] values: Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolResult(dict):
    def __init__(__self__, *,
                 annotations: Sequence['outputs.GetClusterNativeNodePoolsNodePoolAnnotationResult'],
                 cluster_id: _builtins.str,
                 created_at: _builtins.str,
                 deletion_protection: _builtins.bool,
                 labels: Sequence['outputs.GetClusterNativeNodePoolsNodePoolLabelResult'],
                 life_state: _builtins.str,
                 name: _builtins.str,
                 natives: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeResult'],
                 node_pool_id: _builtins.str,
                 tags: Sequence['outputs.GetClusterNativeNodePoolsNodePoolTagResult'],
                 taints: Sequence['outputs.GetClusterNativeNodePoolsNodePoolTaintResult'],
                 type: _builtins.str,
                 unschedulable: _builtins.bool):
        """
        :param Sequence['GetClusterNativeNodePoolsNodePoolAnnotationArgs'] annotations: Node Annotation List.
        :param _builtins.str cluster_id: ID of the cluster.
        :param _builtins.str created_at: Creation time.
        :param _builtins.bool deletion_protection: Whether to enable deletion protection.
        :param Sequence['GetClusterNativeNodePoolsNodePoolLabelArgs'] labels: Node Labels.
        :param _builtins.str life_state: Node pool status.
        :param _builtins.str name: Node pool name.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeArgs'] natives: Native node pool creation parameters.
        :param _builtins.str node_pool_id: ID of the node pool.
        :param Sequence['GetClusterNativeNodePoolsNodePoolTagArgs'] tags: Tag pair list.
        :param Sequence['GetClusterNativeNodePoolsNodePoolTaintArgs'] taints: node taint.
        :param _builtins.str type: Node pool type. Optional value is `Native`.
        :param _builtins.bool unschedulable: Whether the node is not schedulable by default.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deletion_protection", deletion_protection)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "life_state", life_state)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "natives", natives)
        pulumi.set(__self__, "node_pool_id", node_pool_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unschedulable", unschedulable)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolAnnotationResult']:
        """
        Node Annotation List.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> _builtins.bool:
        """
        Whether to enable deletion protection.
        """
        return pulumi.get(self, "deletion_protection")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolLabelResult']:
        """
        Node Labels.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="lifeState")
    def life_state(self) -> _builtins.str:
        """
        Node pool status.
        """
        return pulumi.get(self, "life_state")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Node pool name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def natives(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeResult']:
        """
        Native node pool creation parameters.
        """
        return pulumi.get(self, "natives")

    @_builtins.property
    @pulumi.getter(name="nodePoolId")
    def node_pool_id(self) -> _builtins.str:
        """
        ID of the node pool.
        """
        return pulumi.get(self, "node_pool_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolTagResult']:
        """
        Tag pair list.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolTaintResult']:
        """
        node taint.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Node pool type. Optional value is `Native`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unschedulable(self) -> _builtins.bool:
        """
        Whether the node is not schedulable by default.
        """
        return pulumi.get(self, "unschedulable")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolAnnotationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Node pool name.
        :param _builtins.str value: Value of the taint.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Node pool name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolLabelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Node pool name.
        :param _builtins.str value: Value of the taint.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Node pool name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeResult(dict):
    def __init__(__self__, *,
                 auto_repair: _builtins.bool,
                 data_disks: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeDataDiskResult'],
                 enable_autoscaling: _builtins.bool,
                 health_check_policy_name: _builtins.str,
                 host_name_pattern: _builtins.str,
                 instance_charge_prepaids: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeInstanceChargePrepaidResult'],
                 instance_charge_type: _builtins.str,
                 instance_types: Sequence[_builtins.str],
                 internet_accessibles: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeInternetAccessibleResult'],
                 key_ids: Sequence[_builtins.str],
                 kubelet_args: Sequence[_builtins.str],
                 lifecycles: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeLifecycleResult'],
                 managements: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeManagementResult'],
                 replicas: _builtins.int,
                 runtime_root_dir: _builtins.str,
                 scalings: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeScalingResult'],
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 system_disks: Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeSystemDiskResult']):
        """
        :param _builtins.bool auto_repair: Whether to enable self-healing ability.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeDataDiskArgs'] data_disks: Native node pool data disk list.
        :param _builtins.bool enable_autoscaling: Whether to enable elastic scaling.
        :param _builtins.str health_check_policy_name: Fault self-healing rule name.
        :param _builtins.str host_name_pattern: Native node pool hostName pattern string.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeInstanceChargePrepaidArgs'] instance_charge_prepaids: Billing configuration for yearly and monthly models.
        :param _builtins.str instance_charge_type: Node billing type. `PREPAID` is a yearly and monthly subscription, `POSTPAID_BY_HOUR` is a pay-as-you-go plan. The default is `POSTPAID_BY_HOUR`.
        :param Sequence[_builtins.str] instance_types: Model list.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeInternetAccessibleArgs'] internet_accessibles: Public network bandwidth settings.
        :param Sequence[_builtins.str] key_ids: Node pool ssh public key id array.
        :param Sequence[_builtins.str] kubelet_args: Kubelet custom parameters.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeLifecycleArgs'] lifecycles: Predefined scripts.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeManagementArgs'] managements: Node pool management parameter settings.
        :param _builtins.int replicas: Desired number of nodes.
        :param _builtins.str runtime_root_dir: Runtime root directory.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeScalingArgs'] scalings: Node pool scaling configuration.
        :param Sequence[_builtins.str] security_group_ids: Security group list.
        :param Sequence[_builtins.str] subnet_ids: Subnet list.
        :param Sequence['GetClusterNativeNodePoolsNodePoolNativeSystemDiskArgs'] system_disks: System disk configuration.
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "data_disks", data_disks)
        pulumi.set(__self__, "enable_autoscaling", enable_autoscaling)
        pulumi.set(__self__, "health_check_policy_name", health_check_policy_name)
        pulumi.set(__self__, "host_name_pattern", host_name_pattern)
        pulumi.set(__self__, "instance_charge_prepaids", instance_charge_prepaids)
        pulumi.set(__self__, "instance_charge_type", instance_charge_type)
        pulumi.set(__self__, "instance_types", instance_types)
        pulumi.set(__self__, "internet_accessibles", internet_accessibles)
        pulumi.set(__self__, "key_ids", key_ids)
        pulumi.set(__self__, "kubelet_args", kubelet_args)
        pulumi.set(__self__, "lifecycles", lifecycles)
        pulumi.set(__self__, "managements", managements)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "runtime_root_dir", runtime_root_dir)
        pulumi.set(__self__, "scalings", scalings)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "system_disks", system_disks)

    @_builtins.property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> _builtins.bool:
        """
        Whether to enable self-healing ability.
        """
        return pulumi.get(self, "auto_repair")

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeDataDiskResult']:
        """
        Native node pool data disk list.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="enableAutoscaling")
    def enable_autoscaling(self) -> _builtins.bool:
        """
        Whether to enable elastic scaling.
        """
        return pulumi.get(self, "enable_autoscaling")

    @_builtins.property
    @pulumi.getter(name="healthCheckPolicyName")
    def health_check_policy_name(self) -> _builtins.str:
        """
        Fault self-healing rule name.
        """
        return pulumi.get(self, "health_check_policy_name")

    @_builtins.property
    @pulumi.getter(name="hostNamePattern")
    def host_name_pattern(self) -> _builtins.str:
        """
        Native node pool hostName pattern string.
        """
        return pulumi.get(self, "host_name_pattern")

    @_builtins.property
    @pulumi.getter(name="instanceChargePrepaids")
    def instance_charge_prepaids(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeInstanceChargePrepaidResult']:
        """
        Billing configuration for yearly and monthly models.
        """
        return pulumi.get(self, "instance_charge_prepaids")

    @_builtins.property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> _builtins.str:
        """
        Node billing type. `PREPAID` is a yearly and monthly subscription, `POSTPAID_BY_HOUR` is a pay-as-you-go plan. The default is `POSTPAID_BY_HOUR`.
        """
        return pulumi.get(self, "instance_charge_type")

    @_builtins.property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Sequence[_builtins.str]:
        """
        Model list.
        """
        return pulumi.get(self, "instance_types")

    @_builtins.property
    @pulumi.getter(name="internetAccessibles")
    def internet_accessibles(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeInternetAccessibleResult']:
        """
        Public network bandwidth settings.
        """
        return pulumi.get(self, "internet_accessibles")

    @_builtins.property
    @pulumi.getter(name="keyIds")
    def key_ids(self) -> Sequence[_builtins.str]:
        """
        Node pool ssh public key id array.
        """
        return pulumi.get(self, "key_ids")

    @_builtins.property
    @pulumi.getter(name="kubeletArgs")
    def kubelet_args(self) -> Sequence[_builtins.str]:
        """
        Kubelet custom parameters.
        """
        return pulumi.get(self, "kubelet_args")

    @_builtins.property
    @pulumi.getter
    def lifecycles(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeLifecycleResult']:
        """
        Predefined scripts.
        """
        return pulumi.get(self, "lifecycles")

    @_builtins.property
    @pulumi.getter
    def managements(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeManagementResult']:
        """
        Node pool management parameter settings.
        """
        return pulumi.get(self, "managements")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        """
        Desired number of nodes.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter(name="runtimeRootDir")
    def runtime_root_dir(self) -> _builtins.str:
        """
        Runtime root directory.
        """
        return pulumi.get(self, "runtime_root_dir")

    @_builtins.property
    @pulumi.getter
    def scalings(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeScalingResult']:
        """
        Node pool scaling configuration.
        """
        return pulumi.get(self, "scalings")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Security group list.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        Subnet list.
        """
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="systemDisks")
    def system_disks(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolNativeSystemDiskResult']:
        """
        System disk configuration.
        """
        return pulumi.get(self, "system_disks")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeDataDiskResult(dict):
    def __init__(__self__, *,
                 auto_format_and_mount: _builtins.bool,
                 disk_partition: _builtins.str,
                 disk_size: _builtins.int,
                 disk_type: _builtins.str,
                 encrypt: _builtins.str,
                 file_system: _builtins.str,
                 kms_key_id: _builtins.str,
                 mount_target: _builtins.str,
                 snapshot_id: _builtins.str,
                 throughput_performance: _builtins.int):
        """
        :param _builtins.bool auto_format_and_mount: Whether to automatically format the disk and mount it.
        :param _builtins.str disk_partition: Mount device name or partition name.
        :param _builtins.int disk_size: Cloud disk size (G).
        :param _builtins.str disk_type: Cloud disk type.
        :param _builtins.str encrypt: Pass in this parameter to create an encrypted cloud disk. The value is fixed to `ENCRYPT`.
        :param _builtins.str file_system: File system (ext3/ext4/xfs).
        :param _builtins.str kms_key_id: Customize the key when purchasing an encrypted disk. When this parameter is passed in, the Encrypt parameter is not empty.
        :param _builtins.str mount_target: Mount directory.
        :param _builtins.str snapshot_id: Snapshot ID. If passed in, the cloud disk will be created based on this snapshot. The snapshot type must be a data disk snapshot.
        :param _builtins.int throughput_performance: Cloud disk performance, unit: MB/s. Use this parameter to purchase additional performance for the cloud disk.
        """
        pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        pulumi.set(__self__, "disk_partition", disk_partition)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "encrypt", encrypt)
        pulumi.set(__self__, "file_system", file_system)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "mount_target", mount_target)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "throughput_performance", throughput_performance)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> _builtins.bool:
        """
        Whether to automatically format the disk and mount it.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> _builtins.str:
        """
        Mount device name or partition name.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Cloud disk size (G).
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        Cloud disk type.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def encrypt(self) -> _builtins.str:
        """
        Pass in this parameter to create an encrypted cloud disk. The value is fixed to `ENCRYPT`.
        """
        return pulumi.get(self, "encrypt")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> _builtins.str:
        """
        File system (ext3/ext4/xfs).
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        Customize the key when purchasing an encrypted disk. When this parameter is passed in, the Encrypt parameter is not empty.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> _builtins.str:
        """
        Mount directory.
        """
        return pulumi.get(self, "mount_target")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        Snapshot ID. If passed in, the cloud disk will be created based on this snapshot. The snapshot type must be a data disk snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="throughputPerformance")
    def throughput_performance(self) -> _builtins.int:
        """
        Cloud disk performance, unit: MB/s. Use this parameter to purchase additional performance for the cloud disk.
        """
        return pulumi.get(self, "throughput_performance")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeInstanceChargePrepaidResult(dict):
    def __init__(__self__, *,
                 period: _builtins.int,
                 renew_flag: _builtins.str):
        """
        :param _builtins.int period: Postpaid billing cycle, unit (month): 1, 2, 3, 4, 5,, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        :param _builtins.str renew_flag: Prepaid renewal method:
               - `NOTIFY_AND_AUTO_RENEW`: Notify users of expiration and automatically renew (default).
               - `NOTIFY_AND_MANUAL_RENEW`: Notify users of expiration, but do not automatically renew.
               - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: Do not notify users of expiration and do not automatically renew.
        """
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        Postpaid billing cycle, unit (month): 1, 2, 3, 4, 5,, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> _builtins.str:
        """
        Prepaid renewal method:
        - `NOTIFY_AND_AUTO_RENEW`: Notify users of expiration and automatically renew (default).
        - `NOTIFY_AND_MANUAL_RENEW`: Notify users of expiration, but do not automatically renew.
        - `DISABLE_NOTIFY_AND_MANUAL_RENEW`: Do not notify users of expiration and do not automatically renew.
        """
        return pulumi.get(self, "renew_flag")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeInternetAccessibleResult(dict):
    def __init__(__self__, *,
                 bandwidth_package_id: _builtins.str,
                 charge_type: _builtins.str,
                 max_bandwidth_out: _builtins.int):
        """
        :param _builtins.str bandwidth_package_id: Bandwidth package ID. Note: When ChargeType is BANDWIDTH_PACKAG, the value cannot be empty; otherwise, the value must be empty.
        :param _builtins.str charge_type: Network billing method. Optional value is `TRAFFIC_POSTPAID_BY_HOUR`, `BANDWIDTH_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
        :param _builtins.int max_bandwidth_out: Maximum bandwidth output. Note: When chargeType is `TRAFFIC_POSTPAID_BY_HOUR` and `BANDWIDTH_POSTPAID_BY_HOUR`, the valid range is 1~100. When chargeType is `BANDWIDTH_PACKAG`, the valid range is 1~2000.
        """
        pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        pulumi.set(__self__, "charge_type", charge_type)
        pulumi.set(__self__, "max_bandwidth_out", max_bandwidth_out)

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> _builtins.str:
        """
        Bandwidth package ID. Note: When ChargeType is BANDWIDTH_PACKAG, the value cannot be empty; otherwise, the value must be empty.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="chargeType")
    def charge_type(self) -> _builtins.str:
        """
        Network billing method. Optional value is `TRAFFIC_POSTPAID_BY_HOUR`, `BANDWIDTH_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
        """
        return pulumi.get(self, "charge_type")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthOut")
    def max_bandwidth_out(self) -> _builtins.int:
        """
        Maximum bandwidth output. Note: When chargeType is `TRAFFIC_POSTPAID_BY_HOUR` and `BANDWIDTH_POSTPAID_BY_HOUR`, the valid range is 1~100. When chargeType is `BANDWIDTH_PACKAG`, the valid range is 1~2000.
        """
        return pulumi.get(self, "max_bandwidth_out")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeLifecycleResult(dict):
    def __init__(__self__, *,
                 post_init: _builtins.str,
                 pre_init: _builtins.str):
        """
        :param _builtins.str post_init: Custom script after node initialization.
        :param _builtins.str pre_init: Custom script before node initialization.
        """
        pulumi.set(__self__, "post_init", post_init)
        pulumi.set(__self__, "pre_init", pre_init)

    @_builtins.property
    @pulumi.getter(name="postInit")
    def post_init(self) -> _builtins.str:
        """
        Custom script after node initialization.
        """
        return pulumi.get(self, "post_init")

    @_builtins.property
    @pulumi.getter(name="preInit")
    def pre_init(self) -> _builtins.str:
        """
        Custom script before node initialization.
        """
        return pulumi.get(self, "pre_init")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeManagementResult(dict):
    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 kernel_args: Sequence[_builtins.str],
                 nameservers: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] hosts: Hosts configuration.
        :param Sequence[_builtins.str] kernel_args: Kernel parameter configuration.
        :param Sequence[_builtins.str] nameservers: Dns configuration.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "kernel_args", kernel_args)
        pulumi.set(__self__, "nameservers", nameservers)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        """
        Hosts configuration.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="kernelArgs")
    def kernel_args(self) -> Sequence[_builtins.str]:
        """
        Kernel parameter configuration.
        """
        return pulumi.get(self, "kernel_args")

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Sequence[_builtins.str]:
        """
        Dns configuration.
        """
        return pulumi.get(self, "nameservers")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeScalingResult(dict):
    def __init__(__self__, *,
                 create_policy: _builtins.str,
                 max_replicas: _builtins.int,
                 min_replicas: _builtins.int):
        """
        :param _builtins.str create_policy: Node pool expansion strategy. `ZoneEquality`: multiple availability zones are broken up; `ZonePriority`: the preferred availability zone takes precedence.
        :param _builtins.int max_replicas: Maximum number of replicas in node pool.
        :param _builtins.int min_replicas: Minimum number of replicas in node pool.
        """
        pulumi.set(__self__, "create_policy", create_policy)
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)

    @_builtins.property
    @pulumi.getter(name="createPolicy")
    def create_policy(self) -> _builtins.str:
        """
        Node pool expansion strategy. `ZoneEquality`: multiple availability zones are broken up; `ZonePriority`: the preferred availability zone takes precedence.
        """
        return pulumi.get(self, "create_policy")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        Maximum number of replicas in node pool.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        Minimum number of replicas in node pool.
        """
        return pulumi.get(self, "min_replicas")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolNativeSystemDiskResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type: _builtins.str):
        """
        :param _builtins.int disk_size: Cloud disk size (G).
        :param _builtins.str disk_type: Cloud disk type.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Cloud disk size (G).
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        Cloud disk type.
        """
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolTagResult(dict):
    def __init__(__self__, *,
                 resource_type: _builtins.str,
                 tags: Sequence['outputs.GetClusterNativeNodePoolsNodePoolTagTagResult']):
        """
        :param _builtins.str resource_type: The resource type bound to the label.
        :param Sequence['GetClusterNativeNodePoolsNodePoolTagTagArgs'] tags: Tag pair list.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The resource type bound to the label.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetClusterNativeNodePoolsNodePoolTagTagResult']:
        """
        Tag pair list.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolTagTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Key of the taint.
        :param _builtins.str value: Value of the taint.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNativeNodePoolsNodePoolTaintResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: Effect of the taint.
        :param _builtins.str key: Key of the taint.
        :param _builtins.str value: Value of the taint.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNodePoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
        :param Sequence[_builtins.str] values: Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetResult(dict):
    def __init__(__self__, *,
                 autoscaling_group_id: _builtins.str,
                 autoscaling_group_status: _builtins.str,
                 cluster_instance_id: _builtins.str,
                 data_disks: Sequence['outputs.GetClusterNodePoolsNodePoolSetDataDiskResult'],
                 deletion_protection: _builtins.bool,
                 desired_nodes_num: _builtins.int,
                 desired_pod_num: _builtins.int,
                 docker_graph_path: _builtins.str,
                 extra_args: Sequence['outputs.GetClusterNodePoolsNodePoolSetExtraArgResult'],
                 gpu_args: Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgResult'],
                 image_id: _builtins.str,
                 labels: Sequence['outputs.GetClusterNodePoolsNodePoolSetLabelResult'],
                 launch_configuration_id: _builtins.str,
                 life_state: _builtins.str,
                 max_nodes_num: _builtins.int,
                 min_nodes_num: _builtins.int,
                 name: _builtins.str,
                 node_count_summaries: Sequence['outputs.GetClusterNodePoolsNodePoolSetNodeCountSummaryResult'],
                 node_pool_id: _builtins.str,
                 node_pool_os: _builtins.str,
                 os_customize_type: _builtins.str,
                 pre_start_user_script: _builtins.str,
                 tags: Sequence['outputs.GetClusterNodePoolsNodePoolSetTagResult'],
                 taints: Sequence['outputs.GetClusterNodePoolsNodePoolSetTaintResult'],
                 unschedulable: _builtins.int,
                 user_script: _builtins.str):
        """
        :param _builtins.str autoscaling_group_id: ID of autoscaling group.
        :param _builtins.str autoscaling_group_status: Status information.
        :param _builtins.str cluster_instance_id: ID of the cluster.
        :param Sequence['GetClusterNodePoolsNodePoolSetDataDiskArgs'] data_disks: Multi disk data disk mounting information.
        :param _builtins.bool deletion_protection: Remove protection switch.
        :param _builtins.int desired_nodes_num: Expected number of nodes.
        :param _builtins.int desired_pod_num: When the cluster belongs to the node podCIDR size customization mode, the node pool needs to have the pod number attribute.
        :param _builtins.str docker_graph_path: Dockerd --graph specified value, default to /var/lib/docker.
        :param Sequence['GetClusterNodePoolsNodePoolSetExtraArgArgs'] extra_args: Node configuration.
        :param Sequence['GetClusterNodePoolsNodePoolSetGpuArgArgs'] gpu_args: GPU driver related parameters.
        :param _builtins.str image_id: ID of image.
        :param Sequence['GetClusterNodePoolsNodePoolSetLabelArgs'] labels: Labels of the node pool.
        :param _builtins.str launch_configuration_id: ID of launch configuration.
        :param _builtins.str life_state: Life cycle state of the node pool, include: creating, normal, updating, deleting, deleted.
        :param _builtins.int max_nodes_num: Maximum number of nodes.
        :param _builtins.int min_nodes_num: Minimum number of nodes.
        :param _builtins.str name: Name of the node pool.
        :param Sequence['GetClusterNodePoolsNodePoolSetNodeCountSummaryArgs'] node_count_summaries: Node List.
        :param _builtins.str node_pool_id: ID of the node pool.
        :param _builtins.str node_pool_os: Node Pool OS Name.
        :param _builtins.str os_customize_type: Mirror version of container.
        :param _builtins.str pre_start_user_script: User defined script, executed before User Script.
        :param Sequence['GetClusterNodePoolsNodePoolSetTagArgs'] tags: Resource tags.
        :param Sequence['GetClusterNodePoolsNodePoolSetTaintArgs'] taints: Labels of the node pool.
        :param _builtins.int unschedulable: Is it not schedulable.
        :param _builtins.str user_script: User defined scripts.
        """
        pulumi.set(__self__, "autoscaling_group_id", autoscaling_group_id)
        pulumi.set(__self__, "autoscaling_group_status", autoscaling_group_status)
        pulumi.set(__self__, "cluster_instance_id", cluster_instance_id)
        pulumi.set(__self__, "data_disks", data_disks)
        pulumi.set(__self__, "deletion_protection", deletion_protection)
        pulumi.set(__self__, "desired_nodes_num", desired_nodes_num)
        pulumi.set(__self__, "desired_pod_num", desired_pod_num)
        pulumi.set(__self__, "docker_graph_path", docker_graph_path)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "gpu_args", gpu_args)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "launch_configuration_id", launch_configuration_id)
        pulumi.set(__self__, "life_state", life_state)
        pulumi.set(__self__, "max_nodes_num", max_nodes_num)
        pulumi.set(__self__, "min_nodes_num", min_nodes_num)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count_summaries", node_count_summaries)
        pulumi.set(__self__, "node_pool_id", node_pool_id)
        pulumi.set(__self__, "node_pool_os", node_pool_os)
        pulumi.set(__self__, "os_customize_type", os_customize_type)
        pulumi.set(__self__, "pre_start_user_script", pre_start_user_script)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "unschedulable", unschedulable)
        pulumi.set(__self__, "user_script", user_script)

    @_builtins.property
    @pulumi.getter(name="autoscalingGroupId")
    def autoscaling_group_id(self) -> _builtins.str:
        """
        ID of autoscaling group.
        """
        return pulumi.get(self, "autoscaling_group_id")

    @_builtins.property
    @pulumi.getter(name="autoscalingGroupStatus")
    def autoscaling_group_status(self) -> _builtins.str:
        """
        Status information.
        """
        return pulumi.get(self, "autoscaling_group_status")

    @_builtins.property
    @pulumi.getter(name="clusterInstanceId")
    def cluster_instance_id(self) -> _builtins.str:
        """
        ID of the cluster.
        """
        return pulumi.get(self, "cluster_instance_id")

    @_builtins.property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetDataDiskResult']:
        """
        Multi disk data disk mounting information.
        """
        return pulumi.get(self, "data_disks")

    @_builtins.property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> _builtins.bool:
        """
        Remove protection switch.
        """
        return pulumi.get(self, "deletion_protection")

    @_builtins.property
    @pulumi.getter(name="desiredNodesNum")
    def desired_nodes_num(self) -> _builtins.int:
        """
        Expected number of nodes.
        """
        return pulumi.get(self, "desired_nodes_num")

    @_builtins.property
    @pulumi.getter(name="desiredPodNum")
    def desired_pod_num(self) -> _builtins.int:
        """
        When the cluster belongs to the node podCIDR size customization mode, the node pool needs to have the pod number attribute.
        """
        return pulumi.get(self, "desired_pod_num")

    @_builtins.property
    @pulumi.getter(name="dockerGraphPath")
    def docker_graph_path(self) -> _builtins.str:
        """
        Dockerd --graph specified value, default to /var/lib/docker.
        """
        return pulumi.get(self, "docker_graph_path")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetExtraArgResult']:
        """
        Node configuration.
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="gpuArgs")
    def gpu_args(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgResult']:
        """
        GPU driver related parameters.
        """
        return pulumi.get(self, "gpu_args")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        ID of image.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetLabelResult']:
        """
        Labels of the node pool.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="launchConfigurationId")
    def launch_configuration_id(self) -> _builtins.str:
        """
        ID of launch configuration.
        """
        return pulumi.get(self, "launch_configuration_id")

    @_builtins.property
    @pulumi.getter(name="lifeState")
    def life_state(self) -> _builtins.str:
        """
        Life cycle state of the node pool, include: creating, normal, updating, deleting, deleted.
        """
        return pulumi.get(self, "life_state")

    @_builtins.property
    @pulumi.getter(name="maxNodesNum")
    def max_nodes_num(self) -> _builtins.int:
        """
        Maximum number of nodes.
        """
        return pulumi.get(self, "max_nodes_num")

    @_builtins.property
    @pulumi.getter(name="minNodesNum")
    def min_nodes_num(self) -> _builtins.int:
        """
        Minimum number of nodes.
        """
        return pulumi.get(self, "min_nodes_num")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCountSummaries")
    def node_count_summaries(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetNodeCountSummaryResult']:
        """
        Node List.
        """
        return pulumi.get(self, "node_count_summaries")

    @_builtins.property
    @pulumi.getter(name="nodePoolId")
    def node_pool_id(self) -> _builtins.str:
        """
        ID of the node pool.
        """
        return pulumi.get(self, "node_pool_id")

    @_builtins.property
    @pulumi.getter(name="nodePoolOs")
    def node_pool_os(self) -> _builtins.str:
        """
        Node Pool OS Name.
        """
        return pulumi.get(self, "node_pool_os")

    @_builtins.property
    @pulumi.getter(name="osCustomizeType")
    def os_customize_type(self) -> _builtins.str:
        """
        Mirror version of container.
        """
        return pulumi.get(self, "os_customize_type")

    @_builtins.property
    @pulumi.getter(name="preStartUserScript")
    def pre_start_user_script(self) -> _builtins.str:
        """
        User defined script, executed before User Script.
        """
        return pulumi.get(self, "pre_start_user_script")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetTagResult']:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetTaintResult']:
        """
        Labels of the node pool.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter
    def unschedulable(self) -> _builtins.int:
        """
        Is it not schedulable.
        """
        return pulumi.get(self, "unschedulable")

    @_builtins.property
    @pulumi.getter(name="userScript")
    def user_script(self) -> _builtins.str:
        """
        User defined scripts.
        """
        return pulumi.get(self, "user_script")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetDataDiskResult(dict):
    def __init__(__self__, *,
                 auto_format_and_mount: _builtins.bool,
                 disk_partition: _builtins.str,
                 disk_size: _builtins.int,
                 disk_type: _builtins.str,
                 file_system: _builtins.str,
                 mount_target: _builtins.str):
        """
        :param _builtins.bool auto_format_and_mount: Whether to automate the format disk and mount it.
        :param _builtins.str disk_partition: Mount device name or partition name.
        :param _builtins.int disk_size: Cloud disk size(G).
        :param _builtins.str disk_type: Cloud disk type.
        :param _builtins.str file_system: File system(ext3/ext4/xfs).
        :param _builtins.str mount_target: Mount directory.
        """
        pulumi.set(__self__, "auto_format_and_mount", auto_format_and_mount)
        pulumi.set(__self__, "disk_partition", disk_partition)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "file_system", file_system)
        pulumi.set(__self__, "mount_target", mount_target)

    @_builtins.property
    @pulumi.getter(name="autoFormatAndMount")
    def auto_format_and_mount(self) -> _builtins.bool:
        """
        Whether to automate the format disk and mount it.
        """
        return pulumi.get(self, "auto_format_and_mount")

    @_builtins.property
    @pulumi.getter(name="diskPartition")
    def disk_partition(self) -> _builtins.str:
        """
        Mount device name or partition name.
        """
        return pulumi.get(self, "disk_partition")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Cloud disk size(G).
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        Cloud disk type.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> _builtins.str:
        """
        File system(ext3/ext4/xfs).
        """
        return pulumi.get(self, "file_system")

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> _builtins.str:
        """
        Mount directory.
        """
        return pulumi.get(self, "mount_target")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetExtraArgResult(dict):
    def __init__(__self__, *,
                 kubelets: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] kubelets: Kubelet custom parameters.
        """
        pulumi.set(__self__, "kubelets", kubelets)

    @_builtins.property
    @pulumi.getter
    def kubelets(self) -> Sequence[_builtins.str]:
        """
        Kubelet custom parameters.
        """
        return pulumi.get(self, "kubelets")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetGpuArgResult(dict):
    def __init__(__self__, *,
                 cudas: Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgCudaResult'],
                 cudnns: Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgCudnnResult'],
                 custom_drivers: Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgCustomDriverResult'],
                 drivers: Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgDriverResult'],
                 mig_enable: _builtins.bool):
        """
        :param Sequence['GetClusterNodePoolsNodePoolSetGpuArgCudaArgs'] cudas: CUDA version information.
        :param Sequence['GetClusterNodePoolsNodePoolSetGpuArgCudnnArgs'] cudnns: CuDNN version information.
        :param Sequence['GetClusterNodePoolsNodePoolSetGpuArgCustomDriverArgs'] custom_drivers: Custom GPU driver information.
        :param Sequence['GetClusterNodePoolsNodePoolSetGpuArgDriverArgs'] drivers: GPU driver version information.
        :param _builtins.bool mig_enable: Is the MIG feature enabled.
        """
        pulumi.set(__self__, "cudas", cudas)
        pulumi.set(__self__, "cudnns", cudnns)
        pulumi.set(__self__, "custom_drivers", custom_drivers)
        pulumi.set(__self__, "drivers", drivers)
        pulumi.set(__self__, "mig_enable", mig_enable)

    @_builtins.property
    @pulumi.getter
    def cudas(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgCudaResult']:
        """
        CUDA version information.
        """
        return pulumi.get(self, "cudas")

    @_builtins.property
    @pulumi.getter
    def cudnns(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgCudnnResult']:
        """
        CuDNN version information.
        """
        return pulumi.get(self, "cudnns")

    @_builtins.property
    @pulumi.getter(name="customDrivers")
    def custom_drivers(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgCustomDriverResult']:
        """
        Custom GPU driver information.
        """
        return pulumi.get(self, "custom_drivers")

    @_builtins.property
    @pulumi.getter
    def drivers(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetGpuArgDriverResult']:
        """
        GPU driver version information.
        """
        return pulumi.get(self, "drivers")

    @_builtins.property
    @pulumi.getter(name="migEnable")
    def mig_enable(self) -> _builtins.bool:
        """
        Is the MIG feature enabled.
        """
        return pulumi.get(self, "mig_enable")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetGpuArgCudaResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: Name of the node pool.
        :param _builtins.str version: GPU driver or CUDA version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        GPU driver or CUDA version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetGpuArgCudnnResult(dict):
    def __init__(__self__, *,
                 dev_name: _builtins.str,
                 doc_name: _builtins.str,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str dev_name: Dev name of cuDNN.
        :param _builtins.str doc_name: Doc name of cuDNN.
        :param _builtins.str name: Name of the node pool.
        :param _builtins.str version: GPU driver or CUDA version.
        """
        pulumi.set(__self__, "dev_name", dev_name)
        pulumi.set(__self__, "doc_name", doc_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="devName")
    def dev_name(self) -> _builtins.str:
        """
        Dev name of cuDNN.
        """
        return pulumi.get(self, "dev_name")

    @_builtins.property
    @pulumi.getter(name="docName")
    def doc_name(self) -> _builtins.str:
        """
        Doc name of cuDNN.
        """
        return pulumi.get(self, "doc_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        GPU driver or CUDA version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetGpuArgCustomDriverResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: Custom GPU driver address link.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Custom GPU driver address link.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetGpuArgDriverResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: Name of the node pool.
        :param _builtins.str version: GPU driver or CUDA version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        GPU driver or CUDA version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetLabelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of the node pool.
        :param _builtins.str value: Value of taints mark.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of taints mark.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetNodeCountSummaryResult(dict):
    def __init__(__self__, *,
                 autoscaling_addeds: Sequence['outputs.GetClusterNodePoolsNodePoolSetNodeCountSummaryAutoscalingAddedResult'],
                 manually_addeds: Sequence['outputs.GetClusterNodePoolsNodePoolSetNodeCountSummaryManuallyAddedResult']):
        """
        :param Sequence['GetClusterNodePoolsNodePoolSetNodeCountSummaryAutoscalingAddedArgs'] autoscaling_addeds: Automatically managed nodes.
        :param Sequence['GetClusterNodePoolsNodePoolSetNodeCountSummaryManuallyAddedArgs'] manually_addeds: Manually managed nodes.
        """
        pulumi.set(__self__, "autoscaling_addeds", autoscaling_addeds)
        pulumi.set(__self__, "manually_addeds", manually_addeds)

    @_builtins.property
    @pulumi.getter(name="autoscalingAddeds")
    def autoscaling_addeds(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetNodeCountSummaryAutoscalingAddedResult']:
        """
        Automatically managed nodes.
        """
        return pulumi.get(self, "autoscaling_addeds")

    @_builtins.property
    @pulumi.getter(name="manuallyAddeds")
    def manually_addeds(self) -> Sequence['outputs.GetClusterNodePoolsNodePoolSetNodeCountSummaryManuallyAddedResult']:
        """
        Manually managed nodes.
        """
        return pulumi.get(self, "manually_addeds")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetNodeCountSummaryAutoscalingAddedResult(dict):
    def __init__(__self__, *,
                 initializing: _builtins.int,
                 joining: _builtins.int,
                 normal: _builtins.int,
                 total: _builtins.int):
        """
        :param _builtins.int initializing: Number of nodes in initialization.
        :param _builtins.int joining: Number of nodes joining.
        :param _builtins.int normal: Normal number of nodes.
        :param _builtins.int total: Total number of nodes.
        """
        pulumi.set(__self__, "initializing", initializing)
        pulumi.set(__self__, "joining", joining)
        pulumi.set(__self__, "normal", normal)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def initializing(self) -> _builtins.int:
        """
        Number of nodes in initialization.
        """
        return pulumi.get(self, "initializing")

    @_builtins.property
    @pulumi.getter
    def joining(self) -> _builtins.int:
        """
        Number of nodes joining.
        """
        return pulumi.get(self, "joining")

    @_builtins.property
    @pulumi.getter
    def normal(self) -> _builtins.int:
        """
        Normal number of nodes.
        """
        return pulumi.get(self, "normal")

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Total number of nodes.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetNodeCountSummaryManuallyAddedResult(dict):
    def __init__(__self__, *,
                 initializing: _builtins.int,
                 joining: _builtins.int,
                 normal: _builtins.int,
                 total: _builtins.int):
        """
        :param _builtins.int initializing: Number of nodes in initialization.
        :param _builtins.int joining: Number of nodes joining.
        :param _builtins.int normal: Normal number of nodes.
        :param _builtins.int total: Total number of nodes.
        """
        pulumi.set(__self__, "initializing", initializing)
        pulumi.set(__self__, "joining", joining)
        pulumi.set(__self__, "normal", normal)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def initializing(self) -> _builtins.int:
        """
        Number of nodes in initialization.
        """
        return pulumi.get(self, "initializing")

    @_builtins.property
    @pulumi.getter
    def joining(self) -> _builtins.int:
        """
        Number of nodes joining.
        """
        return pulumi.get(self, "joining")

    @_builtins.property
    @pulumi.getter
    def normal(self) -> _builtins.int:
        """
        Normal number of nodes.
        """
        return pulumi.get(self, "normal")

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Total number of nodes.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Key of taints mark.
        :param _builtins.str value: Value of taints mark.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of taints mark.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of taints mark.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNodePoolsNodePoolSetTaintResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: Effect of taints mark.
        :param _builtins.str key: Key of taints mark.
        :param _builtins.str value: Value of taints mark.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Effect of taints mark.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of taints mark.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of taints mark.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersListResult(dict):
    def __init__(__self__, *,
                 cdc_id: _builtins.str,
                 certification_authority: _builtins.str,
                 claim_expired_seconds: _builtins.int,
                 cluster_as_enabled: _builtins.bool,
                 cluster_cidr: _builtins.str,
                 cluster_deploy_type: _builtins.str,
                 cluster_desc: _builtins.str,
                 cluster_external_endpoint: _builtins.str,
                 cluster_extra_args: Sequence['outputs.GetClustersListClusterExtraArgResult'],
                 cluster_id: _builtins.str,
                 cluster_ipvs: _builtins.bool,
                 cluster_max_pod_num: _builtins.int,
                 cluster_max_service_num: _builtins.int,
                 cluster_name: _builtins.str,
                 cluster_node_num: _builtins.int,
                 cluster_os: _builtins.str,
                 cluster_version: _builtins.str,
                 container_runtime: _builtins.str,
                 deletion_protection: _builtins.bool,
                 domain: _builtins.str,
                 eni_subnet_ids: Sequence[_builtins.str],
                 ignore_cluster_cidr_conflict: _builtins.bool,
                 is_non_static_ip_mode: _builtins.bool,
                 kube_config: _builtins.str,
                 kube_config_intranet: _builtins.str,
                 kube_proxy_mode: _builtins.str,
                 network_type: _builtins.str,
                 node_name_type: _builtins.str,
                 password: _builtins.str,
                 pgw_endpoint: _builtins.str,
                 project_id: _builtins.int,
                 security_policies: Sequence[_builtins.str],
                 service_cidr: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 user_name: _builtins.str,
                 vpc_cni_type: _builtins.str,
                 vpc_id: _builtins.str,
                 worker_instances_lists: Sequence['outputs.GetClustersListWorkerInstancesListResult']):
        """
        :param _builtins.str cdc_id: CDC ID.
        :param _builtins.str certification_authority: The certificate used for access.
        :param _builtins.int claim_expired_seconds: The expired seconds to recycle ENI.
        :param _builtins.bool cluster_as_enabled: Indicates whether to enable cluster node auto scaler.
        :param _builtins.str cluster_cidr: A network address block of the cluster. Different from vpc cidr and cidr of other clusters within this VPC.
        :param _builtins.str cluster_deploy_type: Deployment type of the cluster.
        :param _builtins.str cluster_desc: Description of the cluster.
        :param _builtins.str cluster_external_endpoint: External network address to access.
        :param Sequence['GetClustersListClusterExtraArgArgs'] cluster_extra_args: Customized parameters for master component.
        :param _builtins.str cluster_id: ID of the cluster. Conflict with cluster_name, can not be set at the same time.
        :param _builtins.bool cluster_ipvs: Indicates whether ipvs is enabled.
        :param _builtins.int cluster_max_pod_num: The maximum number of Pods per node in the cluster.
        :param _builtins.int cluster_max_service_num: The maximum number of services in the cluster.
        :param _builtins.str cluster_name: Name of the cluster. Conflict with cluster_id, can not be set at the same time.
        :param _builtins.int cluster_node_num: Number of nodes in the cluster.
        :param _builtins.str cluster_os: Operating system of the cluster.
        :param _builtins.str cluster_version: Version of the cluster.
        :param _builtins.str container_runtime: (**Deprecated**) It has been deprecated from version 1.18.1. Container runtime of the cluster.
        :param _builtins.bool deletion_protection: Indicates whether cluster deletion protection is enabled.
        :param _builtins.str domain: Domain name for access.
        :param Sequence[_builtins.str] eni_subnet_ids: Subnet IDs for cluster with VPC-CNI network mode.
        :param _builtins.bool ignore_cluster_cidr_conflict: Indicates whether to ignore the cluster cidr conflict error.
        :param _builtins.bool is_non_static_ip_mode: Indicates whether non-static ip mode is enabled.
        :param _builtins.str kube_config: Kubernetes config.
        :param _builtins.str kube_config_intranet: Kubernetes config of private network.
        :param _builtins.str kube_proxy_mode: Cluster kube-proxy mode.
        :param _builtins.str network_type: Cluster network type.
        :param _builtins.str node_name_type: Node name type of cluster.
        :param _builtins.str password: Password of account.
        :param _builtins.str pgw_endpoint: The Intranet address used for access.
        :param _builtins.int project_id: Project ID of the cluster.
        :param Sequence[_builtins.str] security_policies: Access policy.
        :param _builtins.str service_cidr: The network address block of the cluster.
        :param Mapping[str, _builtins.str] tags: Tags of the cluster.
        :param _builtins.str user_name: User name of account.
        :param _builtins.str vpc_cni_type: Distinguish between shared network card multi-IP mode and independent network card mode.
        :param _builtins.str vpc_id: Vpc ID of the cluster.
        :param Sequence['GetClustersListWorkerInstancesListArgs'] worker_instances_lists: An information list of cvm within the WORKER clusters. Each element contains the following attributes.
        """
        pulumi.set(__self__, "cdc_id", cdc_id)
        pulumi.set(__self__, "certification_authority", certification_authority)
        pulumi.set(__self__, "claim_expired_seconds", claim_expired_seconds)
        pulumi.set(__self__, "cluster_as_enabled", cluster_as_enabled)
        pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        pulumi.set(__self__, "cluster_deploy_type", cluster_deploy_type)
        pulumi.set(__self__, "cluster_desc", cluster_desc)
        pulumi.set(__self__, "cluster_external_endpoint", cluster_external_endpoint)
        pulumi.set(__self__, "cluster_extra_args", cluster_extra_args)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_ipvs", cluster_ipvs)
        pulumi.set(__self__, "cluster_max_pod_num", cluster_max_pod_num)
        pulumi.set(__self__, "cluster_max_service_num", cluster_max_service_num)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_node_num", cluster_node_num)
        pulumi.set(__self__, "cluster_os", cluster_os)
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "container_runtime", container_runtime)
        pulumi.set(__self__, "deletion_protection", deletion_protection)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "eni_subnet_ids", eni_subnet_ids)
        pulumi.set(__self__, "ignore_cluster_cidr_conflict", ignore_cluster_cidr_conflict)
        pulumi.set(__self__, "is_non_static_ip_mode", is_non_static_ip_mode)
        pulumi.set(__self__, "kube_config", kube_config)
        pulumi.set(__self__, "kube_config_intranet", kube_config_intranet)
        pulumi.set(__self__, "kube_proxy_mode", kube_proxy_mode)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "node_name_type", node_name_type)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "pgw_endpoint", pgw_endpoint)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "security_policies", security_policies)
        pulumi.set(__self__, "service_cidr", service_cidr)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "vpc_cni_type", vpc_cni_type)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "worker_instances_lists", worker_instances_lists)

    @_builtins.property
    @pulumi.getter(name="cdcId")
    def cdc_id(self) -> _builtins.str:
        """
        CDC ID.
        """
        return pulumi.get(self, "cdc_id")

    @_builtins.property
    @pulumi.getter(name="certificationAuthority")
    def certification_authority(self) -> _builtins.str:
        """
        The certificate used for access.
        """
        return pulumi.get(self, "certification_authority")

    @_builtins.property
    @pulumi.getter(name="claimExpiredSeconds")
    def claim_expired_seconds(self) -> _builtins.int:
        """
        The expired seconds to recycle ENI.
        """
        return pulumi.get(self, "claim_expired_seconds")

    @_builtins.property
    @pulumi.getter(name="clusterAsEnabled")
    def cluster_as_enabled(self) -> _builtins.bool:
        """
        Indicates whether to enable cluster node auto scaler.
        """
        return pulumi.get(self, "cluster_as_enabled")

    @_builtins.property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> _builtins.str:
        """
        A network address block of the cluster. Different from vpc cidr and cidr of other clusters within this VPC.
        """
        return pulumi.get(self, "cluster_cidr")

    @_builtins.property
    @pulumi.getter(name="clusterDeployType")
    def cluster_deploy_type(self) -> _builtins.str:
        """
        Deployment type of the cluster.
        """
        return pulumi.get(self, "cluster_deploy_type")

    @_builtins.property
    @pulumi.getter(name="clusterDesc")
    def cluster_desc(self) -> _builtins.str:
        """
        Description of the cluster.
        """
        return pulumi.get(self, "cluster_desc")

    @_builtins.property
    @pulumi.getter(name="clusterExternalEndpoint")
    def cluster_external_endpoint(self) -> _builtins.str:
        """
        External network address to access.
        """
        return pulumi.get(self, "cluster_external_endpoint")

    @_builtins.property
    @pulumi.getter(name="clusterExtraArgs")
    def cluster_extra_args(self) -> Sequence['outputs.GetClustersListClusterExtraArgResult']:
        """
        Customized parameters for master component.
        """
        return pulumi.get(self, "cluster_extra_args")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        ID of the cluster. Conflict with cluster_name, can not be set at the same time.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterIpvs")
    def cluster_ipvs(self) -> _builtins.bool:
        """
        Indicates whether ipvs is enabled.
        """
        return pulumi.get(self, "cluster_ipvs")

    @_builtins.property
    @pulumi.getter(name="clusterMaxPodNum")
    def cluster_max_pod_num(self) -> _builtins.int:
        """
        The maximum number of Pods per node in the cluster.
        """
        return pulumi.get(self, "cluster_max_pod_num")

    @_builtins.property
    @pulumi.getter(name="clusterMaxServiceNum")
    def cluster_max_service_num(self) -> _builtins.int:
        """
        The maximum number of services in the cluster.
        """
        return pulumi.get(self, "cluster_max_service_num")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        Name of the cluster. Conflict with cluster_id, can not be set at the same time.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="clusterNodeNum")
    def cluster_node_num(self) -> _builtins.int:
        """
        Number of nodes in the cluster.
        """
        return pulumi.get(self, "cluster_node_num")

    @_builtins.property
    @pulumi.getter(name="clusterOs")
    def cluster_os(self) -> _builtins.str:
        """
        Operating system of the cluster.
        """
        return pulumi.get(self, "cluster_os")

    @_builtins.property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> _builtins.str:
        """
        Version of the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @_builtins.property
    @pulumi.getter(name="containerRuntime")
    @_utilities.deprecated("""It has been deprecated from version 1.18.1.""")
    def container_runtime(self) -> _builtins.str:
        """
        (**Deprecated**) It has been deprecated from version 1.18.1. Container runtime of the cluster.
        """
        return pulumi.get(self, "container_runtime")

    @_builtins.property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> _builtins.bool:
        """
        Indicates whether cluster deletion protection is enabled.
        """
        return pulumi.get(self, "deletion_protection")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain name for access.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="eniSubnetIds")
    def eni_subnet_ids(self) -> Sequence[_builtins.str]:
        """
        Subnet IDs for cluster with VPC-CNI network mode.
        """
        return pulumi.get(self, "eni_subnet_ids")

    @_builtins.property
    @pulumi.getter(name="ignoreClusterCidrConflict")
    def ignore_cluster_cidr_conflict(self) -> _builtins.bool:
        """
        Indicates whether to ignore the cluster cidr conflict error.
        """
        return pulumi.get(self, "ignore_cluster_cidr_conflict")

    @_builtins.property
    @pulumi.getter(name="isNonStaticIpMode")
    def is_non_static_ip_mode(self) -> _builtins.bool:
        """
        Indicates whether non-static ip mode is enabled.
        """
        return pulumi.get(self, "is_non_static_ip_mode")

    @_builtins.property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> _builtins.str:
        """
        Kubernetes config.
        """
        return pulumi.get(self, "kube_config")

    @_builtins.property
    @pulumi.getter(name="kubeConfigIntranet")
    def kube_config_intranet(self) -> _builtins.str:
        """
        Kubernetes config of private network.
        """
        return pulumi.get(self, "kube_config_intranet")

    @_builtins.property
    @pulumi.getter(name="kubeProxyMode")
    def kube_proxy_mode(self) -> _builtins.str:
        """
        Cluster kube-proxy mode.
        """
        return pulumi.get(self, "kube_proxy_mode")

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> _builtins.str:
        """
        Cluster network type.
        """
        return pulumi.get(self, "network_type")

    @_builtins.property
    @pulumi.getter(name="nodeNameType")
    def node_name_type(self) -> _builtins.str:
        """
        Node name type of cluster.
        """
        return pulumi.get(self, "node_name_type")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password of account.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="pgwEndpoint")
    def pgw_endpoint(self) -> _builtins.str:
        """
        The Intranet address used for access.
        """
        return pulumi.get(self, "pgw_endpoint")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.int:
        """
        Project ID of the cluster.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="securityPolicies")
    def security_policies(self) -> Sequence[_builtins.str]:
        """
        Access policy.
        """
        return pulumi.get(self, "security_policies")

    @_builtins.property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> _builtins.str:
        """
        The network address block of the cluster.
        """
        return pulumi.get(self, "service_cidr")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Tags of the cluster.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        User name of account.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter(name="vpcCniType")
    def vpc_cni_type(self) -> _builtins.str:
        """
        Distinguish between shared network card multi-IP mode and independent network card mode.
        """
        return pulumi.get(self, "vpc_cni_type")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Vpc ID of the cluster.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="workerInstancesLists")
    def worker_instances_lists(self) -> Sequence['outputs.GetClustersListWorkerInstancesListResult']:
        """
        An information list of cvm within the WORKER clusters. Each element contains the following attributes.
        """
        return pulumi.get(self, "worker_instances_lists")


@pulumi.output_type
class GetClustersListClusterExtraArgResult(dict):
    def __init__(__self__, *,
                 kube_apiservers: Sequence[_builtins.str],
                 kube_controller_managers: Sequence[_builtins.str],
                 kube_schedulers: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] kube_apiservers: The customized parameters for kube-apiserver.
        :param Sequence[_builtins.str] kube_controller_managers: The customized parameters for kube-controller-manager.
        :param Sequence[_builtins.str] kube_schedulers: The customized parameters for kube-scheduler.
        """
        pulumi.set(__self__, "kube_apiservers", kube_apiservers)
        pulumi.set(__self__, "kube_controller_managers", kube_controller_managers)
        pulumi.set(__self__, "kube_schedulers", kube_schedulers)

    @_builtins.property
    @pulumi.getter(name="kubeApiservers")
    def kube_apiservers(self) -> Sequence[_builtins.str]:
        """
        The customized parameters for kube-apiserver.
        """
        return pulumi.get(self, "kube_apiservers")

    @_builtins.property
    @pulumi.getter(name="kubeControllerManagers")
    def kube_controller_managers(self) -> Sequence[_builtins.str]:
        """
        The customized parameters for kube-controller-manager.
        """
        return pulumi.get(self, "kube_controller_managers")

    @_builtins.property
    @pulumi.getter(name="kubeSchedulers")
    def kube_schedulers(self) -> Sequence[_builtins.str]:
        """
        The customized parameters for kube-scheduler.
        """
        return pulumi.get(self, "kube_schedulers")


@pulumi.output_type
class GetClustersListWorkerInstancesListResult(dict):
    def __init__(__self__, *,
                 failed_reason: _builtins.str,
                 instance_id: _builtins.str,
                 instance_role: _builtins.str,
                 instance_state: _builtins.str,
                 lan_ip: _builtins.str):
        """
        :param _builtins.str failed_reason: Information of the cvm when it is failed.
        :param _builtins.str instance_id: ID of the cvm.
        :param _builtins.str instance_role: Role of the cvm.
        :param _builtins.str instance_state: State of the cvm.
        :param _builtins.str lan_ip: LAN IP of the cvm.
        """
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_role", instance_role)
        pulumi.set(__self__, "instance_state", instance_state)
        pulumi.set(__self__, "lan_ip", lan_ip)

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        Information of the cvm when it is failed.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        ID of the cvm.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> _builtins.str:
        """
        Role of the cvm.
        """
        return pulumi.get(self, "instance_role")

    @_builtins.property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> _builtins.str:
        """
        State of the cvm.
        """
        return pulumi.get(self, "instance_state")

    @_builtins.property
    @pulumi.getter(name="lanIp")
    def lan_ip(self) -> _builtins.str:
        """
        LAN IP of the cvm.
        """
        return pulumi.get(self, "lan_ip")


