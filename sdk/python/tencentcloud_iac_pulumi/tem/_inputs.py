# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppConfigConfigDataArgs',
    'AppConfigConfigDataArgsDict',
    'ApplicationServiceServiceArgs',
    'ApplicationServiceServiceArgsDict',
    'ApplicationServiceServicePortMappingItemListArgs',
    'ApplicationServiceServicePortMappingItemListArgsDict',
    'GatewayIngressArgs',
    'GatewayIngressArgsDict',
    'GatewayIngressRuleArgs',
    'GatewayIngressRuleArgsDict',
    'GatewayIngressRuleHttpArgs',
    'GatewayIngressRuleHttpArgsDict',
    'GatewayIngressRuleHttpPathArgs',
    'GatewayIngressRuleHttpPathArgsDict',
    'GatewayIngressRuleHttpPathBackendArgs',
    'GatewayIngressRuleHttpPathBackendArgsDict',
    'GatewayIngressTlArgs',
    'GatewayIngressTlArgsDict',
    'ScaleRuleAutoscalerArgs',
    'ScaleRuleAutoscalerArgsDict',
    'ScaleRuleAutoscalerCronHorizontalAutoscalerArgs',
    'ScaleRuleAutoscalerCronHorizontalAutoscalerArgsDict',
    'ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgs',
    'ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgsDict',
    'ScaleRuleAutoscalerHorizontalAutoscalerArgs',
    'ScaleRuleAutoscalerHorizontalAutoscalerArgsDict',
    'WorkloadDeployStrategyConfArgs',
    'WorkloadDeployStrategyConfArgsDict',
    'WorkloadEnvConfArgs',
    'WorkloadEnvConfArgsDict',
    'WorkloadLivenessArgs',
    'WorkloadLivenessArgsDict',
    'WorkloadReadinessArgs',
    'WorkloadReadinessArgsDict',
    'WorkloadStartupProbeArgs',
    'WorkloadStartupProbeArgsDict',
    'WorkloadStorageConfArgs',
    'WorkloadStorageConfArgsDict',
    'WorkloadStorageMountConfArgs',
    'WorkloadStorageMountConfArgsDict',
]

MYPY = False

if not MYPY:
    class AppConfigConfigDataArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        key.
        """
        value: pulumi.Input[_builtins.str]
        """
        value.
        """
elif False:
    AppConfigConfigDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppConfigConfigDataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: key.
        :param pulumi.Input[_builtins.str] value: value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplicationServiceServiceArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        ip address of application service.
        """
        port_mapping_item_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationServiceServicePortMappingItemListArgsDict']]]]
        """
        port mapping item list.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        application service name.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of subnet instance, required when type is `VPC`.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        application service type: EXTERNAL | VPC | CLUSTER.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of vpc instance, required when type is `VPC`.
        """
elif False:
    ApplicationServiceServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationServiceServiceArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 port_mapping_item_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationServiceServicePortMappingItemListArgs']]]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: ip address of application service.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationServiceServicePortMappingItemListArgs']]] port_mapping_item_lists: port mapping item list.
        :param pulumi.Input[_builtins.str] service_name: application service name.
        :param pulumi.Input[_builtins.str] subnet_id: ID of subnet instance, required when type is `VPC`.
        :param pulumi.Input[_builtins.str] type: application service type: EXTERNAL | VPC | CLUSTER.
        :param pulumi.Input[_builtins.str] vpc_id: ID of vpc instance, required when type is `VPC`.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port_mapping_item_lists is not None:
            pulumi.set(__self__, "port_mapping_item_lists", port_mapping_item_lists)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ip address of application service.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="portMappingItemLists")
    def port_mapping_item_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationServiceServicePortMappingItemListArgs']]]]:
        """
        port mapping item list.
        """
        return pulumi.get(self, "port_mapping_item_lists")

    @port_mapping_item_lists.setter
    def port_mapping_item_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationServiceServicePortMappingItemListArgs']]]]):
        pulumi.set(self, "port_mapping_item_lists", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application service name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of subnet instance, required when type is `VPC`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application service type: EXTERNAL | VPC | CLUSTER.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of vpc instance, required when type is `VPC`.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class ApplicationServiceServicePortMappingItemListArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        container port.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        UDP or TCP.
        """
        target_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        application listen port.
        """
elif False:
    ApplicationServiceServicePortMappingItemListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationServiceServicePortMappingItemListArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 target_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: container port.
        :param pulumi.Input[_builtins.str] protocol: UDP or TCP.
        :param pulumi.Input[_builtins.int] target_port: application listen port.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        container port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UDP or TCP.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        application listen port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class GatewayIngressArgsDict(TypedDict):
        address_ip_version: pulumi.Input[_builtins.str]
        """
        ip version, support IPV4.
        """
        environment_id: pulumi.Input[_builtins.str]
        """
        environment ID.
        """
        ingress_name: pulumi.Input[_builtins.str]
        """
        gateway name.
        """
        mixed: pulumi.Input[_builtins.bool]
        """
        mixing HTTP and HTTPS.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleArgsDict']]]
        """
        proxy rules.
        """
        clb_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        related CLB ID, support binding existing clb, does not support modification.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        creation time.
        """
        rewrite_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        redirect mode, support AUTO and NONE.
        """
        tls: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayIngressTlArgsDict']]]]
        """
        ingress TLS configurations.
        """
        vip: NotRequired[pulumi.Input[_builtins.str]]
        """
        gateway vip.
        """
elif False:
    GatewayIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIngressArgs:
    def __init__(__self__, *,
                 address_ip_version: pulumi.Input[_builtins.str],
                 environment_id: pulumi.Input[_builtins.str],
                 ingress_name: pulumi.Input[_builtins.str],
                 mixed: pulumi.Input[_builtins.bool],
                 rules: pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleArgs']]],
                 clb_id: Optional[pulumi.Input[_builtins.str]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 rewrite_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tls: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayIngressTlArgs']]]] = None,
                 vip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address_ip_version: ip version, support IPV4.
        :param pulumi.Input[_builtins.str] environment_id: environment ID.
        :param pulumi.Input[_builtins.str] ingress_name: gateway name.
        :param pulumi.Input[_builtins.bool] mixed: mixing HTTP and HTTPS.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleArgs']]] rules: proxy rules.
        :param pulumi.Input[_builtins.str] clb_id: related CLB ID, support binding existing clb, does not support modification.
        :param pulumi.Input[_builtins.str] create_time: creation time.
        :param pulumi.Input[_builtins.str] rewrite_type: redirect mode, support AUTO and NONE.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayIngressTlArgs']]] tls: ingress TLS configurations.
        :param pulumi.Input[_builtins.str] vip: gateway vip.
        """
        pulumi.set(__self__, "address_ip_version", address_ip_version)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "ingress_name", ingress_name)
        pulumi.set(__self__, "mixed", mixed)
        pulumi.set(__self__, "rules", rules)
        if clb_id is not None:
            pulumi.set(__self__, "clb_id", clb_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if rewrite_type is not None:
            pulumi.set(__self__, "rewrite_type", rewrite_type)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)

    @_builtins.property
    @pulumi.getter(name="addressIpVersion")
    def address_ip_version(self) -> pulumi.Input[_builtins.str]:
        """
        ip version, support IPV4.
        """
        return pulumi.get(self, "address_ip_version")

    @address_ip_version.setter
    def address_ip_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address_ip_version", value)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Input[_builtins.str]:
        """
        environment ID.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "environment_id", value)

    @_builtins.property
    @pulumi.getter(name="ingressName")
    def ingress_name(self) -> pulumi.Input[_builtins.str]:
        """
        gateway name.
        """
        return pulumi.get(self, "ingress_name")

    @ingress_name.setter
    def ingress_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ingress_name", value)

    @_builtins.property
    @pulumi.getter
    def mixed(self) -> pulumi.Input[_builtins.bool]:
        """
        mixing HTTP and HTTPS.
        """
        return pulumi.get(self, "mixed")

    @mixed.setter
    def mixed(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "mixed", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleArgs']]]:
        """
        proxy rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter(name="clbId")
    def clb_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        related CLB ID, support binding existing clb, does not support modification.
        """
        return pulumi.get(self, "clb_id")

    @clb_id.setter
    def clb_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "clb_id", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        creation time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="rewriteType")
    def rewrite_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        redirect mode, support AUTO and NONE.
        """
        return pulumi.get(self, "rewrite_type")

    @rewrite_type.setter
    def rewrite_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rewrite_type", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayIngressTlArgs']]]]:
        """
        ingress TLS configurations.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayIngressTlArgs']]]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter
    def vip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        gateway vip.
        """
        return pulumi.get(self, "vip")

    @vip.setter
    def vip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vip", value)


if not MYPY:
    class GatewayIngressRuleArgsDict(TypedDict):
        http: pulumi.Input['GatewayIngressRuleHttpArgsDict']
        """
        rule payload.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        host name.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        protocol.
        """
elif False:
    GatewayIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIngressRuleArgs:
    def __init__(__self__, *,
                 http: pulumi.Input['GatewayIngressRuleHttpArgs'],
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['GatewayIngressRuleHttpArgs'] http: rule payload.
        :param pulumi.Input[_builtins.str] host: host name.
        :param pulumi.Input[_builtins.str] protocol: protocol.
        """
        pulumi.set(__self__, "http", http)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def http(self) -> pulumi.Input['GatewayIngressRuleHttpArgs']:
        """
        rule payload.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: pulumi.Input['GatewayIngressRuleHttpArgs']):
        pulumi.set(self, "http", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class GatewayIngressRuleHttpArgsDict(TypedDict):
        paths: pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleHttpPathArgsDict']]]
        """
        path payload.
        """
elif False:
    GatewayIngressRuleHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIngressRuleHttpArgs:
    def __init__(__self__, *,
                 paths: pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleHttpPathArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleHttpPathArgs']]] paths: path payload.
        """
        pulumi.set(__self__, "paths", paths)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleHttpPathArgs']]]:
        """
        path payload.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input['GatewayIngressRuleHttpPathArgs']]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class GatewayIngressRuleHttpPathArgsDict(TypedDict):
        backend: pulumi.Input['GatewayIngressRuleHttpPathBackendArgsDict']
        """
        backend payload.
        """
        path: pulumi.Input[_builtins.str]
        """
        path.
        """
elif False:
    GatewayIngressRuleHttpPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIngressRuleHttpPathArgs:
    def __init__(__self__, *,
                 backend: pulumi.Input['GatewayIngressRuleHttpPathBackendArgs'],
                 path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['GatewayIngressRuleHttpPathBackendArgs'] backend: backend payload.
        :param pulumi.Input[_builtins.str] path: path.
        """
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def backend(self) -> pulumi.Input['GatewayIngressRuleHttpPathBackendArgs']:
        """
        backend payload.
        """
        return pulumi.get(self, "backend")

    @backend.setter
    def backend(self, value: pulumi.Input['GatewayIngressRuleHttpPathBackendArgs']):
        pulumi.set(self, "backend", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class GatewayIngressRuleHttpPathBackendArgsDict(TypedDict):
        service_name: pulumi.Input[_builtins.str]
        """
        backend name.
        """
        service_port: pulumi.Input[_builtins.int]
        """
        backend port.
        """
elif False:
    GatewayIngressRuleHttpPathBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIngressRuleHttpPathBackendArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[_builtins.str],
                 service_port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] service_name: backend name.
        :param pulumi.Input[_builtins.int] service_port: backend port.
        """
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "service_port", service_port)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[_builtins.str]:
        """
        backend name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="servicePort")
    def service_port(self) -> pulumi.Input[_builtins.int]:
        """
        backend port.
        """
        return pulumi.get(self, "service_port")

    @service_port.setter
    def service_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "service_port", value)


if not MYPY:
    class GatewayIngressTlArgsDict(TypedDict):
        certificate_id: pulumi.Input[_builtins.str]
        """
        certificate ID.
        """
        hosts: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        host names.
        """
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        secret name, if you use a certificate, you don't need to fill in this field.
        """
elif False:
    GatewayIngressTlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIngressTlArgs:
    def __init__(__self__, *,
                 certificate_id: pulumi.Input[_builtins.str],
                 hosts: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_id: certificate ID.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] hosts: host names.
        :param pulumi.Input[_builtins.str] secret_name: secret name, if you use a certificate, you don't need to fill in this field.
        """
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "hosts", hosts)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> pulumi.Input[_builtins.str]:
        """
        certificate ID.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        host names.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        secret name, if you use a certificate, you don't need to fill in this field.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class ScaleRuleAutoscalerArgsDict(TypedDict):
        autoscaler_name: pulumi.Input[_builtins.str]
        """
        name.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        enable scaler.
        """
        max_replicas: pulumi.Input[_builtins.int]
        """
        maximal replica number.
        """
        min_replicas: pulumi.Input[_builtins.int]
        """
        minimal replica number.
        """
        cron_horizontal_autoscalers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerArgsDict']]]]
        """
        scaler based on cron configuration.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        description.
        """
        horizontal_autoscalers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerHorizontalAutoscalerArgsDict']]]]
        """
        scaler based on metrics.
        """
elif False:
    ScaleRuleAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleAutoscalerArgs:
    def __init__(__self__, *,
                 autoscaler_name: pulumi.Input[_builtins.str],
                 enabled: pulumi.Input[_builtins.bool],
                 max_replicas: pulumi.Input[_builtins.int],
                 min_replicas: pulumi.Input[_builtins.int],
                 cron_horizontal_autoscalers: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 horizontal_autoscalers: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerHorizontalAutoscalerArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] autoscaler_name: name.
        :param pulumi.Input[_builtins.bool] enabled: enable scaler.
        :param pulumi.Input[_builtins.int] max_replicas: maximal replica number.
        :param pulumi.Input[_builtins.int] min_replicas: minimal replica number.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerArgs']]] cron_horizontal_autoscalers: scaler based on cron configuration.
        :param pulumi.Input[_builtins.str] description: description.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerHorizontalAutoscalerArgs']]] horizontal_autoscalers: scaler based on metrics.
        """
        pulumi.set(__self__, "autoscaler_name", autoscaler_name)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        if cron_horizontal_autoscalers is not None:
            pulumi.set(__self__, "cron_horizontal_autoscalers", cron_horizontal_autoscalers)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if horizontal_autoscalers is not None:
            pulumi.set(__self__, "horizontal_autoscalers", horizontal_autoscalers)

    @_builtins.property
    @pulumi.getter(name="autoscalerName")
    def autoscaler_name(self) -> pulumi.Input[_builtins.str]:
        """
        name.
        """
        return pulumi.get(self, "autoscaler_name")

    @autoscaler_name.setter
    def autoscaler_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "autoscaler_name", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        enable scaler.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> pulumi.Input[_builtins.int]:
        """
        maximal replica number.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_replicas", value)

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> pulumi.Input[_builtins.int]:
        """
        minimal replica number.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_replicas", value)

    @_builtins.property
    @pulumi.getter(name="cronHorizontalAutoscalers")
    def cron_horizontal_autoscalers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerArgs']]]]:
        """
        scaler based on cron configuration.
        """
        return pulumi.get(self, "cron_horizontal_autoscalers")

    @cron_horizontal_autoscalers.setter
    def cron_horizontal_autoscalers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerArgs']]]]):
        pulumi.set(self, "cron_horizontal_autoscalers", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="horizontalAutoscalers")
    def horizontal_autoscalers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerHorizontalAutoscalerArgs']]]]:
        """
        scaler based on metrics.
        """
        return pulumi.get(self, "horizontal_autoscalers")

    @horizontal_autoscalers.setter
    def horizontal_autoscalers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerHorizontalAutoscalerArgs']]]]):
        pulumi.set(self, "horizontal_autoscalers", value)


if not MYPY:
    class ScaleRuleAutoscalerCronHorizontalAutoscalerArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        enable scaler.
        """
        name: pulumi.Input[_builtins.str]
        """
        name.
        """
        period: pulumi.Input[_builtins.str]
        """
        period.
        """
        priority: pulumi.Input[_builtins.int]
        """
        priority.
        """
        schedules: pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgsDict']]]
        """
        schedule payload.
        """
elif False:
    ScaleRuleAutoscalerCronHorizontalAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleAutoscalerCronHorizontalAutoscalerArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 name: pulumi.Input[_builtins.str],
                 period: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 schedules: pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgs']]]):
        """
        :param pulumi.Input[_builtins.bool] enabled: enable scaler.
        :param pulumi.Input[_builtins.str] name: name.
        :param pulumi.Input[_builtins.str] period: period.
        :param pulumi.Input[_builtins.int] priority: priority.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgs']]] schedules: schedule payload.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        enable scaler.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.str]:
        """
        period.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgs']]]:
        """
        schedule payload.
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: pulumi.Input[Sequence[pulumi.Input['ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgs']]]):
        pulumi.set(self, "schedules", value)


if not MYPY:
    class ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgsDict(TypedDict):
        start_at: pulumi.Input[_builtins.str]
        """
        start time.
        """
        target_replicas: pulumi.Input[_builtins.int]
        """
        target replica number.
        """
elif False:
    ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgs:
    def __init__(__self__, *,
                 start_at: pulumi.Input[_builtins.str],
                 target_replicas: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] start_at: start time.
        :param pulumi.Input[_builtins.int] target_replicas: target replica number.
        """
        pulumi.set(__self__, "start_at", start_at)
        pulumi.set(__self__, "target_replicas", target_replicas)

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> pulumi.Input[_builtins.str]:
        """
        start time.
        """
        return pulumi.get(self, "start_at")

    @start_at.setter
    def start_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_at", value)

    @_builtins.property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> pulumi.Input[_builtins.int]:
        """
        target replica number.
        """
        return pulumi.get(self, "target_replicas")

    @target_replicas.setter
    def target_replicas(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_replicas", value)


if not MYPY:
    class ScaleRuleAutoscalerHorizontalAutoscalerArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        enable scaler.
        """
        max_replicas: pulumi.Input[_builtins.int]
        """
        maximal replica number.
        """
        metrics: pulumi.Input[_builtins.str]
        """
        metric name.
        """
        min_replicas: pulumi.Input[_builtins.int]
        """
        minimal replica number.
        """
        threshold: pulumi.Input[_builtins.int]
        """
        metric threshold.
        """
elif False:
    ScaleRuleAutoscalerHorizontalAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleAutoscalerHorizontalAutoscalerArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 max_replicas: pulumi.Input[_builtins.int],
                 metrics: pulumi.Input[_builtins.str],
                 min_replicas: pulumi.Input[_builtins.int],
                 threshold: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.bool] enabled: enable scaler.
        :param pulumi.Input[_builtins.int] max_replicas: maximal replica number.
        :param pulumi.Input[_builtins.str] metrics: metric name.
        :param pulumi.Input[_builtins.int] min_replicas: minimal replica number.
        :param pulumi.Input[_builtins.int] threshold: metric threshold.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_replicas", min_replicas)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        enable scaler.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> pulumi.Input[_builtins.int]:
        """
        maximal replica number.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_replicas", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[_builtins.str]:
        """
        metric name.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> pulumi.Input[_builtins.int]:
        """
        minimal replica number.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_replicas", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.int]:
        """
        metric threshold.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class WorkloadDeployStrategyConfArgsDict(TypedDict):
        deploy_strategy_type: pulumi.Input[_builtins.int]
        """
        strategy type, 0 means auto, 1 means manual, 2 means manual with beta batch.
        """
        total_batch_count: pulumi.Input[_builtins.int]
        """
        total batch number.
        """
        batch_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        interval between batches.
        """
        beta_batch_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        beta batch number.
        """
        force: NotRequired[pulumi.Input[_builtins.bool]]
        """
        force update.
        """
        min_available: NotRequired[pulumi.Input[_builtins.int]]
        """
        minimal available instances duration deployment.
        """
elif False:
    WorkloadDeployStrategyConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadDeployStrategyConfArgs:
    def __init__(__self__, *,
                 deploy_strategy_type: pulumi.Input[_builtins.int],
                 total_batch_count: pulumi.Input[_builtins.int],
                 batch_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 beta_batch_num: Optional[pulumi.Input[_builtins.int]] = None,
                 force: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_available: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] deploy_strategy_type: strategy type, 0 means auto, 1 means manual, 2 means manual with beta batch.
        :param pulumi.Input[_builtins.int] total_batch_count: total batch number.
        :param pulumi.Input[_builtins.int] batch_interval: interval between batches.
        :param pulumi.Input[_builtins.int] beta_batch_num: beta batch number.
        :param pulumi.Input[_builtins.bool] force: force update.
        :param pulumi.Input[_builtins.int] min_available: minimal available instances duration deployment.
        """
        pulumi.set(__self__, "deploy_strategy_type", deploy_strategy_type)
        pulumi.set(__self__, "total_batch_count", total_batch_count)
        if batch_interval is not None:
            pulumi.set(__self__, "batch_interval", batch_interval)
        if beta_batch_num is not None:
            pulumi.set(__self__, "beta_batch_num", beta_batch_num)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if min_available is not None:
            pulumi.set(__self__, "min_available", min_available)

    @_builtins.property
    @pulumi.getter(name="deployStrategyType")
    def deploy_strategy_type(self) -> pulumi.Input[_builtins.int]:
        """
        strategy type, 0 means auto, 1 means manual, 2 means manual with beta batch.
        """
        return pulumi.get(self, "deploy_strategy_type")

    @deploy_strategy_type.setter
    def deploy_strategy_type(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "deploy_strategy_type", value)

    @_builtins.property
    @pulumi.getter(name="totalBatchCount")
    def total_batch_count(self) -> pulumi.Input[_builtins.int]:
        """
        total batch number.
        """
        return pulumi.get(self, "total_batch_count")

    @total_batch_count.setter
    def total_batch_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "total_batch_count", value)

    @_builtins.property
    @pulumi.getter(name="batchInterval")
    def batch_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        interval between batches.
        """
        return pulumi.get(self, "batch_interval")

    @batch_interval.setter
    def batch_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_interval", value)

    @_builtins.property
    @pulumi.getter(name="betaBatchNum")
    def beta_batch_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        beta batch number.
        """
        return pulumi.get(self, "beta_batch_num")

    @beta_batch_num.setter
    def beta_batch_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "beta_batch_num", value)

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        force update.
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force", value)

    @_builtins.property
    @pulumi.getter(name="minAvailable")
    def min_available(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        minimal available instances duration deployment.
        """
        return pulumi.get(self, "min_available")

    @min_available.setter
    def min_available(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_available", value)


if not MYPY:
    class WorkloadEnvConfArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        env key.
        """
        value: pulumi.Input[_builtins.str]
        """
        env value.
        """
        config: NotRequired[pulumi.Input[_builtins.str]]
        """
        referenced config name when type=referenced.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        referenced secret name when type=referenced.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        env type, support default, referenced.
        """
elif False:
    WorkloadEnvConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadEnvConfArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 config: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: env key.
        :param pulumi.Input[_builtins.str] value: env value.
        :param pulumi.Input[_builtins.str] config: referenced config name when type=referenced.
        :param pulumi.Input[_builtins.str] secret: referenced secret name when type=referenced.
        :param pulumi.Input[_builtins.str] type: env type, support default, referenced.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        env key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        env value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        referenced config name when type=referenced.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        referenced secret name when type=referenced.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        env type, support default, referenced.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WorkloadLivenessArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        exec_: NotRequired[pulumi.Input[_builtins.str]]
        """
        script.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        initial delay seconds for liveness check.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        path.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        period seconds for liveness check.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        liveness check port.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        protocol.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        timeout seconds for liveness check.
        """
elif False:
    WorkloadLivenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLivenessArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 exec_: Optional[pulumi.Input[_builtins.str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: check type, support HttpGet, TcpSocket and Exec.
        :param pulumi.Input[_builtins.str] exec_: script.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: initial delay seconds for liveness check.
        :param pulumi.Input[_builtins.str] path: path.
        :param pulumi.Input[_builtins.int] period_seconds: period seconds for liveness check.
        :param pulumi.Input[_builtins.int] port: liveness check port.
        :param pulumi.Input[_builtins.str] protocol: protocol.
        :param pulumi.Input[_builtins.int] timeout_seconds: timeout seconds for liveness check.
        """
        pulumi.set(__self__, "type", type)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        script.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        initial delay seconds for liveness check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        period seconds for liveness check.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        liveness check port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        timeout seconds for liveness check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class WorkloadReadinessArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        exec_: NotRequired[pulumi.Input[_builtins.str]]
        """
        script.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        initial delay seconds for readiness check.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        path.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        period seconds for readiness check.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        readiness check port.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        protocol.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        timeout seconds for readiness check.
        """
elif False:
    WorkloadReadinessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadReadinessArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 exec_: Optional[pulumi.Input[_builtins.str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: check type, support HttpGet, TcpSocket and Exec.
        :param pulumi.Input[_builtins.str] exec_: script.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: initial delay seconds for readiness check.
        :param pulumi.Input[_builtins.str] path: path.
        :param pulumi.Input[_builtins.int] period_seconds: period seconds for readiness check.
        :param pulumi.Input[_builtins.int] port: readiness check port.
        :param pulumi.Input[_builtins.str] protocol: protocol.
        :param pulumi.Input[_builtins.int] timeout_seconds: timeout seconds for readiness check.
        """
        pulumi.set(__self__, "type", type)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        script.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        initial delay seconds for readiness check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        period seconds for readiness check.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        readiness check port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        timeout seconds for readiness check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class WorkloadStartupProbeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        exec_: NotRequired[pulumi.Input[_builtins.str]]
        """
        script.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        initial delay seconds for startup check.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        path.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        period seconds for startup check.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        startup check port.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        protocol.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        timeout seconds for startup check.
        """
elif False:
    WorkloadStartupProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStartupProbeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 exec_: Optional[pulumi.Input[_builtins.str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: check type, support HttpGet, TcpSocket and Exec.
        :param pulumi.Input[_builtins.str] exec_: script.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: initial delay seconds for startup check.
        :param pulumi.Input[_builtins.str] path: path.
        :param pulumi.Input[_builtins.int] period_seconds: period seconds for startup check.
        :param pulumi.Input[_builtins.int] port: startup check port.
        :param pulumi.Input[_builtins.str] protocol: protocol.
        :param pulumi.Input[_builtins.int] timeout_seconds: timeout seconds for startup check.
        """
        pulumi.set(__self__, "type", type)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        script.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        initial delay seconds for startup check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        period seconds for startup check.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        startup check port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        timeout seconds for startup check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class WorkloadStorageConfArgsDict(TypedDict):
        storage_vol_ip: pulumi.Input[_builtins.str]
        """
        volume ip.
        """
        storage_vol_name: pulumi.Input[_builtins.str]
        """
        volume name.
        """
        storage_vol_path: pulumi.Input[_builtins.str]
        """
        volume path.
        """
elif False:
    WorkloadStorageConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStorageConfArgs:
    def __init__(__self__, *,
                 storage_vol_ip: pulumi.Input[_builtins.str],
                 storage_vol_name: pulumi.Input[_builtins.str],
                 storage_vol_path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] storage_vol_ip: volume ip.
        :param pulumi.Input[_builtins.str] storage_vol_name: volume name.
        :param pulumi.Input[_builtins.str] storage_vol_path: volume path.
        """
        pulumi.set(__self__, "storage_vol_ip", storage_vol_ip)
        pulumi.set(__self__, "storage_vol_name", storage_vol_name)
        pulumi.set(__self__, "storage_vol_path", storage_vol_path)

    @_builtins.property
    @pulumi.getter(name="storageVolIp")
    def storage_vol_ip(self) -> pulumi.Input[_builtins.str]:
        """
        volume ip.
        """
        return pulumi.get(self, "storage_vol_ip")

    @storage_vol_ip.setter
    def storage_vol_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_vol_ip", value)

    @_builtins.property
    @pulumi.getter(name="storageVolName")
    def storage_vol_name(self) -> pulumi.Input[_builtins.str]:
        """
        volume name.
        """
        return pulumi.get(self, "storage_vol_name")

    @storage_vol_name.setter
    def storage_vol_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_vol_name", value)

    @_builtins.property
    @pulumi.getter(name="storageVolPath")
    def storage_vol_path(self) -> pulumi.Input[_builtins.str]:
        """
        volume path.
        """
        return pulumi.get(self, "storage_vol_path")

    @storage_vol_path.setter
    def storage_vol_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_vol_path", value)


if not MYPY:
    class WorkloadStorageMountConfArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        """
        mount path.
        """
        volume_name: pulumi.Input[_builtins.str]
        """
        volume name.
        """
elif False:
    WorkloadStorageMountConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStorageMountConfArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 volume_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mount_path: mount path.
        :param pulumi.Input[_builtins.str] volume_name: volume name.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "volume_name", volume_name)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        mount path.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> pulumi.Input[_builtins.str]:
        """
        volume name.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_name", value)


