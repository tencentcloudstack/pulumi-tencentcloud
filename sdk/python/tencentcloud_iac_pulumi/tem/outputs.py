# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AppConfigConfigData',
    'ApplicationServiceService',
    'ApplicationServiceServicePortMappingItemList',
    'GatewayIngress',
    'GatewayIngressRule',
    'GatewayIngressRuleHttp',
    'GatewayIngressRuleHttpPath',
    'GatewayIngressRuleHttpPathBackend',
    'GatewayIngressTl',
    'ScaleRuleAutoscaler',
    'ScaleRuleAutoscalerCronHorizontalAutoscaler',
    'ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule',
    'ScaleRuleAutoscalerHorizontalAutoscaler',
    'WorkloadDeployStrategyConf',
    'WorkloadEnvConf',
    'WorkloadLiveness',
    'WorkloadReadiness',
    'WorkloadStartupProbe',
    'WorkloadStorageConf',
    'WorkloadStorageMountConf',
]

@pulumi.output_type
class AppConfigConfigData(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: key.
        :param _builtins.str value: value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ApplicationServiceService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portMappingItemLists":
            suggest = "port_mapping_item_lists"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationServiceService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationServiceService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationServiceService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 port_mapping_item_lists: Optional[Sequence['outputs.ApplicationServiceServicePortMappingItemList']] = None,
                 service_name: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpc_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip: ip address of application service.
        :param Sequence['ApplicationServiceServicePortMappingItemListArgs'] port_mapping_item_lists: port mapping item list.
        :param _builtins.str service_name: application service name.
        :param _builtins.str subnet_id: ID of subnet instance, required when type is `VPC`.
        :param _builtins.str type: application service type: EXTERNAL | VPC | CLUSTER.
        :param _builtins.str vpc_id: ID of vpc instance, required when type is `VPC`.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port_mapping_item_lists is not None:
            pulumi.set(__self__, "port_mapping_item_lists", port_mapping_item_lists)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        ip address of application service.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="portMappingItemLists")
    def port_mapping_item_lists(self) -> Optional[Sequence['outputs.ApplicationServiceServicePortMappingItemList']]:
        """
        port mapping item list.
        """
        return pulumi.get(self, "port_mapping_item_lists")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        application service name.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of subnet instance, required when type is `VPC`.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        application service type: EXTERNAL | VPC | CLUSTER.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[_builtins.str]:
        """
        ID of vpc instance, required when type is `VPC`.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ApplicationServiceServicePortMappingItemList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationServiceServicePortMappingItemList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationServiceServicePortMappingItemList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationServiceServicePortMappingItemList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 target_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int port: container port.
        :param _builtins.str protocol: UDP or TCP.
        :param _builtins.int target_port: application listen port.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        container port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        UDP or TCP.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[_builtins.int]:
        """
        application listen port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GatewayIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressIpVersion":
            suggest = "address_ip_version"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "ingressName":
            suggest = "ingress_name"
        elif key == "clbId":
            suggest = "clb_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "rewriteType":
            suggest = "rewrite_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_ip_version: _builtins.str,
                 environment_id: _builtins.str,
                 ingress_name: _builtins.str,
                 mixed: _builtins.bool,
                 rules: Sequence['outputs.GatewayIngressRule'],
                 clb_id: Optional[_builtins.str] = None,
                 create_time: Optional[_builtins.str] = None,
                 rewrite_type: Optional[_builtins.str] = None,
                 tls: Optional[Sequence['outputs.GatewayIngressTl']] = None,
                 vip: Optional[_builtins.str] = None):
        """
        :param _builtins.str address_ip_version: ip version, support IPV4.
        :param _builtins.str environment_id: environment ID.
        :param _builtins.str ingress_name: gateway name.
        :param _builtins.bool mixed: mixing HTTP and HTTPS.
        :param Sequence['GatewayIngressRuleArgs'] rules: proxy rules.
        :param _builtins.str clb_id: related CLB ID, support binding existing clb, does not support modification.
        :param _builtins.str create_time: creation time.
        :param _builtins.str rewrite_type: redirect mode, support AUTO and NONE.
        :param Sequence['GatewayIngressTlArgs'] tls: ingress TLS configurations.
        :param _builtins.str vip: gateway vip.
        """
        pulumi.set(__self__, "address_ip_version", address_ip_version)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "ingress_name", ingress_name)
        pulumi.set(__self__, "mixed", mixed)
        pulumi.set(__self__, "rules", rules)
        if clb_id is not None:
            pulumi.set(__self__, "clb_id", clb_id)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if rewrite_type is not None:
            pulumi.set(__self__, "rewrite_type", rewrite_type)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)

    @_builtins.property
    @pulumi.getter(name="addressIpVersion")
    def address_ip_version(self) -> _builtins.str:
        """
        ip version, support IPV4.
        """
        return pulumi.get(self, "address_ip_version")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> _builtins.str:
        """
        environment ID.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter(name="ingressName")
    def ingress_name(self) -> _builtins.str:
        """
        gateway name.
        """
        return pulumi.get(self, "ingress_name")

    @_builtins.property
    @pulumi.getter
    def mixed(self) -> _builtins.bool:
        """
        mixing HTTP and HTTPS.
        """
        return pulumi.get(self, "mixed")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GatewayIngressRule']:
        """
        proxy rules.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="clbId")
    def clb_id(self) -> Optional[_builtins.str]:
        """
        related CLB ID, support binding existing clb, does not support modification.
        """
        return pulumi.get(self, "clb_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        creation time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="rewriteType")
    def rewrite_type(self) -> Optional[_builtins.str]:
        """
        redirect mode, support AUTO and NONE.
        """
        return pulumi.get(self, "rewrite_type")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[Sequence['outputs.GatewayIngressTl']]:
        """
        ingress TLS configurations.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> Optional[_builtins.str]:
        """
        gateway vip.
        """
        return pulumi.get(self, "vip")


@pulumi.output_type
class GatewayIngressRule(dict):
    def __init__(__self__, *,
                 http: 'outputs.GatewayIngressRuleHttp',
                 host: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param 'GatewayIngressRuleHttpArgs' http: rule payload.
        :param _builtins.str host: host name.
        :param _builtins.str protocol: protocol.
        """
        pulumi.set(__self__, "http", http)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def http(self) -> 'outputs.GatewayIngressRuleHttp':
        """
        rule payload.
        """
        return pulumi.get(self, "http")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        host name.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GatewayIngressRuleHttp(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GatewayIngressRuleHttpPath']):
        """
        :param Sequence['GatewayIngressRuleHttpPathArgs'] paths: path payload.
        """
        pulumi.set(__self__, "paths", paths)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GatewayIngressRuleHttpPath']:
        """
        path payload.
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class GatewayIngressRuleHttpPath(dict):
    def __init__(__self__, *,
                 backend: 'outputs.GatewayIngressRuleHttpPathBackend',
                 path: _builtins.str):
        """
        :param 'GatewayIngressRuleHttpPathBackendArgs' backend: backend payload.
        :param _builtins.str path: path.
        """
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def backend(self) -> 'outputs.GatewayIngressRuleHttpPathBackend':
        """
        backend payload.
        """
        return pulumi.get(self, "backend")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GatewayIngressRuleHttpPathBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"
        elif key == "servicePort":
            suggest = "service_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayIngressRuleHttpPathBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayIngressRuleHttpPathBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayIngressRuleHttpPathBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: _builtins.str,
                 service_port: _builtins.int):
        """
        :param _builtins.str service_name: backend name.
        :param _builtins.int service_port: backend port.
        """
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "service_port", service_port)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        backend name.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="servicePort")
    def service_port(self) -> _builtins.int:
        """
        backend port.
        """
        return pulumi.get(self, "service_port")


@pulumi.output_type
class GatewayIngressTl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayIngressTl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayIngressTl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayIngressTl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: _builtins.str,
                 hosts: Sequence[_builtins.str],
                 secret_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_id: certificate ID.
        :param Sequence[_builtins.str] hosts: host names.
        :param _builtins.str secret_name: secret name, if you use a certificate, you don't need to fill in this field.
        """
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "hosts", hosts)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        certificate ID.
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        """
        host names.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[_builtins.str]:
        """
        secret name, if you use a certificate, you don't need to fill in this field.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class ScaleRuleAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscalerName":
            suggest = "autoscaler_name"
        elif key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "cronHorizontalAutoscalers":
            suggest = "cron_horizontal_autoscalers"
        elif key == "horizontalAutoscalers":
            suggest = "horizontal_autoscalers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaler_name: _builtins.str,
                 enabled: _builtins.bool,
                 max_replicas: _builtins.int,
                 min_replicas: _builtins.int,
                 cron_horizontal_autoscalers: Optional[Sequence['outputs.ScaleRuleAutoscalerCronHorizontalAutoscaler']] = None,
                 description: Optional[_builtins.str] = None,
                 horizontal_autoscalers: Optional[Sequence['outputs.ScaleRuleAutoscalerHorizontalAutoscaler']] = None):
        """
        :param _builtins.str autoscaler_name: name.
        :param _builtins.bool enabled: enable scaler.
        :param _builtins.int max_replicas: maximal replica number.
        :param _builtins.int min_replicas: minimal replica number.
        :param Sequence['ScaleRuleAutoscalerCronHorizontalAutoscalerArgs'] cron_horizontal_autoscalers: scaler based on cron configuration.
        :param _builtins.str description: description.
        :param Sequence['ScaleRuleAutoscalerHorizontalAutoscalerArgs'] horizontal_autoscalers: scaler based on metrics.
        """
        pulumi.set(__self__, "autoscaler_name", autoscaler_name)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        if cron_horizontal_autoscalers is not None:
            pulumi.set(__self__, "cron_horizontal_autoscalers", cron_horizontal_autoscalers)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if horizontal_autoscalers is not None:
            pulumi.set(__self__, "horizontal_autoscalers", horizontal_autoscalers)

    @_builtins.property
    @pulumi.getter(name="autoscalerName")
    def autoscaler_name(self) -> _builtins.str:
        """
        name.
        """
        return pulumi.get(self, "autoscaler_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        enable scaler.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        maximal replica number.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        minimal replica number.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="cronHorizontalAutoscalers")
    def cron_horizontal_autoscalers(self) -> Optional[Sequence['outputs.ScaleRuleAutoscalerCronHorizontalAutoscaler']]:
        """
        scaler based on cron configuration.
        """
        return pulumi.get(self, "cron_horizontal_autoscalers")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="horizontalAutoscalers")
    def horizontal_autoscalers(self) -> Optional[Sequence['outputs.ScaleRuleAutoscalerHorizontalAutoscaler']]:
        """
        scaler based on metrics.
        """
        return pulumi.get(self, "horizontal_autoscalers")


@pulumi.output_type
class ScaleRuleAutoscalerCronHorizontalAutoscaler(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 name: _builtins.str,
                 period: _builtins.str,
                 priority: _builtins.int,
                 schedules: Sequence['outputs.ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule']):
        """
        :param _builtins.bool enabled: enable scaler.
        :param _builtins.str name: name.
        :param _builtins.str period: period.
        :param _builtins.int priority: priority.
        :param Sequence['ScaleRuleAutoscalerCronHorizontalAutoscalerScheduleArgs'] schedules: schedule payload.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        enable scaler.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.str:
        """
        period.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule']:
        """
        schedule payload.
        """
        return pulumi.get(self, "schedules")


@pulumi.output_type
class ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startAt":
            suggest = "start_at"
        elif key == "targetReplicas":
            suggest = "target_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_at: _builtins.str,
                 target_replicas: _builtins.int):
        """
        :param _builtins.str start_at: start time.
        :param _builtins.int target_replicas: target replica number.
        """
        pulumi.set(__self__, "start_at", start_at)
        pulumi.set(__self__, "target_replicas", target_replicas)

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> _builtins.str:
        """
        start time.
        """
        return pulumi.get(self, "start_at")

    @_builtins.property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> _builtins.int:
        """
        target replica number.
        """
        return pulumi.get(self, "target_replicas")


@pulumi.output_type
class ScaleRuleAutoscalerHorizontalAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleAutoscalerHorizontalAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleAutoscalerHorizontalAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleAutoscalerHorizontalAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_replicas: _builtins.int,
                 metrics: _builtins.str,
                 min_replicas: _builtins.int,
                 threshold: _builtins.int):
        """
        :param _builtins.bool enabled: enable scaler.
        :param _builtins.int max_replicas: maximal replica number.
        :param _builtins.str metrics: metric name.
        :param _builtins.int min_replicas: minimal replica number.
        :param _builtins.int threshold: metric threshold.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_replicas", min_replicas)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        enable scaler.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        maximal replica number.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> _builtins.str:
        """
        metric name.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        minimal replica number.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.int:
        """
        metric threshold.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WorkloadDeployStrategyConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployStrategyType":
            suggest = "deploy_strategy_type"
        elif key == "totalBatchCount":
            suggest = "total_batch_count"
        elif key == "batchInterval":
            suggest = "batch_interval"
        elif key == "betaBatchNum":
            suggest = "beta_batch_num"
        elif key == "minAvailable":
            suggest = "min_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadDeployStrategyConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadDeployStrategyConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadDeployStrategyConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_strategy_type: _builtins.int,
                 total_batch_count: _builtins.int,
                 batch_interval: Optional[_builtins.int] = None,
                 beta_batch_num: Optional[_builtins.int] = None,
                 force: Optional[_builtins.bool] = None,
                 min_available: Optional[_builtins.int] = None):
        """
        :param _builtins.int deploy_strategy_type: strategy type, 0 means auto, 1 means manual, 2 means manual with beta batch.
        :param _builtins.int total_batch_count: total batch number.
        :param _builtins.int batch_interval: interval between batches.
        :param _builtins.int beta_batch_num: beta batch number.
        :param _builtins.bool force: force update.
        :param _builtins.int min_available: minimal available instances duration deployment.
        """
        pulumi.set(__self__, "deploy_strategy_type", deploy_strategy_type)
        pulumi.set(__self__, "total_batch_count", total_batch_count)
        if batch_interval is not None:
            pulumi.set(__self__, "batch_interval", batch_interval)
        if beta_batch_num is not None:
            pulumi.set(__self__, "beta_batch_num", beta_batch_num)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if min_available is not None:
            pulumi.set(__self__, "min_available", min_available)

    @_builtins.property
    @pulumi.getter(name="deployStrategyType")
    def deploy_strategy_type(self) -> _builtins.int:
        """
        strategy type, 0 means auto, 1 means manual, 2 means manual with beta batch.
        """
        return pulumi.get(self, "deploy_strategy_type")

    @_builtins.property
    @pulumi.getter(name="totalBatchCount")
    def total_batch_count(self) -> _builtins.int:
        """
        total batch number.
        """
        return pulumi.get(self, "total_batch_count")

    @_builtins.property
    @pulumi.getter(name="batchInterval")
    def batch_interval(self) -> Optional[_builtins.int]:
        """
        interval between batches.
        """
        return pulumi.get(self, "batch_interval")

    @_builtins.property
    @pulumi.getter(name="betaBatchNum")
    def beta_batch_num(self) -> Optional[_builtins.int]:
        """
        beta batch number.
        """
        return pulumi.get(self, "beta_batch_num")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        """
        force update.
        """
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="minAvailable")
    def min_available(self) -> Optional[_builtins.int]:
        """
        minimal available instances duration deployment.
        """
        return pulumi.get(self, "min_available")


@pulumi.output_type
class WorkloadEnvConf(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 config: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: env key.
        :param _builtins.str value: env value.
        :param _builtins.str config: referenced config name when type=referenced.
        :param _builtins.str secret: referenced secret name when type=referenced.
        :param _builtins.str type: env type, support default, referenced.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        env key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        env value.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[_builtins.str]:
        """
        referenced config name when type=referenced.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        referenced secret name when type=referenced.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        env type, support default, referenced.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WorkloadLiveness(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLiveness. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLiveness.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLiveness.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 exec_: Optional[_builtins.str] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: check type, support HttpGet, TcpSocket and Exec.
        :param _builtins.str exec_: script.
        :param _builtins.int initial_delay_seconds: initial delay seconds for liveness check.
        :param _builtins.str path: path.
        :param _builtins.int period_seconds: period seconds for liveness check.
        :param _builtins.int port: liveness check port.
        :param _builtins.str protocol: protocol.
        :param _builtins.int timeout_seconds: timeout seconds for liveness check.
        """
        pulumi.set(__self__, "type", type)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[_builtins.str]:
        """
        script.
        """
        return pulumi.get(self, "exec_")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        initial delay seconds for liveness check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        period seconds for liveness check.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        liveness check port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        timeout seconds for liveness check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadReadiness(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadReadiness. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadReadiness.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadReadiness.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 exec_: Optional[_builtins.str] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: check type, support HttpGet, TcpSocket and Exec.
        :param _builtins.str exec_: script.
        :param _builtins.int initial_delay_seconds: initial delay seconds for readiness check.
        :param _builtins.str path: path.
        :param _builtins.int period_seconds: period seconds for readiness check.
        :param _builtins.int port: readiness check port.
        :param _builtins.str protocol: protocol.
        :param _builtins.int timeout_seconds: timeout seconds for readiness check.
        """
        pulumi.set(__self__, "type", type)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[_builtins.str]:
        """
        script.
        """
        return pulumi.get(self, "exec_")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        initial delay seconds for readiness check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        period seconds for readiness check.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        readiness check port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        timeout seconds for readiness check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadStartupProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStartupProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStartupProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStartupProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 exec_: Optional[_builtins.str] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: check type, support HttpGet, TcpSocket and Exec.
        :param _builtins.str exec_: script.
        :param _builtins.int initial_delay_seconds: initial delay seconds for startup check.
        :param _builtins.str path: path.
        :param _builtins.int period_seconds: period seconds for startup check.
        :param _builtins.int port: startup check port.
        :param _builtins.str protocol: protocol.
        :param _builtins.int timeout_seconds: timeout seconds for startup check.
        """
        pulumi.set(__self__, "type", type)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        check type, support HttpGet, TcpSocket and Exec.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[_builtins.str]:
        """
        script.
        """
        return pulumi.get(self, "exec_")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        initial delay seconds for startup check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        period seconds for startup check.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        startup check port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        timeout seconds for startup check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadStorageConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageVolIp":
            suggest = "storage_vol_ip"
        elif key == "storageVolName":
            suggest = "storage_vol_name"
        elif key == "storageVolPath":
            suggest = "storage_vol_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStorageConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStorageConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStorageConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_vol_ip: _builtins.str,
                 storage_vol_name: _builtins.str,
                 storage_vol_path: _builtins.str):
        """
        :param _builtins.str storage_vol_ip: volume ip.
        :param _builtins.str storage_vol_name: volume name.
        :param _builtins.str storage_vol_path: volume path.
        """
        pulumi.set(__self__, "storage_vol_ip", storage_vol_ip)
        pulumi.set(__self__, "storage_vol_name", storage_vol_name)
        pulumi.set(__self__, "storage_vol_path", storage_vol_path)

    @_builtins.property
    @pulumi.getter(name="storageVolIp")
    def storage_vol_ip(self) -> _builtins.str:
        """
        volume ip.
        """
        return pulumi.get(self, "storage_vol_ip")

    @_builtins.property
    @pulumi.getter(name="storageVolName")
    def storage_vol_name(self) -> _builtins.str:
        """
        volume name.
        """
        return pulumi.get(self, "storage_vol_name")

    @_builtins.property
    @pulumi.getter(name="storageVolPath")
    def storage_vol_path(self) -> _builtins.str:
        """
        volume path.
        """
        return pulumi.get(self, "storage_vol_path")


@pulumi.output_type
class WorkloadStorageMountConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStorageMountConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStorageMountConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStorageMountConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: _builtins.str,
                 volume_name: _builtins.str):
        """
        :param _builtins.str mount_path: mount path.
        :param _builtins.str volume_name: volume name.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "volume_name", volume_name)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        mount path.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> _builtins.str:
        """
        volume name.
        """
        return pulumi.get(self, "volume_name")


