# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AuditLogFileFilterArgs',
    'AuditLogFileFilterArgsDict',
    'BackupDownloadRestrictionLimitVpcArgs',
    'BackupDownloadRestrictionLimitVpcArgsDict',
    'InstanceClusterTopologyArgs',
    'InstanceClusterTopologyArgsDict',
    'InstanceClusterTopologyReadOnlyNodeArgs',
    'InstanceClusterTopologyReadOnlyNodeArgsDict',
    'InstanceClusterTopologyReadWriteNodeArgs',
    'InstanceClusterTopologyReadWriteNodeArgsDict',
    'ParamTemplateParamListArgs',
    'ParamTemplateParamListArgsDict',
    'PasswordComplexityParamListArgs',
    'PasswordComplexityParamListArgsDict',
    'PrivilegeColumnArgs',
    'PrivilegeColumnArgsDict',
    'PrivilegeDatabaseArgs',
    'PrivilegeDatabaseArgsDict',
    'PrivilegeTableArgs',
    'PrivilegeTableArgsDict',
    'ProxyProxyNodeCustomArgs',
    'ProxyProxyNodeCustomArgsDict',
    'ReadonlyInstanceClusterTopologyArgs',
    'ReadonlyInstanceClusterTopologyArgsDict',
    'ReadonlyInstanceClusterTopologyReadOnlyNodeArgs',
    'ReadonlyInstanceClusterTopologyReadOnlyNodeArgsDict',
    'ReadonlyInstanceClusterTopologyReadWriteNodeArgs',
    'ReadonlyInstanceClusterTopologyReadWriteNodeArgsDict',
    'RoGroupRoGroupInfoArgs',
    'RoGroupRoGroupInfoArgsDict',
    'RoGroupRoWeightValueArgs',
    'RoGroupRoWeightValueArgsDict',
    'RollbackDatabaseArgs',
    'RollbackDatabaseArgsDict',
    'RollbackTableArgs',
    'RollbackTableArgsDict',
    'RollbackTableTableArgs',
    'RollbackTableTableArgsDict',
]

MYPY = False

if not MYPY:
    class AuditLogFileFilterArgsDict(TypedDict):
        affect_rows: NotRequired[pulumi.Input[_builtins.int]]
        """
        Affects the number of rows. Indicates to filter audit logs whose number of affected rows is greater than this value.
        """
        db_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Database name.
        """
        exec_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Execution time. The unit is: ms. Indicates to filter audit logs whose execution time is greater than this value.
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Client address.
        """
        policy_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The name of policy.
        """
        sql: NotRequired[pulumi.Input[_builtins.str]]
        """
        SQL statement. support fuzzy matching.
        """
        sql_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        SQL type. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
        """
        sql_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        SQL type. Supports simultaneous query of multiple types. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
        """
        sqls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        SQL statement. Support passing multiple sql statements.
        """
        table_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Table name.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        User name.
        """
elif False:
    AuditLogFileFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditLogFileFilterArgs:
    def __init__(__self__, *,
                 affect_rows: Optional[pulumi.Input[_builtins.int]] = None,
                 db_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exec_time: Optional[pulumi.Input[_builtins.int]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policy_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sql: Optional[pulumi.Input[_builtins.str]] = None,
                 sql_type: Optional[pulumi.Input[_builtins.str]] = None,
                 sql_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sqls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 table_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] affect_rows: Affects the number of rows. Indicates to filter audit logs whose number of affected rows is greater than this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] db_names: Database name.
        :param pulumi.Input[_builtins.int] exec_time: Execution time. The unit is: ms. Indicates to filter audit logs whose execution time is greater than this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] hosts: Client address.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_names: The name of policy.
        :param pulumi.Input[_builtins.str] sql: SQL statement. support fuzzy matching.
        :param pulumi.Input[_builtins.str] sql_type: SQL type. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sql_types: SQL type. Supports simultaneous query of multiple types. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sqls: SQL statement. Support passing multiple sql statements.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] table_names: Table name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] users: User name.
        """
        if affect_rows is not None:
            pulumi.set(__self__, "affect_rows", affect_rows)
        if db_names is not None:
            pulumi.set(__self__, "db_names", db_names)
        if exec_time is not None:
            pulumi.set(__self__, "exec_time", exec_time)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if policy_names is not None:
            pulumi.set(__self__, "policy_names", policy_names)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if sql_type is not None:
            pulumi.set(__self__, "sql_type", sql_type)
        if sql_types is not None:
            pulumi.set(__self__, "sql_types", sql_types)
        if sqls is not None:
            pulumi.set(__self__, "sqls", sqls)
        if table_names is not None:
            pulumi.set(__self__, "table_names", table_names)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter(name="affectRows")
    def affect_rows(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Affects the number of rows. Indicates to filter audit logs whose number of affected rows is greater than this value.
        """
        return pulumi.get(self, "affect_rows")

    @affect_rows.setter
    def affect_rows(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "affect_rows", value)

    @_builtins.property
    @pulumi.getter(name="dbNames")
    def db_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Database name.
        """
        return pulumi.get(self, "db_names")

    @db_names.setter
    def db_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "db_names", value)

    @_builtins.property
    @pulumi.getter(name="execTime")
    def exec_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Execution time. The unit is: ms. Indicates to filter audit logs whose execution time is greater than this value.
        """
        return pulumi.get(self, "exec_time")

    @exec_time.setter
    def exec_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "exec_time", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Client address.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter(name="policyNames")
    def policy_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The name of policy.
        """
        return pulumi.get(self, "policy_names")

    @policy_names.setter
    def policy_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policy_names", value)

    @_builtins.property
    @pulumi.getter
    def sql(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SQL statement. support fuzzy matching.
        """
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql", value)

    @_builtins.property
    @pulumi.getter(name="sqlType")
    def sql_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SQL type. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
        """
        return pulumi.get(self, "sql_type")

    @sql_type.setter
    def sql_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql_type", value)

    @_builtins.property
    @pulumi.getter(name="sqlTypes")
    def sql_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        SQL type. Supports simultaneous query of multiple types. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
        """
        return pulumi.get(self, "sql_types")

    @sql_types.setter
    def sql_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sql_types", value)

    @_builtins.property
    @pulumi.getter
    def sqls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        SQL statement. Support passing multiple sql statements.
        """
        return pulumi.get(self, "sqls")

    @sqls.setter
    def sqls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sqls", value)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Table name.
        """
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "table_names", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        User name.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class BackupDownloadRestrictionLimitVpcArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        Restrict downloads from regions. Currently only the current region is supported.
        """
        vpc_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of vpcs to limit downloads.
        """
elif False:
    BackupDownloadRestrictionLimitVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupDownloadRestrictionLimitVpcArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 vpc_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] region: Restrict downloads from regions. Currently only the current region is supported.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] vpc_lists: List of vpcs to limit downloads.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vpc_lists", vpc_lists)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Restrict downloads from regions. Currently only the current region is supported.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="vpcLists")
    def vpc_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of vpcs to limit downloads.
        """
        return pulumi.get(self, "vpc_lists")

    @vpc_lists.setter
    def vpc_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "vpc_lists", value)


if not MYPY:
    class InstanceClusterTopologyArgsDict(TypedDict):
        read_only_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceClusterTopologyReadOnlyNodeArgsDict']]]]
        """
        RO Node Topology.
        """
        read_write_node: NotRequired[pulumi.Input['InstanceClusterTopologyReadWriteNodeArgsDict']]
        """
        RW Node Topology.
        """
elif False:
    InstanceClusterTopologyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceClusterTopologyArgs:
    def __init__(__self__, *,
                 read_only_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceClusterTopologyReadOnlyNodeArgs']]]] = None,
                 read_write_node: Optional[pulumi.Input['InstanceClusterTopologyReadWriteNodeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceClusterTopologyReadOnlyNodeArgs']]] read_only_nodes: RO Node Topology.
        :param pulumi.Input['InstanceClusterTopologyReadWriteNodeArgs'] read_write_node: RW Node Topology.
        """
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        if read_write_node is not None:
            pulumi.set(__self__, "read_write_node", read_write_node)

    @_builtins.property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceClusterTopologyReadOnlyNodeArgs']]]]:
        """
        RO Node Topology.
        """
        return pulumi.get(self, "read_only_nodes")

    @read_only_nodes.setter
    def read_only_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceClusterTopologyReadOnlyNodeArgs']]]]):
        pulumi.set(self, "read_only_nodes", value)

    @_builtins.property
    @pulumi.getter(name="readWriteNode")
    def read_write_node(self) -> Optional[pulumi.Input['InstanceClusterTopologyReadWriteNodeArgs']]:
        """
        RW Node Topology.
        """
        return pulumi.get(self, "read_write_node")

    @read_write_node.setter
    def read_write_node(self, value: Optional[pulumi.Input['InstanceClusterTopologyReadWriteNodeArgs']]):
        pulumi.set(self, "read_write_node", value)


if not MYPY:
    class InstanceClusterTopologyReadOnlyNodeArgsDict(TypedDict):
        is_random_zone: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to distribute in random availability zones. Enter `true` to specify a random availability zone. Otherwise, use the availability zone specified by Zone.
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the availability zone where the node is distributed.
        """
elif False:
    InstanceClusterTopologyReadOnlyNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceClusterTopologyReadOnlyNodeArgs:
    def __init__(__self__, *,
                 is_random_zone: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_id: Optional[pulumi.Input[_builtins.str]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_random_zone: Whether to distribute in random availability zones. Enter `true` to specify a random availability zone. Otherwise, use the availability zone specified by Zone.
        :param pulumi.Input[_builtins.str] node_id: When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        :param pulumi.Input[_builtins.str] zone: Specifies the availability zone where the node is distributed.
        """
        if is_random_zone is not None:
            pulumi.set(__self__, "is_random_zone", is_random_zone)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="isRandomZone")
    def is_random_zone(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to distribute in random availability zones. Enter `true` to specify a random availability zone. Otherwise, use the availability zone specified by Zone.
        """
        return pulumi.get(self, "is_random_zone")

    @is_random_zone.setter
    def is_random_zone(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_random_zone", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the availability zone where the node is distributed.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class InstanceClusterTopologyReadWriteNodeArgsDict(TypedDict):
        zone: pulumi.Input[_builtins.str]
        """
        The availability zone where the RW node is located.
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
elif False:
    InstanceClusterTopologyReadWriteNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceClusterTopologyReadWriteNodeArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[_builtins.str],
                 node_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] zone: The availability zone where the RW node is located.
        :param pulumi.Input[_builtins.str] node_id: When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        pulumi.set(__self__, "zone", zone)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        The availability zone where the RW node is located.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)


if not MYPY:
    class ParamTemplateParamListArgsDict(TypedDict):
        current_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of parameter.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of parameter.
        """
elif False:
    ParamTemplateParamListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParamTemplateParamListArgs:
    def __init__(__self__, *,
                 current_value: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] current_value: The value of parameter.
        :param pulumi.Input[_builtins.str] name: The name of parameter.
        """
        if current_value is not None:
            pulumi.set(__self__, "current_value", current_value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="currentValue")
    def current_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of parameter.
        """
        return pulumi.get(self, "current_value")

    @current_value.setter
    def current_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PasswordComplexityParamListArgsDict(TypedDict):
        current_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name.
        """
elif False:
    PasswordComplexityParamListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PasswordComplexityParamListArgs:
    def __init__(__self__, *,
                 current_value: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] current_value: Parameter value.
        :param pulumi.Input[_builtins.str] name: Parameter name.
        """
        if current_value is not None:
            pulumi.set(__self__, "current_value", current_value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="currentValue")
    def current_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value.
        """
        return pulumi.get(self, "current_value")

    @current_value.setter
    def current_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PrivilegeColumnArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        """
        Column name.
        """
        database_name: pulumi.Input[_builtins.str]
        """
        Database name.
        """
        privileges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Column privilege.available values for Privileges:SELECT,INSERT,UPDATE,REFERENCES.
        """
        table_name: pulumi.Input[_builtins.str]
        """
        Table name.
        """
elif False:
    PrivilegeColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivilegeColumnArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 table_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] column_name: Column name.
        :param pulumi.Input[_builtins.str] database_name: Database name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] privileges: Column privilege.available values for Privileges:SELECT,INSERT,UPDATE,REFERENCES.
        :param pulumi.Input[_builtins.str] table_name: Table name.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "privileges", privileges)
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Column privilege.available values for Privileges:SELECT,INSERT,UPDATE,REFERENCES.
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "privileges", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        """
        Table name.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class PrivilegeDatabaseArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        """
        Database name.
        """
        privileges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Database privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE TEMPORARY TABLES,LOCK TABLES,EXECUTE,CREATE VIEW,SHOW VIEW,CREATE ROUTINE,ALTER ROUTINE,EVENT,TRIGGER.
        """
elif False:
    PrivilegeDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivilegeDatabaseArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] database_name: Database name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] privileges: Database privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE TEMPORARY TABLES,LOCK TABLES,EXECUTE,CREATE VIEW,SHOW VIEW,CREATE ROUTINE,ALTER ROUTINE,EVENT,TRIGGER.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "privileges", privileges)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Database privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE TEMPORARY TABLES,LOCK TABLES,EXECUTE,CREATE VIEW,SHOW VIEW,CREATE ROUTINE,ALTER ROUTINE,EVENT,TRIGGER.
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "privileges", value)


if not MYPY:
    class PrivilegeTableArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        """
        Database name.
        """
        privileges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Table privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE VIEW,SHOW VIEW,TRIGGER.
        """
        table_name: pulumi.Input[_builtins.str]
        """
        Table name.
        """
elif False:
    PrivilegeTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivilegeTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 table_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] database_name: Database name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] privileges: Table privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE VIEW,SHOW VIEW,TRIGGER.
        :param pulumi.Input[_builtins.str] table_name: Table name.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "privileges", privileges)
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Table privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE VIEW,SHOW VIEW,TRIGGER.
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "privileges", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        """
        Table name.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class ProxyProxyNodeCustomArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.int]
        """
        Number of CPU cores.
        """
        mem: pulumi.Input[_builtins.int]
        """
        Memory size.
        """
        node_count: pulumi.Input[_builtins.int]
        """
        Number of nodes.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region.
        """
        zone: pulumi.Input[_builtins.str]
        """
        Zone.
        """
elif False:
    ProxyProxyNodeCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProxyProxyNodeCustomArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.int],
                 mem: pulumi.Input[_builtins.int],
                 node_count: pulumi.Input[_builtins.int],
                 region: pulumi.Input[_builtins.str],
                 zone: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPU cores.
        :param pulumi.Input[_builtins.int] mem: Memory size.
        :param pulumi.Input[_builtins.int] node_count: Number of nodes.
        :param pulumi.Input[_builtins.str] region: Region.
        :param pulumi.Input[_builtins.str] zone: Zone.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "mem", mem)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.int]:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def mem(self) -> pulumi.Input[_builtins.int]:
        """
        Memory size.
        """
        return pulumi.get(self, "mem")

    @mem.setter
    def mem(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "mem", value)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[_builtins.int]:
        """
        Number of nodes.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "node_count", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        Zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ReadonlyInstanceClusterTopologyArgsDict(TypedDict):
        read_only_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ReadonlyInstanceClusterTopologyReadOnlyNodeArgsDict']]]]
        """
        RO Node Topology.
        """
        read_write_node: NotRequired[pulumi.Input['ReadonlyInstanceClusterTopologyReadWriteNodeArgsDict']]
        """
        RW Node Topology.
        """
elif False:
    ReadonlyInstanceClusterTopologyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReadonlyInstanceClusterTopologyArgs:
    def __init__(__self__, *,
                 read_only_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['ReadonlyInstanceClusterTopologyReadOnlyNodeArgs']]]] = None,
                 read_write_node: Optional[pulumi.Input['ReadonlyInstanceClusterTopologyReadWriteNodeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ReadonlyInstanceClusterTopologyReadOnlyNodeArgs']]] read_only_nodes: RO Node Topology.
        :param pulumi.Input['ReadonlyInstanceClusterTopologyReadWriteNodeArgs'] read_write_node: RW Node Topology.
        """
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        if read_write_node is not None:
            pulumi.set(__self__, "read_write_node", read_write_node)

    @_builtins.property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReadonlyInstanceClusterTopologyReadOnlyNodeArgs']]]]:
        """
        RO Node Topology.
        """
        return pulumi.get(self, "read_only_nodes")

    @read_only_nodes.setter
    def read_only_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReadonlyInstanceClusterTopologyReadOnlyNodeArgs']]]]):
        pulumi.set(self, "read_only_nodes", value)

    @_builtins.property
    @pulumi.getter(name="readWriteNode")
    def read_write_node(self) -> Optional[pulumi.Input['ReadonlyInstanceClusterTopologyReadWriteNodeArgs']]:
        """
        RW Node Topology.
        """
        return pulumi.get(self, "read_write_node")

    @read_write_node.setter
    def read_write_node(self, value: Optional[pulumi.Input['ReadonlyInstanceClusterTopologyReadWriteNodeArgs']]):
        pulumi.set(self, "read_write_node", value)


if not MYPY:
    class ReadonlyInstanceClusterTopologyReadOnlyNodeArgsDict(TypedDict):
        is_random_zone: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to distribute in random availability zones. Enter `true` to specify a random availability zone. Otherwise, use the availability zone specified by Zone.
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the availability zone where the node is distributed.
        """
elif False:
    ReadonlyInstanceClusterTopologyReadOnlyNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReadonlyInstanceClusterTopologyReadOnlyNodeArgs:
    def __init__(__self__, *,
                 is_random_zone: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_id: Optional[pulumi.Input[_builtins.str]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_random_zone: Whether to distribute in random availability zones. Enter `true` to specify a random availability zone. Otherwise, use the availability zone specified by Zone.
        :param pulumi.Input[_builtins.str] node_id: When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        :param pulumi.Input[_builtins.str] zone: Specifies the availability zone where the node is distributed.
        """
        if is_random_zone is not None:
            pulumi.set(__self__, "is_random_zone", is_random_zone)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="isRandomZone")
    def is_random_zone(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to distribute in random availability zones. Enter `true` to specify a random availability zone. Otherwise, use the availability zone specified by Zone.
        """
        return pulumi.get(self, "is_random_zone")

    @is_random_zone.setter
    def is_random_zone(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_random_zone", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the availability zone where the node is distributed.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ReadonlyInstanceClusterTopologyReadWriteNodeArgsDict(TypedDict):
        zone: pulumi.Input[_builtins.str]
        """
        The availability zone where the RW node is located.
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
elif False:
    ReadonlyInstanceClusterTopologyReadWriteNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReadonlyInstanceClusterTopologyReadWriteNodeArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[_builtins.str],
                 node_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] zone: The availability zone where the RW node is located.
        :param pulumi.Input[_builtins.str] node_id: When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        pulumi.set(__self__, "zone", zone)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        The availability zone where the RW node is located.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When upgrading a cluster instance, if you want to adjust the availability zone of a read-only node, you need to specify the node ID.
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)


if not MYPY:
    class RoGroupRoGroupInfoArgsDict(TypedDict):
        min_ro_in_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of reserved instances. It can be set to any value less than or equal to the number of RO instances under this RO group. Note that if the setting value is greater than the number of RO instances, it will not be removed; if it is set to 0, all instances whose latency exceeds the limit will be removed.
        """
        replication_delay_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Delayed replication time.
        """
        ro_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        RO group name.
        """
        ro_max_delay_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        RO instance maximum latency threshold. The unit is seconds, the minimum value is 1. Note that the RO group must have enabled instance delay culling policy for this value to be valid.
        """
        ro_offline_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Whether to enable delayed culling of instances. Supported values are: 1 - on; 0 - not on. Note that if you enable instance delay culling, you must set the delay threshold (RoMaxDelayTime) parameter.
        """
        weight_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        weight mode. Supported values include: `system` - automatically assigned by the system; `custom` - user-defined settings. Note that if the `custom` mode is set, the RO instance weight configuration (RoWeightValues) parameter must be set.
        """
elif False:
    RoGroupRoGroupInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoGroupRoGroupInfoArgs:
    def __init__(__self__, *,
                 min_ro_in_group: Optional[pulumi.Input[_builtins.int]] = None,
                 replication_delay_time: Optional[pulumi.Input[_builtins.int]] = None,
                 ro_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ro_max_delay_time: Optional[pulumi.Input[_builtins.int]] = None,
                 ro_offline_delay: Optional[pulumi.Input[_builtins.int]] = None,
                 weight_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] min_ro_in_group: The minimum number of reserved instances. It can be set to any value less than or equal to the number of RO instances under this RO group. Note that if the setting value is greater than the number of RO instances, it will not be removed; if it is set to 0, all instances whose latency exceeds the limit will be removed.
        :param pulumi.Input[_builtins.int] replication_delay_time: Delayed replication time.
        :param pulumi.Input[_builtins.str] ro_group_name: RO group name.
        :param pulumi.Input[_builtins.int] ro_max_delay_time: RO instance maximum latency threshold. The unit is seconds, the minimum value is 1. Note that the RO group must have enabled instance delay culling policy for this value to be valid.
        :param pulumi.Input[_builtins.int] ro_offline_delay: Whether to enable delayed culling of instances. Supported values are: 1 - on; 0 - not on. Note that if you enable instance delay culling, you must set the delay threshold (RoMaxDelayTime) parameter.
        :param pulumi.Input[_builtins.str] weight_mode: weight mode. Supported values include: `system` - automatically assigned by the system; `custom` - user-defined settings. Note that if the `custom` mode is set, the RO instance weight configuration (RoWeightValues) parameter must be set.
        """
        if min_ro_in_group is not None:
            pulumi.set(__self__, "min_ro_in_group", min_ro_in_group)
        if replication_delay_time is not None:
            pulumi.set(__self__, "replication_delay_time", replication_delay_time)
        if ro_group_name is not None:
            pulumi.set(__self__, "ro_group_name", ro_group_name)
        if ro_max_delay_time is not None:
            pulumi.set(__self__, "ro_max_delay_time", ro_max_delay_time)
        if ro_offline_delay is not None:
            pulumi.set(__self__, "ro_offline_delay", ro_offline_delay)
        if weight_mode is not None:
            pulumi.set(__self__, "weight_mode", weight_mode)

    @_builtins.property
    @pulumi.getter(name="minRoInGroup")
    def min_ro_in_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of reserved instances. It can be set to any value less than or equal to the number of RO instances under this RO group. Note that if the setting value is greater than the number of RO instances, it will not be removed; if it is set to 0, all instances whose latency exceeds the limit will be removed.
        """
        return pulumi.get(self, "min_ro_in_group")

    @min_ro_in_group.setter
    def min_ro_in_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_ro_in_group", value)

    @_builtins.property
    @pulumi.getter(name="replicationDelayTime")
    def replication_delay_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Delayed replication time.
        """
        return pulumi.get(self, "replication_delay_time")

    @replication_delay_time.setter
    def replication_delay_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replication_delay_time", value)

    @_builtins.property
    @pulumi.getter(name="roGroupName")
    def ro_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RO group name.
        """
        return pulumi.get(self, "ro_group_name")

    @ro_group_name.setter
    def ro_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ro_group_name", value)

    @_builtins.property
    @pulumi.getter(name="roMaxDelayTime")
    def ro_max_delay_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        RO instance maximum latency threshold. The unit is seconds, the minimum value is 1. Note that the RO group must have enabled instance delay culling policy for this value to be valid.
        """
        return pulumi.get(self, "ro_max_delay_time")

    @ro_max_delay_time.setter
    def ro_max_delay_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ro_max_delay_time", value)

    @_builtins.property
    @pulumi.getter(name="roOfflineDelay")
    def ro_offline_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether to enable delayed culling of instances. Supported values are: 1 - on; 0 - not on. Note that if you enable instance delay culling, you must set the delay threshold (RoMaxDelayTime) parameter.
        """
        return pulumi.get(self, "ro_offline_delay")

    @ro_offline_delay.setter
    def ro_offline_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ro_offline_delay", value)

    @_builtins.property
    @pulumi.getter(name="weightMode")
    def weight_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        weight mode. Supported values include: `system` - automatically assigned by the system; `custom` - user-defined settings. Note that if the `custom` mode is set, the RO instance weight configuration (RoWeightValues) parameter must be set.
        """
        return pulumi.get(self, "weight_mode")

    @weight_mode.setter
    def weight_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "weight_mode", value)


if not MYPY:
    class RoGroupRoWeightValueArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        RO instance ID.
        """
        weight: pulumi.Input[_builtins.int]
        """
        Weights. The value range is [0, 100].
        """
elif False:
    RoGroupRoWeightValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoGroupRoWeightValueArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] instance_id: RO instance ID.
        :param pulumi.Input[_builtins.int] weight: Weights. The value range is [0, 100].
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        RO instance ID.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        Weights. The value range is [0, 100].
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RollbackDatabaseArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        """
        The original database name before rollback.
        """
        new_database_name: pulumi.Input[_builtins.str]
        """
        The new database name after rollback.
        """
elif False:
    RollbackDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RollbackDatabaseArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 new_database_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] database_name: The original database name before rollback.
        :param pulumi.Input[_builtins.str] new_database_name: The new database name after rollback.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "new_database_name", new_database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        The original database name before rollback.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="newDatabaseName")
    def new_database_name(self) -> pulumi.Input[_builtins.str]:
        """
        The new database name after rollback.
        """
        return pulumi.get(self, "new_database_name")

    @new_database_name.setter
    def new_database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "new_database_name", value)


if not MYPY:
    class RollbackTableArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        Database name.
        """
        tables: pulumi.Input[Sequence[pulumi.Input['RollbackTableTableArgsDict']]]
        """
        Database table details.
        """
elif False:
    RollbackTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RollbackTableArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 tables: pulumi.Input[Sequence[pulumi.Input['RollbackTableTableArgs']]]):
        """
        :param pulumi.Input[_builtins.str] database: Database name.
        :param pulumi.Input[Sequence[pulumi.Input['RollbackTableTableArgs']]] tables: Database table details.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> pulumi.Input[Sequence[pulumi.Input['RollbackTableTableArgs']]]:
        """
        Database table details.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: pulumi.Input[Sequence[pulumi.Input['RollbackTableTableArgs']]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class RollbackTableTableArgsDict(TypedDict):
        new_table_name: pulumi.Input[_builtins.str]
        """
        New database table name after rollback.
        """
        table_name: pulumi.Input[_builtins.str]
        """
        The original database table name before rollback.
        """
elif False:
    RollbackTableTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RollbackTableTableArgs:
    def __init__(__self__, *,
                 new_table_name: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] new_table_name: New database table name after rollback.
        :param pulumi.Input[_builtins.str] table_name: The original database table name before rollback.
        """
        pulumi.set(__self__, "new_table_name", new_table_name)
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="newTableName")
    def new_table_name(self) -> pulumi.Input[_builtins.str]:
        """
        New database table name after rollback.
        """
        return pulumi.get(self, "new_table_name")

    @new_table_name.setter
    def new_table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "new_table_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        """
        The original database table name before rollback.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)


