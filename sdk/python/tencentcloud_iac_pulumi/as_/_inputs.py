# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'LifecycleHookLifecycleCommandArgs',
    'LoadBalancerForwardLoadBalancerArgs',
    'LoadBalancerForwardLoadBalancerTargetAttributeArgs',
    'ScalingConfigDataDiskArgs',
    'ScalingConfigHostNameSettingsArgs',
    'ScalingConfigInstanceNameSettingsArgs',
    'ScalingGroupForwardBalancerIdArgs',
    'ScalingGroupForwardBalancerIdTargetAttributeArgs',
    'StartInstanceRefreshRefreshSettingsArgs',
    'StartInstanceRefreshRefreshSettingsRollingUpdateSettingsArgs',
    'GetInstancesFilterArgs',
]

@pulumi.input_type
class LifecycleHookLifecycleCommandArgs:
    def __init__(__self__, *,
                 command_id: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] command_id: Remote command ID. It is required to execute a command.
        :param pulumi.Input[str] parameters: Custom parameter. The field type is JSON encoded string. For example, {"varA": "222"}.
        """
        pulumi.set(__self__, "command_id", command_id)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="commandId")
    def command_id(self) -> pulumi.Input[str]:
        """
        Remote command ID. It is required to execute a command.
        """
        return pulumi.get(self, "command_id")

    @command_id.setter
    def command_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "command_id", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Custom parameter. The field type is JSON encoded string. For example, {"varA": "222"}.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class LoadBalancerForwardLoadBalancerArgs:
    def __init__(__self__, *,
                 listener_id: pulumi.Input[str],
                 load_balancer_id: pulumi.Input[str],
                 target_attributes: pulumi.Input[Sequence[pulumi.Input['LoadBalancerForwardLoadBalancerTargetAttributeArgs']]],
                 location_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] listener_id: Application load balancer listener ID.
        :param pulumi.Input[str] load_balancer_id: Application load balancer instance ID.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerForwardLoadBalancerTargetAttributeArgs']]] target_attributes: List of TargetAttribute.
        :param pulumi.Input[str] location_id: Application load balancer location ID.
        :param pulumi.Input[str] region: Load balancer instance region. Default value is the region of current auto scaling group. The format is the same as the public parameter Region, for example: ap-guangzhou.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "target_attributes", target_attributes)
        if location_id is not None:
            pulumi.set(__self__, "location_id", location_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> pulumi.Input[str]:
        """
        Application load balancer listener ID.
        """
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "listener_id", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> pulumi.Input[str]:
        """
        Application load balancer instance ID.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> pulumi.Input[Sequence[pulumi.Input['LoadBalancerForwardLoadBalancerTargetAttributeArgs']]]:
        """
        List of TargetAttribute.
        """
        return pulumi.get(self, "target_attributes")

    @target_attributes.setter
    def target_attributes(self, value: pulumi.Input[Sequence[pulumi.Input['LoadBalancerForwardLoadBalancerTargetAttributeArgs']]]):
        pulumi.set(self, "target_attributes", value)

    @property
    @pulumi.getter(name="locationId")
    def location_id(self) -> Optional[pulumi.Input[str]]:
        """
        Application load balancer location ID.
        """
        return pulumi.get(self, "location_id")

    @location_id.setter
    def location_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancer instance region. Default value is the region of current auto scaling group. The format is the same as the public parameter Region, for example: ap-guangzhou.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class LoadBalancerForwardLoadBalancerTargetAttributeArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[int] port: Target port.
        :param pulumi.Input[int] weight: Target weight.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Target port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Target weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class ScalingConfigDataDiskArgs:
    def __init__(__self__, *,
                 delete_with_instance: Optional[pulumi.Input[bool]] = None,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_with_instance: Indicates whether the disk remove after instance terminated. Default is `false`.
        :param pulumi.Input[int] disk_size: Volume of disk in GB. Default is `0`.
        :param pulumi.Input[str] disk_type: Types of disk. Valid values: `CLOUD_PREMIUM` and `CLOUD_SSD`. valid when disk_type_policy is ORIGINAL.
        :param pulumi.Input[str] snapshot_id: Data disk snapshot ID.
        """
        if delete_with_instance is not None:
            pulumi.set(__self__, "delete_with_instance", delete_with_instance)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the disk remove after instance terminated. Default is `false`.
        """
        return pulumi.get(self, "delete_with_instance")

    @delete_with_instance.setter
    def delete_with_instance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_with_instance", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Volume of disk in GB. Default is `0`.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Types of disk. Valid values: `CLOUD_PREMIUM` and `CLOUD_SSD`. valid when disk_type_policy is ORIGINAL.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        Data disk snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)


@pulumi.input_type
class ScalingConfigHostNameSettingsArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[str],
                 host_name_style: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_name: The host name of the cloud server; dots (.) and dashes (-) cannot be used as the first and last characters of HostName, and cannot be used consecutively; Windows instances are not supported; other types (Linux, etc.) instances: the character length is [2, 40], it is allowed to support multiple dots, and there is a paragraph between the dots, and each paragraph is allowed to consist of letters (no uppercase and lowercase restrictions), numbers and dashes (-). Pure numbers are not allowed.
        :param pulumi.Input[str] host_name_style: The style of the host name of the cloud server, the value range includes `ORIGINAL` and `UNIQUE`, the default is `ORIGINAL`; `ORIGINAL`, the AS directly passes the HostName filled in the input parameter to the CVM, and the CVM may append a sequence to the HostName number, the HostName of the instance in the scaling group will conflict; `UNIQUE`, the HostName filled in as a parameter is equivalent to the host name prefix, AS and CVM will expand it, and the HostName of the instance in the scaling group can be guaranteed to be unique.
        """
        pulumi.set(__self__, "host_name", host_name)
        if host_name_style is not None:
            pulumi.set(__self__, "host_name_style", host_name_style)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        """
        The host name of the cloud server; dots (.) and dashes (-) cannot be used as the first and last characters of HostName, and cannot be used consecutively; Windows instances are not supported; other types (Linux, etc.) instances: the character length is [2, 40], it is allowed to support multiple dots, and there is a paragraph between the dots, and each paragraph is allowed to consist of letters (no uppercase and lowercase restrictions), numbers and dashes (-). Pure numbers are not allowed.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="hostNameStyle")
    def host_name_style(self) -> Optional[pulumi.Input[str]]:
        """
        The style of the host name of the cloud server, the value range includes `ORIGINAL` and `UNIQUE`, the default is `ORIGINAL`; `ORIGINAL`, the AS directly passes the HostName filled in the input parameter to the CVM, and the CVM may append a sequence to the HostName number, the HostName of the instance in the scaling group will conflict; `UNIQUE`, the HostName filled in as a parameter is equivalent to the host name prefix, AS and CVM will expand it, and the HostName of the instance in the scaling group can be guaranteed to be unique.
        """
        return pulumi.get(self, "host_name_style")

    @host_name_style.setter
    def host_name_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name_style", value)


@pulumi.input_type
class ScalingConfigInstanceNameSettingsArgs:
    def __init__(__self__, *,
                 instance_name: pulumi.Input[str],
                 instance_name_style: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_name: CVM instance name.
        :param pulumi.Input[str] instance_name_style: Type of CVM instance name. Valid values: `ORIGINAL` and `UNIQUE`. Default is `ORIGINAL`.
        """
        pulumi.set(__self__, "instance_name", instance_name)
        if instance_name_style is not None:
            pulumi.set(__self__, "instance_name_style", instance_name_style)

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> pulumi.Input[str]:
        """
        CVM instance name.
        """
        return pulumi.get(self, "instance_name")

    @instance_name.setter
    def instance_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_name", value)

    @property
    @pulumi.getter(name="instanceNameStyle")
    def instance_name_style(self) -> Optional[pulumi.Input[str]]:
        """
        Type of CVM instance name. Valid values: `ORIGINAL` and `UNIQUE`. Default is `ORIGINAL`.
        """
        return pulumi.get(self, "instance_name_style")

    @instance_name_style.setter
    def instance_name_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_name_style", value)


@pulumi.input_type
class ScalingGroupForwardBalancerIdArgs:
    def __init__(__self__, *,
                 listener_id: pulumi.Input[str],
                 load_balancer_id: pulumi.Input[str],
                 target_attributes: pulumi.Input[Sequence[pulumi.Input['ScalingGroupForwardBalancerIdTargetAttributeArgs']]],
                 rule_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] listener_id: Listener ID for application load balancers.
        :param pulumi.Input[str] load_balancer_id: ID of available load balancers.
        :param pulumi.Input[Sequence[pulumi.Input['ScalingGroupForwardBalancerIdTargetAttributeArgs']]] target_attributes: Attribute list of target rules.
        :param pulumi.Input[str] rule_id: ID of forwarding rules.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "target_attributes", target_attributes)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> pulumi.Input[str]:
        """
        Listener ID for application load balancers.
        """
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "listener_id", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> pulumi.Input[str]:
        """
        ID of available load balancers.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> pulumi.Input[Sequence[pulumi.Input['ScalingGroupForwardBalancerIdTargetAttributeArgs']]]:
        """
        Attribute list of target rules.
        """
        return pulumi.get(self, "target_attributes")

    @target_attributes.setter
    def target_attributes(self, value: pulumi.Input[Sequence[pulumi.Input['ScalingGroupForwardBalancerIdTargetAttributeArgs']]]):
        pulumi.set(self, "target_attributes", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of forwarding rules.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_id", value)


@pulumi.input_type
class ScalingGroupForwardBalancerIdTargetAttributeArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[int] port: Port number.
        :param pulumi.Input[int] weight: Weight.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class StartInstanceRefreshRefreshSettingsArgs:
    def __init__(__self__, *,
                 rolling_update_settings: pulumi.Input['StartInstanceRefreshRefreshSettingsRollingUpdateSettingsArgs'],
                 check_instance_target_health: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['StartInstanceRefreshRefreshSettingsRollingUpdateSettingsArgs'] rolling_update_settings: Rolling update settings parameters. RefreshMode is the rolling update. This parameter must be filled in.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[bool] check_instance_target_health: Backend service health check status for instances, defaults to FALSE. This setting takes effect only for scaling groups bound with application load balancers. When enabled, if an instance fails the check after being refreshed, its load balancer port weight remains 0 and is marked as a refresh failure. Valid values: <br><li>TRUE: Enable the check.</li> <li>FALSE: Do not enable the check.
        """
        pulumi.set(__self__, "rolling_update_settings", rolling_update_settings)
        if check_instance_target_health is not None:
            pulumi.set(__self__, "check_instance_target_health", check_instance_target_health)

    @property
    @pulumi.getter(name="rollingUpdateSettings")
    def rolling_update_settings(self) -> pulumi.Input['StartInstanceRefreshRefreshSettingsRollingUpdateSettingsArgs']:
        """
        Rolling update settings parameters. RefreshMode is the rolling update. This parameter must be filled in.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "rolling_update_settings")

    @rolling_update_settings.setter
    def rolling_update_settings(self, value: pulumi.Input['StartInstanceRefreshRefreshSettingsRollingUpdateSettingsArgs']):
        pulumi.set(self, "rolling_update_settings", value)

    @property
    @pulumi.getter(name="checkInstanceTargetHealth")
    def check_instance_target_health(self) -> Optional[pulumi.Input[bool]]:
        """
        Backend service health check status for instances, defaults to FALSE. This setting takes effect only for scaling groups bound with application load balancers. When enabled, if an instance fails the check after being refreshed, its load balancer port weight remains 0 and is marked as a refresh failure. Valid values: <br><li>TRUE: Enable the check.</li> <li>FALSE: Do not enable the check.
        """
        return pulumi.get(self, "check_instance_target_health")

    @check_instance_target_health.setter
    def check_instance_target_health(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_instance_target_health", value)


@pulumi.input_type
class StartInstanceRefreshRefreshSettingsRollingUpdateSettingsArgs:
    def __init__(__self__, *,
                 batch_number: pulumi.Input[int],
                 batch_pause: Optional[pulumi.Input[str]] = None,
                 max_surge: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] batch_number: Batch quantity. The batch quantity should be a positive integer greater than 0, but cannot exceed the total number of instances pending refresh.
        :param pulumi.Input[str] batch_pause: Pause policy between batches. Default value: Automatic. Valid values: <br><li>FIRST_BATCH_PAUSE: Pause after the first batch update completes.</li> <li>BATCH_INTERVAL_PAUSE: Pause between each batch update.</li> <li>AUTOMATIC: No pauses.
        :param pulumi.Input[int] max_surge: Maximum Extra Quantity. After setting this parameter, a batch of pay-as-you-go extra instances will be created according to the launch configuration before the rolling update starts, and the extra instances will be destroyed after the rolling update is completed.
        """
        pulumi.set(__self__, "batch_number", batch_number)
        if batch_pause is not None:
            pulumi.set(__self__, "batch_pause", batch_pause)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="batchNumber")
    def batch_number(self) -> pulumi.Input[int]:
        """
        Batch quantity. The batch quantity should be a positive integer greater than 0, but cannot exceed the total number of instances pending refresh.
        """
        return pulumi.get(self, "batch_number")

    @batch_number.setter
    def batch_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_number", value)

    @property
    @pulumi.getter(name="batchPause")
    def batch_pause(self) -> Optional[pulumi.Input[str]]:
        """
        Pause policy between batches. Default value: Automatic. Valid values: <br><li>FIRST_BATCH_PAUSE: Pause after the first batch update completes.</li> <li>BATCH_INTERVAL_PAUSE: Pause between each batch update.</li> <li>AUTOMATIC: No pauses.
        """
        return pulumi.get(self, "batch_pause")

    @batch_pause.setter
    def batch_pause(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_pause", value)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Extra Quantity. After setting this parameter, a batch of pay-as-you-go extra instances will be created according to the launch configuration before the rolling update starts, and the extra instances will be destroyed after the rolling update is completed.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_surge", value)


@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Fields to be filtered. Valid names: `instance-id`: Filters by instance ID, `auto-scaling-group-id`: Filter by scaling group ID.
        :param Sequence[str] values: Value of the field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fields to be filtered. Valid names: `instance-id`: Filters by instance ID, `auto-scaling-group-id`: Filter by scaling group ID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Value of the field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


