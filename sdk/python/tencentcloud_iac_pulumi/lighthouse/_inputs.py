# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DiskAutoMountConfigurationArgs',
    'DiskAutoMountConfigurationArgsDict',
    'DiskDiskChargePrepaidArgs',
    'DiskDiskChargePrepaidArgsDict',
    'FirewallRuleFirewallRuleArgs',
    'FirewallRuleFirewallRuleArgsDict',
    'FirewallTemplateTemplateRuleArgs',
    'FirewallTemplateTemplateRuleArgsDict',
    'InstanceContainerArgs',
    'InstanceContainerArgsDict',
    'InstanceContainerEnvArgs',
    'InstanceContainerEnvArgsDict',
    'InstanceContainerPublishPortArgs',
    'InstanceContainerPublishPortArgsDict',
    'InstanceContainerVolumeArgs',
    'InstanceContainerVolumeArgsDict',
    'InstanceLoginConfigurationArgs',
    'InstanceLoginConfigurationArgsDict',
    'RenewDiskRenewDiskChargePrepaidArgs',
    'RenewDiskRenewDiskChargePrepaidArgsDict',
    'RenewInstanceInstanceChargePrepaidArgs',
    'RenewInstanceInstanceChargePrepaidArgsDict',
    'GetBundleFilterArgs',
    'GetBundleFilterArgsDict',
    'GetDiskConfigFilterArgs',
    'GetDiskConfigFilterArgsDict',
    'GetDisksFilterArgs',
    'GetDisksFilterArgsDict',
    'GetModifyInstanceBundleFilterArgs',
    'GetModifyInstanceBundleFilterArgsDict',
    'GetResetInstanceBlueprintFilterArgs',
    'GetResetInstanceBlueprintFilterArgsDict',
]

MYPY = False

if not MYPY:
    class DiskAutoMountConfigurationArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        Instance ID to be mounted. The specified instance must be in the Running state.
        """
        file_system_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The file system type. Value: ext4, xfs. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it defaults to ext4.
        """
        mount_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mount point within the instance. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it will be mounted under the /data/disk path by default.
        """
elif False:
    DiskAutoMountConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskAutoMountConfigurationArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 file_system_type: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_point: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_id: Instance ID to be mounted. The specified instance must be in the Running state.
        :param pulumi.Input[_builtins.str] file_system_type: The file system type. Value: ext4, xfs. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it defaults to ext4.
        :param pulumi.Input[_builtins.str] mount_point: The mount point within the instance. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it will be mounted under the /data/disk path by default.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        if file_system_type is not None:
            pulumi.set(__self__, "file_system_type", file_system_type)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Instance ID to be mounted. The specified instance must be in the Running state.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemType")
    def file_system_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The file system type. Value: ext4, xfs. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it defaults to ext4.
        """
        return pulumi.get(self, "file_system_type")

    @file_system_type.setter
    def file_system_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_system_type", value)

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mount point within the instance. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it will be mounted under the /data/disk path by default.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_point", value)


if not MYPY:
    class DiskDiskChargePrepaidArgsDict(TypedDict):
        period: pulumi.Input[_builtins.int]
        """
        new purchase cycle.
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Automatic renewal flag. Value: `NOTIFY_AND_AUTO_RENEW`: Notice expires and auto-renews. `NOTIFY_AND_MANUAL_RENEW`: Notification expires without automatic renewal, users need to manually renew. `DISABLE_NOTIFY_AND_AUTO_RENEW`: No automatic renewal and no notification. Default: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the disk will be automatically renewed monthly when the account balance is sufficient.
        """
        time_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        newly purchased unit. Default: m.
        """
elif False:
    DiskDiskChargePrepaidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskDiskChargePrepaidArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[_builtins.int],
                 renew_flag: Optional[pulumi.Input[_builtins.str]] = None,
                 time_unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] period: new purchase cycle.
        :param pulumi.Input[_builtins.str] renew_flag: Automatic renewal flag. Value: `NOTIFY_AND_AUTO_RENEW`: Notice expires and auto-renews. `NOTIFY_AND_MANUAL_RENEW`: Notification expires without automatic renewal, users need to manually renew. `DISABLE_NOTIFY_AND_AUTO_RENEW`: No automatic renewal and no notification. Default: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the disk will be automatically renewed monthly when the account balance is sufficient.
        :param pulumi.Input[_builtins.str] time_unit: newly purchased unit. Default: m.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        new purchase cycle.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Automatic renewal flag. Value: `NOTIFY_AND_AUTO_RENEW`: Notice expires and auto-renews. `NOTIFY_AND_MANUAL_RENEW`: Notification expires without automatic renewal, users need to manually renew. `DISABLE_NOTIFY_AND_AUTO_RENEW`: No automatic renewal and no notification. Default: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the disk will be automatically renewed monthly when the account balance is sufficient.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_flag", value)

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        newly purchased unit. Default: m.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class FirewallRuleFirewallRuleArgsDict(TypedDict):
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol. Valid values are TCP, UDP, ICMP, ALL.
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Valid values are ACCEPT, DROP. Default value is ACCEPT.
        """
        cidr_block: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP range or IP (mutually exclusive). Default value is 0.0.0.0/0, which indicates all sources.
        """
        firewall_rule_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firewall rule description.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port. Valid values are ALL, one single port, multiple ports separated by commas, or port range indicated by a minus sign.
        """
elif False:
    FirewallRuleFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRuleFirewallRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 cidr_block: Optional[pulumi.Input[_builtins.str]] = None,
                 firewall_rule_description: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] protocol: Protocol. Valid values are TCP, UDP, ICMP, ALL.
        :param pulumi.Input[_builtins.str] action: Valid values are ACCEPT, DROP. Default value is ACCEPT.
        :param pulumi.Input[_builtins.str] cidr_block: IP range or IP (mutually exclusive). Default value is 0.0.0.0/0, which indicates all sources.
        :param pulumi.Input[_builtins.str] firewall_rule_description: Firewall rule description.
        :param pulumi.Input[_builtins.str] port: Port. Valid values are ALL, one single port, multiple ports separated by commas, or port range indicated by a minus sign.
        """
        pulumi.set(__self__, "protocol", protocol)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if firewall_rule_description is not None:
            pulumi.set(__self__, "firewall_rule_description", firewall_rule_description)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol. Valid values are TCP, UDP, ICMP, ALL.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Valid values are ACCEPT, DROP. Default value is ACCEPT.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP range or IP (mutually exclusive). Default value is 0.0.0.0/0, which indicates all sources.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_block", value)

    @_builtins.property
    @pulumi.getter(name="firewallRuleDescription")
    def firewall_rule_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firewall rule description.
        """
        return pulumi.get(self, "firewall_rule_description")

    @firewall_rule_description.setter
    def firewall_rule_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firewall_rule_description", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port. Valid values are ALL, one single port, multiple ports separated by commas, or port range indicated by a minus sign.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class FirewallTemplateTemplateRuleArgsDict(TypedDict):
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol. Values: TCP, UDP, ICMP, ALL.
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action. Values: ACCEPT, DROP. The default is `ACCEPT`.
        """
        cidr_block: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network segment or IP (mutually exclusive). The default is `0.0.0.0`, indicating all sources.
        """
        firewall_rule_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Firewall rule description.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port. Values: ALL, Separate ports, comma-separated discrete ports, minus sign-separated port ranges.
        """
elif False:
    FirewallTemplateTemplateRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallTemplateTemplateRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 cidr_block: Optional[pulumi.Input[_builtins.str]] = None,
                 firewall_rule_description: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] protocol: Protocol. Values: TCP, UDP, ICMP, ALL.
        :param pulumi.Input[_builtins.str] action: Action. Values: ACCEPT, DROP. The default is `ACCEPT`.
        :param pulumi.Input[_builtins.str] cidr_block: Network segment or IP (mutually exclusive). The default is `0.0.0.0`, indicating all sources.
        :param pulumi.Input[_builtins.str] firewall_rule_description: Firewall rule description.
        :param pulumi.Input[_builtins.str] port: Port. Values: ALL, Separate ports, comma-separated discrete ports, minus sign-separated port ranges.
        """
        pulumi.set(__self__, "protocol", protocol)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if firewall_rule_description is not None:
            pulumi.set(__self__, "firewall_rule_description", firewall_rule_description)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol. Values: TCP, UDP, ICMP, ALL.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action. Values: ACCEPT, DROP. The default is `ACCEPT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network segment or IP (mutually exclusive). The default is `0.0.0.0`, indicating all sources.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_block", value)

    @_builtins.property
    @pulumi.getter(name="firewallRuleDescription")
    def firewall_rule_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Firewall rule description.
        """
        return pulumi.get(self, "firewall_rule_description")

    @firewall_rule_description.setter
    def firewall_rule_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firewall_rule_description", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port. Values: ALL, Separate ports, comma-separated discrete ports, minus sign-separated port ranges.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class InstanceContainerArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        The command to run.
        """
        container_image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Container image address.
        """
        container_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Container name.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceContainerEnvArgsDict']]]]
        """
        List of environment variables.
        """
        publish_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceContainerPublishPortArgsDict']]]]
        """
        List of mappings of container ports and host ports.
        """
        volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceContainerVolumeArgsDict']]]]
        """
        List of container mount volumes.
        """
elif False:
    InstanceContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceContainerArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 container_image: Optional[pulumi.Input[_builtins.str]] = None,
                 container_name: Optional[pulumi.Input[_builtins.str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerEnvArgs']]]] = None,
                 publish_ports: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerPublishPortArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerVolumeArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] command: The command to run.
        :param pulumi.Input[_builtins.str] container_image: Container image address.
        :param pulumi.Input[_builtins.str] container_name: Container name.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceContainerEnvArgs']]] envs: List of environment variables.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceContainerPublishPortArgs']]] publish_ports: List of mappings of container ports and host ports.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceContainerVolumeArgs']]] volumes: List of container mount volumes.
        """
        if command is not None:
            pulumi.set(__self__, "command", command)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if publish_ports is not None:
            pulumi.set(__self__, "publish_ports", publish_ports)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The command to run.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Container image address.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_image", value)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Container name.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerEnvArgs']]]]:
        """
        List of environment variables.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter(name="publishPorts")
    def publish_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerPublishPortArgs']]]]:
        """
        List of mappings of container ports and host ports.
        """
        return pulumi.get(self, "publish_ports")

    @publish_ports.setter
    def publish_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerPublishPortArgs']]]]):
        pulumi.set(self, "publish_ports", value)

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerVolumeArgs']]]]:
        """
        List of container mount volumes.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceContainerVolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


if not MYPY:
    class InstanceContainerEnvArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Environment variable key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Environment variable value.
        """
elif False:
    InstanceContainerEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceContainerEnvArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Environment variable key.
        :param pulumi.Input[_builtins.str] value: Environment variable value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Environment variable key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InstanceContainerPublishPortArgsDict(TypedDict):
        container_port: pulumi.Input[_builtins.int]
        """
        Container port.
        """
        host_port: pulumi.Input[_builtins.int]
        """
        Host port.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        External IP. It defaults to 0.0.0.0.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol defaults to tcp. Valid values: tcp, udp and sctp.
        """
elif False:
    InstanceContainerPublishPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceContainerPublishPortArgs:
    def __init__(__self__, *,
                 container_port: pulumi.Input[_builtins.int],
                 host_port: pulumi.Input[_builtins.int],
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] container_port: Container port.
        :param pulumi.Input[_builtins.int] host_port: Host port.
        :param pulumi.Input[_builtins.str] ip: External IP. It defaults to 0.0.0.0.
        :param pulumi.Input[_builtins.str] protocol: The protocol defaults to tcp. Valid values: tcp, udp and sctp.
        """
        pulumi.set(__self__, "container_port", container_port)
        pulumi.set(__self__, "host_port", host_port)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[_builtins.int]:
        """
        Container port.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> pulumi.Input[_builtins.int]:
        """
        Host port.
        """
        return pulumi.get(self, "host_port")

    @host_port.setter
    def host_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "host_port", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External IP. It defaults to 0.0.0.0.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol defaults to tcp. Valid values: tcp, udp and sctp.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class InstanceContainerVolumeArgsDict(TypedDict):
        container_path: pulumi.Input[_builtins.str]
        """
        Container path.
        """
        host_path: pulumi.Input[_builtins.str]
        """
        Host path.
        """
elif False:
    InstanceContainerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceContainerVolumeArgs:
    def __init__(__self__, *,
                 container_path: pulumi.Input[_builtins.str],
                 host_path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] container_path: Container path.
        :param pulumi.Input[_builtins.str] host_path: Host path.
        """
        pulumi.set(__self__, "container_path", container_path)
        pulumi.set(__self__, "host_path", host_path)

    @_builtins.property
    @pulumi.getter(name="containerPath")
    def container_path(self) -> pulumi.Input[_builtins.str]:
        """
        Container path.
        """
        return pulumi.get(self, "container_path")

    @container_path.setter
    def container_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_path", value)

    @_builtins.property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> pulumi.Input[_builtins.str]:
        """
        Host path.
        """
        return pulumi.get(self, "host_path")

    @host_path.setter
    def host_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_path", value)


if not MYPY:
    class InstanceLoginConfigurationArgsDict(TypedDict):
        auto_generate_password: pulumi.Input[_builtins.str]
        """
        whether auto generate password. if false, need set password.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Login password.
        """
elif False:
    InstanceLoginConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceLoginConfigurationArgs:
    def __init__(__self__, *,
                 auto_generate_password: pulumi.Input[_builtins.str],
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auto_generate_password: whether auto generate password. if false, need set password.
        :param pulumi.Input[_builtins.str] password: Login password.
        """
        pulumi.set(__self__, "auto_generate_password", auto_generate_password)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="autoGeneratePassword")
    def auto_generate_password(self) -> pulumi.Input[_builtins.str]:
        """
        whether auto generate password. if false, need set password.
        """
        return pulumi.get(self, "auto_generate_password")

    @auto_generate_password.setter
    def auto_generate_password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auto_generate_password", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Login password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class RenewDiskRenewDiskChargePrepaidArgsDict(TypedDict):
        cur_instance_deadline: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current instance expiration time. Such as 2018-01-01 00:00:00. Specifying this parameter can align the expiration time of the instance attached to the disk. One of this parameter and Period must be specified, and cannot be specified at the same time.
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Renewal period.
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Automatic renewal falg. Value:NOTIFY_AND_AUTO_RENEW: Notice expires and auto-renews.NOTIFY_AND_MANUAL_RENEW: Notification expires without automatic renewal, users need to manually renew.DISABLE_NOTIFY_AND_AUTO_RENEW: No automatic renewal and no notification.Default: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the disk will be automatically renewed monthly when the account balance is sufficient.
        """
        time_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        newly purchased unit. Default: m.
        """
elif False:
    RenewDiskRenewDiskChargePrepaidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RenewDiskRenewDiskChargePrepaidArgs:
    def __init__(__self__, *,
                 cur_instance_deadline: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 renew_flag: Optional[pulumi.Input[_builtins.str]] = None,
                 time_unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cur_instance_deadline: Current instance expiration time. Such as 2018-01-01 00:00:00. Specifying this parameter can align the expiration time of the instance attached to the disk. One of this parameter and Period must be specified, and cannot be specified at the same time.
        :param pulumi.Input[_builtins.int] period: Renewal period.
        :param pulumi.Input[_builtins.str] renew_flag: Automatic renewal falg. Value:NOTIFY_AND_AUTO_RENEW: Notice expires and auto-renews.NOTIFY_AND_MANUAL_RENEW: Notification expires without automatic renewal, users need to manually renew.DISABLE_NOTIFY_AND_AUTO_RENEW: No automatic renewal and no notification.Default: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the disk will be automatically renewed monthly when the account balance is sufficient.
        :param pulumi.Input[_builtins.str] time_unit: newly purchased unit. Default: m.
        """
        if cur_instance_deadline is not None:
            pulumi.set(__self__, "cur_instance_deadline", cur_instance_deadline)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @_builtins.property
    @pulumi.getter(name="curInstanceDeadline")
    def cur_instance_deadline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current instance expiration time. Such as 2018-01-01 00:00:00. Specifying this parameter can align the expiration time of the instance attached to the disk. One of this parameter and Period must be specified, and cannot be specified at the same time.
        """
        return pulumi.get(self, "cur_instance_deadline")

    @cur_instance_deadline.setter
    def cur_instance_deadline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cur_instance_deadline", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Renewal period.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Automatic renewal falg. Value:NOTIFY_AND_AUTO_RENEW: Notice expires and auto-renews.NOTIFY_AND_MANUAL_RENEW: Notification expires without automatic renewal, users need to manually renew.DISABLE_NOTIFY_AND_AUTO_RENEW: No automatic renewal and no notification.Default: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the disk will be automatically renewed monthly when the account balance is sufficient.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_flag", value)

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        newly purchased unit. Default: m.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class RenewInstanceInstanceChargePrepaidArgsDict(TypedDict):
        period: pulumi.Input[_builtins.int]
        """
        The duration of purchasing an instance. Unit is month. Valid values are (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60).
        """
        renew_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Automatic renewal logo. Values:
        - `NOTIFY_AND_AUTO_RENEW`: notify expiration and renew automatically;
        - `NOTIFY_AND_MANUAL_RENEW`: notification of expiration does not renew automatically. Users need to renew manually;
        - `DISABLE_NOTIFY_AND_AUTO_RENEW`: no automatic renewal and no notification;
        Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis after expiration, when the account balance is sufficient.
        """
elif False:
    RenewInstanceInstanceChargePrepaidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RenewInstanceInstanceChargePrepaidArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[_builtins.int],
                 renew_flag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] period: The duration of purchasing an instance. Unit is month. Valid values are (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60).
        :param pulumi.Input[_builtins.str] renew_flag: Automatic renewal logo. Values:
               - `NOTIFY_AND_AUTO_RENEW`: notify expiration and renew automatically;
               - `NOTIFY_AND_MANUAL_RENEW`: notification of expiration does not renew automatically. Users need to renew manually;
               - `DISABLE_NOTIFY_AND_AUTO_RENEW`: no automatic renewal and no notification;
               Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis after expiration, when the account balance is sufficient.
        """
        pulumi.set(__self__, "period", period)
        if renew_flag is not None:
            pulumi.set(__self__, "renew_flag", renew_flag)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        The duration of purchasing an instance. Unit is month. Valid values are (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60).
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="renewFlag")
    def renew_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Automatic renewal logo. Values:
        - `NOTIFY_AND_AUTO_RENEW`: notify expiration and renew automatically;
        - `NOTIFY_AND_MANUAL_RENEW`: notification of expiration does not renew automatically. Users need to renew manually;
        - `DISABLE_NOTIFY_AND_AUTO_RENEW`: no automatic renewal and no notification;
        Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis after expiration, when the account balance is sufficient.
        """
        return pulumi.get(self, "renew_flag")

    @renew_flag.setter
    def renew_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_flag", value)


if not MYPY:
    class GetBundleFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Field to be filtered.
        """
        values: Sequence[_builtins.str]
        """
        Filter value of field.
        """
elif False:
    GetBundleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBundleFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Field to be filtered.
        :param Sequence[_builtins.str] values: Filter value of field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field to be filtered.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter value of field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetDiskConfigFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Field to be filtered.
        """
        values: Sequence[_builtins.str]
        """
        Filter value of field.
        """
elif False:
    GetDiskConfigFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDiskConfigFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Field to be filtered.
        :param Sequence[_builtins.str] values: Filter value of field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field to be filtered.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter value of field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetDisksFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Fields to be filtered. Valid names: `disk-id`: Filters by disk id; `instance-id`: Filter by instance id; `disk-name`: Filter by disk name; `zone`: Filter by zone; `disk-usage`: Filter by disk usage(Values: `SYSTEM_DISK` or `DATA_DISK`); `disk-state`: Filter by disk state.
        """
        values: Sequence[_builtins.str]
        """
        Value of the field.
        """
elif False:
    GetDisksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDisksFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Fields to be filtered. Valid names: `disk-id`: Filters by disk id; `instance-id`: Filter by instance id; `disk-name`: Filter by disk name; `zone`: Filter by zone; `disk-usage`: Filter by disk usage(Values: `SYSTEM_DISK` or `DATA_DISK`); `disk-state`: Filter by disk state.
        :param Sequence[_builtins.str] values: Value of the field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Fields to be filtered. Valid names: `disk-id`: Filters by disk id; `instance-id`: Filter by instance id; `disk-name`: Filter by disk name; `zone`: Filter by zone; `disk-usage`: Filter by disk usage(Values: `SYSTEM_DISK` or `DATA_DISK`); `disk-state`: Filter by disk state.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Value of the field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetModifyInstanceBundleFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Field to be filtered.
        """
        values: Sequence[_builtins.str]
        """
        Filter value of field.
        """
elif False:
    GetModifyInstanceBundleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModifyInstanceBundleFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Field to be filtered.
        :param Sequence[_builtins.str] values: Filter value of field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field to be filtered.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter value of field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetResetInstanceBlueprintFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Field to be filtered.
        """
        values: Sequence[_builtins.str]
        """
        Filter value of field.
        """
elif False:
    GetResetInstanceBlueprintFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResetInstanceBlueprintFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Field to be filtered.
        :param Sequence[_builtins.str] values: Filter value of field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Field to be filtered.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Filter value of field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


