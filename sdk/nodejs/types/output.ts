// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace Address {
    export interface GetTemplateGroupsGroupList {
        /**
         * Id of the address template group to query.
         */
        id: string;
        /**
         * Name of the address template group to query.
         */
        name: string;
        /**
         * ID set of the address template.
         */
        templateIds: string[];
    }

    export interface GetTemplatesTemplateList {
        /**
         * Set of the addresses.
         */
        addresses: string[];
        /**
         * ID of the address template to query.
         */
        id: string;
        /**
         * Name of the address template to query.
         */
        name: string;
    }

}

export namespace Antiddos {
    export interface CcBlackWhiteIpBlackWhiteIp {
        /**
         * ip address.
         */
        ip: string;
        /**
         * ip mask.
         */
        mask: number;
    }

    export interface CcPrecisionPolicyPolicyList {
        /**
         * Configuration fields can take values of cgi, ua, cookie, referer, accept, srcip.
         */
        fieldName: string;
        /**
         * field type.
         */
        fieldType: string;
        /**
         * value.
         */
        value: string;
        /**
         * Configuration item value comparison method, can take values of equal, not_ Equal, include.
         */
        valueOperator: string;
    }

    export interface DdosGeoIpBlockConfigDdosGeoIpBlockConfig {
        /**
         * Blocking action, value [drop (intercept) trans (release)].
         */
        action: string;
        /**
         * When RegionType is customized, an AreaList must be filled in, with a maximum of 128 entries;.
         */
        areaLists?: number[];
        /**
         * Region type, value [oversea (overseas) China (domestic) customized (custom region)].
         */
        regionType: string;
    }

    export interface DdosSpeedLimitConfigDdosSpeedLimitConfig {
        /**
         * List of port ranges, up to 8, multiple; Separate and indicate the range with -; This port range must be filled in; Fill in style 1:0-65535, style 2: 80; 443; 1000-2000.
         */
        dstPortList?: string;
        /**
         * This field has been deprecated. Please fill in the new field DstPortList.
         */
        dstPortScopes?: outputs.Antiddos.DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScope[];
        /**
         * Speed limit mode, value [1 (based on source IP speed limit) 2 (based on destination port speed limit)].
         */
        mode: number;
        /**
         * IP protocol numbers, values [ALL (all protocols) TCP (tcp protocol) UDP (udp protocol) SMP (smp protocol) 1; 2-100 (custom protocol number range, up to 8)] Note: When customizing the protocol number range, only the protocol number can be filled in, multiple ranges; Separation; When filling in ALL, no other agreements or agreements can be filled inNumber.
         */
        protocolList?: string;
        /**
         * Speed limit values, each type of speed limit value can support up to 1; This field array has at least one speed limit value.
         */
        speedValues: outputs.Antiddos.DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValue[];
    }

    export interface DdosSpeedLimitConfigDdosSpeedLimitConfigDstPortScope {
        /**
         * Starting port, ranging from 1 to 65535.
         */
        beginPort: number;
        /**
         * end  port, ranging from 1 to 65535.
         */
        endPort: number;
    }

    export interface DdosSpeedLimitConfigDdosSpeedLimitConfigSpeedValue {
        /**
         * Speed limit value type, value [1 (packet rate pps) 2 (bandwidth bps)].
         */
        type: number;
        /**
         * value.
         */
        value: number;
    }

    export interface DefaultAlarmThresholdDefaultAlarmConfig {
        /**
         * Alarm threshold, in Mbps, with a value of&gt;=0; When used as an input parameter, setting 0 will delete the alarm threshold configuration;.
         */
        alarmThreshold?: number;
        /**
         * Alarm threshold type, value [1 (incoming traffic alarm threshold) 2 (attack cleaning traffic alarm threshold)].
         */
        alarmType?: number;
    }

    export interface GetBasicDeviceStatusClbData {
        /**
         * Properties name.
         */
        key: string;
        /**
         * Properties value.
         */
        value: string;
    }

    export interface GetBasicDeviceStatusData {
        /**
         * Properties name.
         */
        key: string;
        /**
         * Properties value.
         */
        value: string;
    }

    export interface GetListListenerLayer4Listener {
        /**
         * Origin port, value 1~65535.
         */
        backendPort: number;
        /**
         * Forwarding port, value 1~65535.
         */
        frontendPort: number;
        /**
         * Resource instance to which the rule belongs.
         */
        instanceDetailRules: outputs.Antiddos.GetListListenerLayer4ListenerInstanceDetailRule[];
        /**
         * InstanceDetails.
         */
        instanceDetails: outputs.Antiddos.GetListListenerLayer4ListenerInstanceDetail[];
        /**
         * Protocol.
         */
        protocol: string;
        /**
         * Source server list.
         */
        realServers: outputs.Antiddos.GetListListenerLayer4ListenerRealServer[];
    }

    export interface GetListListenerLayer4ListenerInstanceDetail {
        /**
         * Instance ip list.
         */
        eipLists: string[];
        /**
         * Instance id.
         */
        instanceId: string;
    }

    export interface GetListListenerLayer4ListenerInstanceDetailRule {
        /**
         * Cname.
         */
        cname: string;
        /**
         * Instance ip list.
         */
        eipLists: string[];
        /**
         * Instance id.
         */
        instanceId: string;
    }

    export interface GetListListenerLayer4ListenerRealServer {
        /**
         * 0-65535.
         */
        port: number;
        /**
         * Source server list.
         */
        realServer: string;
        /**
         * 1: domain, 2: ip.
         */
        rsType: number;
        /**
         * Weight: 1-100.
         */
        weight: number;
    }

    export interface GetListListenerLayer7Listener {
        /**
         * Domain.
         */
        domain: string;
        /**
         * Resource instance to which the rule belongs.
         */
        instanceDetailRules: outputs.Antiddos.GetListListenerLayer7ListenerInstanceDetailRule[];
        /**
         * InstanceDetails.
         */
        instanceDetails: outputs.Antiddos.GetListListenerLayer7ListenerInstanceDetail[];
        /**
         * Protocol.
         */
        protocol: string;
        /**
         * List of forwarding types.
         */
        proxyTypeLists: outputs.Antiddos.GetListListenerLayer7ListenerProxyTypeList[];
        /**
         * Source server list.
         */
        realServers: outputs.Antiddos.GetListListenerLayer7ListenerRealServer[];
        /**
         * Port.
         */
        vport: number;
    }

    export interface GetListListenerLayer7ListenerInstanceDetail {
        /**
         * Instance ip list.
         */
        eipLists: string[];
        /**
         * Instance id.
         */
        instanceId: string;
    }

    export interface GetListListenerLayer7ListenerInstanceDetailRule {
        /**
         * Cname.
         */
        cname: string;
        /**
         * Instance ip list.
         */
        eipLists: string[];
        /**
         * Instance id.
         */
        instanceId: string;
    }

    export interface GetListListenerLayer7ListenerProxyTypeList {
        /**
         * Forwarding listening port list, port value is 1~65535.
         */
        proxyPorts: number[];
        /**
         * Http, https.
         */
        proxyType: string;
    }

    export interface GetListListenerLayer7ListenerRealServer {
        /**
         * 0-65535.
         */
        port: number;
        /**
         * Source server list.
         */
        realServer: string;
        /**
         * 1: domain, 2: ip.
         */
        rsType: number;
        /**
         * Weight: 1-100.
         */
        weight: number;
    }

    export interface GetOverviewDdosEventListEventList {
        /**
         * filter event by attack status, start: attacking; end: attack end.
         */
        attackStatus: number;
        /**
         * AttackType.
         */
        attackType: string;
        /**
         * Dayu sub product code (bgpip represents advanced defense IP; net represents professional version of advanced defense IP).
         */
        business: string;
        /**
         * EndTime.
         */
        endTime: string;
        /**
         * event id.
         */
        id: string;
        /**
         * InstanceId.
         */
        instanceId: string;
        /**
         * InstanceId.
         */
        instanceName: string;
        /**
         * Attack traffic, unit Mbps.
         */
        mbps: number;
        /**
         * unit Mbps.
         */
        pps: number;
        /**
         * StartTime.
         */
        startTime: string;
        /**
         * ip.
         */
        vip: string;
    }

    export interface PacketFilterConfigPacketFilterConfig {
        /**
         * Action, value [drop (discard) transmit (release) dropBlack (discard and pull black) dropRst (intercept) dropBlackRst (intercept and pull black) forward (continue protection)].
         */
        action: string;
        /**
         * The detection depth starting from the detection position, with a value of [0-1500].
         */
        depth?: number;
        /**
         * The second detection depth starting from the second detection position, with a value of [01500].
         */
        depth2?: number;
        /**
         * end destination port, ranging from 0 to 65535.
         */
        dportEnd: number;
        /**
         * Starting destination port, ranging from 0 to 65535.
         */
        dportStart: number;
        /**
         * Whether to include detection values, with a value of [0 (inclusive) and 1 (exclusive)].
         */
        isNot?: number;
        /**
         * Whether the second detection includes detection values, with a value of [0 (inclusive) and 1 (exclusive)].
         */
        isNot2?: number;
        /**
         * Detection position, value [beginL3 (IP header) beginL4 (TCP/UDP header) beginL5 (T payload) noMatch (mismatch)].
         */
        matchBegin?: string;
        /**
         * Second detection position, value [beginL5 (load) noMatch (mismatch)].
         */
        matchBegin2: string;
        /**
         * When there is a second detection condition, the AND or relationship with the first detection condition, with the value [and (and relationship) none (fill in this value when there is no second detection condition)].
         */
        matchLogic: string;
        /**
         * Detection type, value [Sunday (keyword) pcre (regular expression)].
         */
        matchType?: string;
        /**
         * The second detection type, with a value of [Sunday (keyword) pcre (regular expression)].
         */
        matchType2?: string;
        /**
         * The offset from the detection position, with a value range of [0, Depth].
         */
        offset?: number;
        /**
         * The offset from the second detection position, with a value range of [0, Depth2].
         */
        offset2?: number;
        /**
         * Greater than message length, value 1+.
         */
        pktLenGt?: number;
        /**
         * The maximum message length, ranging from 1 to 1500, must be greater than or equal to the minimum message length.
         */
        pktlenMax: number;
        /**
         * Minimum message length, ranging from 1 to 1500.
         */
        pktlenMin: number;
        /**
         * Protocol, value [TCP udp icmp all].
         */
        protocol: string;
        /**
         * End source port, values range from 1 to 65535, must be greater than or equal to the start source port.
         */
        sportEnd: number;
        /**
         * Starting source port, ranging from 0 to 65535.
         */
        sportStart: number;
        /**
         * Detection value, key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
         */
        str?: string;
        /**
         * key string or regular expression, value [When the detection type is Sunday, please fill in the string or hexadecimal bytecode, for example, x313233 corresponds to the hexadecimal word&gt;section code of the string &#39;123&#39;; when the detection type is pcre, please fill in the regular expression character string;].
         */
        str2?: string;
    }

    export interface PortAclConfigAclConfig {
        /**
         * Action, can take values: drop, transmit, forward.
         */
        action: string;
        /**
         * end from port, with a range of 0~65535 values.
         */
        dPortEnd: number;
        /**
         * Starting from port, with a range of 0~65535 values.
         */
        dPortStart: number;
        /**
         * Protocol type, can take TCP, udp, all values.
         */
        forwardProtocol: string;
        /**
         * The policy priority, the smaller the number, the higher the level, and the higher the matching of the rule, with values ranging from 1 to 1000. Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        priority?: number;
        /**
         * end from the source port, with a value range of 0~65535.
         */
        sPortEnd: number;
        /**
         * Starting from the source port, with a value range of 0~65535.
         */
        sPortStart: number;
    }

}

export namespace ApiGateway {
    export interface ApiConstantParameter {
        /**
         * Default value for constant parameters. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        defaultValue?: string;
        /**
         * Constant parameter description. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        desc?: string;
        /**
         * Constant parameter name. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        name?: string;
        /**
         * Constant parameter position. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        position?: string;
    }

    export interface ApiMicroService {
        /**
         * Micro service cluster.
         */
        clusterId: string;
        /**
         * Microservice name.
         */
        microServiceName: string;
        /**
         * Microservice namespace.
         */
        namespaceId: string;
    }

    export interface ApiOauthConfig {
        /**
         * Redirect address, used to guide users in login operations.
         */
        loginRedirectUrl?: string;
        /**
         * Public key, used to verify user tokens.
         */
        publicKey: string;
        /**
         * Token passes the position.
         */
        tokenLocation: string;
    }

    export interface ApiRequestParameter {
        /**
         * Parameter default value.
         */
        defaultValue?: string;
        /**
         * Parameter description.
         */
        desc?: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter location.
         */
        position: string;
        /**
         * If this parameter required. Default value: `false`.
         */
        required?: boolean;
        /**
         * Parameter type.
         */
        type: string;
    }

    export interface ApiResponseErrorCode {
        /**
         * Custom response configuration error code.
         */
        code: number;
        /**
         * Custom error code conversion.
         */
        convertedCode?: number;
        /**
         * Parameter description.
         */
        desc?: string;
        /**
         * Custom response configuration error message.
         */
        msg: string;
        /**
         * Whether to enable error code conversion. Default value: `false`.
         */
        needConvert?: boolean;
    }

    export interface ApiServiceConfigCosConfig {
        /**
         * The API calls the backend COS method, and the optional values for the front-end request method and Action are:GET: GetObjectPUT: PutObjectPOST: PostObject, AppendObjectHEAD: HeadObjectDELETE: DeleteObject.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        action: string;
        /**
         * The API calls the signature switch of the backend COS, which defaults to false.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        authorization?: boolean;
        /**
         * The bucket name of the API backend COS.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        bucketName: string;
        /**
         * Path matching mode for API backend COS, optional values:BackEndPath: Backend path matchingFullPath: Full Path MatchingThe default value is: BackEndPathNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        pathMatchMode?: string;
    }

    export interface ApiServiceParameter {
        /**
         * The default value for the backend service parameters of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        defaultValue?: string;
        /**
         * The backend service parameter name of the API. This parameter is only used when ServiceType is HTTP. The front and rear parameter names can be different.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        name?: string;
        /**
         * The backend service parameter location of the API, such as head. This parameter is only used when ServiceType is HTTP. The parameter positions at the front and rear ends can be configured differently.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        position?: string;
        /**
         * Remarks on the backend service parameters of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterDesc?: string;
        /**
         * The name of the front-end parameter corresponding to the backend service parameter of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterName?: string;
        /**
         * The location of the front-end parameters corresponding to the backend service parameters of the API, such as head. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterPosition?: string;
        /**
         * The backend service parameter type of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterType?: string;
    }

    export interface ApiServiceTsfHealthCheckConf {
        /**
         * Threshold percentage.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        errorThresholdPercentage?: number;
        /**
         * Whether to initiate a health check.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        isHealthCheck?: boolean;
        /**
         * Health check threshold.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        requestVolumeThreshold?: number;
        /**
         * Window size.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        sleepWindowInMilliseconds?: number;
    }

    export interface ApiServiceTsfLoadBalanceConf {
        /**
         * Is load balancing enabled.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        isLoadBalance?: boolean;
        /**
         * Load balancing method.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        method?: string;
        /**
         * Whether to enable session persistence.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        sessionStickRequired?: boolean;
        /**
         * Session hold timeout.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        sessionStickTimeout?: number;
    }

    export interface ApiTargetService {
        /**
         * docker ip.
         */
        dockerIp?: string;
        /**
         * Host IP of the CVM.
         */
        hostIp: string;
        /**
         * vm ip.
         */
        vmIp: string;
        /**
         * vm port.
         */
        vmPort: number;
        /**
         * vpc id.
         */
        vpcId: string;
    }

    export interface ApiTargetServicesHealthCheckConf {
        /**
         * Threshold percentage.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        errorThresholdPercentage?: number;
        /**
         * Whether to initiate a health check.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        isHealthCheck?: boolean;
        /**
         * Health check threshold.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        requestVolumeThreshold?: number;
        /**
         * Window size.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        sleepWindowInMilliseconds?: number;
    }

    export interface GetApiAppApiResult {
        /**
         * Type of OAUTH API. Possible values are NORMAL (Business API), OAUTH (Authorization API).
         */
        apiBusinessType: string;
        /**
         * Description of the API interface.
         */
        apiDesc: string;
        /**
         * API interface unique ID.
         */
        apiId: string;
        /**
         * The name of the API interface.
         */
        apiName: string;
        /**
         * API type. Possible values are NORMAL (normal API) and TSF (microservice API).
         */
        apiType: string;
        /**
         * OAUTH The unique ID of the authorization API associated with the business API.
         */
        authRelationApiId: string;
        /**
         * API authentication type. Possible values are SECRET (key pair authentication), NONE (authentication-free), and OAUTH.
         */
        authType: string;
        /**
         * Header triggers rules, and the total number of rules does not exceed 10.
         */
        base64EncodedTriggerRules: outputs.ApiGateway.GetApiAppApiResultBase64EncodedTriggerRule[];
        /**
         * Constant parameters.
         */
        constantParameters: outputs.ApiGateway.GetApiAppApiResultConstantParameter[];
        /**
         * Creation time, expressed in accordance with the ISO8601 standard and using UTC time. The format is: YYYY-MM-DDThh:mm:ssZ.
         */
        createdTime: string;
        /**
         * Whether to enable cross-domain.
         */
        enableCors: boolean;
        /**
         * API published environment information.
         */
        environments: string[];
        /**
         * WEBSOCKET pushback address.
         */
        internalDomain: string;
        /**
         * Whether to enable Base64 encoding will only take effect when the backend is scf.
         */
        isBase64Encoded: boolean;
        /**
         * Whether to enable Base64-encoded header triggering will only take effect when the backend is scf.
         */
        isBase64Trigger: boolean;
        /**
         * Whether to debug after purchase (parameters reserved in the cloud market).
         */
        isDebugAfterCharge: boolean;
        /**
         * API binding microservice list.
         */
        microServices: outputs.ApiGateway.GetApiAppApiResultMicroService[];
        /**
         * Microservice information details.
         */
        microServicesInfos: number[];
        /**
         * Last modification time, expressed in accordance with the ISO8601 standard and using UTC time. The format is: YYYY-MM-DDThh:mm:ssZ.
         */
        modifiedTime: string;
        /**
         * OAUTH configuration.
         */
        oauthConfigs: outputs.ApiGateway.GetApiAppApiResultOauthConfig[];
        /**
         * The front-end request type of the API, such as HTTP or HTTPS or HTTP and HTTPS.
         */
        protocol: string;
        /**
         * The requested frontend configuration.
         */
        requestConfigs: outputs.ApiGateway.GetApiAppApiResultRequestConfig[];
        /**
         * Front-end request parameters.
         */
        requestParameters: outputs.ApiGateway.GetApiAppApiResultRequestParameter[];
        /**
         * User-defined error code configuration.
         */
        responseErrorCodes: outputs.ApiGateway.GetApiAppApiResultResponseErrorCode[];
        /**
         * Custom response configuration failure response example.
         */
        responseFailExample: string;
        /**
         * Custom response configuration successful response example.
         */
        responseSuccessExample: string;
        /**
         * Return type.
         */
        responseType: string;
        /**
         * Backend service configuration for the API.
         */
        serviceConfigs: outputs.ApiGateway.GetApiAppApiResultServiceConfig[];
        /**
         * A description of the service where the API resides.
         */
        serviceDesc: string;
        /**
         * The unique ID of the service where the API resides.
         */
        serviceId: string;
        /**
         * APIs backend Mock returns information. If ServiceType is Mock, this parameter must be passed.
         */
        serviceMockReturnMessage: string;
        /**
         * The name of the service where the API resides.
         */
        serviceName: string;
        /**
         * API backend service parameters.
         */
        serviceParameters: outputs.ApiGateway.GetApiAppApiResultServiceParameter[];
        /**
         * Scf function name. Effective when the backend type is SCF.
         */
        serviceScfFunctionName: string;
        /**
         * Scf function namespace. Effective when the backend type is SCF.
         */
        serviceScfFunctionNamespace: string;
        /**
         * Scf function version. Effective when the backend type is SCF.
         */
        serviceScfFunctionQualifier: string;
        /**
         * Whether to enable integrated response.
         */
        serviceScfIsIntegratedResponse: boolean;
        /**
         * The backend service timeout of the API, in seconds.
         */
        serviceTimeout: number;
        /**
         * Health check configuration for microservices.
         */
        serviceTsfHealthCheckConfs: outputs.ApiGateway.GetApiAppApiResultServiceTsfHealthCheckConf[];
        /**
         * Load balancing configuration for microservices.
         */
        serviceTsfLoadBalanceConfs: outputs.ApiGateway.GetApiAppApiResultServiceTsfLoadBalanceConf[];
        /**
         * The backend service type of the API. Possible values are HTTP, MOCK, TSF, CLB, SCF, WEBSOCKET, and TARGET (internal testing).
         */
        serviceType: string;
        /**
         * Scf websocket cleaning function. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketCleanupFunctionName: string;
        /**
         * Scf websocket cleanup function namespace. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketCleanupFunctionNamespace: string;
        /**
         * Scf websocket cleanup function version. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketCleanupFunctionQualifier: string;
        /**
         * Scf websocket registration function namespace. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketRegisterFunctionName: string;
        /**
         * Scf websocket registration function namespace. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketRegisterFunctionNamespace: string;
        /**
         * Scf websocket transfer function version. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketRegisterFunctionQualifier: string;
        /**
         * Scf websocket transfer function. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketTransportFunctionName: string;
        /**
         * Scf websocket transfer function namespace. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketTransportFunctionNamespace: string;
        /**
         * Scf websocket transfer function version. Valid when the front-end type is WEBSOCKET and the back-end type is SCF.
         */
        serviceWebsocketTransportFunctionQualifier: string;
        /**
         * API binding tag information.
         */
        tags: outputs.ApiGateway.GetApiAppApiResultTag[];
    }

    export interface GetApiAppApiResultBase64EncodedTriggerRule {
        /**
         * The backend service parameter name of the API. This parameter will be used only if the ServiceType is HTTP. The front-end and back-end parameter names can be different.
         */
        name: string;
        /**
         * The value of the note.
         */
        values: string[];
    }

    export interface GetApiAppApiResultConstantParameter {
        /**
         * Default values for the APIs backend service parameters. This parameter is only used if the ServiceType is HTTP.
         */
        defaultValue: string;
        /**
         * Custom response configuration error code remarks.
         */
        desc: string;
        /**
         * The backend service parameter name of the API. This parameter will be used only if the ServiceType is HTTP. The front-end and back-end parameter names can be different.
         */
        name: string;
        /**
         * The backend service parameter location of the API, such as head. This parameter is only used if the ServiceType is HTTP. The front-end and back-end parameter positions can be configured differently.
         */
        position: string;
    }

    export interface GetApiAppApiResultMicroService {
        /**
         * Microservice cluster ID.
         */
        clusterId: string;
        /**
         * Microservice name.
         */
        microServiceName: string;
        /**
         * Microservice namespace ID.
         */
        namespaceId: string;
    }

    export interface GetApiAppApiResultOauthConfig {
        /**
         * Redirect address, used to guide users to log in.
         */
        loginRedirectUrl: string;
        /**
         * Public key, used to verify user token.
         */
        publicKey: string;
        /**
         * Token delivery position.
         */
        tokenLocation: string;
    }

    export interface GetApiAppApiResultRequestConfig {
        /**
         * Load balancing method.
         */
        method: string;
        /**
         * API backend service path, such as /path. If ServiceType is HTTP, this parameter is required. The front-end and back-end paths can be different.
         */
        path: string;
    }

    export interface GetApiAppApiResultRequestParameter {
        /**
         * Default values for the APIs backend service parameters. This parameter is only used if the ServiceType is HTTP.
         */
        defaultValue: string;
        /**
         * Custom response configuration error code remarks.
         */
        desc: string;
        /**
         * The backend service parameter name of the API. This parameter will be used only if the ServiceType is HTTP. The front-end and back-end parameter names can be different.
         */
        name: string;
        /**
         * The backend service parameter location of the API, such as head. This parameter is only used if the ServiceType is HTTP. The front-end and back-end parameter positions can be configured differently.
         */
        position: string;
        /**
         * .
         */
        required: boolean;
        /**
         * API front-end parameter type, such as String, int.
         */
        type: string;
    }

    export interface GetApiAppApiResultResponseErrorCode {
        /**
         * Custom response configuration error code.
         */
        code: number;
        /**
         * Custom error code conversion.
         */
        convertedCode: number;
        /**
         * Custom response configuration error code remarks.
         */
        desc: string;
        /**
         * Custom response configuration error message.
         */
        msg: string;
        /**
         * Whether it is necessary to enable error code conversion.
         */
        needConvert: boolean;
    }

    export interface GetApiAppApiResultServiceConfig {
        /**
         * Load balancing method.
         */
        method: string;
        /**
         * API backend service path, such as /path. If ServiceType is HTTP, this parameter is required. The front-end and back-end paths can be different.
         */
        path: string;
        /**
         * Backend type. It takes effect when vpc is enabled. Currently supported types are clb, cvm and upstream.
         */
        product: string;
        /**
         * The unique ID of the vpc.
         */
        uniqVpcId: string;
        /**
         * Only required when binding vpc channel.
         */
        upstreamId: string;
        /**
         * API&amp;#39;s backend service url. If ServiceType is HTTP, this parameter must be passed.
         */
        url: string;
    }

    export interface GetApiAppApiResultServiceParameter {
        /**
         * Default values for the APIs backend service parameters. This parameter is only used if the ServiceType is HTTP.
         */
        defaultValue: string;
        /**
         * The backend service parameter name of the API. This parameter will be used only if the ServiceType is HTTP. The front-end and back-end parameter names can be different.
         */
        name: string;
        /**
         * The backend service parameter location of the API, such as head. This parameter is only used if the ServiceType is HTTP. The front-end and back-end parameter positions can be configured differently.
         */
        position: string;
        /**
         * Remarks on the backend service parameters of the API. This parameter is only used if the ServiceType is HTTP.
         */
        relevantRequestParameterDesc: string;
        /**
         * The front-end parameter name corresponding to the back-end service parameter of the API. This parameter is only used if the ServiceType is HTTP.
         */
        relevantRequestParameterName: string;
        /**
         * The front-end parameter position corresponding to the back-end service parameter of the API, such as head. This parameter is only used if the ServiceType is HTTP.
         */
        relevantRequestParameterPosition: string;
    }

    export interface GetApiAppApiResultServiceTsfHealthCheckConf {
        /**
         * Threshold percentage.
         */
        errorThresholdPercentage: number;
        /**
         * Whether to enable health check.
         */
        isHealthCheck: boolean;
        /**
         * Health check threshold.
         */
        requestVolumeThreshold: number;
        /**
         * Window size.
         */
        sleepWindowInMilliseconds: number;
    }

    export interface GetApiAppApiResultServiceTsfLoadBalanceConf {
        /**
         * Whether to enable load balancing.
         */
        isLoadBalance: boolean;
        /**
         * Load balancing method.
         */
        method: string;
        /**
         * Whether to enable session persistence.
         */
        sessionStickRequired: boolean;
        /**
         * Session retention timeout.
         */
        sessionStickTimeout: number;
    }

    export interface GetApiAppApiResultTag {
        /**
         * Key of the label.
         */
        key: string;
        /**
         * The value of the note.
         */
        value: string;
    }

    export interface GetApiAppServiceApiIdStatusSet {
        /**
         * API business type.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiBusinessType: string;
        /**
         * API DescriptionNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiDesc: string;
        /**
         * API unique ID.
         */
        apiId: string;
        /**
         * API name.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiName: string;
        /**
         * API type.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiType: string;
        /**
         * Unique ID of the association authorization API.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        authRelationApiId: string;
        /**
         * Authorization type.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        authType: string;
        /**
         * Use planned time.
         */
        createdTime: string;
        /**
         * Whether to debug after purchase.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        isDebugAfterCharge: boolean;
        /**
         * API METHOD.
         */
        method: string;
        /**
         * Use the schedule to modify the time.
         */
        modifiedTime: string;
        /**
         * OAuth configuration information.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        oauthConfigs: outputs.ApiGateway.GetApiAppServiceApiIdStatusSetOauthConfig[];
        /**
         * API PATH.
         */
        path: string;
        /**
         * Service support protocol, optional values are http, https, and http&amp;amp;https.
         */
        protocol: string;
        /**
         * The unique ID of the service to be queried.
         */
        serviceId: string;
        /**
         * OAuth2.0 API request, token storage location.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        tokenLocation: string;
        /**
         * VPC unique ID.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        uniqVpcId: string;
    }

    export interface GetApiAppServiceApiIdStatusSetOauthConfig {
        /**
         * Redirect address, used to guide users in login operations.
         */
        loginRedirectUrl: string;
        /**
         * Public key, used to verify user tokens.
         */
        publicKey: string;
        /**
         * OAuth2.0 API request, token storage location.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        tokenLocation: string;
    }

    export interface GetApiAppServiceUsagePlanList {
        /**
         * Use planned time.
         */
        createdTime: string;
        /**
         * Environment name.
         */
        environment: string;
        /**
         * Use plan qps, -1 indicates no restrictions.
         */
        maxRequestNumPreSec: number;
        /**
         * Use the schedule to modify the time.
         */
        modifiedTime: string;
        /**
         * Use plan description.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        usagePlanDesc: string;
        /**
         * Use a unique ID for the plan.
         */
        usagePlanId: string;
        /**
         * Use the plan name.
         */
        usagePlanName: string;
    }

    export interface GetApiAppsApiAppList {
        /**
         * ApiApp description.
         */
        apiAppDesc: string;
        /**
         * Api app ID.
         */
        apiAppId: string;
        /**
         * ApiApp key.
         */
        apiAppKey: string;
        /**
         * Api app name.
         */
        apiAppName: string;
        /**
         * ApiApp secret.
         */
        apiAppSecret: string;
        /**
         * ApiApp create time.
         */
        createdTime: string;
        /**
         * ApiApp modified time.
         */
        modifiedTime: string;
    }

    export interface GetApiDocsApiDocList {
        /**
         * Api Doc ID.
         */
        apiDocId: string;
        /**
         * Api Doc Name.
         */
        apiDocName: string;
        /**
         * Api Doc Status.
         */
        apiDocStatus: string;
    }

    export interface GetApiKeysList {
        /**
         * Created API key.
         */
        accessKeySecret: string;
        /**
         * Created API key ID, this field is exactly the same as ID.
         */
        apiKeyId: string;
        /**
         * Creation time in the format of `YYYY-MM-DDThh:mm:ssZ` according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * Last modified time in the format of `YYYY-MM-DDThh:mm:ssZ` according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * Key status. Values: `on`, `off`.
         */
        status: string;
    }

    export interface GetApiPluginsResult {
        /**
         * Binding time.
         */
        attachedTime: string;
        /**
         * Plugin description.
         */
        description: string;
        /**
         * Environment information.
         */
        environment: string;
        /**
         * Plug-in definition statement.
         */
        pluginData: string;
        /**
         * Plugin ID.
         */
        pluginId: string;
        /**
         * Plugin name.
         */
        pluginName: string;
        /**
         * Plugin type.
         */
        pluginType: string;
    }

    export interface GetApiUsagePlansResult {
        /**
         * API unique ID.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiId: string;
        /**
         * API name.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiName: string;
        /**
         * Create a time using a schedule.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        createdTime: string;
        /**
         * Use the service environment bound by the plan.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        environment: string;
        /**
         * The quota that has already been used.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        inUseRequestNum: number;
        /**
         * Request total quota, -1 indicates no limit.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        maxRequestNum: number;
        /**
         * Request QPS upper limit, -1 indicates no limit.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        maxRequestNumPreSec: number;
        /**
         * API method.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        method: string;
        /**
         * Use the last modification time of the plan.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        modifiedTime: string;
        /**
         * API path.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        path: string;
        /**
         * The unique ID of the service to be queried.
         */
        serviceId: string;
        /**
         * Service name.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        serviceName: string;
        /**
         * Description of the usage plan.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        usagePlanDesc: string;
        /**
         * Use the unique ID of the plan.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        usagePlanId: string;
        /**
         * Use the name of the plan.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        usagePlanName: string;
    }

    export interface GetApisList {
        /**
         * Custom API description.
         */
        apiDesc: string;
        /**
         * Custom API name.
         */
        apiName: string;
        /**
         * API authentication type. Valid values: `SECRET`, `NONE`. `SECRET` means key pair authentication, `NONE` means no authentication.
         */
        authType: string;
        /**
         * Creation time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * Whether to enable CORS.
         */
        enableCors: boolean;
        /**
         * Last modified time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * API frontend request type, such as `HTTP`,`WEBSOCKET`.
         */
        protocol: string;
        /**
         * Request frontend method configuration. Like `GET`,`POST`,`PUT`,`DELETE`,`HEAD`,`ANY`.
         */
        requestConfigMethod: string;
        /**
         * Request frontend path configuration. Like `/user/getinfo`.
         */
        requestConfigPath: string;
        /**
         * Frontend request parameters.
         */
        requestParameters: outputs.ApiGateway.GetApisListRequestParameter[];
        /**
         * Custom error code configuration. Must keep at least one after set.
         */
        responseErrorCodes: outputs.ApiGateway.GetApisListResponseErrorCode[];
        /**
         * Response failure sample of custom response configuration.
         */
        responseFailExample: string;
        /**
         * Successful response sample of custom response configuration.
         */
        responseSuccessExample: string;
        /**
         * Return type.
         */
        responseType: string;
        /**
         * API backend service request method, such as `GET`. If `serviceConfigType` is `HTTP`, this parameter will be required. The frontend `requestConfigMethod` and backend method `serviceConfigMethod` can be different.
         */
        serviceConfigMethod: string;
        /**
         * Returned information of API backend mocking.
         */
        serviceConfigMockReturnMessage: string;
        /**
         * API backend service path, such as /path. If `serviceConfigType` is `HTTP`, this parameter will be required. The frontend `requestConfigPath` and backend path `serviceConfigPath` can be different.
         */
        serviceConfigPath: string;
        /**
         * Backend type. This parameter takes effect when VPC is enabled. Currently, only `clb` is supported.
         */
        serviceConfigProduct: string;
        /**
         * SCF function name. This parameter takes effect when `serviceConfigType` is `SCF`.
         */
        serviceConfigScfFunctionName: string;
        /**
         * SCF function namespace. This parameter takes effect when  `serviceConfigType` is `SCF`.
         */
        serviceConfigScfFunctionNamespace: string;
        /**
         * SCF function version. This parameter takes effect when `serviceConfigType`  is `SCF`.
         */
        serviceConfigScfFunctionQualifier: string;
        /**
         * API backend service timeout period in seconds.
         */
        serviceConfigTimeout: number;
        /**
         * API backend service type.
         */
        serviceConfigType: string;
        /**
         * API backend service url. This parameter is required when `serviceConfigType` is `HTTP`.
         */
        serviceConfigUrl: string;
        /**
         * Unique VPC ID.
         */
        serviceConfigVpcId: string;
        /**
         * Service ID for query.
         */
        serviceId: string;
    }

    export interface GetApisListRequestParameter {
        /**
         * Parameter default value.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        desc: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter location.
         */
        position: string;
        /**
         * If this parameter required.
         */
        required: boolean;
        /**
         * Parameter type.
         */
        type: string;
    }

    export interface GetApisListResponseErrorCode {
        /**
         * Custom response configuration error code.
         */
        code: number;
        /**
         * Custom error code conversion.
         */
        convertedCode: number;
        /**
         * Parameter description.
         */
        desc: string;
        /**
         * Custom response configuration error message.
         */
        msg: string;
        /**
         * Whether to enable error code conversion. Default value: `false`.
         */
        needConvert: boolean;
    }

    export interface GetBindApiAppsStatusFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter value of the field.
         */
        values: string[];
    }

    export interface GetBindApiAppsStatusResult {
        /**
         * Application bound API information array.
         */
        apiAppApiSets: outputs.ApiGateway.GetBindApiAppsStatusResultApiAppApiSet[];
    }

    export interface GetBindApiAppsStatusResultApiAppApiSet {
        /**
         * Application ID.
         */
        apiAppId: string;
        /**
         * Application Name.
         */
        apiAppName: string;
        /**
         * API ID.
         */
        apiId: string;
        /**
         * API name.
         */
        apiName: string;
        /**
         * Apis region.
         */
        apiRegion: string;
        /**
         * Authorization binding time, expressed in accordance with the ISO8601 standard and using UTC time. The format is: YYYY-MM-DDThh:mm:ssZ.
         */
        authorizedTime: string;
        /**
         * Authorization binding environment.
         */
        environmentName: string;
        /**
         * Service ID.
         */
        serviceId: string;
    }

    export interface GetCustomerDomainsList {
        /**
         * The certificate ID.
         */
        certificateId: string;
        /**
         * Domain name.
         */
        domainName: string;
        /**
         * Whether to use default path mapping. Valid values: `true`, `false`. `true` means to use default path mapping, `false` means to use custom path mapping.
         */
        isDefaultMapping: boolean;
        /**
         * Domain name resolution status. Valid values: `true`, `false`. `true` means normal parsing, `false` means parsing failed.
         */
        isStatusOn: boolean;
        /**
         * Network type.
         */
        netType: string;
        /**
         * Domain name mapping path and environment list.
         */
        pathMappings: outputs.ApiGateway.GetCustomerDomainsListPathMapping[];
        /**
         * Custom domain name agreement type.
         */
        protocol: string;
    }

    export interface GetCustomerDomainsListPathMapping {
        /**
         * Release environment.
         */
        environment: string;
        /**
         * The domain mapping path.
         */
        path: string;
    }

    export interface GetIpStrategiesList {
        /**
         * List of bound API details.
         */
        attachLists: outputs.ApiGateway.GetIpStrategiesListAttachList[];
        /**
         * The number of API bound to the strategy.
         */
        bindApiTotalCount: number;
        /**
         * Creation time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * The list of IP.
         */
        ipList: string;
        /**
         * Last modified time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * The service ID to be queried.
         */
        serviceId: string;
        /**
         * The strategy ID.
         */
        strategyId: string;
        /**
         * Name of IP policy.
         */
        strategyName: string;
        /**
         * Type of the strategy.
         */
        strategyType: string;
    }

    export interface GetIpStrategiesListAttachList {
        /**
         * The type of oauth API. This field is valid when the `authType` is `OAUTH`, and the values are `NORMAL` (business API) and `OAUTH` (authorization API).
         */
        apiBusinessType: string;
        /**
         * API interface description.
         */
        apiDesc: string;
        /**
         * The API ID.
         */
        apiId: string;
        /**
         * API name.
         */
        apiName: string;
        /**
         * API type. Valid values: `NORMAL`, `TSF`. `NORMAL` means common API, `TSF` means microservice API.
         */
        apiType: string;
        /**
         * The unique ID of the associated authorization API, which takes effect when the authType is `OAUTH` and `ApiBusinessType` is normal. Identifies the unique ID of the oauth2.0 authorization API bound to the business API.
         */
        authRelationApiId: string;
        /**
         * API authentication type. Valid values: `SECRET`, `NONE`, `OAUTH`. `SECRET` means key pair authentication, `NONE` means no authentication.
         */
        authType: string;
        /**
         * Creation time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * API request method.
         */
        method: string;
        /**
         * Last modified time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * OAUTH configuration information. It takes effect when authType is `OAUTH`.
         */
        oauthConfig: {[key: string]: any};
        /**
         * API path.
         */
        path: string;
        /**
         * API protocol.
         */
        protocol: string;
        /**
         * List of business API associated with authorized API.
         */
        relationBusinessApiIds: string[];
        /**
         * The service ID to be queried.
         */
        serviceId: string;
        /**
         * The label information associated with the API.
         */
        tags: string[];
        /**
         * VPC unique ID.
         */
        uniqVpcId: string;
        /**
         * VPC ID.
         */
        vpcId: number;
    }

    export interface GetPluginsResult {
        /**
         * API ID.
         */
        apiId: string;
        /**
         * API name.
         */
        apiName: string;
        /**
         * API type.
         */
        apiType: string;
        /**
         * Whether the API is bound to other plugins.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        attachedOtherPlugin: boolean;
        /**
         * Whether the API is bound to the current plugin.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        isAttached: boolean;
        /**
         * API method.
         */
        method: string;
        /**
         * API path.
         */
        path: string;
    }

    export interface GetServiceEnvironmentListResult {
        /**
         * Environment name.
         */
        environmentName: string;
        /**
         * Release status, 1 means released, 0 means not released.
         */
        status: number;
        /**
         * Access path.
         */
        url: string;
        /**
         * Running version.
         */
        versionName: string;
    }

    export interface GetServiceReleaseVersionsResult {
        /**
         * Version description.Note: This field may return null, indicating that no valid value can be obtained.
         */
        versionDesc: string;
        /**
         * Version number.Note: This field may return null, indicating that no valid value can be obtained.
         */
        versionName: string;
    }

    export interface GetServicesList {
        /**
         * Creation time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * (**Deprecated**) It has been deprecated from version 1.81.9. Self-deployed cluster name, which is used to specify the self-deployed cluster where the service is to be created.
         *
         * @deprecated It has been deprecated from version 1.81.9.
         */
        exclusiveSetName: string;
        /**
         * Port number for http access over private network.
         */
        innerHttpPort: number;
        /**
         * Port number for https access over private network.
         */
        innerHttpsPort: number;
        /**
         * Private network access sub-domain name.
         */
        internalSubDomain: string;
        /**
         * IP version number.
         */
        ipVersion: string;
        /**
         * Last modified time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * Network type list, which is used to specify the supported network types. Valid values: `INNER`, `OUTER`. `INNER` indicates access over private network, and `OUTER` indicates access over public network.
         */
        netTypes: string[];
        /**
         * Public network access subdomain name.
         */
        outerSubDomain: string;
        /**
         * Service frontend request type. Valid values: `http`, `https`, `http&https`.
         */
        protocol: string;
        /**
         * Custom service description.
         */
        serviceDesc: string;
        /**
         * Service ID for query.
         */
        serviceId: string;
        /**
         * Service name for query.
         */
        serviceName: string;
        /**
         * A list of attach usage plans. Each element contains the following attributes:
         */
        usagePlanLists: outputs.ApiGateway.GetServicesListUsagePlanList[];
    }

    export interface GetServicesListUsagePlanList {
        /**
         * ID of the API.
         */
        apiId: string;
        /**
         * Binding type.
         */
        bindType: string;
        /**
         * ID of the usage plan.
         */
        usagePlanId: string;
        /**
         * Name of the usage plan.
         */
        usagePlanName: string;
    }

    export interface GetThrottlingApisList {
        /**
         * List of throttling policies bound to API.
         */
        apiEnvironmentStrategies: outputs.ApiGateway.GetThrottlingApisListApiEnvironmentStrategy[];
        /**
         * Unique service ID of API.
         */
        serviceId: string;
    }

    export interface GetThrottlingApisListApiEnvironmentStrategy {
        /**
         * Unique API ID.
         */
        apiId: string;
        /**
         * Custom API name.
         */
        apiName: string;
        /**
         * API method.
         */
        method: string;
        /**
         * API path.
         */
        path: string;
        /**
         * Environment throttling information.
         */
        strategyLists: outputs.ApiGateway.GetThrottlingApisListApiEnvironmentStrategyStrategyList[];
    }

    export interface GetThrottlingApisListApiEnvironmentStrategyStrategyList {
        /**
         * Environment name.
         */
        environmentName: string;
        /**
         * Throttling value.
         */
        quota: number;
    }

    export interface GetThrottlingServicesList {
        /**
         * A list of Throttling policy.
         */
        environments: outputs.ApiGateway.GetThrottlingServicesListEnvironment[];
        /**
         * Service ID for query.
         */
        serviceId: string;
    }

    export interface GetThrottlingServicesListEnvironment {
        /**
         * Environment name.
         */
        environmentName: string;
        /**
         * Release status.
         */
        status: number;
        /**
         * Throttling value.
         */
        strategy: number;
        /**
         * Access service environment URL.
         */
        url: string;
        /**
         * Published version number.
         */
        versionName: string;
    }

    export interface GetUpstreamsFilter {
        /**
         * Fields that need to be filtered.
         */
        name: string;
        /**
         * The filtering value of the field.
         */
        values: string[];
    }

    export interface GetUpstreamsResult {
        /**
         * API Unique ID.
         */
        apiId: string;
        /**
         * API nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiName: string;
        /**
         * binding time.
         */
        bindTime: string;
        /**
         * Service Unique ID.
         */
        serviceId: string;
        /**
         * Service NameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        serviceName: string;
    }

    export interface GetUsagePlanEnvironmentsList {
        /**
         * The API ID, this value is empty if attach service.
         */
        apiId: string;
        /**
         * The API name, this value is empty if attach service.
         */
        apiName: string;
        /**
         * Creation time in the format of `YYYY-MM-DDThh:mm:ssZ` according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * The environment name.
         */
        environment: string;
        /**
         * The API method, this value is empty if attach service.
         */
        method: string;
        /**
         * Last modified time in the format of `YYYY-MM-DDThh:mm:ssZ` according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * The API path, this value is empty if attach service.
         */
        path: string;
        /**
         * The service ID.
         */
        serviceId: string;
        /**
         * The service name.
         */
        serviceName: string;
    }

    export interface GetUsagePlansList {
        /**
         * Creation time in the format of `YYYY-MM-DDThh:mm:ssZ` according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * Total number of requests allowed. Valid value formats: `-1`, `[1,99999999]`. The default value is -1, which indicates no limit.
         */
        maxRequestNum: number;
        /**
         * Limit of requests per second. Valid values formats: `-1`, `[1,2000]`. The default value is -1, which indicates no limit.
         */
        maxRequestNumPreSec: number;
        /**
         * Last modified time in the format of `YYYY-MM-DDThh:mm:ssZ` according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * Custom usage plan description.
         */
        usagePlanDesc: string;
        /**
         * ID of the usage plan.
         */
        usagePlanId: string;
        /**
         * Name of the usage plan.
         */
        usagePlanName: string;
    }

    export interface ImportOpenApiConstantParameter {
        /**
         * The default value for the backend service parameters of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        desc: string;
        /**
         * The backend service parameter name of the API. This parameter is only used when ServiceType is HTTP. The front and rear parameter names can be different.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        name: string;
        /**
         * The backend service parameter location of the API, such as head. This parameter is only used when ServiceType is HTTP. The parameter positions at the front and rear ends can be configured differently.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        position: string;
    }

    export interface ImportOpenApiMicroService {
        /**
         * Micro service cluster.
         */
        clusterId: string;
        /**
         * Microservice name.
         */
        microServiceName: string;
        /**
         * Microservice namespace.
         */
        namespaceId: string;
    }

    export interface ImportOpenApiOauthConfig {
        /**
         * Redirect address, used to guide users in login operations.
         */
        loginRedirectUrl: string;
        /**
         * Public key, used to verify user tokens.
         */
        publicKey: string;
        /**
         * Token passes the position.
         */
        tokenLocation: string;
    }

    export interface ImportOpenApiRequestParameter {
        /**
         * The default value for the backend service parameters of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        desc: string;
        /**
         * The backend service parameter name of the API. This parameter is only used when ServiceType is HTTP. The front and rear parameter names can be different.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        name: string;
        /**
         * The backend service parameter location of the API, such as head. This parameter is only used when ServiceType is HTTP. The parameter positions at the front and rear ends can be configured differently.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        position: string;
        /**
         * If this parameter required. Default value: `false`.
         */
        required: boolean;
        /**
         * Parameter type.
         */
        type: string;
    }

    export interface ImportOpenApiResponseErrorCode {
        /**
         * Custom response configuration error code.
         */
        code: number;
        /**
         * Custom error code conversion.
         */
        convertedCode: number;
        /**
         * Parameter description.
         */
        desc: string;
        /**
         * Custom response configuration error message.
         */
        msg: string;
        /**
         * Whether to enable error code conversion. Default value: `false`.
         */
        needConvert: boolean;
    }

    export interface ImportOpenApiServiceConfigCosConfig {
        /**
         * The API calls the backend COS method, and the optional values for the front-end request method and Action are:GET: GetObjectPUT: PutObjectPOST: PostObject, AppendObjectHEAD: HeadObjectDELETE: DeleteObject.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        action: string;
        /**
         * The API calls the signature switch of the backend COS, which defaults to false.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        authorization: boolean;
        /**
         * The bucket name of the API backend COS.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        bucketName: string;
        /**
         * Path matching mode for API backend COS, optional values:BackEndPath: Backend path matchingFullPath: Full Path MatchingThe default value is: BackEndPathNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        pathMatchMode: string;
    }

    export interface ImportOpenApiServiceParameter {
        /**
         * The default value for the backend service parameters of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        defaultValue: string;
        /**
         * The backend service parameter name of the API. This parameter is only used when ServiceType is HTTP. The front and rear parameter names can be different.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        name: string;
        /**
         * The backend service parameter location of the API, such as head. This parameter is only used when ServiceType is HTTP. The parameter positions at the front and rear ends can be configured differently.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        position: string;
        /**
         * Remarks on the backend service parameters of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterDesc: string;
        /**
         * The name of the front-end parameter corresponding to the backend service parameter of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterName: string;
        /**
         * The location of the front-end parameters corresponding to the backend service parameters of the API, such as head. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterPosition: string;
        /**
         * The backend service parameter type of the API. This parameter is only used when ServiceType is HTTP.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        relevantRequestParameterType: string;
    }

    export interface ImportOpenApiServiceTsfHealthCheckConf {
        /**
         * Threshold percentage.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        errorThresholdPercentage: number;
        /**
         * Whether to initiate a health check.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        isHealthCheck: boolean;
        /**
         * Health check threshold.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        requestVolumeThreshold: number;
        /**
         * Window size.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        sleepWindowInMilliseconds: number;
    }

    export interface ImportOpenApiServiceTsfLoadBalanceConf {
        /**
         * Is load balancing enabled.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        isLoadBalance: boolean;
        /**
         * Load balancing method.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        method: string;
        /**
         * Whether to enable session persistence.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        sessionStickRequired: boolean;
        /**
         * Session hold timeout.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        sessionStickTimeout: number;
    }

    export interface ServiceApiList {
        /**
         * Description of the API.
         */
        apiDesc: string;
        /**
         * ID of the API.
         */
        apiId: string;
        /**
         * Name of the API.
         */
        apiName: string;
        /**
         * Method of the API.
         */
        method: string;
        /**
         * Path of the API.
         */
        path: string;
    }

    export interface ServiceUsagePlanList {
        /**
         * ID of the API.
         */
        apiId: string;
        /**
         * Binding type.
         */
        bindType: string;
        /**
         * ID of the usage plan.
         */
        usagePlanId: string;
        /**
         * Name of the usage plan.
         */
        usagePlanName: string;
    }

    export interface UpstreamHealthChecker {
        /**
         * Detect the requested path during active health checks. The default is&#39;/&#39;.
         */
        activeCheckHttpPath?: string;
        /**
         * The time interval for active health checks is 5 seconds by default.
         */
        activeCheckInterval?: number;
        /**
         * The detection request for active health check timed out in seconds. The default is 5 seconds.
         */
        activeCheckTimeout?: number;
        /**
         * Identify whether active health checks are enabled.
         */
        enableActiveCheck: boolean;
        /**
         * Identify whether passive health checks are enabled.
         */
        enablePassiveCheck: boolean;
        /**
         * The HTTP status code that determines a successful request during a health check.
         */
        healthyHttpStatus: string;
        /**
         * HTTP continuous error threshold. 0 means HTTP checking is disabled. Value range: [0, 254].
         */
        httpFailureThreshold: number;
        /**
         * TCP continuous error threshold. 0 indicates disabling TCP checking. Value range: [0, 254].
         */
        tcpFailureThreshold: number;
        /**
         * Continuous timeout threshold. 0 indicates disabling timeout checking. Value range: [0, 254].
         */
        timeoutThreshold: number;
        /**
         * The HTTP status code that determines a failed request during a health check.
         */
        unhealthyHttpStatus: string;
        /**
         * The automatic recovery time of abnormal node status, in seconds. When only passive checking is enabled, it must be set to a value&gt;0, otherwise the passive exception node will not be able to recover. The default is 30 seconds.
         *
         * The `k8sService` object supports the following:
         */
        unhealthyTimeout?: number;
    }

    export interface UpstreamK8sService {
        /**
         * K8s cluster ID.
         */
        clusterId: string;
        /**
         * Additional Selected Pod Label.
         */
        extraLabels: outputs.ApiGateway.UpstreamK8sServiceExtraLabel[];
        /**
         * Customized service name, optional.
         */
        name?: string;
        /**
         * Container namespace.
         */
        namespace: string;
        /**
         * Port of service.
         */
        port: number;
        /**
         * The name of the container service.
         */
        serviceName: string;
        /**
         * weight.
         */
        weight: number;
    }

    export interface UpstreamK8sServiceExtraLabel {
        /**
         * Key of Label.
         */
        key: string;
        /**
         * Value of Label.
         */
        value: string;
    }

    export interface UpstreamNode {
        /**
         * The ID of the TKE clusterNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        clusterId?: string;
        /**
         * IP or domain name.
         */
        host: string;
        /**
         * K8S namespaceNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        nameSpace?: string;
        /**
         * Port [0, 65535].
         */
        port: number;
        /**
         * K8S container service nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        serviceName?: string;
        /**
         * Source of Node, value range: K8SNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        source?: string;
        /**
         * Dye labelNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        tags?: string[];
        /**
         * Unique service name recorded internally by API gatewayNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        uniqueServiceName?: string;
        /**
         * CVM instance IDNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        vmInstanceId?: string;
        /**
         * Weight [0, 100], 0 is disabled.
         */
        weight: number;
    }

    export interface UsagePlanAttachList {
        /**
         * The API ID, this value is empty if attach service.
         */
        apiId: string;
        /**
         * The API name, this value is empty if attach service.
         */
        apiName: string;
        /**
         * Creation time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        createTime: string;
        /**
         * The environment name.
         */
        environment: string;
        /**
         * The API method, this value is empty if attach service.
         */
        method: string;
        /**
         * Last modified time in the format of YYYY-MM-DDThh:mm:ssZ according to ISO 8601 standard. UTC time is used.
         */
        modifyTime: string;
        /**
         * The API path, this value is empty if attach service.
         */
        path: string;
        /**
         * The service ID.
         */
        serviceId: string;
        /**
         * The service name.
         */
        serviceName: string;
    }

}

export namespace As {
    export interface GetAdvicesAutoScalingAdviceSet {
        /**
         * A collection of suggestions for scaling group configurations.
         */
        advices: outputs.As.GetAdvicesAutoScalingAdviceSetAdvice[];
        /**
         * Auto scaling group ID.
         */
        autoScalingGroupId: string;
        /**
         * Scaling group warning level. Valid values: NORMAL, WARNING, CRITICAL.
         */
        level: string;
    }

    export interface GetAdvicesAutoScalingAdviceSetAdvice {
        /**
         * Problem Details.
         */
        detail: string;
        /**
         * Problem Description.
         */
        problem: string;
        /**
         * Recommended resolutions.
         */
        solution: string;
    }

    export interface GetInstancesFilter {
        /**
         * Fields to be filtered. Valid names: `instance-id`: Filters by instance ID, `auto-scaling-group-id`: Filter by scaling group ID.
         */
        name: string;
        /**
         * Value of the field.
         */
        values: string[];
    }

    export interface GetInstancesInstanceList {
        /**
         * The time when the instance joined the group.
         */
        addTime: string;
        /**
         * Auto scaling group ID.
         */
        autoScalingGroupId: string;
        /**
         * Auto scaling group name.
         */
        autoScalingGroupName: string;
        /**
         * Valid values: `AUTO_CREATION`, `MANUAL_ATTACHING`.
         */
        creationType: string;
        /**
         * Health status, the valid values are HEALTHY and UNHEALTHY.
         */
        healthStatus: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Launch configuration ID.
         */
        launchConfigurationId: string;
        /**
         * Launch configuration name.
         */
        launchConfigurationName: string;
        /**
         * Life cycle state. Please refer to the link for field value details: https://cloud.tencent.com/document/api/377/20453#Instance.
         */
        lifeCycleState: string;
        /**
         * Enable scale in protection.
         */
        protectedFromScaleIn: boolean;
        /**
         * Version ID.
         */
        versionNumber: number;
        /**
         * Available zone.
         */
        zone: string;
    }

    export interface GetLastActivityActivitySet {
        /**
         * Scaling activity ID.
         */
        activityId: string;
        /**
         * Information set of the instances related to the scaling activity.
         */
        activityRelatedInstanceSets: outputs.As.GetLastActivityActivitySetActivityRelatedInstanceSet[];
        /**
         * Type of the scaling activity. Value range: SCALE_OUT, SCALE_IN, ATTACH_INSTANCES, REMOVE_INSTANCES, DETACH_INSTANCES, TERMINATE_INSTANCES_UNEXPECTEDLY, REPLACE_UNHEALTHY_INSTANCE, START_INSTANCES, STOP_INSTANCES, INVOKE_COMMAND.
         */
        activityType: string;
        /**
         * Auto scaling group ID.
         */
        autoScalingGroupId: string;
        /**
         * Cause of the scaling activity.
         */
        cause: string;
        /**
         * Creation time of the scaling activity.
         */
        createdTime: string;
        /**
         * Description of the scaling activity.
         */
        description: string;
        /**
         * Detailed description of scaling activity status.
         */
        detailedStatusMessageSets: outputs.As.GetLastActivityActivitySetDetailedStatusMessageSet[];
        /**
         * End time of the scaling activity.
         */
        endTime: string;
        /**
         * Result of the command execution.
         */
        invocationResultSets: outputs.As.GetLastActivityActivitySetInvocationResultSet[];
        /**
         * Result of the lifecycle hook action in the scaling activity.
         */
        lifecycleActionResultSets: outputs.As.GetLastActivityActivitySetLifecycleActionResultSet[];
        /**
         * Start time of the scaling activity.
         */
        startTime: string;
        /**
         * Scaling activity status. Value range: INIT, RUNNING, SUCCESSFUL, PARTIALLY_SUCCESSFUL, FAILED, CANCELLED.
         */
        statusCode: string;
        /**
         * Description of the scaling activity status.
         */
        statusMessage: string;
        /**
         * Brief description of the scaling activity status.
         */
        statusMessageSimplified: string;
    }

    export interface GetLastActivityActivitySetActivityRelatedInstanceSet {
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * Status of the instance in the scaling activity. Value range: INIT, RUNNING, SUCCESSFUL, FAILED.
         */
        instanceStatus: string;
    }

    export interface GetLastActivityActivitySetDetailedStatusMessageSet {
        /**
         * Error type.
         */
        code: string;
        /**
         * Instance billing mode.
         */
        instanceChargeType: string;
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Error message.
         */
        message: string;
        /**
         * Subnet ID.
         */
        subnetId: string;
        /**
         * AZ information.
         */
        zone: string;
    }

    export interface GetLastActivityActivitySetInvocationResultSet {
        /**
         * Command ID. Note: This field may return null, indicating that no valid values can be obtained.
         */
        commandId: string;
        /**
         * Execution exception information. Note: This field may return null, indicating that no valid values can be obtained.
         */
        errorMessage: string;
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * Execution task ID. You can query the result by using the DescribeInvocations API of TAT.
         */
        invocationId: string;
        /**
         * Execution task ID. Note: This field may return null, indicating that no valid values can be obtained.
         */
        invocationTaskId: string;
        /**
         * Execution Status. Note: This field may return null, indicating that no valid values can be obtained.
         */
        taskStatus: string;
    }

    export interface GetLastActivityActivitySetLifecycleActionResultSet {
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * Execution task ID. You can query the result by using the DescribeInvocations API of TAT.
         */
        invocationId: string;
        /**
         * Result of command invocation, value range: SUCCESSFUL, FAILED, NONE.
         */
        invokeCommandResult: string;
        /**
         * Result of the lifecycle hook action, value range: CONTINUE, ABANDON.
         */
        lifecycleActionResult: string;
        /**
         * ID of the lifecycle hook.
         */
        lifecycleHookId: string;
        /**
         * Notification result, which indicates whether it is successful to notify CMQ/TDMQ, value range: SUCCESSFUL, FAILED, NONE.
         */
        notificationResult: string;
        /**
         * Reason of the result, value range: HEARTBEAT_TIMEOUT: Heartbeat timed out. The setting of DefaultResult is used. NOTIFICATION_FAILURE: Failed to send the notification. The setting of DefaultResult is used. CALL_INTERFACE: Calls the CompleteLifecycleAction to set the result ANOTHER_ACTION_ABANDON: It has been set to ABANDON by another operation. COMMAND_CALL_FAILURE: Failed to call the command. The DefaultResult is applied. COMMAND_EXEC_FINISH: Command completed COMMAND_CALL_FAILURE: Failed to execute the command. The DefaultResult is applied. COMMAND_EXEC_RESULT_CHECK_FAILURE: Failed to check the command result. The DefaultResult is applied.
         */
        resultReason: string;
    }

    export interface GetScalingConfigsConfigurationList {
        /**
         * Launch configuration ID.
         */
        configurationId: string;
        /**
         * Launch configuration name.
         */
        configurationName: string;
        /**
         * The time when the launch configuration was created.
         */
        createTime: string;
        /**
         * Configurations of data disk.
         */
        dataDisks: outputs.As.GetScalingConfigsConfigurationListDataDisk[];
        /**
         * Policy of cloud disk type.
         */
        diskTypePolicy: string;
        /**
         * Whether to activate cloud monitor service.
         */
        enhancedMonitorService: boolean;
        /**
         * Whether to activate cloud security service.
         */
        enhancedSecurityService: boolean;
        /**
         * ID of available image, for example `img-8toqc6s3`.
         */
        imageId: string;
        /**
         * A tag list associates with an instance.
         */
        instanceTags: {[key: string]: any};
        /**
         * Instance type list of the scaling configuration.
         */
        instanceTypes: string[];
        /**
         * Charge types for network traffic.
         */
        internetChargeType: string;
        /**
         * Max bandwidth of Internet access in Mbps.
         */
        internetMaxBandwidthOut: number;
        /**
         * ID list of login keys.
         */
        keyIds: string[];
        /**
         * ID of the project to which the configuration belongs. Default value is 0.
         */
        projectId: number;
        /**
         * Specify whether to assign an Internet IP address.
         */
        publicIpAssigned: boolean;
        /**
         * Security groups to which the instance belongs.
         */
        securityGroupIds: string[];
        /**
         * Current status of a launch configuration.
         */
        status: string;
        /**
         * System disk size of the scaling configuration in GB.
         */
        systemDiskSize: number;
        /**
         * System disk category of the scaling configuration.
         */
        systemDiskType: string;
        /**
         * Base64-encoded User Data text.
         */
        userData: string;
    }

    export interface GetScalingConfigsConfigurationListDataDisk {
        /**
         * Indicates whether the disk remove after instance terminated.
         */
        deleteWithInstance: boolean;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize: number;
        /**
         * Type of disk.
         */
        diskType: string;
        /**
         * Data disk snapshot ID.
         */
        snapshotId: string;
    }

    export interface GetScalingGroupsScalingGroupList {
        /**
         * Filter results by launch configuration ID.
         */
        configurationId: string;
        /**
         * The time when the AS group was created.
         */
        createTime: string;
        /**
         * Default cooldown time of scaling group.
         */
        defaultCooldown: number;
        /**
         * The desired number of CVM instances.
         */
        desiredCapacity: number;
        /**
         * A list of application clb ids.
         */
        forwardBalancerIds: outputs.As.GetScalingGroupsScalingGroupListForwardBalancerId[];
        /**
         * Number of instance.
         */
        instanceCount: number;
        /**
         * A list of traditional clb ids which the CVM instances attached to.
         */
        loadBalancerIds: string[];
        /**
         * The maximum number of CVM instances.
         */
        maxSize: number;
        /**
         * The minimum number of CVM instances.
         */
        minSize: number;
        /**
         * Multi zone or subnet strategy, Valid values: PRIORITY and EQUALITY.
         */
        multiZoneSubnetPolicy: string;
        /**
         * ID of the project to which the scaling group belongs. Default value is 0.
         */
        projectId: number;
        /**
         * A retry policy can be used when a creation fails.
         */
        retryPolicy: string;
        /**
         * A specified scaling group ID used to query.
         */
        scalingGroupId: string;
        /**
         * A scaling group name used to query.
         */
        scalingGroupName: string;
        /**
         * Current status of a scaling group.
         */
        status: string;
        /**
         * A list of subnet IDs.
         */
        subnetIds: string[];
        /**
         * Tags used to query.
         */
        tags: {[key: string]: any};
        /**
         * A policy used to select a CVM instance to be terminated from the scaling group.
         */
        terminationPolicies: string[];
        /**
         * ID of the vpc with which the instance is associated.
         */
        vpcId: string;
        /**
         * A list of available zones.
         */
        zones: string[];
    }

    export interface GetScalingGroupsScalingGroupListForwardBalancerId {
        /**
         * Listener ID for application load balancers.
         */
        listenerId: string;
        /**
         * ID of available load balancers.
         */
        loadBalancerId: string;
        /**
         * ID of forwarding rules.
         */
        locationId: string;
        /**
         * Attribute list of target rules.
         */
        targetAttributes: outputs.As.GetScalingGroupsScalingGroupListForwardBalancerIdTargetAttribute[];
    }

    export interface GetScalingGroupsScalingGroupListForwardBalancerIdTargetAttribute {
        /**
         * Port number.
         */
        port: number;
        /**
         * Weight.
         */
        weight: number;
    }

    export interface GetScalingPoliciesScalingPolicyList {
        /**
         * Adjustment type of the scaling rule.
         */
        adjustmentType: string;
        /**
         * Adjustment value of the scaling rule.
         */
        adjustmentValue: number;
        /**
         * Comparison operator.
         */
        comparisonOperator: string;
        /**
         * Retry times.
         */
        continuousTime: number;
        /**
         * Cool down time of the scaling rule.
         */
        cooldown: number;
        /**
         * Name of an indicator.
         */
        metricName: string;
        /**
         * Users need to be notified when an alarm is triggered.
         */
        notificationUserGroupIds: string[];
        /**
         * Time period in second.
         */
        period: number;
        /**
         * Scaling policy name.
         */
        policyName: string;
        /**
         * Scaling group ID.
         */
        scalingGroupId: string;
        /**
         * Statistic types.
         */
        statistic: string;
        /**
         * Alarm threshold.
         */
        threshold: number;
    }

    export interface LoadBalancerForwardLoadBalancer {
        /**
         * Application load balancer listener ID.
         */
        listenerId: string;
        /**
         * Application load balancer instance ID.
         */
        loadBalancerId: string;
        /**
         * Application load balancer location ID.
         */
        locationId?: string;
        /**
         * Load balancer instance region. Default value is the region of current auto scaling group. The format is the same as the public parameter Region, for example: ap-guangzhou.
         */
        region?: string;
        /**
         * List of TargetAttribute.
         */
        targetAttributes: outputs.As.LoadBalancerForwardLoadBalancerTargetAttribute[];
    }

    export interface LoadBalancerForwardLoadBalancerTargetAttribute {
        /**
         * Target port.
         */
        port: number;
        /**
         * Target weight.
         */
        weight: number;
    }

    export interface ScalingConfigDataDisk {
        /**
         * Indicates whether the disk remove after instance terminated. Default is `false`.
         */
        deleteWithInstance?: boolean;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk. Valid values: `CLOUD_PREMIUM` and `CLOUD_SSD`. valid when diskTypePolicy is ORIGINAL.
         */
        diskType?: string;
        /**
         * Data disk snapshot ID.
         */
        snapshotId?: string;
    }

    export interface ScalingConfigHostNameSettings {
        /**
         * The host name of the cloud server; dots (.) and dashes (-) cannot be used as the first and last characters of HostName, and cannot be used consecutively; Windows instances are not supported; other types (Linux, etc.) instances: the character length is [2, 40], it is allowed to support multiple dots, and there is a paragraph between the dots, and each paragraph is allowed to consist of letters (no uppercase and lowercase restrictions), numbers and dashes (-). Pure numbers are not allowed.
         */
        hostName: string;
        /**
         * The style of the host name of the cloud server, the value range includes `ORIGINAL` and `UNIQUE`, the default is `ORIGINAL`; `ORIGINAL`, the AS directly passes the HostName filled in the input parameter to the CVM, and the CVM may append a sequence to the HostName number, the HostName of the instance in the scaling group will conflict; `UNIQUE`, the HostName filled in as a parameter is equivalent to the host name prefix, AS and CVM will expand it, and the HostName of the instance in the scaling group can be guaranteed to be unique.
         */
        hostNameStyle?: string;
    }

    export interface ScalingConfigInstanceNameSettings {
        /**
         * CVM instance name.
         */
        instanceName: string;
        /**
         * Type of CVM instance name. Valid values: `ORIGINAL` and `UNIQUE`. Default is `ORIGINAL`.
         */
        instanceNameStyle?: string;
    }

    export interface ScalingGroupForwardBalancerId {
        /**
         * Listener ID for application load balancers.
         */
        listenerId: string;
        /**
         * ID of available load balancers.
         */
        loadBalancerId: string;
        /**
         * ID of forwarding rules.
         */
        ruleId?: string;
        /**
         * Attribute list of target rules.
         */
        targetAttributes: outputs.As.ScalingGroupForwardBalancerIdTargetAttribute[];
    }

    export interface ScalingGroupForwardBalancerIdTargetAttribute {
        /**
         * Port number.
         */
        port: number;
        /**
         * Weight.
         */
        weight: number;
    }

}

export namespace Audit {
    export interface GetCosRegionsAuditCosRegionList {
        /**
         * Cos region.
         */
        cosRegion: string;
        /**
         * Cos region chinese name.
         */
        cosRegionName: string;
    }

    export interface GetKeyAliasAuditKeyAliasList {
        /**
         * Key alias.
         */
        keyAlias: string;
        /**
         * Key ID.
         */
        keyId: string;
    }

    export interface TrackStorage {
        /**
         * Track Storage name:- when StorageType is `cls`, StorageName is cls topicId- when StorageType is `cos`, StorageName is cos bucket name that does not contain `-APPID`.
         */
        storageName: string;
        /**
         * Storage path prefix.
         */
        storagePrefix: string;
        /**
         * Storage region.
         */
        storageRegion: string;
        /**
         * Track Storage type, optional:- `cos`- `cls`.
         */
        storageType: string;
    }

}

export namespace Audits {
    export interface GetInstanceAuditList {
        /**
         * Indicate whether audit start logging or not.
         */
        auditSwitch: boolean;
        /**
         * Cos bucket name where audit save logs.
         */
        cosBucket: string;
        /**
         * ID of the audit.
         */
        id: string;
        /**
         * Prefix of the log file of the audit.
         */
        logFilePrefix: string;
        /**
         * Name of the audits.
         */
        name: string;
    }

}

export namespace Availability {
    export interface GetRegionsRegion {
        /**
         * The description of the region, like `Guangzhou Region`.
         */
        description: string;
        /**
         * When specified, only the region with the exactly name match will be returned. `default` value means it consistent with the provider region.
         */
        name: string;
        /**
         * The state of the region, indicate availability using `AVAILABLE` and `UNAVAILABLE` values.
         */
        state: string;
    }

    export interface GetZonesByProductZone {
        /**
         * The description of the zone, like `Guangzhou Zone 3`.
         */
        description: string;
        /**
         * An internal id for the zone, like `200003`, usually not so useful.
         */
        id: string;
        /**
         * When specified, only the zone with the exactly name match will be returned.
         */
        name: string;
        /**
         * The state of the zone, indicate availability using `AVAILABLE` and `UNAVAILABLE` values.
         */
        state: string;
    }

}

export namespace Bi {
    export interface DatasourceCloudServiceType {
        /**
         * Instance Id.
         */
        instanceId: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Service type, Cloud.
         */
        type: string;
    }

    export interface GetProjectList {
        /**
         * Apply(Note: This field may return null, indicating that no valid value can be obtained).
         */
        apply: boolean;
        /**
         * List of permissions within the project(Note: This field may return null, indicating that no valid value can be obtained).
         */
        authLists: string[];
        /**
         * Logo colour(Note: This field may return null, indicating that no valid value can be obtained).
         */
        colorCode: string;
        /**
         * Customized parameters, this parameter can be ignored(Note: This field may return null, indicating that no valid value can be obtained).
         */
        configLists: outputs.Bi.GetProjectListConfigList[];
        /**
         * Enterprise id(Note: This field may return null, indicating that no valid value can be obtained).
         */
        corpId: string;
        /**
         * Created at(Note: This field may return null, indicating that no valid value can be obtained).
         */
        createdAt: string;
        /**
         * Created by(Note: This field may return null, indicating that no valid value can be obtained).
         */
        createdUser: string;
        /**
         * Project id.
         */
        id: number;
        /**
         * Determine whether it is hosted(Note: This field may return null, indicating that no valid value can be obtained).
         */
        isExternalManage: boolean;
        /**
         * Last modified report and presentation names(Note: This field may return null, indicating that no valid value can be obtained).
         */
        lastModifyName: string;
        /**
         * Project logo(Note: This field may return null, indicating that no valid value can be obtained).
         */
        logo: string;
        /**
         * Hosting platform name(Note: This field may return null, indicating that no valid value can be obtained).
         */
        managePlatform: string;
        /**
         * Remark(Note: This field may return null, indicating that no valid value can be obtained).
         */
        mark: string;
        /**
         * Member count(Note: This field may return null, indicating that no valid value can be obtained).
         */
        memberCount: number;
        /**
         * Project name(Note: This field may return null, indicating that no valid value can be obtained).
         */
        name: string;
        /**
         * Page count(Note: This field may return null, indicating that no valid value can be obtained).
         */
        pageCount: number;
        /**
         * Default kanban(Note: This field may return null, indicating that no valid value can be obtained).
         */
        panelScope: string;
        /**
         * Obfuscated field(Note: This field may return null, indicating that no valid value can be obtained).
         */
        seed: string;
        /**
         * Interface call source(Note: This field may return null, indicating that no valid value can be obtained).
         */
        source: string;
        /**
         * Updated by(Note: This field may return null, indicating that no valid value can be obtained).
         */
        updatedAt: string;
        /**
         * Updated by(Note: This field may return null, indicating that no valid value can be obtained).
         */
        updatedUser: string;
    }

    export interface GetProjectListConfigList {
        /**
         * Components(Note: This field may return null, indicating that no valid value can be obtained).
         */
        components: outputs.Bi.GetProjectListConfigListComponent[];
        /**
         * Module group(Note: This field may return null, indicating that no valid value can be obtained).
         */
        moduleGroup: string;
    }

    export interface GetProjectListConfigListComponent {
        /**
         * Include type(Note: This field may return null, indicating that no valid value can be obtained).
         */
        includeType: string;
        /**
         * Module id(Note: This field may return null, indicating that no valid value can be obtained).
         */
        moduleId: string;
        /**
         * Extra parameters(Note: This field may return null, indicating that no valid value can be obtained).
         */
        params: string;
    }

    export interface GetUserProjectList {
        /**
         * Mobile area code(Note: This field may return null, indicating that no valid value can be obtained).
         */
        areaCode: string;
        /**
         * Enterprise id(Note: This field may return null, indicating that no valid value can be obtained).
         */
        corpId: string;
        /**
         * Created at(Note: This field may return null, indicating that no valid value can be obtained).
         */
        createdAt: string;
        /**
         * Created by(Note: This field may return null, indicating that no valid value can be obtained).
         */
        createdUser: string;
        /**
         * E-mail(Note: This field may return null, indicating that no valid value can be obtained).
         */
        email: string;
        /**
         * First login to change password, public cloud unrelated fields(Note: This field may return null, indicating that no valid value can be obtained).
         */
        firstModify: number;
        /**
         * Global role name(Note: This field may return null, indicating that no valid value can be obtained).
         */
        globalUserName: string;
        /**
         * Last login time, public cloud unrelated fields(Note: This field may return null, indicating that no valid value can be obtained).
         */
        lastLogin: string;
        /**
         * Mobile number, public cloud unrelated fields(Note: This field may return null, indicating that no valid value can be obtained).
         */
        mobile: string;
        /**
         * Phone number(Note: This field may return null, indicating that no valid value can be obtained).
         */
        phoneNumber: string;
        /**
         * Disabled state(Note: This field may return null, indicating that no valid value can be obtained).
         */
        status: number;
        /**
         * Updated at(Note: This field may return null, indicating that no valid value can be obtained).
         */
        updatedAt: string;
        /**
         * Updated by(Note: This field may return null, indicating that no valid value can be obtained).
         */
        updatedUser: string;
        /**
         * User id.
         */
        userId: string;
        /**
         * Username.
         */
        userName: string;
    }

}

export namespace Cam {
    export interface GetGroupMembershipsMembershipList {
        /**
         * ID of CAM group to be queried.
         */
        groupId: string;
        /**
         * (**Deprecated**) It has been deprecated from version 1.59.5. Use `userNames` instead. ID set of the CAM group members.
         *
         * @deprecated It has been deprecated from version 1.59.5. Use `userNames` instead.
         */
        userIds: string[];
        /**
         * ID set of the CAM group members.
         */
        userNames: string[];
    }

    export interface GetGroupPolicyAttachmentsGroupPolicyAttachmentList {
        /**
         * Mode of creation of the CAM user policy attachment. 1 means the cam policy attachment is created by production, and the others indicate syntax strategy ways.
         */
        createMode: number;
        /**
         * Create time of the CAM group policy attachment.
         */
        createTime: string;
        /**
         * ID of the attached CAM group to be queried.
         */
        groupId: string;
        /**
         * ID of CAM policy to be queried.
         */
        policyId: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Type of the policy strategy. 'User' means customer strategy and 'QCS' means preset strategy.
         */
        policyType: string;
    }

    export interface GetGroupUserAccountGroupInfo {
        /**
         * Create time.
         */
        createTime: string;
        /**
         * User group ID.
         */
        groupId: number;
        /**
         * User group name.
         */
        groupName: string;
        /**
         * Remark.
         */
        remark: string;
    }

    export interface GetGroupsGroupList {
        /**
         * Create time of the CAM group.
         */
        createTime: string;
        /**
         * ID of CAM group to be queried.
         */
        groupId: string;
        /**
         * Name of the CAM group to be queried.
         */
        name: string;
        /**
         * Description of the cam group to be queried.
         */
        remark: string;
    }

    export interface GetListAttachedUserPolicyPolicyList {
        /**
         * Creation time.
         */
        addTime: string;
        /**
         * Creation mode (1 represents policies created by product or project permissions, others represent policies created by policy syntax).
         */
        createMode: string;
        /**
         * Has it been taken offline (0: No 1: Yes)Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        deactived: number;
        /**
         * List of offline productsNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        deactivedDetails: string[];
        /**
         * Policy Description.
         */
        description: string;
        /**
         * Associated information with groupNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        groups: outputs.Cam.GetListAttachedUserPolicyPolicyListGroup[];
        /**
         * Policy ID.
         */
        policyId: string;
        /**
         * Policy Name.
         */
        policyName: string;
        /**
         * Policy type (1 represents custom policy, 2 represents preset policy).
         */
        strategyType: string;
    }

    export interface GetListAttachedUserPolicyPolicyListGroup {
        /**
         * Group ID.
         */
        groupId: number;
        /**
         * Group Name.
         */
        groupName: string;
    }

    export interface GetListEntitiesForPolicyList {
        /**
         * Policy association timeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        attachmentTime: string;
        /**
         * Entity ID.
         */
        id: string;
        /**
         * Entity NameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        name: string;
        /**
         * Association type. 1. User association; 2 User Group Association.
         */
        relatedType: number;
        /**
         * Entity UinNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        uin: number;
    }

    export interface GetPoliciesPolicyList {
        /**
         * Number of attached users.
         */
        attachments: number;
        /**
         * Mode of creation of policy strategy. Valid values: `1`, `2`. `1` means policy was created with console, and `2` means it was created by strategies.
         */
        createMode: number;
        /**
         * Create time of the CAM policy.
         */
        createTime: string;
        /**
         * The description of the CAM policy.
         */
        description: string;
        /**
         * Name of the CAM policy to be queried.
         */
        name: string;
        /**
         * ID of CAM policy to be queried.
         */
        policyId: string;
        /**
         * Name of attached products.
         */
        serviceType: string;
        /**
         * Type of the policy strategy. Valid values: `1`, `2`. `1` means customer strategy and `2` means preset strategy.
         */
        type: number;
    }

    export interface GetPolicyGrantingServiceAccessList {
        /**
         * Action list.
         */
        actions: outputs.Cam.GetPolicyGrantingServiceAccessListAction[];
        /**
         * Policy list.
         */
        policies: outputs.Cam.GetPolicyGrantingServiceAccessListPolicy[];
        /**
         * Service info.
         */
        services: outputs.Cam.GetPolicyGrantingServiceAccessListService[];
    }

    export interface GetPolicyGrantingServiceAccessListAction {
        /**
         * Action description.
         */
        description: string;
        /**
         * Action name.
         */
        name: string;
    }

    export interface GetPolicyGrantingServiceAccessListPolicy {
        /**
         * Policy description.
         */
        policyDescription: string;
        /**
         * Policy Id.
         */
        policyId: string;
        /**
         * Policy name.
         */
        policyName: string;
        /**
         * Polic type.
         */
        policyType: string;
    }

    export interface GetPolicyGrantingServiceAccessListService {
        /**
         * Service name.
         */
        serviceName: string;
        /**
         * Service type, this field needs to be passed when viewing the details of the service authorization interface.
         */
        serviceType: string;
    }

    export interface GetRolePolicyAttachmentsRolePolicyAttachmentList {
        /**
         * Mode of Creation of the CAM user policy attachment. `1` means the cam policy attachment is created by production, and the others indicate syntax strategy ways.
         */
        createMode: number;
        /**
         * Create time of the CAM role policy attachment.
         */
        createTime: string;
        /**
         * ID of CAM policy to be queried.
         */
        policyId: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Type of the policy strategy. Valid values are 'User', 'QCS'. 'User' means customer strategy and 'QCS' means preset strategy.
         */
        policyType: string;
        /**
         * ID of the attached CAM role to be queried.
         */
        roleId: string;
    }

    export interface GetRolesRoleList {
        /**
         * Indicate whether the CAM role can be login or not.
         */
        consoleLogin: boolean;
        /**
         * The create time of the CAM role.
         */
        createTime: string;
        /**
         * The description of the CAM role to be queried.
         */
        description: string;
        /**
         * Policy document of CAM role.
         */
        document: string;
        /**
         * Name of the CAM policy to be queried.
         */
        name: string;
        /**
         * ID of the CAM role to be queried.
         */
        roleId: string;
        /**
         * The last update time of the CAM role.
         */
        updateTime: string;
    }

    export interface GetSamlProvidersProviderList {
        /**
         * Create time of the CAM SAML provider.
         */
        createTime: string;
        /**
         * The description of the CAM SAML provider.
         */
        description: string;
        /**
         * The last modify time of the CAM SAML provider.
         */
        modifyTime: string;
        /**
         * Name of the CAM SAML provider to be queried.
         */
        name: string;
    }

    export interface GetSecretLastUsedTimeSecretIdLastUsedRow {
        /**
         * Last used timestamp.
         */
        lastSecretUsedDate: number;
        /**
         * Last used date (with 1 day delay).
         */
        lastUsedDate: string;
        /**
         * Secret Id.
         */
        secretId: string;
    }

    export interface GetUserPolicyAttachmentsUserPolicyAttachmentList {
        /**
         * Mode of Creation of the CAM user policy attachment. `1` means the CAM policy attachment is created by production, and the others indicate syntax strategy ways.
         */
        createMode: number;
        /**
         * The create time of the CAM user policy attachment.
         */
        createTime: string;
        /**
         * ID of CAM policy to be queried.
         */
        policyId: string;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * Type of the policy strategy. 'User' means customer strategy and 'QCS' means preset strategy.
         */
        policyType: string;
        /**
         * It has been deprecated from version 1.59.6. Use `userName` instead. ID of the attached CAM user to be queried.
         *
         * @deprecated It has been deprecated from version 1.59.6. Use `userName` instead.
         */
        userId: string;
        /**
         * Name of the attached CAM user as unique key to be queried.
         */
        userName: string;
    }

    export interface GetUsersUserList {
        /**
         * Indicate whether the user can login in.
         */
        consoleLogin?: boolean;
        /**
         * Country code of the CAM user to be queried.
         */
        countryCode: string;
        /**
         * Email of the CAM user to be queried.
         */
        email: string;
        /**
         * Name of CAM user to be queried.
         */
        name: string;
        /**
         * Phone num of the CAM user to be queried.
         */
        phoneNum: string;
        /**
         * Remark of the CAM user to be queried.
         */
        remark: string;
        /**
         * Uid of the CAM user to be queried.
         */
        uid: number;
        /**
         * Uin of the CAM user to be queried.
         */
        uin: number;
        /**
         * ID of CAM user. Its value equals to `name` argument.
         */
        userId: string;
    }

    export interface MfaFlagActionFlag {
        /**
         * Phone.
         */
        phone?: number;
        /**
         * Soft token.
         */
        stoken?: number;
        /**
         * Wechat.
         */
        wechat?: number;
    }

    export interface MfaFlagLoginFlag {
        /**
         * Phone.
         */
        phone?: number;
        /**
         * Soft token.
         */
        stoken?: number;
        /**
         * Wechat.
         */
        wechat?: number;
    }

    export interface PolicyVersionPolicyVersion {
        /**
         * Strategic version creation timeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        createDate: string;
        /**
         * Strategic grammar textNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        document: string;
        /**
         * Whether it is an effective version.0 means not, 1 means yesNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        isDefaultVersion: number;
        /**
         * Strategic version numberNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        versionId: number;
    }

    export interface TagRoleAttachmentTag {
        /**
         * Label.
         */
        key: string;
        /**
         * Label.
         */
        value: string;
    }

}

export namespace Cat {
    export interface GetNodeNodeDefine {
        /**
         * City.
         */
        city: string;
        /**
         * Node ID.
         */
        code: string;
        /**
         * If the node type is base, it is an availability dial test point; if it is blank, it is an advanced dial test point.
         */
        codeType: string;
        /**
         * District.
         */
        district: string;
        /**
         * IP type:1 = IPv4,2 = IPv6.
         */
        ipType: number;
        /**
         * Node area:1=Chinese Mainland,2=Hong Kong, Macao and Taiwan,3=Overseas.
         */
        location: number;
        /**
         * Node name.
         */
        name: string;
        /**
         * Network service provider.
         */
        netService: string;
        /**
         * Node status: 1=running, 2=offline.
         */
        nodeDefineStatus: number;
        /**
         * The task types supported by the node. `1`: page performance, `2`: file upload, `3`: file download, `4`: port performance, `5`: network quality, `6`: audio and video experience.
         */
        taskTypes: number[];
        /**
         * Node Type;1 = IDC,2 = LastMile,3 = Mobile.
         */
        type: number;
    }

    export interface GetProbeDataDetailedSingleDataDefine {
        /**
         * Fields.
         */
        fields: outputs.Cat.GetProbeDataDetailedSingleDataDefineField[];
        /**
         * Labels.
         */
        labels: outputs.Cat.GetProbeDataDetailedSingleDataDefineLabel[];
        /**
         * Probe time.
         */
        probeTime: number;
    }

    export interface GetProbeDataDetailedSingleDataDefineField {
        /**
         * ID.
         */
        id: number;
        /**
         * Custom Field Name/Description.
         */
        name: string;
        /**
         * Value.
         */
        value: number;
    }

    export interface GetProbeDataDetailedSingleDataDefineLabel {
        /**
         * ID.
         */
        id: number;
        /**
         * Custom Field Name/Description.
         */
        name: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface TaskSetBatchTasks {
        /**
         * Task name.
         */
        name: string;
        /**
         * Target address.
         */
        targetAddress: string;
    }

}

export namespace Cbs {
    export interface GetSnapshotPoliciesSnapshotPolicyList {
        /**
         * Storage IDs that the snapshot policy attached.
         */
        attachedStorageIds: string[];
        /**
         * Create time of the snapshot policy.
         */
        createTime: string;
        /**
         * Trigger hours of periodic snapshot.
         */
        repeatHours: number[];
        /**
         * Trigger days of periodic snapshot.
         */
        repeatWeekdays: number[];
        /**
         * Retention days of the snapshot.
         */
        retentionDays: number;
        /**
         * ID of the snapshot policy to be queried.
         */
        snapshotPolicyId: string;
        /**
         * Name of the snapshot policy to be queried.
         */
        snapshotPolicyName: string;
        /**
         * Status of the snapshot policy.
         */
        status: string;
    }

    export interface GetSnapshotsSnapshotList {
        /**
         * The available zone that the CBS instance locates at.
         */
        availabilityZone: string;
        /**
         * Creation time of snapshot.
         */
        createTime: string;
        /**
         * Indicates whether the snapshot is encrypted.
         */
        encrypt: boolean;
        /**
         * Snapshot creation progress percentage.
         */
        percent: number;
        /**
         * ID of the project within the snapshot.
         */
        projectId: number;
        /**
         * ID of the snapshot to be queried.
         */
        snapshotId: string;
        /**
         * Name of the snapshot to be queried.
         */
        snapshotName: string;
        /**
         * ID of the the CBS which this snapshot created from.
         */
        storageId: string;
        /**
         * Volume of storage which this snapshot created from.
         */
        storageSize: number;
        /**
         * Types of CBS which this snapshot created from, and available values include SYSTEM_DISK and DATA_DISK.
         */
        storageUsage: string;
    }

    export interface GetStoragesSetStorageList {
        /**
         * Indicates whether the CBS is mounted the CVM.
         */
        attached: boolean;
        /**
         * The available zone that the CBS instance locates at.
         */
        availabilityZone: string;
        /**
         * List filter by disk charge type (`POSTPAID_BY_HOUR` | `PREPAID`).
         */
        chargeType: string;
        /**
         * Creation time of CBS.
         */
        createTime: string;
        /**
         * Indicates whether CBS is encrypted.
         */
        encrypt: boolean;
        /**
         * ID of the CVM instance that be mounted by this CBS.
         */
        instanceId: string;
        /**
         * The way that CBS instance will be renew automatically or not when it reach the end of the prepaid tenancy.
         */
        prepaidRenewFlag: string;
        /**
         * ID of the project with which the CBS is associated.
         */
        projectId: number;
        /**
         * Status of CBS.
         */
        status: string;
        /**
         * ID of the CBS to be queried.
         */
        storageId: string;
        /**
         * Name of the CBS to be queried.
         */
        storageName: string;
        /**
         * Volume of CBS.
         */
        storageSize: number;
        /**
         * Filter by cloud disk media type (`CLOUD_BASIC`: HDD cloud disk | `CLOUD_PREMIUM`: Premium Cloud Storage | `CLOUD_SSD`: SSD cloud disk).
         */
        storageType: string;
        /**
         * Filter by cloud disk type (`SYSTEM_DISK`: system disk | `DATA_DISK`: data disk).
         */
        storageUsage: string;
        /**
         * The available tags within this CBS.
         */
        tags: {[key: string]: any};
        /**
         * Add extra performance to the data disk. Only works when disk type is `CLOUD_TSSD` or `CLOUD_HSSD`.
         */
        throughputPerformance: number;
    }

    export interface GetStoragesStorageList {
        /**
         * Indicates whether the CBS is mounted the CVM.
         */
        attached: boolean;
        /**
         * The available zone that the CBS instance locates at.
         */
        availabilityZone: string;
        /**
         * List filter by disk charge type (`POSTPAID_BY_HOUR` | `PREPAID`).
         */
        chargeType: string;
        /**
         * Creation time of CBS.
         */
        createTime: string;
        /**
         * Indicates whether CBS is encrypted.
         */
        encrypt: boolean;
        /**
         * ID of the CVM instance that be mounted by this CBS.
         */
        instanceId: string;
        /**
         * The way that CBS instance will be renew automatically or not when it reach the end of the prepaid tenancy.
         */
        prepaidRenewFlag: string;
        /**
         * ID of the project with which the CBS is associated.
         */
        projectId: number;
        /**
         * Status of CBS.
         */
        status: string;
        /**
         * ID of the CBS to be queried.
         */
        storageId: string;
        /**
         * Name of the CBS to be queried.
         */
        storageName: string;
        /**
         * Volume of CBS.
         */
        storageSize: number;
        /**
         * Filter by cloud disk media type (`CLOUD_BASIC`: HDD cloud disk | `CLOUD_PREMIUM`: Premium Cloud Storage | `CLOUD_SSD`: SSD cloud disk).
         */
        storageType: string;
        /**
         * Filter by cloud disk type (`SYSTEM_DISK`: system disk | `DATA_DISK`: data disk).
         */
        storageUsage: string;
        /**
         * The available tags within this CBS.
         */
        tags: {[key: string]: any};
        /**
         * Add extra performance to the data disk. Only works when disk type is `CLOUD_TSSD` or `CLOUD_HSSD`.
         */
        throughputPerformance: number;
    }

}

export namespace Ccn {
    export interface GetBandwidthLimitsLimit {
        /**
         * Limitation of bandwidth.
         */
        bandwidthLimit: number;
        /**
         * Destination area restriction.
         */
        dstRegion: string;
        /**
         * Limitation of region.
         */
        region: string;
    }

    export interface GetCrossBorderFlowMonitorCrossBorderFlowMonitorData {
        /**
         * in bandwidth, `bps`.
         */
        inBandwidths: number[];
        /**
         * in pkg, `pps`.
         */
        inPkgs: number[];
        /**
         * out bandwidth, `bps`.
         */
        outBandwidths: number[];
        /**
         * out pkg, `pps`.
         */
        outPkgs: number[];
    }

    export interface GetCrossBorderRegionBandwidthLimitsCcnBandwidthSet {
        /**
         * ccn id.
         */
        ccnId: string;
        /**
         * bandwidth limit of cross region.
         */
        ccnRegionBandwidthLimits: outputs.Ccn.GetCrossBorderRegionBandwidthLimitsCcnBandwidthSetCcnRegionBandwidthLimit[];
        /**
         * create time.
         */
        createdTime: string;
        /**
         * expired time.
         */
        expiredTime: string;
        /**
         * `POSTPAID` or `PREPAID`.
         */
        instanceChargeType: string;
        /**
         * if cross region.
         */
        isCrossBorder: boolean;
        /**
         * `true` means locked.
         */
        isSecurityLock: boolean;
        /**
         * market id.
         */
        marketId: string;
        /**
         * Id of RegionFlowControl.
         */
        regionFlowControlId: string;
        /**
         * renew flag.
         */
        renewFlag: string;
        /**
         * update time.
         */
        updateTime: string;
        /**
         * user account id.
         */
        userAccountId: string;
    }

    export interface GetCrossBorderRegionBandwidthLimitsCcnBandwidthSetCcnRegionBandwidthLimit {
        /**
         * bandwidth list(Mbps).
         */
        bandwidthLimit: number;
        /**
         * destination region, such as.
         */
        destinationRegion: string;
        /**
         * source region, such as &#39;ap-shanghai&#39;.
         */
        sourceRegion: string;
    }

    export interface GetCrossBorderRegionBandwidthLimitsFilter {
        /**
         * attribute name.
         */
        name: string;
        /**
         * Value of the field.
         */
        values: string[];
    }

    export interface GetInstancesInstanceList {
        /**
         * Information list of instance is attached.
         */
        attachmentLists: outputs.Ccn.GetInstancesInstanceListAttachmentList[];
        /**
         * The speed limit type.
         */
        bandwidthLimitType: string;
        /**
         * ID of the CCN to be queried.
         */
        ccnId: string;
        /**
         * Billing mode.
         */
        chargeType: string;
        /**
         * Creation time of resource.
         */
        createTime: string;
        /**
         * Description of the CCN.
         */
        description: string;
        /**
         * Name of the CCN to be queried.
         */
        name: string;
        /**
         * Service quality of CCN, and the available value include 'PT', 'AU', 'AG'. The default is 'AU'.
         */
        qos: string;
        /**
         * States of instance. The available value include 'ISOLATED'(arrears) and 'AVAILABLE'.
         */
        state: string;
    }

    export interface GetInstancesInstanceListAttachmentList {
        /**
         * Time of attaching.
         */
        attachedTime: string;
        /**
         * A network address block of the instance that is attached.
         */
        cidrBlocks: string[];
        /**
         * ID of instance is attached.
         */
        instanceId: string;
        /**
         * The region that the instance locates at.
         */
        instanceRegion: string;
        /**
         * Type of attached instance network, and available values include VPC, DIRECTCONNECT, BMVPC and VPNGW.
         */
        instanceType: string;
        /**
         * States of instance. The available value include 'ISOLATED'(arrears) and 'AVAILABLE'.
         */
        state: string;
    }

    export interface InstancesAcceptAttachInstance {
        /**
         * Description.
         */
        description?: string;
        /**
         * Attachment Instance ID.
         */
        instanceId: string;
        /**
         * Instance Region.
         */
        instanceRegion: string;
        /**
         * InstanceType: `VPC`, `DIRECTCONNECT`, `BMVPC`, `VPNGW`.
         */
        instanceType?: string;
        /**
         * ID of the routing table associated with the instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        routeTableId?: string;
    }

    export interface InstancesRejectAttachInstance {
        /**
         * Description.
         */
        description?: string;
        /**
         * Attachment Instance ID.
         */
        instanceId: string;
        /**
         * Instance Region.
         */
        instanceRegion: string;
        /**
         * InstanceType: `VPC`, `DIRECTCONNECT`, `BMVPC`, `VPNGW`.
         */
        instanceType?: string;
        /**
         * ID of the routing table associated with the instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        routeTableId?: string;
    }

    export interface InstancesResetAttachInstance {
        /**
         * Description.
         */
        description?: string;
        /**
         * Attachment Instance ID.
         */
        instanceId: string;
        /**
         * Instance Region.
         */
        instanceRegion: string;
        /**
         * InstanceType: `VPC`, `DIRECTCONNECT`, `BMVPC`, `VPNGW`.
         */
        instanceType?: string;
        /**
         * ID of the routing table associated with the instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        routeTableId?: string;
    }

}

export namespace Cdh {
    export interface GetInstancesCdhInstanceList {
        /**
         * The available zone that the CDH instance locates at.
         */
        availabilityZone: string;
        /**
         * Cage ID of the CDH instance. This parameter is only valid for CDH instances in the cages of finance availability zones.
         */
        cageId: string;
        /**
         * The charge type of the CDH instance.
         */
        chargeType: string;
        /**
         * Creation time of the CDH instance.
         */
        createTime: string;
        /**
         * Id of CVM instances that have been created on the CDH instance.
         */
        cvmInstanceIds: string[];
        /**
         * Expired time of the CDH instance.
         */
        expiredTime: string;
        /**
         * ID of the CDH instances to be queried.
         */
        hostId: string;
        /**
         * Name of the CDH instances to be queried.
         */
        hostName: string;
        /**
         * An information list of host resource. Each element contains the following attributes:
         */
        hostResources: outputs.Cdh.GetInstancesCdhInstanceListHostResource[];
        /**
         * State of the CDH instances to be queried. Valid values: `PENDING`, `LAUNCH_FAILURE`, `RUNNING`, `EXPIRED`.
         */
        hostState: string;
        /**
         * Type of the CDH instance.
         */
        hostType: string;
        /**
         * Auto renewal flag.
         */
        prepaidRenewFlag: string;
        /**
         * The project CDH belongs to.
         */
        projectId: number;
    }

    export interface GetInstancesCdhInstanceListHostResource {
        /**
         * The number of available CPU cores of the instance.
         */
        cpuAvailableNum: number;
        /**
         * The number of total CPU cores of the instance.
         */
        cpuTotalNum: number;
        /**
         * Instance disk available capacity, unit in GB.
         */
        diskAvailableSize: number;
        /**
         * Instance disk total capacity, unit in GB.
         */
        diskTotalSize: number;
        /**
         * Type of the disk.
         */
        diskType: string;
        /**
         * Instance memory available capacity, unit in GB.
         */
        memoryAvailableSize: number;
        /**
         * Instance memory total capacity, unit in GB.
         */
        memoryTotalSize: number;
    }

    export interface InstanceHostResource {
        /**
         * The number of available CPU cores of the instance.
         */
        cpuAvailableNum: number;
        /**
         * The number of total CPU cores of the instance.
         */
        cpuTotalNum: number;
        /**
         * Instance disk available capacity, unit in GB.
         */
        diskAvailableSize: number;
        /**
         * Instance disk total capacity, unit in GB.
         */
        diskTotalSize: number;
        /**
         * Type of the disk.
         */
        diskType: string;
        /**
         * Instance memory available capacity, unit in GB.
         */
        memoryAvailableSize: number;
        /**
         * Instance memory total capacity, unit in GB.
         */
        memoryTotalSize: number;
    }

}

export namespace Cdn {
    export interface DomainAuthentication {
        /**
         * Authentication switching, available values: `on`, `off`.
         */
        switch?: string;
        /**
         * Timestamp hotlink protection mode A configuration.
         */
        typeA?: outputs.Cdn.DomainAuthenticationTypeA;
        /**
         * Timestamp hotlink protection mode B configuration. NOTE: according to upgrading of TencentCloud Platform, TypeB is unavailable for now.
         */
        typeB?: outputs.Cdn.DomainAuthenticationTypeB;
        /**
         * Timestamp hotlink protection mode C configuration.
         */
        typeC?: outputs.Cdn.DomainAuthenticationTypeC;
        /**
         * Timestamp hotlink protection mode D configuration.
         */
        typeD?: outputs.Cdn.DomainAuthenticationTypeD;
    }

    export interface DomainAuthenticationTypeA {
        /**
         * Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
         */
        backupSecretKey?: string;
        /**
         * Signature expiration time in second. The maximum value is 630720000.
         */
        expireTime: number;
        /**
         * File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
         */
        fileExtensions: string[];
        /**
         * Available values: `whitelist` - all types apart from `fileExtensions` are authenticated, `blacklist`: - only the types in the `fileExtensions` are authenticated.
         */
        filterType: string;
        /**
         * The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
         */
        secretKey: string;
        /**
         * Signature parameter name. Only upper and lower-case letters, digits, and underscores (_) are allowed. It cannot start with a digit. Length limit: 1-100 characters.
         */
        signParam: string;
    }

    export interface DomainAuthenticationTypeB {
        /**
         * Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
         */
        backupSecretKey?: string;
        /**
         * Signature expiration time in second. The maximum value is 630720000.
         */
        expireTime: number;
        /**
         * File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
         */
        fileExtensions: string[];
        /**
         * Available values: `whitelist` - all types apart from `fileExtensions` are authenticated, `blacklist`: - only the types in the `fileExtensions` are authenticated.
         */
        filterType: string;
        /**
         * The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
         */
        secretKey: string;
    }

    export interface DomainAuthenticationTypeC {
        /**
         * Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
         */
        backupSecretKey?: string;
        /**
         * Signature expiration time in second. The maximum value is 630720000.
         */
        expireTime: number;
        /**
         * File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
         */
        fileExtensions: string[];
        /**
         * Available values: `whitelist` - all types apart from `fileExtensions` are authenticated, `blacklist`: - only the types in the `fileExtensions` are authenticated.
         */
        filterType: string;
        /**
         * The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
         */
        secretKey: string;
        /**
         * Timestamp formation, available values: `dec`, `hex`.
         */
        timeFormat?: string;
    }

    export interface DomainAuthenticationTypeD {
        /**
         * Used for calculate a signature. 6-32 characters. Only digits and letters are allowed.
         */
        backupSecretKey?: string;
        /**
         * Signature expiration time in second. The maximum value is 630720000.
         */
        expireTime: number;
        /**
         * File extension list settings determining if authentication should be performed. NOTE: If it contains an asterisk (*), this indicates all files.
         */
        fileExtensions: string[];
        /**
         * Available values: `whitelist` - all types apart from `fileExtensions` are authenticated, `blacklist`: - only the types in the `fileExtensions` are authenticated.
         */
        filterType: string;
        /**
         * The key for signature calculation. Only digits, upper and lower-case letters are allowed. Length limit: 6-32 characters.
         */
        secretKey: string;
        /**
         * Timestamp formation, available values: `dec`, `hex`.
         */
        timeFormat?: string;
        /**
         * Timestamp parameter name. Only upper and lower-case letters, digits, and underscores (_) are allowed. It cannot start with a digit. Length limit: 1-100 characters.
         */
        timeParam?: string;
    }

    export interface DomainAwsPrivateAccess {
        /**
         * Access ID.
         */
        accessKey?: string;
        /**
         * Bucket.
         */
        bucket?: string;
        /**
         * Region.
         */
        region?: string;
        /**
         * Key.
         */
        secretKey?: string;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainBandWidthAlert {
        /**
         * Alert percentage.
         */
        alertPercentage?: number;
        /**
         * Switch alert.
         */
        alertSwitch?: string;
        /**
         * threshold of bps.
         */
        bpsThreshold?: number;
        /**
         * Counter measure.
         */
        counterMeasure?: string;
        /**
         * Last trigger time.
         */
        lastTriggerTime: string;
        /**
         * Last trigger time of overseas.
         */
        lastTriggerTimeOverseas: string;
        /**
         * Metric.
         */
        metric?: string;
        /**
         * Specify statistic item configuration.
         */
        statisticItem?: outputs.Cdn.DomainBandWidthAlertStatisticItem;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainBandWidthAlertStatisticItem {
        /**
         * Alert percentage.
         */
        alertPercentage?: number;
        /**
         * Switch alert.
         */
        alertSwitch?: string;
        /**
         * threshold of bps.
         */
        bpsThreshold?: number;
        /**
         * Counter measure, values: `RETURN_404`, `RESOLVE_DNS_TO_ORIGIN`.
         */
        counterMeasure?: string;
        /**
         * Cycle of checking in minutes, values `60`, `1440`.
         */
        cycle?: number;
        /**
         * Metric.
         */
        metric?: string;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
        /**
         * Type of statistic item.
         */
        type?: string;
        /**
         * Time of auto unblock.
         */
        unblockTime?: number;
    }

    export interface DomainCacheKey {
        /**
         * Whether to enable full-path cache, values `on` (DEFAULT ON), `off`.
         */
        fullUrlCache?: string;
        /**
         * Specifies whether the cache key is case sensitive.
         */
        ignoreCase?: string;
        /**
         * Path-specific cache key configuration.
         */
        keyRules?: outputs.Cdn.DomainCacheKeyKeyRule[];
        /**
         * Request parameter contained in CacheKey.
         */
        queryString?: outputs.Cdn.DomainCacheKeyQueryString;
    }

    export interface DomainCacheKeyKeyRule {
        /**
         * Whether to enable full-path cache, values `on` (DEFAULT ON), `off`.
         */
        fullUrlCache?: string;
        /**
         * Whether caches are case insensitive.
         */
        ignoreCase?: string;
        /**
         * Request parameter contained in CacheKey.
         */
        queryString: outputs.Cdn.DomainCacheKeyKeyRuleQueryString;
        /**
         * List of rule paths for each `keyRules`: `/` for `index`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
         */
        rulePaths: string[];
        /**
         * Specify rule tag, default value is `user`.
         */
        ruleTag?: string;
        /**
         * Rule type, available: `file`, `directory`, `path`, `index`.
         */
        ruleType: string;
    }

    export interface DomainCacheKeyKeyRuleQueryString {
        /**
         * Specify key rule QS action, values: `includeCustom`, `excludeCustom`.
         */
        action?: string;
        /**
         * Whether to use QueryString as part of CacheKey, values `on`, `off` (Default).
         */
        switch?: string;
        /**
         * Array of included/excluded query strings (separated by `;`).
         */
        value?: string;
    }

    export interface DomainCacheKeyQueryString {
        /**
         * Specify key rule QS action, values: `includeCustom`, `excludeCustom`.
         */
        action: string;
        /**
         * Whether to sort again, values `on`, `off` (Default).
         */
        reorder?: string;
        /**
         * Whether to use QueryString as part of CacheKey, values `on`, `off` (Default).
         */
        switch?: string;
        /**
         * Array of included/excluded query strings (separated by `;`).
         */
        value?: string;
    }

    export interface DomainCompression {
        /**
         * List of compression rules.
         */
        compressionRules?: outputs.Cdn.DomainCompressionCompressionRule[];
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainCompressionCompressionRule {
        /**
         * List of algorithms, available: `gzip` and `brotli`.
         */
        algorithms: string[];
        /**
         * Must be set as true, enables compression.
         */
        compress: boolean;
        /**
         * List of file extensions like `jpg`, `txt`.
         */
        fileExtensions?: string[];
        /**
         * The maximum file size to trigger compression (in bytes).
         */
        maxLength: number;
        /**
         * The minimum file size to trigger compression (in bytes).
         */
        minLength: number;
        /**
         * List of rule paths for each `ruleType`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
         */
        rulePaths?: string[];
        /**
         * Rule type, available: `all`, `file`, `directory`, `path`, `contentType`.
         */
        ruleType?: string;
    }

    export interface DomainDownstreamCapping {
        /**
         * List of capping rule.
         */
        cappingRules?: outputs.Cdn.DomainDownstreamCappingCappingRule[];
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainDownstreamCappingCappingRule {
        /**
         * Capping rule kbps threshold.
         */
        kbpsThreshold: number;
        /**
         * List of capping rule path.
         */
        rulePaths: string[];
        /**
         * Capping rule type.
         */
        ruleType: string;
    }

    export interface DomainErrorPage {
        /**
         * List of error page rule.
         */
        pageRules?: outputs.Cdn.DomainErrorPagePageRule[];
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainErrorPagePageRule {
        /**
         * Redirect code of error page rules.
         */
        redirectCode: number;
        /**
         * Redirect url of error page rules.
         */
        redirectUrl: string;
        /**
         * Status code of error page rules.
         */
        statusCode: number;
    }

    export interface DomainHttpsConfig {
        /**
         * Client certificate configuration information.
         */
        clientCertificateConfig?: outputs.Cdn.DomainHttpsConfigClientCertificateConfig;
        /**
         * Configuration of forced HTTP or HTTPS redirects.
         */
        forceRedirect: outputs.Cdn.DomainHttpsConfigForceRedirect;
        /**
         * HTTP2 configuration switch. Valid values are `on` and `off`. and default value is `off`.
         */
        http2Switch?: string;
        /**
         * HTTPS configuration switch. Valid values are `on` and `off`.
         */
        httpsSwitch: string;
        /**
         * OCSP configuration switch. Valid values are `on` and `off`. and default value is `off`.
         */
        ocspStaplingSwitch?: string;
        /**
         * Server certificate configuration information.
         */
        serverCertificateConfig?: outputs.Cdn.DomainHttpsConfigServerCertificateConfig;
        /**
         * Spdy configuration switch. Valid values are `on` and `off`. and default value is `off`. This parameter is for white-list customer.
         */
        spdySwitch?: string;
        /**
         * Tls version settings, only support some Advanced domain names, support settings TLSv1, TLSV1.1, TLSV1.2, TLSv1.3, when modifying must open consecutive versions.
         */
        tlsVersions: string[];
        /**
         * Client certificate authentication feature. Valid values are `on` and `off`. and default value is `off`.
         */
        verifyClient?: string;
    }

    export interface DomainHttpsConfigClientCertificateConfig {
        /**
         * Client Certificate PEM format, requires Base64 encoding.
         */
        certificateContent: string;
        /**
         * Client certificate name.
         */
        certificateName: string;
        /**
         * Deploy time of client certificate.
         */
        deployTime: string;
        /**
         * Signature expiration time in second. The maximum value is 630720000.
         */
        expireTime: string;
    }

    export interface DomainHttpsConfigForceRedirect {
        /**
         * Whether to return the newly added header during force redirection. Values: `on`, `off`.
         */
        carryHeaders?: string;
        /**
         * Forced redirect status code. Valid values are `301` and `302`. When `switch` setting `off`, this property does not need to be set or set to `302`. Default value is `302`.
         */
        redirectStatusCode?: number;
        /**
         * Forced redirect type. Valid values are `http` and `https`. `http` means a forced redirect from HTTPS to HTTP, `https` means a forced redirect from HTTP to HTTPS. When `switch` setting `off`, this property does not need to be set or set to `http`. Default value is `http`.
         */
        redirectType?: string;
        /**
         * Forced redirect configuration switch. Valid values are `on` and `off`. Default value is `off`.
         */
        switch?: string;
    }

    export interface DomainHttpsConfigServerCertificateConfig {
        /**
         * Server certificate information. This is required when uploading an external certificate, which should contain the complete certificate chain.
         */
        certificateContent?: string;
        /**
         * Server certificate ID.
         */
        certificateId?: string;
        /**
         * Server certificate name.
         */
        certificateName: string;
        /**
         * Deploy time of server certificate.
         */
        deployTime: string;
        /**
         * Signature expiration time in second. The maximum value is 630720000.
         */
        expireTime: string;
        /**
         * Certificate remarks.
         */
        message?: string;
        /**
         * Server key information. This is required when uploading an external certificate.
         */
        privateKey?: string;
    }

    export interface DomainHwPrivateAccess {
        /**
         * Access ID.
         */
        accessKey?: string;
        /**
         * Bucket.
         */
        bucket?: string;
        /**
         * Key.
         */
        secretKey?: string;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainIpFilter {
        /**
         * Ip filter rules, This feature is only available to selected beta customers.
         */
        filterRules?: outputs.Cdn.DomainIpFilterFilterRule[];
        /**
         * IP `blacklist`/`whitelist` type.
         */
        filterType?: string;
        /**
         * Ip filter list, Supports IPs in X.X.X.X format, or /8, /16, /24 format IP ranges. Up to 50 allowlists or blocklists can be entered.
         */
        filters?: string[];
        /**
         * Return code, available values: 400-499.
         */
        returnCode?: number;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainIpFilterFilterRule {
        /**
         * Ip filter `blacklist`/`whitelist` type of filter rules.
         */
        filterType: string;
        /**
         * Ip filter rule list, supports IPs in X.X.X.X format, or /8, /16, /24 format IP ranges. Up to 50 allowlists or blocklists can be entered.
         */
        filters: string[];
        /**
         * Content list for each `ruleType`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
         */
        rulePaths: string[];
        /**
         * Ip filter rule type of filter rules, available: `all`, `file`, `directory`, `path`.
         */
        ruleType: string;
    }

    export interface DomainIpFreqLimit {
        /**
         * Sets the limited number of requests per second, 514 will be returned for requests that exceed the limit.
         */
        qps?: number;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainMaxAge {
        /**
         * List of Max Age rule configuration.
         */
        maxAgeRules?: outputs.Cdn.DomainMaxAgeMaxAgeRule[];
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainMaxAgeMaxAgeRule {
        /**
         * Whether to follow origin, values: `on`/`off`, if set to `on`, the `maxAgeTime` will be ignored.
         */
        followOrigin?: string;
        /**
         * List of rule paths for each `maxAgeType`: `*` for `all`, file ext like `jpg` for `file`, `/dir/like/` for `directory` and `/path/index.html` for `path`.
         */
        maxAgeContents: string[];
        /**
         * Max Age time in seconds, this can set to `0` that stands for no cache.
         */
        maxAgeTime: number;
        /**
         * The following types are supported: `all`: all documents take effect, `file`: the specified file suffix takes effect, `directory`: the specified path takes effect, `path`: specify the absolute path to take effect, `index`: home page.
         */
        maxAgeType: string;
    }

    export interface DomainOrigin {
        /**
         * Backup origin server list. Valid values can be ip or domain name. When modifying the backup origin server, you need to enter the corresponding `backupOriginType`.
         */
        backupOriginLists?: string[];
        /**
         * Backup origin server type, which supports the following types: `domain`: domain name type, `ip`: IP list used as origin server.
         */
        backupOriginType?: string;
        /**
         * Host header used when accessing the backup origin server. If left empty, the ServerName of master origin server will be used by default.
         */
        backupServerName?: string;
        /**
         * When OriginType is COS, you can specify if access to private buckets is allowed. Valid values are `on` and `off`. and default value is `off`.
         */
        cosPrivateAccess?: string;
        /**
         * Master origin server list. Valid values can be ip or domain name. When modifying the origin server, you need to enter the corresponding `originType`.
         */
        originLists: string[];
        /**
         * Origin-pull protocol configuration. `http`: forced HTTP origin-pull, `follow`: protocol follow origin-pull, `https`: forced HTTPS origin-pull. This only supports origin server port 443 for origin-pull.
         */
        originPullProtocol?: string;
        /**
         * Master origin server type. The following types are supported: `domain`: domain name type, `cos`: COS origin, `ip`: IP list used as origin server, `ipv6`: origin server list is a single IPv6 address, `ipIpv6`: origin server list is multiple IPv4 addresses and an IPv6 address.
         */
        originType: string;
        /**
         * Host header used when accessing the master origin server. If left empty, the acceleration domain name will be used by default.
         */
        serverName: string;
    }

    export interface DomainOriginPullOptimization {
        /**
         * Optimization type, values: `OVToCN` - Overseas to CN, `CNToOV` CN to Overseas.
         */
        optimizationType?: string;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainOriginPullTimeout {
        /**
         * The origin-pull connection timeout (in seconds). Valid range: 5-60.
         */
        connectTimeout: number;
        /**
         * The origin-pull receipt timeout (in seconds). Valid range: 10-60.
         */
        receiveTimeout: number;
    }

    export interface DomainOssPrivateAccess {
        /**
         * Access ID.
         */
        accessKey?: string;
        /**
         * Bucket.
         */
        bucket?: string;
        /**
         * Region.
         */
        region?: string;
        /**
         * Key.
         */
        secretKey?: string;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainPostMaxSize {
        /**
         * Maximum size in MB, value range is `[1, 200]`.
         */
        maxSize?: number;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainQnPrivateAccess {
        /**
         * Access ID.
         */
        accessKey?: string;
        /**
         * Key.
         */
        secretKey?: string;
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainReferer {
        /**
         * List of referer rules.
         */
        refererRules?: outputs.Cdn.DomainRefererRefererRule[];
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainRefererRefererRule {
        /**
         * Whether to allow emptpy.
         */
        allowEmpty: boolean;
        /**
         * Referer type.
         */
        refererType: string;
        /**
         * Referer list.
         */
        referers: string[];
        /**
         * Referer rule path list.
         */
        rulePaths: string[];
        /**
         * Referer rule type.
         */
        ruleType: string;
    }

    export interface DomainRequestHeader {
        /**
         * Custom request header configuration rules.
         */
        headerRules?: outputs.Cdn.DomainRequestHeaderHeaderRule[];
        /**
         * Custom request header configuration switch. Valid values are `on` and `off`. and default value is `off`.
         */
        switch?: string;
    }

    export interface DomainRequestHeaderHeaderRule {
        /**
         * Response header mode.
         */
        headerMode: string;
        /**
         * response header name of rule.
         */
        headerName: string;
        /**
         * response header value of rule.
         */
        headerValue: string;
        /**
         * response rule paths of rule.
         */
        rulePaths: string[];
        /**
         * response rule type of rule.
         */
        ruleType: string;
    }

    export interface DomainResponseHeader {
        /**
         * List of response header rule.
         */
        headerRules?: outputs.Cdn.DomainResponseHeaderHeaderRule[];
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainResponseHeaderHeaderRule {
        /**
         * Response header mode.
         */
        headerMode: string;
        /**
         * response header name of rule.
         */
        headerName: string;
        /**
         * response header value of rule.
         */
        headerValue: string;
        /**
         * response rule paths of rule.
         */
        rulePaths: string[];
        /**
         * response rule type of rule.
         */
        ruleType: string;
    }

    export interface DomainRuleCach {
        /**
         * Cache expiration time setting, the unit is second, the maximum can be set to 365 days.
         */
        cacheTime: number;
        /**
         * Advanced cache expiration configuration. When it is turned on, it will compare the max-age value returned by the origin site with the cache expiration time set in CacheRules, and take the minimum value to cache at the node. Valid values are `on` and `off`. Default value is `off`.
         */
        compareMaxAge?: string;
        /**
         * Follow the source station configuration switch. Valid values are `on` and `off`.
         */
        followOriginSwitch?: string;
        /**
         * Specify whether to enable heuristic cache, only available while `followOriginSwitch` enabled, values: `on`, `off` (Default).
         */
        heuristicCacheSwitch?: string;
        /**
         * Specify heuristic cache time in second, only available while `followOriginSwitch` and `heuristicCacheSwitch` enabled.
         */
        heuristicCacheTime?: number;
        /**
         * Force caching. After opening, the no-store and no-cache resources returned by the origin site will also be cached in accordance with the CacheRules rules. Valid values are `on` and `off`. Default value is `off`.
         */
        ignoreCacheControl?: string;
        /**
         * Ignore the Set-Cookie header of the origin site. Valid values are `on` and `off`. Default value is `off`. This parameter is for white-list customer.
         */
        ignoreSetCookie?: string;
        /**
         * Cache configuration switch. Valid values are `on` and `off`.
         */
        noCacheSwitch?: string;
        /**
         * Always check back to origin. Valid values are `on` and `off`. Default value is `off`.
         */
        reValidate?: string;
        /**
         * Matching content under the corresponding type of CacheType: `all`: fill *, `file`: fill in the suffix name, such as jpg, txt, `directory`: fill in the path, such as /xxx/test, `path`: fill in the absolute path, such as /xxx/test.html, `index`: fill /.
         */
        rulePaths: string[];
        /**
         * Rule type. The following types are supported: `all`: all documents take effect, `file`: the specified file suffix takes effect, `directory`: the specified path takes effect, `path`: specify the absolute path to take effect, `index`: home page.
         */
        ruleType?: string;
        /**
         * Cache configuration switch. Valid values are `on` and `off`.
         */
        switch?: string;
    }

    export interface DomainStatusCodeCache {
        /**
         * List of cache rule.
         */
        cacheRules?: outputs.Cdn.DomainStatusCodeCacheCacheRule[];
        /**
         * Configuration switch, available values: `on`, `off` (default).
         */
        switch: string;
    }

    export interface DomainStatusCodeCacheCacheRule {
        /**
         * Status code cache expiration time (in seconds).
         */
        cacheTime: number;
        /**
         * Code of status cache. available values: `403`, `404`.
         */
        statusCode: string;
    }

    export interface GetDomainsDomainList {
        /**
         * Acceleration region.
         */
        area: string;
        /**
         * CNAME address of domain name.
         */
        cname: string;
        /**
         * Domain name creation time.
         */
        createTime: string;
        /**
         * Acceleration domain name.
         */
        domain: string;
        /**
         * Whether to enable full-path cache.
         */
        fullUrlCache: boolean;
        /**
         * HTTPS acceleration configuration. It's a list and consist of at most one item.
         */
        httpsConfigs: outputs.Cdn.GetDomainsDomainListHttpsConfig[];
        /**
         * Domain name ID.
         */
        id: string;
        /**
         * Origin server configuration.
         */
        origins: outputs.Cdn.GetDomainsDomainListOrigin[];
        /**
         * The project CDN belongs to.
         */
        projectId: number;
        /**
         * Sharding back to source configuration switch.
         */
        rangeOriginSwitch: string;
        /**
         * Request header configuration.
         */
        requestHeaders: outputs.Cdn.GetDomainsDomainListRequestHeader[];
        /**
         * Advanced path cache configuration.
         */
        ruleCaches: outputs.Cdn.GetDomainsDomainListRuleCach[];
        /**
         * Service type of acceleration domain name. The available value include `web`, `download` and `media`.
         */
        serviceType: string;
        /**
         * Acceleration service status.
         */
        status: string;
        /**
         * Tags of cdn domain.
         */
        tags: {[key: string]: any};
        /**
         * Last modified time of domain name.
         */
        updateTime: string;
    }

    export interface GetDomainsDomainListHttpsConfig {
        /**
         * HTTP2 configuration switch.
         */
        http2Switch: string;
        /**
         * HTTPS configuration. Valid values: `on`, `off` and `processing`.
         */
        httpsSwitch: string;
        /**
         * OCSP configuration switch.
         */
        ocspStaplingSwitch: string;
        /**
         * Spdy configuration switch.
         */
        spdySwitch: string;
        /**
         * Client certificate authentication feature.
         */
        verifyClient: string;
    }

    export interface GetDomainsDomainListOrigin {
        /**
         * Backup origin server list.
         */
        backupOriginLists: string[];
        /**
         * Backup origin server type.
         */
        backupOriginType: string;
        /**
         * Host header used when accessing the backup origin server. If left empty, the ServerName of master origin server will be used by default.
         */
        backupServerName: string;
        /**
         * When OriginType is COS, you can specify if access to private buckets is allowed.
         */
        cosPrivateAccess: string;
        /**
         * Master origin server list.
         */
        originLists: string[];
        /**
         * Origin-pull protocol configuration. Valid values: `http`, `https` and `follow`.
         */
        originPullProtocol: string;
        /**
         * Master origin server type.
         */
        originType: string;
        /**
         * Host header used when accessing the master origin server. If left empty, the acceleration domain name will be used by default.
         */
        serverName: string;
    }

    export interface GetDomainsDomainListRequestHeader {
        /**
         * Custom request header configuration rules.
         */
        headerRules: outputs.Cdn.GetDomainsDomainListRequestHeaderHeaderRule[];
        /**
         * Cache configuration switch.
         */
        switch: string;
    }

    export interface GetDomainsDomainListRequestHeaderHeaderRule {
        /**
         * Http header setting method.
         */
        headerMode: string;
        /**
         * Http header name.
         */
        headerName: string;
        /**
         * Http header value.
         */
        headerValue: string;
        /**
         * Rule paths.
         */
        rulePaths: string[];
        /**
         * Rule type.
         */
        ruleType: string;
    }

    export interface GetDomainsDomainListRuleCach {
        /**
         * Cache expiration time setting, the unit is second.
         */
        cacheTime: number;
        /**
         * Advanced cache expiration configuration.
         */
        compareMaxAge?: string;
        /**
         * Follow the source station configuration switch.
         */
        followOriginSwitch: string;
        /**
         * Force caching. After opening, the no-store and no-cache resources returned by the origin site will also be cached in accordance with the CacheRules rules.
         */
        ignoreCacheControl?: string;
        /**
         * Ignore the Set-Cookie header of the origin site.
         */
        ignoreSetCookie: string;
        /**
         * Cache configuration switch.
         */
        noCacheSwitch: string;
        /**
         * Always check back to origin.
         */
        reValidate: string;
        /**
         * Rule paths.
         */
        rulePaths: string[];
        /**
         * Rule type.
         */
        ruleType: string;
        /**
         * Cache configuration switch.
         */
        switch: string;
    }

    export interface UrlPurgePurgeHistory {
        /**
         * Purge task create time.
         */
        createTime: string;
        /**
         * Purge flush type of `flush` or `delete`.
         */
        flushType: string;
        /**
         * Purge category in of `url` or `path`.
         */
        purgeType: string;
        /**
         * Purge status of `fail`, `done`, `process`.
         */
        status: string;
        /**
         * Task id of last operation.
         */
        taskId: string;
        /**
         * Purge url.
         */
        url: string;
    }

    export interface UrlPushPushHistory {
        /**
         * Specify push area. NOTE: only push same area cache contents.
         */
        area: string;
        /**
         * Push task create time.
         */
        createTime: string;
        /**
         * Push progress in percent.
         */
        percent: number;
        /**
         * Push status of `fail`, `done`, `process` or `invalid` (4xx, 5xx response).
         */
        status: string;
        /**
         * Push task id.
         */
        taskId: string;
        /**
         * Push task update time.
         */
        updateTime: string;
        /**
         * Push url.
         */
        url: string;
    }

}

export namespace Cdwpg {
    export interface InstanceChargeProperties {
        /**
         * Charge type, vaild values: PREPAID, POSTPAID_BY_HOUR.
         */
        chargeType?: string;
        /**
         * 0-no automatic renewal,1-automatic renewalNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        renewFlag: number;
        /**
         * Time RangeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        timeSpan: number;
        /**
         * Time Unit,Generally h and mNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        timeUnit: string;
    }

    export interface InstanceResource {
        /**
         * resource count.
         */
        count: number;
        /**
         * disk Information.
         */
        diskSpec: outputs.Cdwpg.InstanceResourceDiskSpec;
        /**
         * resource name.
         */
        specName: string;
        /**
         * resource type.
         */
        type: string;
    }

    export interface InstanceResourceDiskSpec {
        /**
         * disk count.
         */
        diskCount: number;
        /**
         * disk size.
         */
        diskSize: number;
        /**
         * disk type.
         */
        diskType: string;
    }

}

export namespace Cfs {
    export interface GetAccessGroupsAccessGroupList {
        /**
         * A specified access group ID used to query.
         */
        accessGroupId: string;
        /**
         * Creation time of the access group.
         */
        createTime: string;
        /**
         * Description of the access group.
         */
        description: string;
        /**
         * A access group Name used to query.
         */
        name: string;
    }

    export interface GetAccessRulesAccessRuleList {
        /**
         * A specified access rule ID used to query.
         */
        accessRuleId: string;
        /**
         * Allowed IP of the access rule.
         */
        authClientIp: string;
        /**
         * The priority level of access rule.
         */
        priority: number;
        /**
         * Read and write permissions.
         */
        rwPermission: string;
        /**
         * The permissions of accessing users.
         */
        userPermission: string;
    }

    export interface GetAvailableZoneRegionZone {
        /**
         * Region name, such as `ap-beijing`.
         */
        region: string;
        /**
         * Region chinese name, such as `Guangzhou`.
         */
        regionCnName: string;
        /**
         * Region name, such as `bj`.
         */
        regionName: string;
        /**
         * Region availability. If a region has at least one AZ where resources are purchasable, this value will be AVAILABLE; otherwise, it will be UNAVAILABLE.
         */
        regionStatus: string;
        /**
         * Array of AZs.
         */
        zones: outputs.Cfs.GetAvailableZoneRegionZoneZone[];
    }

    export interface GetAvailableZoneRegionZoneZone {
        /**
         * Array of classes.
         */
        types: outputs.Cfs.GetAvailableZoneRegionZoneZoneType[];
        /**
         * AZ name.
         */
        zone: string;
        /**
         * Chinese name of an AZ.
         */
        zoneCnName: string;
        /**
         * AZ ID.
         */
        zoneId: number;
        /**
         * Chinese and English names of an AZ.
         */
        zoneName: string;
    }

    export interface GetAvailableZoneRegionZoneZoneType {
        /**
         * Indicates whether prepaid is supported. true: yes; false: no.
         */
        prepayment: boolean;
        /**
         * Protocol and sale details.
         */
        protocols: outputs.Cfs.GetAvailableZoneRegionZoneZoneTypeProtocol[];
        /**
         * Storage class. Valid values: SD (standard storage) and HP (high-performance storage).
         */
        type: string;
    }

    export interface GetAvailableZoneRegionZoneZoneTypeProtocol {
        /**
         * Protocol type. Valid values: NFS, CIFS.
         */
        protocol: string;
        /**
         * Sale status. Valid values: saleOut (sold out), saling (purchasable), noSaling (non-purchasable).
         */
        saleStatus: string;
    }

    export interface GetFileSystemClientsClientList {
        /**
         * IP address of the file system.
         */
        cfsVip: string;
        /**
         * Client IP.
         */
        clientIp: string;
        /**
         * Path in which the file system is mounted to the client.
         */
        mountDirectory: string;
        /**
         * File system VPCID.
         */
        vpcId: string;
        /**
         * Name of the availability zone, e.g. ap-beijing-1. For more information, see regions and availability zones in the Overview document.
         */
        zone: string;
        /**
         * AZ name.
         */
        zoneName: string;
    }

    export interface GetFileSystemsFileSystemList {
        /**
         * ID of the access group.
         */
        accessGroupId: string;
        /**
         * The available zone that the file system locates at.
         */
        availabilityZone: string;
        /**
         * Creation time of the file system.
         */
        createTime: string;
        /**
         * A specified file system ID used to query.
         */
        fileSystemId: string;
        /**
         * Mount root-directory.
         */
        fsId: string;
        /**
         * IP of the file system.
         */
        mountIp: string;
        /**
         * A file system name used to query.
         */
        name: string;
        /**
         * Protocol of the file system.
         */
        protocol: string;
        /**
         * Size limit of the file system.
         */
        sizeLimit: number;
        /**
         * Size used of the file system.
         */
        sizeUsed: number;
        /**
         * Status of the file system.
         */
        status: string;
        /**
         * Storage type of the file system.
         */
        storageType: string;
    }

    export interface GetMountTargetsMountTarget {
        /**
         * CCN instance ID used by CFS Turbo.
         */
        ccnId: string;
        /**
         * CCN IP range used by CFS Turbo.
         */
        cidrBlock: string;
        /**
         * File system ID.
         */
        fileSystemId: string;
        /**
         * Mount root-directory.
         */
        fsId: string;
        /**
         * Mount target IP.
         */
        ipAddress: string;
        /**
         * Mount target status.
         */
        lifeCycleState: string;
        /**
         * Mount target ID.
         */
        mountTargetId: string;
        /**
         * Network type.
         */
        networkInterface: string;
        /**
         * Subnet ID.
         */
        subnetId: string;
        /**
         * Subnet name.
         */
        subnetName: string;
        /**
         * VPC ID.
         */
        vpcId: string;
        /**
         * VPC name.
         */
        vpcName: string;
    }

}

export namespace Cfw {
    export interface GetEdgeFwSwitchesData {
        /**
         * Asset Type.
         */
        assetType: string;
        /**
         * Instance Id.
         */
        instanceId: string;
        /**
         * Instance Name.
         */
        instanceName: string;
        /**
         * Intranet Ip.
         */
        intranetIp: string;
        /**
         * public ip.
         */
        publicIp: string;
        /**
         * Public IP type.
         */
        publicIpType: number;
        /**
         * region.
         */
        region: string;
        /**
         * status.
         */
        status: number;
        /**
         * switch mode.
         */
        switchMode: number;
        /**
         * vpc id.
         */
        vpcId: string;
    }

    export interface GetNatFwSwitchesData {
        /**
         * Whether the switch is abnormal, 0: normal, 1: abnormal.
         */
        abnormal: number;
        /**
         * Cvm Num.
         */
        cvmNum: number;
        /**
         * Effective status.
         */
        enable: number;
        /**
         * ID.
         */
        id: number;
        /**
         * NAT gatway Id.
         */
        natId: string;
        /**
         * Filter the NAT firewall instance to which the NAT firewall subnet switch belongs.
         */
        natInsId: string;
        /**
         * NAT firewall instance name.
         */
        natInsName: string;
        /**
         * NAT gatway name.
         */
        natName: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Route Id.
         */
        routeId: string;
        /**
         * Route Name.
         */
        routeName: string;
        /**
         * Switch status, 1 open; 0 close.
         */
        status: number;
        /**
         * IPv4 CIDR.
         */
        subnetCidr: string;
        /**
         * Subnet Id.
         */
        subnetId: string;
        /**
         * Subnet Name.
         */
        subnetName: string;
        /**
         * Vpc Id.
         */
        vpcId: string;
        /**
         * Vpc Name.
         */
        vpcName: string;
    }

    export interface GetVpcFwSwitchesSwitchList {
        /**
         * Switch status 0: off, 1: on.
         */
        enable: number;
        /**
         * Switch status 0: normal, 1: switching.
         */
        status: number;
        /**
         * Firewall switch ID.
         */
        switchId: string;
        /**
         * switch mode.
         */
        switchMode: number;
        /**
         * Firewall switch name.
         */
        switchName: string;
    }

    export interface NatInstanceNewModeItems {
        /**
         * List of egress elastic public network IPs bound in the new mode.
         */
        eips: string[];
        /**
         * List of vpcs connected in new mode.
         */
        vpcLists: string[];
    }

    export interface VpcInstanceVpcFwInstance {
        /**
         * Deploy regional information.
         */
        fwDeploy: outputs.Cfw.VpcInstanceVpcFwInstanceFwDeploy;
        /**
         * Firewall instance ID (passed in editing scenario).
         */
        fwInsId: string;
        /**
         * Firewall instance name.
         */
        name: string;
        /**
         * List of VpcIds accessed in private network mode; only used in private network mode.
         */
        vpcIds?: string[];
    }

    export interface VpcInstanceVpcFwInstanceFwDeploy {
        /**
         * Off-site disaster recovery 1: use off-site disaster recovery; 0: do not use off-site disaster recovery; if it is empty, off-site disaster recovery will not be used by default.
         */
        crossAZone?: number;
        /**
         * Firewall Deployment Region.
         */
        deployRegion: string;
        /**
         * Bandwidth, unit: Mbps.
         */
        width: number;
        /**
         * Zone list.
         */
        zoneSets: string[];
    }

    export interface VpcPolicyBetaList {
        /**
         * Last execution time. Note: This field may return null, indicating that no valid value can be obtained.
         */
        lastTime?: string;
        /**
         * Task id. Note: This field may return null, indicating that no valid value can be obtained.
         */
        taskId?: number;
        /**
         * Mission name. Note: This field may return null, indicating that no valid value can be obtained.
         */
        taskName?: string;
    }

}

export namespace Chdfs {
    export interface AccessRuleAccessRule {
        /**
         * rule access mode, 1: read only, 2: read &amp; wirte.
         */
        accessMode?: number;
        /**
         * single rule id.
         */
        accessRuleId: number;
        /**
         * rule address, IP OR IP SEG.
         */
        address?: string;
        /**
         * rule create time.
         */
        createTime: string;
        /**
         * rule priority, range 1 - 100, value less higher priority.
         */
        priority?: number;
    }

    export interface GetAccessGroupsAccessGroup {
        /**
         * access group id.
         */
        accessGroupId: string;
        /**
         * access group name.
         */
        accessGroupName: string;
        /**
         * create time.
         */
        createTime: string;
        /**
         * access group description.
         */
        description: string;
        /**
         * get groups belongs to the vpc id, must set but only can use one of VpcId and OwnerUin to get the groups.
         */
        vpcId: string;
        /**
         * vpc network type(1:CVM, 2:BM 1.0).
         */
        vpcType: number;
    }

    export interface GetFileSystemsFileSystem {
        /**
         * appid of the user.
         */
        appId: number;
        /**
         * block size of the file system(byte).
         */
        blockSize: number;
        /**
         * capacity of the file system(byte).
         */
        capacityQuota: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * desc of the file system.
         */
        description: string;
        /**
         * check the ranger address or not.
         */
        enableRanger: boolean;
        /**
         * file system id.
         */
        fileSystemId: string;
        /**
         * file system name.
         */
        fileSystemName: string;
        /**
         * check POSIX ACL or not.
         */
        posixAcl: boolean;
        /**
         * ranger address list.
         */
        rangerServiceAddresses: string[];
        /**
         * region of the file system.
         */
        region: string;
        /**
         * status of the file system(1: creating create success 3: create failed).
         */
        status: number;
        /**
         * super users of the file system.
         */
        superUsers: string[];
    }

    export interface GetMountPointsMountPoint {
        /**
         * associated group ids.
         */
        accessGroupIds: string[];
        /**
         * create time.
         */
        createTime: string;
        /**
         * get mount points belongs to file system id, only can use one of the AccessGroupId,FileSystemId,OwnerUin parameters.
         */
        fileSystemId: string;
        /**
         * mount point id.
         */
        mountPointId: string;
        /**
         * mount point name.
         */
        mountPointName: string;
        /**
         * mount point status.
         */
        status: number;
    }

    export interface LifeCycleRuleLifeCycleRule {
        /**
         * rule create time.
         */
        createTime: string;
        /**
         * single rule id.
         */
        lifeCycleRuleId: number;
        /**
         * rule name.
         */
        lifeCycleRuleName?: string;
        /**
         * rule op path.
         */
        path?: string;
        /**
         * rule status, 1:open, 2:close.
         */
        status?: number;
        /**
         * life cycle rule transition list.
         */
        transitions?: outputs.Chdfs.LifeCycleRuleLifeCycleRuleTransition[];
    }

    export interface LifeCycleRuleLifeCycleRuleTransition {
        /**
         * trigger days(n day).
         */
        days: number;
        /**
         * transition type, 1: archive, 2: delete, 3: low rate.
         */
        type: number;
    }

}

export namespace Ci {
    export interface MediaAnimationTemplateContainer {
        /**
         * Package format.
         */
        format: string;
    }

    export interface MediaAnimationTemplateTimeInterval {
        /**
         * duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        duration?: string;
        /**
         * Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        start?: string;
    }

    export interface MediaAnimationTemplateVideo {
        /**
         * Animation per second frame number, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
         */
        animateFramesPerSecond?: string;
        /**
         * GIFs are kept only Keyframe, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
         */
        animateOnlyKeepKeyFrame?: string;
        /**
         * Animation frame extraction every time, (0, video duration], Animation frame extraction time interval, If TimeInterval.Duration is set, it is less than this value.
         */
        animateTimeIntervalOfFrame?: string;
        /**
         * Codec format `gif`, `webp`.
         */
        codec: string;
        /**
         * Frame rate, value range: (0, 60], Unit: fps.
         */
        fps?: string;
        /**
         * High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
         */
        height?: string;
        /**
         * Set relative quality, [1, 100), webp image quality setting takes effect, gif has no quality parameter.
         */
        quality?: string;
        /**
         * width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
         */
        width?: string;
    }

    export interface MediaConcatTemplateConcatTemplate {
        /**
         * audio parameters, the target file does not require Audio information, need to set Audio.Remove to true.
         */
        audio?: outputs.Ci.MediaConcatTemplateConcatTemplateAudio;
        /**
         * mixing parameters.
         */
        audioMixes?: outputs.Ci.MediaConcatTemplateConcatTemplateAudioMix[];
        /**
         * Package format.
         */
        concatFragments: outputs.Ci.MediaConcatTemplateConcatTemplateConcatFragment[];
        /**
         * Only splicing without transcoding.
         */
        container: outputs.Ci.MediaConcatTemplateConcatTemplateContainer;
        /**
         * video information, do not upload Video, which is equivalent to deleting video information.
         */
        video?: outputs.Ci.MediaConcatTemplateConcatTemplateVideo;
    }

    export interface MediaConcatTemplateConcatTemplateAudio {
        /**
         * Original audio bit rate, unit: Kbps, Value range: [8, 1000].
         */
        bitrate?: string;
        /**
         * number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
         */
        channels?: string;
        /**
         * Codec format, value aac, mp3.
         */
        codec: string;
        /**
         * Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
         */
        samplerate?: string;
    }

    export interface MediaConcatTemplateConcatTemplateAudioMix {
        /**
         * The media address of the audio track that needs to be mixed.
         */
        audioSource: string;
        /**
         * Mix Fade Configuration.
         */
        effectConfig?: outputs.Ci.MediaConcatTemplateConcatTemplateAudioMixEffectConfig;
        /**
         * Mixing mode Repeat: background sound loop, Once: The background sound is played once.
         */
        mixMode?: string;
        /**
         * Whether to replace the original audio of the Input media file with the mixed audio track media.
         */
        replace?: string;
    }

    export interface MediaConcatTemplateConcatTemplateAudioMixEffectConfig {
        /**
         * bgm transition fade-in duration, support floating point numbers.
         */
        bgmFadeTime?: string;
        /**
         * Enable bgm conversion fade in.
         */
        enableBgmFade?: string;
        /**
         * enable fade out.
         */
        enableEndFadeout?: string;
        /**
         * enable fade in.
         */
        enableStartFadein?: string;
        /**
         * fade out time, greater than 0, support floating point numbers.
         */
        endFadeoutTime: string;
        /**
         * Fade in duration, greater than 0, support floating point numbers.
         */
        startFadeinTime?: string;
    }

    export interface MediaConcatTemplateConcatTemplateConcatFragment {
        /**
         * node type, `start`, `end`.
         */
        mode: string;
        /**
         * Splicing object address.
         */
        url: string;
    }

    export interface MediaConcatTemplateConcatTemplateContainer {
        /**
         * Container format: mp4, flv, hls, ts, mp3, aac.
         */
        format: string;
    }

    export interface MediaConcatTemplateConcatTemplateVideo {
        /**
         * Original audio bit rate, unit: Kbps, Value range: [8, 1000].
         */
        bitrate?: string;
        /**
         * Codec format `H.264`.
         */
        codec: string;
        /**
         * Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
         */
        crf?: string;
        /**
         * Frame rate, value range: (0, 60], Unit: fps.
         */
        fps?: string;
        /**
         * High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
         */
        height?: string;
        /**
         * Whether to delete the source audio stream, the value is true, false.
         */
        remove: string;
        /**
         * Rotation angle, Value range: [0, 360), Unit: degree.
         */
        rotate?: string;
        /**
         * width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
         */
        width?: string;
    }

    export interface MediaPicProcessTemplatePicProcess {
        /**
         * Whether to return the original image information.
         */
        isPicInfo?: string;
        /**
         * Image processing rules, 1: basic image processing, please refer to the basic image processing document, 2: image compression, please refer to the image compression document, 3: blind watermark, please refer to the blind watermark document.
         */
        processRule: string;
    }

    export interface MediaSmartCoverTemplateSmartCover {
        /**
         * Number of screenshots, [1,10].
         */
        count?: string;
        /**
         * cover deduplication, true/false.
         */
        deleteDuplicates?: string;
        /**
         * Image Format, value jpg, png, webp.
         */
        format: string;
        /**
         * Height, value range: [128, 4096], unit: px, if only Height is set, Width is calculated according to the original video ratio.
         */
        height?: string;
        /**
         * Width, value range: [128, 4096], unit: px, if only Width is set, Height is calculated according to the original ratio of the video.
         */
        width?: string;
    }

    export interface MediaSnapshotTemplateSnapshot {
        /**
         * Screenshot black screen detection parameters, Valid when IsCheckBlack=true, Value reference range [30, 100], indicating the proportion of black pixels, the smaller the value, the smaller the proportion of black pixels, Start&gt;0, the parameter setting is invalid, no filter black screen, Start =0 parameter is valid, the start time of the frame capture is the first frame non-black screen start.
         */
        blackLevel: string;
        /**
         * Screenshot image processing parameters, for example: imageMogr2/format/png.
         */
        ciParam: string;
        /**
         * Number of screenshots, range (0 10000].
         */
        count: string;
        /**
         * high, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video.
         */
        height: string;
        /**
         * Whether to enable black screen detection true/false.
         */
        isCheckBlack: string;
        /**
         * Whether to check the number of screenshots forcibly, when using custom interval mode to take screenshots, the video time is not long enough to capture Count screenshots, you can switch to average screenshot mode to capture Count screenshots.
         */
        isCheckCount: string;
        /**
         * Screenshot mode, value range: {Interval, Average, KeyFrame}- Interval means interval mode Average means average mode- KeyFrame represents the key frame mode- Interval mode: Start, TimeInterval, The Count parameter takes effect. When Count is set and TimeInterval is not set, Indicates to capture all frames, a total of Count pictures- Average mode: Start, the Count parameter takes effect. express.
         */
        mode: string;
        /**
         * Screenshot black screen detection parameters, Valid when IsCheckBlack=true, The threshold for judging whether a pixel is a black point, value range: [0, 255].
         */
        pixelBlackThreshold: string;
        /**
         * Screenshot output mode parameters, Value range: {OnlySnapshot, OnlySprite, SnapshotAndSprite}, OnlySnapshot means output only screenshot mode OnlySprite means only output sprite mode SnapshotAndSprite means output screenshot and sprite mode.
         */
        snapshotOutMode: string;
        /**
         * Screenshot output configuration.
         */
        spriteSnapshotConfig: outputs.Ci.MediaSnapshotTemplateSnapshotSpriteSnapshotConfig;
        /**
         * Starting time, [0 video duration] in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        start: string;
        /**
         * Screenshot time interval, (0 3600], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        timeInterval: string;
        /**
         * wide, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video.
         */
        width: string;
    }

    export interface MediaSnapshotTemplateSnapshotSpriteSnapshotConfig {
        /**
         * Single image height Value range: [8, 4096], Unit: px.
         */
        cellHeight: string;
        /**
         * Single image width Value range: [8, 4096], Unit: px.
         */
        cellWidth: string;
        /**
         * See `https://www.ffmpeg.org/ffmpeg-utils.html#color-syntax` for details on supported colors.
         */
        color: string;
        /**
         * Number of screenshot columns, value range: [1, 10000].
         */
        columns: string;
        /**
         * Number of screenshot lines, value range: [1, 10000].
         */
        lines: string;
        /**
         * screenshot margin size, Value range: [8, 4096], Unit: px.
         */
        margin: string;
        /**
         * screenshot padding size, Value range: [8, 4096], Unit: px.
         */
        padding: string;
    }

    export interface MediaSpeechRecognitionTemplateSpeechRecognition {
        /**
         * Number of voice channels: 1 means mono. EngineModelType supports only mono for non-telephone scenarios, and 2 means dual channels (only 8kZh engine model supports dual channels, which should correspond to both sides of the call).
         */
        channelNum: string;
        /**
         * Whether to perform intelligent conversion of Arabic numerals (currently supports Mandarin Chinese engine): 0 means no conversion, directly output Chinese numbers, 1 means intelligently convert to Arabic numerals according to the scene, 3 means enable math-related digital conversion, the default value is 0.
         */
        convertNumMode?: string;
        /**
         * Engine model type, divided into phone scene and non-phone scene, phone scene: 8k_zh: phone 8k Chinese Mandarin general (can be used for dual-channel audio), 8k_zh_s: phone 8k Chinese Mandarin speaker separation (only for monophonic audio), 8k_en: Telephone 8k English; non-telephone scene: 16k_zh: 16k Mandarin Chinese, 16k_zh_video: 16k audio and video field, 16k_en: 16k English, 16k_ca: 16k Cantonese, 16k_ja: 16k Japanese, 16k_zh_edu: Chinese education, 16k_en_edu: English education, 16k_zh_medical: medical, 16k_th: Thai, 16k_zh_dialect: multi-dialect, supports 23 dialects.
         */
        engineModelType: string;
        /**
         * Whether to filter dirty words (currently supports Mandarin Chinese engine): 0 means not to filter dirty words, 1 means to filter dirty words, 2 means to replace dirty words with *, the default value is 0.
         */
        filterDirty?: string;
        /**
         * Whether to pass modal particles (currently supports Mandarin Chinese engine): 0 means not to filter modal particles, 1 means partial filtering, 2 means strict filtering, and the default value is 0.
         */
        filterModal?: string;
        /**
         * Whether to filter punctuation (currently supports Mandarin Chinese engine): 0 means no filtering, 1 means filtering end-of-sentence punctuation, 2 means filtering all punctuation, the default value is 0.
         */
        filterPunc?: string;
        /**
         * Output file type, optional txt, srt. The default is txt.
         */
        outputFileType?: string;
        /**
         * Recognition result return form: 0 means the recognition result text (including segmented time stamps), 1 is the detailed recognition result at the word level granularity, without punctuation, and includes the speech rate value (a list of word time stamps, generally used to generate subtitle scenes), 2 Detailed recognition results at word-level granularity (including punctuation and speech rate values)..
         */
        resTextFormat?: string;
        /**
         * Whether to enable speaker separation: 0 means not enabled, 1 means enabled (only supports 8k_zh, 16k_zh, 16k_zh_video, monophonic audio), the default value is 0, Note: 8K telephony scenarios suggest using dual-channel to distinguish between the two parties, set ChannelNum=2 is enough, no need to enable speaker separation.
         */
        speakerDiarization?: string;
        /**
         * The number of speakers to be separated (need to be used in conjunction with enabling speaker separation), value range: 0-10, 0 means automatic separation (currently only supports <= 6 people), 1-10 represents the number of specified speakers to be separated. The default value is 0.
         */
        speakerNumber?: string;
    }

    export interface MediaTranscodeProTemplateAudio {
        /**
         * Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
         */
        codec: string;
        /**
         * Whether to delete the source audio stream, the value is true, false.
         */
        remove?: string;
    }

    export interface MediaTranscodeProTemplateContainer {
        /**
         * Fragment configuration, valid when format is hls and dash.
         */
        clipConfig?: outputs.Ci.MediaTranscodeProTemplateContainerClipConfig;
        /**
         * Package format.
         */
        format: string;
    }

    export interface MediaTranscodeProTemplateContainerClipConfig {
        /**
         * Fragmentation duration, default 5s.
         */
        duration?: string;
    }

    export interface MediaTranscodeProTemplateTimeInterval {
        /**
         * duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        duration?: string;
        /**
         * Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        start?: string;
    }

    export interface MediaTranscodeProTemplateTransConfig {
        /**
         * Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
         */
        adjDarMethod?: string;
        /**
         * Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
         */
        audioBitrateAdjMethod?: string;
        /**
         * Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
         */
        deleteMetadata?: string;
        /**
         * Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
         */
        isCheckAudioBitrate?: string;
        /**
         * Whether to check the resolution, when it is false, transcode according to the configuration parameters.
         */
        isCheckReso?: string;
        /**
         * Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
         */
        isCheckVideoBitrate?: string;
        /**
         * Whether to enable HDR to SDR true, false.
         */
        isHdr2Sdr?: string;
        /**
         * Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
         */
        resoAdjMethod?: string;
        /**
         * Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
         */
        videoBitrateAdjMethod?: string;
    }

    export interface MediaTranscodeProTemplateVideo {
        /**
         * Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
         */
        bitrate?: string;
        /**
         * Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
         */
        codec?: string;
        /**
         * Frame rate, value range: (0, 60], Unit: fps.
         */
        fps?: string;
        /**
         * High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
         */
        height?: string;
        /**
         * field pattern.
         */
        interlaced?: string;
        /**
         * encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
         */
        profile?: string;
        /**
         * Rotation angle, Value range: [0, 360), Unit: degree.
         */
        rotate?: string;
        /**
         * width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
         */
        width?: string;
    }

    export interface MediaTranscodeTemplateAudio {
        /**
         * Original audio bit rate, unit: Kbps, Value range: [8, 1000].
         */
        bitrate?: string;
        /**
         * number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3/opus, support 1, 2- When Codec is set to Vorbis, only 2 is supported- When Codec is set to amr, only 1 is supported- When Codec is set to pcm_s16le, only 1 and 2 are supported- When the encapsulation format is dash, 8 is not supported.
         */
        channels?: string;
        /**
         * Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
         */
        codec?: string;
        /**
         * Keep dual audio tracks, the value is true, false. This parameter is invalid when Video.Codec is H.265.
         */
        keepTwoTracks?: string;
        /**
         * Whether to delete the source audio stream, the value is true, false.
         */
        remove?: string;
        /**
         * Sampling bit width- When Codec is set to aac, support fltp- When Codec is set to mp3, fltp, s16p, s32p are supported- When Codec is set to flac, s16, s32, s16p, s32p are supported- When Codec is set to amr, support s16, s16p- When Codec is set to opus, support s16- When Codec is set to pcm_s16le, support s16- When Codec is set to Vorbis, support fltp- This parameter is invalid when Video.Codec is H.265.
         */
        sampleFormat?: string;
        /**
         * Sampling Rate- Unit: Hz- Optional 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below- When Codec is set to amr, only 8000 is supported- When Codec is set to opus, it supports 8000, 16000, 24000, 48000.
         */
        samplerate?: string;
        /**
         * Convert track, the value is true, false. This parameter is invalid when Video.Codec is H.265.
         */
        switchTrack?: string;
    }

    export interface MediaTranscodeTemplateAudioMix {
        /**
         * The media address of the audio track that needs to be mixed.
         */
        audioSource: string;
        /**
         * Mix Fade Configuration.
         */
        effectConfig?: outputs.Ci.MediaTranscodeTemplateAudioMixEffectConfig;
        /**
         * Mixing mode Repeat: background sound loop, Once: The background sound is played once.
         */
        mixMode?: string;
        /**
         * Whether to replace the original audio of the Input media file with the mixed audio track media.
         */
        replace?: string;
    }

    export interface MediaTranscodeTemplateAudioMixEffectConfig {
        /**
         * bgm transition fade-in duration, support floating point numbers.
         */
        bgmFadeTime?: string;
        /**
         * Enable bgm conversion fade in.
         */
        enableBgmFade?: string;
        /**
         * enable fade out.
         */
        enableEndFadeout?: string;
        /**
         * enable fade in.
         */
        enableStartFadein?: string;
        /**
         * fade out time, greater than 0, support floating point numbers.
         */
        endFadeoutTime?: string;
        /**
         * Fade in duration, greater than 0, support floating point numbers.
         */
        startFadeinTime?: string;
    }

    export interface MediaTranscodeTemplateContainer {
        /**
         * Fragment configuration, valid when format is hls and dash.
         */
        clipConfig?: outputs.Ci.MediaTranscodeTemplateContainerClipConfig;
        /**
         * Package format.
         */
        format: string;
    }

    export interface MediaTranscodeTemplateContainerClipConfig {
        /**
         * Fragmentation duration, default 5s.
         */
        duration?: string;
    }

    export interface MediaTranscodeTemplateTimeInterval {
        /**
         * duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        duration?: string;
        /**
         * Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
         */
        start?: string;
    }

    export interface MediaTranscodeTemplateTransConfig {
        /**
         * Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
         */
        adjDarMethod?: string;
        /**
         * Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
         */
        audioBitrateAdjMethod?: string;
        /**
         * Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
         */
        deleteMetadata?: string;
        /**
         * hls encryption configuration.
         */
        hlsEncrypt: outputs.Ci.MediaTranscodeTemplateTransConfigHlsEncrypt;
        /**
         * Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
         */
        isCheckAudioBitrate?: string;
        /**
         * Whether to check the resolution, when it is false, transcode according to the configuration parameters.
         */
        isCheckReso?: string;
        /**
         * Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
         */
        isCheckVideoBitrate?: string;
        /**
         * Whether to enable HDR to SDR true, false.
         */
        isHdr2Sdr?: string;
        /**
         * Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
         */
        resoAdjMethod?: string;
        /**
         * Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
         */
        videoBitrateAdjMethod?: string;
    }

    export interface MediaTranscodeTemplateTransConfigHlsEncrypt {
        /**
         * Whether to enable HLS encryption, support encryption when Container.Format is hls.
         */
        isHlsEncrypt: string;
        /**
         * HLS encrypted key, this parameter is only meaningful when IsHlsEncrypt is true.
         */
        uriKey: string;
    }

    export interface MediaTranscodeTemplateVideo {
        /**
         * Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
         */
        bitrate?: string;
        /**
         * buffer size, Value range: [1000, 128000], Unit: Kb, This parameter is not supported when Codec is VP8/VP9.
         */
        bufsize?: string;
        /**
         * Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
         */
        codec?: string;
        /**
         * Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
         */
        crf?: string;
        /**
         * Frame rate, value range: (0, 60], Unit: fps.
         */
        fps?: string;
        /**
         * The maximum number of frames between key frames, value range: [1, 100000].
         */
        gop?: string;
        /**
         * High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
         */
        height?: string;
        /**
         * Adaptive length,true, false, This parameter is not supported when Codec is VP8/VP9/AV1.
         */
        longShortMode?: string;
        /**
         * Peak video bit rate, Value range: [10, 50000], Unit: Kbps, This parameter is not supported when Codec is VP8/VP9.
         */
        maxrate?: string;
        /**
         * video color format, H.264 support: yuv420p, yuv422p, yuv444p, yuvj420p, yuvj422p, yuvj444p, auto, H.265 support: yuv420p, yuv420p10le, auto, This parameter is not supported when Codec is VP8/VP9/AV1.
         */
        pixfmt?: string;
        /**
         * Video Algorithm Presets- H.264 supports this parameter, the values are veryfast, fast, medium, slow, slower- VP8 supports this parameter, the value is good, realtime- AV1 supports this parameter, the value is 5 (recommended value), 4- H.265 and VP9 do not support this parameter.
         */
        preset?: string;
        /**
         * encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
         */
        profile?: string;
        /**
         * Whether to delete the video stream, true, false.
         */
        remove?: string;
        /**
         * Rotation angle, Value range: [0, 360), Unit: degree.
         */
        rotate?: string;
        /**
         * width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
         */
        width?: string;
    }

    export interface MediaVideoMontageTemplateAudio {
        /**
         * Original audio bit rate, unit: Kbps, Value range: [8, 1000].
         */
        bitrate?: string;
        /**
         * number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
         */
        channels?: string;
        /**
         * Codec format, value aac, mp3.
         */
        codec: string;
        /**
         * Whether to delete the source audio stream, the value is true, false.
         */
        remove?: string;
        /**
         * Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
         */
        samplerate?: string;
    }

    export interface MediaVideoMontageTemplateAudioMix {
        /**
         * The media address of the audio track that needs to be mixed.
         */
        audioSource: string;
        /**
         * Mix Fade Configuration.
         */
        effectConfig?: outputs.Ci.MediaVideoMontageTemplateAudioMixEffectConfig;
        /**
         * Mixing mode Repeat: background sound loop, Once: The background sound is played once.
         */
        mixMode?: string;
        /**
         * Whether to replace the original audio of the Input media file with the mixed audio track media.
         */
        replace?: string;
    }

    export interface MediaVideoMontageTemplateAudioMixEffectConfig {
        /**
         * bgm transition fade-in duration, support floating point numbers.
         */
        bgmFadeTime?: string;
        /**
         * Enable bgm conversion fade in.
         */
        enableBgmFade?: string;
        /**
         * enable fade out.
         */
        enableEndFadeout?: string;
        /**
         * enable fade in.
         */
        enableStartFadein?: string;
        /**
         * fade out time, greater than 0, support floating point numbers.
         */
        endFadeoutTime?: string;
        /**
         * Fade in duration, greater than 0, support floating point numbers.
         */
        startFadeinTime?: string;
    }

    export interface MediaVideoMontageTemplateContainer {
        /**
         * Container format: mp4, flv, hls, ts, mkv.
         */
        format: string;
    }

    export interface MediaVideoMontageTemplateVideo {
        /**
         * Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
         */
        bitrate?: string;
        /**
         * Codec format `H.264`.
         */
        codec: string;
        /**
         * Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
         */
        crf?: string;
        /**
         * Frame rate, value range: (0, 60], Unit: fps.
         */
        fps?: string;
        /**
         * High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
         */
        height?: string;
        /**
         * Whether to delete the source audio stream, the value is true, false.
         */
        remove?: string;
        /**
         * width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
         */
        width?: string;
    }

    export interface MediaVideoProcessTemplateColorEnhance {
        /**
         * Contrast, value range: [0, 100], empty string (indicates automatic analysis).
         */
        contrast?: string;
        /**
         * colorcorrection, value range: [0, 100], empty string (indicating automatic analysis).
         */
        correction?: string;
        /**
         * Whether color enhancement is turned on.
         */
        enable?: string;
        /**
         * Saturation, value range: [0, 100], empty string (indicating automatic analysis).
         */
        saturation?: string;
    }

    export interface MediaVideoProcessTemplateMsSharpen {
        /**
         * Whether detail enhancement is enabled.
         */
        enable?: string;
        /**
         * Enhancement level, value range: [0, 10], empty string (indicates automatic analysis).
         */
        sharpenLevel?: string;
    }

    export interface MediaVoiceSeparateTemplateAudioConfig {
        /**
         * Original audio bit rate, unit: Kbps, Value range: [8, 1000].
         */
        bitrate?: string;
        /**
         * number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2- When Codec is set to amr, only 1 is supported.
         */
        channels?: string;
        /**
         * Codec format, value aac, mp3, flac, amr.
         */
        codec: string;
        /**
         * Sampling Rate- 1: Unit: Hz- 2: Optional 8000, 11025, 22050, 32000, 44100, 48000, 96000- 3: When Codec is set to aac/flac, 8000 is not supported- 4: When Codec is set to mp3, 8000 and 96000 are not supported- 5: When Codec is set to amr, only 8000 is supported.
         */
        samplerate?: string;
    }

    export interface MediaWatermarkTemplateWatermark {
        /**
         * Horizontal offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ], 2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Top, Bottom and Center, the parameter is invalid.
         */
        dx: string;
        /**
         * Vertical offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ],2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096],3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Left, Right and Center, the parameter is invalid.
         */
        dy: string;
        /**
         * Watermark end time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
         */
        endTime?: string;
        /**
         * Image watermark node.
         */
        image?: outputs.Ci.MediaWatermarkTemplateWatermarkImage;
        /**
         * Offset method, Relativity: proportional, Absolute: fixed position.
         */
        locMode: string;
        /**
         * Reference position, TopRight, TopLeft, BottomRight, BottomLeft, Left, Right, Top, Bottom, Center.
         */
        pos: string;
        /**
         * Watermark start time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
         */
        startTime?: string;
        /**
         * Text Watermark Node.
         */
        text?: outputs.Ci.MediaWatermarkTemplateWatermarkText;
        /**
         * Watermark type, Text: text watermark, Image: image watermark.
         */
        type: string;
    }

    export interface MediaWatermarkTemplateWatermarkImage {
        /**
         * Whether the background image.
         */
        background: string;
        /**
         * High, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
         */
        height?: string;
        /**
         * Size mode, Original: original size, Proportion: proportional, Fixed: fixed size.
         */
        mode: string;
        /**
         * Transparency, value range: [1 100], unit %.
         */
        transparency: string;
        /**
         * Address of watermark map (pass in after Urlencode is required).
         */
        url: string;
        /**
         * Width, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
         */
        width?: string;
    }

    export interface MediaWatermarkTemplateWatermarkText {
        /**
         * Font color, format: 0xRRGGBB.
         */
        fontColor: string;
        /**
         * Font size, value range: [5 100], unit px.
         */
        fontSize: string;
        /**
         * font type.
         */
        fontType: string;
        /**
         * Watermark content, the length does not exceed 64 characters, only supports Chinese, English, numbers, _, - and *.
         */
        text: string;
        /**
         * Transparency, value range: [1 100], unit %.
         */
        transparency: string;
    }

}

export namespace Ckafka {
    export interface AclRuleRuleList {
        /**
         * The default is *, which means that any host can be accessed. Currently, ckafka does not support host and ip network segment.
         */
        host: string;
        /**
         * Acl operation mode, enumeration value (all operations All, read Read, write Write).
         */
        operation: string;
        /**
         * permission type, (Deny|Allow).
         */
        permissionType: string;
        /**
         * User list, the default is User:, which means that any user can access, and the current user can only be the user included in the user list. The input format needs to be prefixed with [User:]. For example, user A is passed in as User:A.
         */
        principal: string;
    }

    export interface ConnectResourceClickhouseConnectParam {
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * Password for Clickhouse connection source.
         */
        password: string;
        /**
         * Clickhouse connection port.
         */
        port: number;
        /**
         * Instance resources for Click House connection sources.
         */
        resource: string;
        /**
         * Whether the Clickhouse connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Instance VIP of the ClickHouse connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * The vpc Id of the source of the ClickHouse connection, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId?: string;
        /**
         * The username of the clickhouse connection source.
         */
        userName: string;
    }

    export interface ConnectResourceDorisConnectParam {
        /**
         * Doris http CLB port, Usually mapped to port 8040 of be.
         */
        bePort?: number;
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * Doris  password.
         */
        password: string;
        /**
         * Doris jdbc CLB port, Usually mapped to port 9030 of fe.
         */
        port: number;
        /**
         * Doris  instanceId.
         */
        resource: string;
        /**
         * Doris Whether the connection source is a self-built cluster, default: false.
         */
        selfBuilt?: boolean;
        /**
         * Doris vip, When it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * Doris vpcId, When it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId?: string;
        /**
         * Doris  The username of the connection source.
         */
        userName: string;
    }

    export interface ConnectResourceDtsConnectParam {
        /**
         * Id of the Dts consumption group.
         */
        groupId: string;
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * The password of the Dts consumption group.
         */
        password: string;
        /**
         * Dts port.
         */
        port: number;
        /**
         * Dts instance Id.
         */
        resource: string;
        /**
         * Topic subscribed by Dts.
         */
        topic: string;
        /**
         * The account number of the Dts consumption group.
         */
        userName: string;
    }

    export interface ConnectResourceEsConnectParam {
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * Es The password of the connection source.
         */
        password: string;
        /**
         * Es port.
         */
        port: number;
        /**
         * Instance resource of Es connection source.
         */
        resource: string;
        /**
         * Whether the Es connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * The instance vip of the Es connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * The vpc Id of the Es connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId?: string;
        /**
         * Es The username of the connection source.
         */
        userName: string;
    }

    export interface ConnectResourceKafkaConnectParam {
        /**
         * Kafka broker ip, Mandatory when self-built.
         */
        brokerAddress?: string;
        /**
         * Whether to update to the associated Dip task, default: false.
         */
        isUpdate?: boolean;
        /**
         * CKafka instanceId region, Required when crossing regions.
         */
        region?: string;
        /**
         * Kafka instanceId, When it is a Tencent Cloud instance, it is required.
         */
        resource?: string;
        /**
         * Whether it is a self-built cluster, default: false.
         */
        selfBuilt?: boolean;
    }

    export interface ConnectResourceMariadbConnectParam {
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * MariaDB password.
         */
        password: string;
        /**
         * MariaDB port.
         */
        port: number;
        /**
         * MariaDB instanceId.
         */
        resource: string;
        /**
         * The instance vip of the Maria DB connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * MariaDB vpcId, When it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId?: string;
        /**
         * MariaDB The username of the connection source.
         */
        userName: string;
    }

    export interface ConnectResourceMongodbConnectParam {
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * Password for the source of the Mongo DB connection.
         */
        password: string;
        /**
         * MongoDB port.
         */
        port: number;
        /**
         * Instance resource of Mongo DB connection source.
         */
        resource: string;
        /**
         * Whether the Mongo DB connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * The instance VIP of the Mongo DB connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * The vpc Id of the Mongo DB connection source, which is required when it is a Tencent Cloud instance.
         */
        uniqVpcId?: string;
        /**
         * The username of the Mongo DB connection source.
         */
        userName: string;
    }

    export interface ConnectResourceMysqlConnectParam {
        /**
         * Required when type is TDSQL C_MYSQL.
         */
        clusterId?: string;
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * Mysql connection source password.
         */
        password: string;
        /**
         * MySQL port.
         */
        port: number;
        /**
         * Instance resource of My SQL connection source.
         */
        resource: string;
        /**
         * Mysql Whether the connection source is a self-built cluster, default: false.
         */
        selfBuilt?: boolean;
        /**
         * The instance vip of the MySQL connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * The vpc Id of the My SQL connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId?: string;
        /**
         * Username of Mysql connection source.
         */
        userName: string;
    }

    export interface ConnectResourcePostgresqlConnectParam {
        /**
         * Required when type is TDSQL C_POSTGRESQL.
         */
        clusterId?: string;
        /**
         * Whether to update to the associated Datahub task, default: false.
         */
        isUpdate?: boolean;
        /**
         * PostgreSQL password.
         */
        password: string;
        /**
         * PostgreSQL port.
         */
        port: number;
        /**
         * PostgreSQL instanceId.
         */
        resource: string;
        /**
         * PostgreSQL Whether the connection source is a self-built cluster, default: false.
         */
        selfBuilt?: boolean;
        /**
         * The instance VIP of the Postgresql connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * The instance vpcId of the Postgresql connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId?: string;
        /**
         * PostgreSQL The username of the connection source.
         */
        userName: string;
    }

    export interface ConnectResourceSqlserverConnectParam {
        /**
         * Whether to update to the associated Dip task, default: false.
         */
        isUpdate?: boolean;
        /**
         * SQLServer password.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * SQLServer instanceId.
         */
        resource: string;
        /**
         * SQLServer instance vip, When it is a Tencent Cloud instance, it is required.
         */
        serviceVip?: string;
        /**
         * SQLServer vpcId, When it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId?: string;
        /**
         * SQLServer The username of the connection source.
         */
        userName: string;
    }

    export interface DatahubTaskSourceResource {
        /**
         * ClickHouse config, Type CLICKHOUSE requierd.
         */
        clickHouseParam?: outputs.Ckafka.DatahubTaskSourceResourceClickHouseParam;
        /**
         * Cls configuration, Required when Type is CLS.
         */
        clsParam?: outputs.Ckafka.DatahubTaskSourceResourceClsParam;
        /**
         * Cos configuration, required when Type is COS.
         */
        cosParam?: outputs.Ckafka.DatahubTaskSourceResourceCosParam;
        /**
         * Ctsdb configuration, Required when Type is CTSDB.
         */
        ctsdbParam?: outputs.Ckafka.DatahubTaskSourceResourceCtsdbParam;
        /**
         * Dts configuration, required when Type is DTS.
         */
        dtsParam?: outputs.Ckafka.DatahubTaskSourceResourceDtsParam;
        /**
         * Es configuration, required when Type is ES.
         */
        esParam?: outputs.Ckafka.DatahubTaskSourceResourceEsParam;
        /**
         * EB configuration, required when type is EB.
         */
        eventBusParam?: outputs.Ckafka.DatahubTaskSourceResourceEventBusParam;
        /**
         * ckafka configuration, required when Type is KAFKA.
         */
        kafkaParam?: outputs.Ckafka.DatahubTaskSourceResourceKafkaParam;
        /**
         * MariaDB configuration, Required when Type is MARIADB.
         */
        mariaDbParam?: outputs.Ckafka.DatahubTaskSourceResourceMariaDbParam;
        /**
         * MongoDB config, Required when Type is MONGODB.
         */
        mongoDbParam?: outputs.Ckafka.DatahubTaskSourceResourceMongoDbParam;
        /**
         * MySQL configuration, Required when Type is MYSQL.
         */
        mySqlParam?: outputs.Ckafka.DatahubTaskSourceResourceMySqlParam;
        /**
         * PostgreSQL configuration, Required when Type is POSTGRESQL or TDSQL C_POSTGRESQL.
         */
        postgreSqlParam?: outputs.Ckafka.DatahubTaskSourceResourcePostgreSqlParam;
        /**
         * Scf configuration, Required when Type is SCF.
         */
        scfParam?: outputs.Ckafka.DatahubTaskSourceResourceScfParam;
        /**
         * SQLServer configuration, Required when Type is SQLSERVER.
         */
        sqlServerParam?: outputs.Ckafka.DatahubTaskSourceResourceSqlServerParam;
        /**
         * Tdw configuration, required when Type is TDW.
         */
        tdwParam?: outputs.Ckafka.DatahubTaskSourceResourceTdwParam;
        /**
         * Topic configuration, Required when Type is Topic.
         */
        topicParam?: outputs.Ckafka.DatahubTaskSourceResourceTopicParam;
        /**
         * resource type.
         */
        type: string;
    }

    export interface DatahubTaskSourceResourceClickHouseParam {
        /**
         * ClickHouse cluster.
         */
        cluster: string;
        /**
         * ClickHouse database name.
         */
        database: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls?: outputs.Ckafka.DatahubTaskSourceResourceClickHouseParamDropCls;
        /**
         * Whether ClickHouse discards the message that fails to parse, the default is true.
         */
        dropInvalidMessage?: boolean;
        /**
         * ClickHouse ip.
         */
        ip?: string;
        /**
         * ClickHouse passwd.
         */
        password?: string;
        /**
         * ClickHouse port.
         */
        port?: number;
        /**
         * resource id.
         */
        resource: string;
        /**
         * ClickHouse schema.
         */
        schemas: outputs.Ckafka.DatahubTaskSourceResourceClickHouseParamSchema[];
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt?: boolean;
        /**
         * instance vip.
         */
        serviceVip?: string;
        /**
         * ClickHouse table.
         */
        table: string;
        /**
         * ClickHouse type, emr-clickhouse: emr;cdw-clickhouse: cdwch;selfBuilt: ``.
         */
        type?: string;
        /**
         * instance vpc id.
         */
        uniqVpcId?: string;
        /**
         * ClickHouse user name.
         */
        userName?: string;
    }

    export interface DatahubTaskSourceResourceClickHouseParamDropCls {
        /**
         * cls LogSet id.
         */
        dropClsLogSet?: string;
        /**
         * account.
         */
        dropClsOwneruin?: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion?: string;
        /**
         * cls topic.
         */
        dropClsTopicId?: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskSourceResourceClickHouseParamSchema {
        /**
         * Whether the column item is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * column name.
         */
        columnName: string;
        /**
         * The json Key name corresponding to this column.
         */
        jsonKey: string;
        /**
         * type of table column.
         */
        type: string;
    }

    export interface DatahubTaskSourceResourceClsParam {
        /**
         * Required when Decode Json is false.
         */
        contentKey?: string;
        /**
         * Whether the produced information is in json format.
         */
        decodeJson: boolean;
        /**
         * LogSet id.
         */
        logSet?: string;
        /**
         * cls id.
         */
        resource: string;
        /**
         * Specify the content of a field in the message as the time of the cls log. The format of the field content needs to be a second-level timestamp.
         */
        timeField?: string;
    }

    export interface DatahubTaskSourceResourceCosParam {
        /**
         * The size of aggregated messages MB.
         */
        aggregateBatchSize?: number;
        /**
         * time interval.
         */
        aggregateInterval?: number;
        /**
         * cos bucket name.
         */
        bucketName: string;
        /**
         * Partition format formatted according to strptime time.
         */
        directoryTimeFormat?: string;
        /**
         * The file format after message aggregation csv|json.
         */
        formatOutputType?: string;
        /**
         * ObjectKey.
         */
        objectKey?: string;
        /**
         * Dumped object directory prefix.
         */
        objectKeyPrefix?: string;
        /**
         * region code.
         */
        region: string;
    }

    export interface DatahubTaskSourceResourceCtsdbParam {
        /**
         * Ctsdb metric.
         */
        ctsdbMetric?: string;
        /**
         * resource id.
         */
        resource?: string;
    }

    export interface DatahubTaskSourceResourceDtsParam {
        /**
         * Dts consumer group Id.
         */
        groupId?: string;
        /**
         * Dts consumer group passwd.
         */
        groupPassword?: string;
        /**
         * Dts account.
         */
        groupUser?: string;
        /**
         * Dts connection ip.
         */
        ip?: string;
        /**
         * Dts connection port.
         */
        port?: number;
        /**
         * Dts instance Id.
         */
        resource: string;
        /**
         * Dts topic.
         */
        topic?: string;
        /**
         * False to synchronize the original data, true to synchronize the parsed json format data, the default is true.
         */
        tranSql?: boolean;
    }

    export interface DatahubTaskSourceResourceEsParam {
        /**
         * key for data in non-json format.
         */
        contentKey?: string;
        /**
         * When the message dumped to ES is the binlog of Database, if you need to synchronize database operations, that is, fill in the primary key of the database table when adding, deleting, and modifying operations to ES.
         */
        databasePrimaryKey?: string;
        /**
         * Es date suffix.
         */
        dateFormat?: string;
        /**
         * The field name of the document ID value dumped into Es.
         */
        documentIdField?: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropCls;
        /**
         * dead letter queue.
         */
        dropDlq?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlq;
        /**
         * Whether Es discards messages in non-json format.
         */
        dropInvalidJsonMessage?: boolean;
        /**
         * Whether Es discards the message of parsing failure.
         */
        dropInvalidMessage?: boolean;
        /**
         * Es index name.
         */
        index?: string;
        /**
         * Es custom index name type, STRING, JSONPATH, the default is STRING.
         */
        indexType?: string;
        /**
         * Es Password.
         */
        password?: string;
        /**
         * Es connection port.
         */
        port?: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt?: boolean;
        /**
         * instance vip.
         */
        serviceVip?: string;
        /**
         * instance vpc id.
         */
        uniqVpcId?: string;
        /**
         * Es UserName.
         */
        userName?: string;
    }

    export interface DatahubTaskSourceResourceEsParamDropCls {
        /**
         * cls LogSet id.
         */
        dropClsLogSet?: string;
        /**
         * account.
         */
        dropClsOwneruin?: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion?: string;
        /**
         * cls topic.
         */
        dropClsTopicId?: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlq {
        /**
         * dlq type, CKAFKA|TOPIC.
         */
        dlqType?: string;
        /**
         * Ckafka type dlq.
         */
        kafkaParam?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlqKafkaParam;
        /**
         * retry times.
         */
        maxRetryAttempts?: number;
        /**
         * retry interval.
         */
        retryInterval?: number;
        /**
         * DIP Topic type dead letter queue.
         */
        topicParam?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlqTopicParam;
        /**
         * type, DLQ dead letter queue, IGNORE_ERROR|DROP.
         */
        type: string;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlqKafkaParam {
        /**
         * Whether to compress when writing to the Topic, if it is not enabled, fill in none, if it is enabled, fill in open.
         */
        compressionType?: string;
        /**
         * enable dead letter queue.
         */
        enableToleration?: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, from beginning:earliest, from latest:latest, from specific time:timestamp.
         */
        offsetType?: string;
        /**
         * the partition num of the topic.
         */
        partitionNum?: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit?: number;
        /**
         * instance resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName?: string;
        /**
         * whether the cluster is built by yourself instead of cloud product.
         */
        selfBuilt: boolean;
        /**
         * when Offset type timestamp is required.
         */
        startTime?: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlqKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic?: string;
        /**
         * Topic id.
         */
        topicId?: string;
        /**
         * Does the used topic need to be automatically created (currently only supports SOURCE inflow tasks, if you do not use to distribute to multiple topics, you need to fill in the topic name that needs to be automatically created in the Topic field).
         */
        useAutoCreateTopic?: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping?: boolean;
        /**
         * Zone ID.
         */
        zoneId?: number;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlqKafkaParamTableMapping {
        /**
         * database name.
         */
        database: string;
        /**
         * table name,use, to separate.
         */
        table: string;
        /**
         * Topic name.
         */
        topic: string;
        /**
         * Topic ID.
         */
        topicId: string;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlqTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType?: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType?: string;
        /**
         * The topic name of the topic sold separately.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime?: number;
        /**
         * Topic TopicId.
         */
        topicId?: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskSourceResourceEventBusParam {
        /**
         * SCF function name.
         */
        functionName?: string;
        /**
         * SCF namespace.
         */
        namespace?: string;
        /**
         * SCF version and alias.
         */
        qualifier?: string;
        /**
         * instance id.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * resource type. EB_COS/EB_ES/EB_CLS.
         */
        type: string;
    }

    export interface DatahubTaskSourceResourceKafkaParam {
        /**
         * Whether to compress when writing to the Topic, if it is not enabled, fill in none, if it is enabled, fill in open.
         */
        compressionType?: string;
        /**
         * enable dead letter queue.
         */
        enableToleration?: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, from beginning:earliest, from latest:latest, from specific time:timestamp.
         */
        offsetType?: string;
        /**
         * the partition num of the topic.
         */
        partitionNum?: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit?: number;
        /**
         * instance resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName?: string;
        /**
         * whether the cluster is built by yourself instead of cloud product.
         */
        selfBuilt: boolean;
        /**
         * when Offset type timestamp is required.
         */
        startTime?: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings?: outputs.Ckafka.DatahubTaskSourceResourceKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic?: string;
        /**
         * Topic id.
         */
        topicId?: string;
        /**
         * Does the used topic need to be automatically created (currently only supports SOURCE inflow tasks, if you do not use to distribute to multiple topics, you need to fill in the topic name that needs to be automatically created in the Topic field).
         */
        useAutoCreateTopic?: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping?: boolean;
        /**
         * Zone ID.
         */
        zoneId?: number;
    }

    export interface DatahubTaskSourceResourceKafkaParamTableMapping {
        /**
         * database name.
         */
        database: string;
        /**
         * table name,use, to separate.
         */
        table: string;
        /**
         * Topic name.
         */
        topic: string;
        /**
         * Topic ID.
         */
        topicId: string;
    }

    export interface DatahubTaskSourceResourceMariaDbParam {
        /**
         * MariaDB database name, * for all database.
         */
        database: string;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges?: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery?: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix?: boolean;
        /**
         * Format  library 1. table 1: field 1, field 2; library 2. table 2: field 2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns?: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat?: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema?: boolean;
        /**
         * MariaDB connection Id.
         */
        resource: string;
        /**
         * schema_only|initial, default initial.
         */
        snapshotMode?: string;
        /**
         * MariaDB db name, *is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface DatahubTaskSourceResourceMongoDbParam {
        /**
         * MongoDB collection.
         */
        collection: string;
        /**
         * Whether to copy the stock data, the default parameter is true.
         */
        copyExisting: boolean;
        /**
         * MongoDB database name.
         */
        database: string;
        /**
         * Mongo DB connection ip.
         */
        ip?: string;
        /**
         * Listening event type, if it is empty, it means select all. Values include insert, update, replace, delete, invalidate, drop, dropdatabase, rename, used between multiple types, separated by commas.
         */
        listeningEvent?: string;
        /**
         * MongoDB database password.
         */
        password?: string;
        /**
         * aggregation pipeline.
         */
        pipeline?: string;
        /**
         * MongoDB connection port.
         */
        port?: number;
        /**
         * Master-slave priority, default master node.
         */
        readPreference?: string;
        /**
         * resource id.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt?: boolean;
        /**
         * MongoDB database user name.
         */
        userName?: string;
    }

    export interface DatahubTaskSourceResourceMySqlParam {
        /**
         * the name of the column to be monitored.
         */
        dataSourceIncrementColumn?: string;
        /**
         * TIMESTAMP indicates that the incremental column is of timestamp type, INCREMENT indicates that the incremental column is of self-incrementing id type.
         */
        dataSourceIncrementMode?: string;
        /**
         * TABLE indicates that the read item is a table, QUERY indicates that the read item is a query.
         */
        dataSourceMonitorMode?: string;
        /**
         * When DataMonitorMode=TABLE, pass in the Table that needs to be read; when DataMonitorMode=QUERY, pass in the query sql statement that needs to be read.
         */
        dataSourceMonitorResource?: string;
        /**
         * HEAD means copy stock + incremental data, TAIL means copy only incremental data.
         */
        dataSourceStartFrom?: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode?: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField?: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskSourceResourceMySqlParamDataTargetRecordMapping[];
        /**
         * MySQL database name, * is the whole database.
         */
        database: string;
        /**
         * The Topic that stores the Ddl information of My SQL, if it is empty, it will not be stored by default.
         */
        ddlTopic?: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls?: outputs.Ckafka.DatahubTaskSourceResourceMySqlParamDropCls;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage?: boolean;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges?: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery?: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix?: boolean;
        /**
         * Whether the input table is a regular expression, if this option and Is Table Prefix are true at the same time, the judgment priority of this option is higher than Is Table Prefix.
         */
        isTableRegular?: boolean;
        /**
         * Format library1.table1 field 1,field 2;library 2.table2 field 2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns?: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat?: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema?: boolean;
        /**
         * MySQL connection Id.
         */
        resource: string;
        /**
         * database name of signal table.
         */
        signalDatabase?: string;
        /**
         * whether to Copy inventory information (schema_only does not copy, initial full amount), the default is initial.
         */
        snapshotMode?: string;
        /**
         * The name of the MySQL data table,  is the non-system table in all the monitored databases, which can be separated by, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name, when a regular expression needs to be filled in, the format is data database name.data table name.
         */
        table: string;
        /**
         * Regular expression for routing events to specific topics, defaults to (.*).
         */
        topicRegex?: string;
        /**
         * TopicRegex, $1, $2.
         */
        topicReplacement?: string;
    }

    export interface DatahubTaskSourceResourceMySqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull?: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement?: boolean;
        /**
         * Column Name.
         */
        columnName?: string;
        /**
         * current ColumnSize.
         */
        columnSize?: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits?: string;
        /**
         * Database table default parameters.
         */
        defaultValue?: string;
        /**
         * Database table extra fields.
         */
        extraInfo?: string;
        /**
         * The key name of the message.
         */
        jsonKey?: string;
        /**
         * message type.
         */
        type?: string;
    }

    export interface DatahubTaskSourceResourceMySqlParamDropCls {
        /**
         * cls LogSet id.
         */
        dropClsLogSet?: string;
        /**
         * account.
         */
        dropClsOwneruin?: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion?: string;
        /**
         * cls topic.
         */
        dropClsTopicId?: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskSourceResourcePostgreSqlParam {
        /**
         * Upstream data format (JSON|Debezium), required when the database synchronization mode matches the default field.
         */
        dataFormat?: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode?: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField?: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskSourceResourcePostgreSqlParamDataTargetRecordMapping[];
        /**
         * PostgreSQL database name.
         */
        database: string;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage?: boolean;
        /**
         * Whether the input table is a regular expression.
         */
        isTableRegular?: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns?: string;
        /**
         * (decoderbufs/pgoutput), default decoderbufs.
         */
        pluginName: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema?: boolean;
        /**
         * PostgreSQL connection Id.
         */
        resource: string;
        /**
         * never|initial, default initial.
         */
        snapshotMode?: string;
        /**
         * PostgreSQL tableName, * is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of Schema name.Data table name, and you need to fill in a regular expression When, the format is Schema name.data table name.
         */
        table: string;
    }

    export interface DatahubTaskSourceResourcePostgreSqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull?: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement?: boolean;
        /**
         * Column Name.
         */
        columnName?: string;
        /**
         * current ColumnSize.
         */
        columnSize?: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits?: string;
        /**
         * Database table default parameters.
         */
        defaultValue?: string;
        /**
         * Database table extra fields.
         */
        extraInfo?: string;
        /**
         * The key name of the message.
         */
        jsonKey?: string;
        /**
         * message type.
         */
        type?: string;
    }

    export interface DatahubTaskSourceResourceScfParam {
        /**
         * The maximum number of messages sent in each batch, the default is 1000.
         */
        batchSize?: number;
        /**
         * SCF function name.
         */
        functionName: string;
        /**
         * The number of retries after the SCF call fails, the default is 5.
         */
        maxRetries?: number;
        /**
         * SCF cloud function namespace, the default is default.
         */
        namespace?: string;
        /**
         * SCF cloud function version and alias, the default is DEFAULT.
         */
        qualifier?: string;
    }

    export interface DatahubTaskSourceResourceSqlServerParam {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * SQLServer connection Id.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode?: string;
        /**
         * SQLServer table, *is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface DatahubTaskSourceResourceTdwParam {
        /**
         * Tdw bid.
         */
        bid: string;
        /**
         * default true.
         */
        isDomestic?: boolean;
        /**
         * TDW address, defalt tl-tdbank-tdmanager.tencent-distribute.com.
         */
        tdwHost?: string;
        /**
         * TDW port, default 8099.
         */
        tdwPort?: number;
        /**
         * Tdw tid.
         */
        tid: string;
    }

    export interface DatahubTaskSourceResourceTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType?: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType?: string;
        /**
         * The topic name of the topic sold separately.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime?: number;
        /**
         * Topic TopicId.
         */
        topicId?: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTargetResource {
        /**
         * ClickHouse config, Type CLICKHOUSE requierd.
         */
        clickHouseParam?: outputs.Ckafka.DatahubTaskTargetResourceClickHouseParam;
        /**
         * Cls configuration, Required when Type is CLS.
         */
        clsParam?: outputs.Ckafka.DatahubTaskTargetResourceClsParam;
        /**
         * Cos configuration, required when Type is COS.
         */
        cosParam?: outputs.Ckafka.DatahubTaskTargetResourceCosParam;
        /**
         * Ctsdb configuration, Required when Type is CTSDB.
         */
        ctsdbParam?: outputs.Ckafka.DatahubTaskTargetResourceCtsdbParam;
        /**
         * Dts configuration, required when Type is DTS.
         */
        dtsParam?: outputs.Ckafka.DatahubTaskTargetResourceDtsParam;
        /**
         * Es configuration, required when Type is ES.
         */
        esParam?: outputs.Ckafka.DatahubTaskTargetResourceEsParam;
        /**
         * EB configuration, required when type is EB.
         */
        eventBusParam?: outputs.Ckafka.DatahubTaskTargetResourceEventBusParam;
        /**
         * ckafka configuration, required when Type is KAFKA.
         */
        kafkaParam?: outputs.Ckafka.DatahubTaskTargetResourceKafkaParam;
        /**
         * MariaDB configuration, Required when Type is MARIADB.
         */
        mariaDbParam?: outputs.Ckafka.DatahubTaskTargetResourceMariaDbParam;
        /**
         * MongoDB config, Required when Type is MONGODB.
         */
        mongoDbParam?: outputs.Ckafka.DatahubTaskTargetResourceMongoDbParam;
        /**
         * MySQL configuration, Required when Type is MYSQL.
         */
        mySqlParam?: outputs.Ckafka.DatahubTaskTargetResourceMySqlParam;
        /**
         * PostgreSQL configuration, Required when Type is POSTGRESQL or TDSQL C_POSTGRESQL.
         */
        postgreSqlParam?: outputs.Ckafka.DatahubTaskTargetResourcePostgreSqlParam;
        /**
         * Scf configuration, Required when Type is SCF.
         */
        scfParam?: outputs.Ckafka.DatahubTaskTargetResourceScfParam;
        /**
         * SQLServer configuration, Required when Type is SQLSERVER.
         */
        sqlServerParam?: outputs.Ckafka.DatahubTaskTargetResourceSqlServerParam;
        /**
         * Tdw configuration, required when Type is TDW.
         */
        tdwParam?: outputs.Ckafka.DatahubTaskTargetResourceTdwParam;
        /**
         * Topic configuration, Required when Type is Topic.
         */
        topicParam?: outputs.Ckafka.DatahubTaskTargetResourceTopicParam;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface DatahubTaskTargetResourceClickHouseParam {
        /**
         * ClickHouse cluster.
         */
        cluster: string;
        /**
         * ClickHouse database name.
         */
        database: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls?: outputs.Ckafka.DatahubTaskTargetResourceClickHouseParamDropCls;
        /**
         * Whether ClickHouse discards the message that fails to parse, the default is true.
         */
        dropInvalidMessage?: boolean;
        /**
         * ClickHouse ip.
         */
        ip?: string;
        /**
         * ClickHouse passwd.
         */
        password?: string;
        /**
         * ClickHouse port.
         */
        port?: number;
        /**
         * resource id.
         */
        resource: string;
        /**
         * ClickHouse schema.
         */
        schemas: outputs.Ckafka.DatahubTaskTargetResourceClickHouseParamSchema[];
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt?: boolean;
        /**
         * instance vip.
         */
        serviceVip?: string;
        /**
         * ClickHouse table.
         */
        table: string;
        /**
         * ClickHouse type, emr-clickhouse: emr;cdw-clickhouse: cdwch;selfBuilt: ``.
         */
        type?: string;
        /**
         * instance vpc id.
         */
        uniqVpcId?: string;
        /**
         * ClickHouse user name.
         */
        userName?: string;
    }

    export interface DatahubTaskTargetResourceClickHouseParamDropCls {
        /**
         * cls LogSet id.
         */
        dropClsLogSet?: string;
        /**
         * account.
         */
        dropClsOwneruin?: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion?: string;
        /**
         * cls topic.
         */
        dropClsTopicId?: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskTargetResourceClickHouseParamSchema {
        /**
         * Whether the column item is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * column name.
         */
        columnName: string;
        /**
         * The json Key name corresponding to this column.
         */
        jsonKey: string;
        /**
         * type of table column.
         */
        type: string;
    }

    export interface DatahubTaskTargetResourceClsParam {
        /**
         * Required when Decode Json is false.
         */
        contentKey?: string;
        /**
         * Whether the produced information is in json format.
         */
        decodeJson: boolean;
        /**
         * LogSet id.
         */
        logSet?: string;
        /**
         * cls id.
         */
        resource: string;
        /**
         * Specify the content of a field in the message as the time of the cls log. The format of the field content needs to be a second-level timestamp.
         */
        timeField?: string;
    }

    export interface DatahubTaskTargetResourceCosParam {
        /**
         * The size of aggregated messages MB.
         */
        aggregateBatchSize?: number;
        /**
         * time interval.
         */
        aggregateInterval?: number;
        /**
         * cos bucket name.
         */
        bucketName: string;
        /**
         * Partition format formatted according to strptime time.
         */
        directoryTimeFormat?: string;
        /**
         * The file format after message aggregation csv|json.
         */
        formatOutputType?: string;
        /**
         * ObjectKey.
         */
        objectKey?: string;
        /**
         * Dumped object directory prefix.
         */
        objectKeyPrefix?: string;
        /**
         * region code.
         */
        region: string;
    }

    export interface DatahubTaskTargetResourceCtsdbParam {
        /**
         * Ctsdb metric.
         */
        ctsdbMetric?: string;
        /**
         * resource id.
         */
        resource?: string;
    }

    export interface DatahubTaskTargetResourceDtsParam {
        /**
         * Dts consumer group Id.
         */
        groupId?: string;
        /**
         * Dts consumer group passwd.
         */
        groupPassword?: string;
        /**
         * Dts account.
         */
        groupUser?: string;
        /**
         * Dts connection ip.
         */
        ip?: string;
        /**
         * Dts connection port.
         */
        port?: number;
        /**
         * Dts instance Id.
         */
        resource: string;
        /**
         * Dts topic.
         */
        topic?: string;
        /**
         * False to synchronize the original data, true to synchronize the parsed json format data, the default is true.
         */
        tranSql?: boolean;
    }

    export interface DatahubTaskTargetResourceEsParam {
        /**
         * key for data in non-json format.
         */
        contentKey?: string;
        /**
         * When the message dumped to ES is the binlog of Database, if you need to synchronize database operations, that is, fill in the primary key of the database table when adding, deleting, and modifying operations to ES.
         */
        databasePrimaryKey?: string;
        /**
         * Es date suffix.
         */
        dateFormat?: string;
        /**
         * The field name of the document ID value dumped into Es.
         */
        documentIdField?: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropCls;
        /**
         * dead letter queue.
         */
        dropDlq?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlq;
        /**
         * Whether Es discards messages in non-json format.
         */
        dropInvalidJsonMessage?: boolean;
        /**
         * Whether Es discards the message of parsing failure.
         */
        dropInvalidMessage?: boolean;
        /**
         * Es index name.
         */
        index?: string;
        /**
         * Es custom index name type, STRING, JSONPATH, the default is STRING.
         */
        indexType?: string;
        /**
         * Es Password.
         */
        password?: string;
        /**
         * Es connection port.
         */
        port?: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt?: boolean;
        /**
         * instance vip.
         */
        serviceVip?: string;
        /**
         * instance vpc id.
         */
        uniqVpcId?: string;
        /**
         * Es UserName.
         */
        userName?: string;
    }

    export interface DatahubTaskTargetResourceEsParamDropCls {
        /**
         * cls LogSet id.
         */
        dropClsLogSet?: string;
        /**
         * account.
         */
        dropClsOwneruin?: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion?: string;
        /**
         * cls topic.
         */
        dropClsTopicId?: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlq {
        /**
         * dlq type, CKAFKA|TOPIC.
         */
        dlqType?: string;
        /**
         * Ckafka type dlq.
         */
        kafkaParam?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlqKafkaParam;
        /**
         * retry times.
         */
        maxRetryAttempts?: number;
        /**
         * retry interval.
         */
        retryInterval?: number;
        /**
         * DIP Topic type dead letter queue.
         */
        topicParam?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlqTopicParam;
        /**
         * type, DLQ dead letter queue, IGNORE_ERROR|DROP.
         */
        type: string;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlqKafkaParam {
        /**
         * Whether to compress when writing to the Topic, if it is not enabled, fill in none, if it is enabled, fill in open.
         */
        compressionType?: string;
        /**
         * enable dead letter queue.
         */
        enableToleration?: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, from beginning:earliest, from latest:latest, from specific time:timestamp.
         */
        offsetType?: string;
        /**
         * the partition num of the topic.
         */
        partitionNum?: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit?: number;
        /**
         * instance resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName?: string;
        /**
         * whether the cluster is built by yourself instead of cloud product.
         */
        selfBuilt: boolean;
        /**
         * when Offset type timestamp is required.
         */
        startTime?: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlqKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic?: string;
        /**
         * Topic id.
         */
        topicId?: string;
        /**
         * Does the used topic need to be automatically created (currently only supports SOURCE inflow tasks, if you do not use to distribute to multiple topics, you need to fill in the topic name that needs to be automatically created in the Topic field).
         */
        useAutoCreateTopic?: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping?: boolean;
        /**
         * Zone ID.
         */
        zoneId?: number;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlqKafkaParamTableMapping {
        /**
         * database name.
         */
        database: string;
        /**
         * table name,use, to separate.
         */
        table: string;
        /**
         * Topic name.
         */
        topic: string;
        /**
         * Topic ID.
         */
        topicId: string;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlqTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType?: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType?: string;
        /**
         * The topic name of the topic sold separately.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime?: number;
        /**
         * Topic TopicId.
         */
        topicId?: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTargetResourceEventBusParam {
        /**
         * SCF function name.
         */
        functionName?: string;
        /**
         * SCF namespace.
         */
        namespace?: string;
        /**
         * SCF version and alias.
         */
        qualifier?: string;
        /**
         * instance id.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * resource type. EB_COS/EB_ES/EB_CLS.
         */
        type: string;
    }

    export interface DatahubTaskTargetResourceKafkaParam {
        /**
         * Whether to compress when writing to the Topic, if it is not enabled, fill in none, if it is enabled, fill in open.
         */
        compressionType?: string;
        /**
         * enable dead letter queue.
         */
        enableToleration?: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, from beginning:earliest, from latest:latest, from specific time:timestamp.
         */
        offsetType?: string;
        /**
         * the partition num of the topic.
         */
        partitionNum?: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit?: number;
        /**
         * instance resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName?: string;
        /**
         * whether the cluster is built by yourself instead of cloud product.
         */
        selfBuilt: boolean;
        /**
         * when Offset type timestamp is required.
         */
        startTime?: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings?: outputs.Ckafka.DatahubTaskTargetResourceKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic?: string;
        /**
         * Topic id.
         */
        topicId?: string;
        /**
         * Does the used topic need to be automatically created (currently only supports SOURCE inflow tasks, if you do not use to distribute to multiple topics, you need to fill in the topic name that needs to be automatically created in the Topic field).
         */
        useAutoCreateTopic?: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping?: boolean;
        /**
         * Zone ID.
         */
        zoneId?: number;
    }

    export interface DatahubTaskTargetResourceKafkaParamTableMapping {
        /**
         * database name.
         */
        database: string;
        /**
         * table name,use, to separate.
         */
        table: string;
        /**
         * Topic name.
         */
        topic: string;
        /**
         * Topic ID.
         */
        topicId: string;
    }

    export interface DatahubTaskTargetResourceMariaDbParam {
        /**
         * MariaDB database name, * for all database.
         */
        database: string;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges?: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery?: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix?: boolean;
        /**
         * Format  library 1. table 1: field 1, field 2; library 2. table 2: field 2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns?: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat?: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema?: boolean;
        /**
         * MariaDB connection Id.
         */
        resource: string;
        /**
         * schema_only|initial, default initial.
         */
        snapshotMode?: string;
        /**
         * MariaDB db name, *is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface DatahubTaskTargetResourceMongoDbParam {
        /**
         * MongoDB collection.
         */
        collection: string;
        /**
         * Whether to copy the stock data, the default parameter is true.
         */
        copyExisting: boolean;
        /**
         * MongoDB database name.
         */
        database: string;
        /**
         * Mongo DB connection ip.
         */
        ip?: string;
        /**
         * Listening event type, if it is empty, it means select all. Values include insert, update, replace, delete, invalidate, drop, dropdatabase, rename, used between multiple types, separated by commas.
         */
        listeningEvent?: string;
        /**
         * MongoDB database password.
         */
        password?: string;
        /**
         * aggregation pipeline.
         */
        pipeline?: string;
        /**
         * MongoDB connection port.
         */
        port?: number;
        /**
         * Master-slave priority, default master node.
         */
        readPreference?: string;
        /**
         * resource id.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt?: boolean;
        /**
         * MongoDB database user name.
         */
        userName?: string;
    }

    export interface DatahubTaskTargetResourceMySqlParam {
        /**
         * the name of the column to be monitored.
         */
        dataSourceIncrementColumn?: string;
        /**
         * TIMESTAMP indicates that the incremental column is of timestamp type, INCREMENT indicates that the incremental column is of self-incrementing id type.
         */
        dataSourceIncrementMode?: string;
        /**
         * TABLE indicates that the read item is a table, QUERY indicates that the read item is a query.
         */
        dataSourceMonitorMode?: string;
        /**
         * When DataMonitorMode=TABLE, pass in the Table that needs to be read; when DataMonitorMode=QUERY, pass in the query sql statement that needs to be read.
         */
        dataSourceMonitorResource?: string;
        /**
         * HEAD means copy stock + incremental data, TAIL means copy only incremental data.
         */
        dataSourceStartFrom?: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode?: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField?: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskTargetResourceMySqlParamDataTargetRecordMapping[];
        /**
         * MySQL database name, * is the whole database.
         */
        database: string;
        /**
         * The Topic that stores the Ddl information of My SQL, if it is empty, it will not be stored by default.
         */
        ddlTopic?: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls?: outputs.Ckafka.DatahubTaskTargetResourceMySqlParamDropCls;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage?: boolean;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges?: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery?: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix?: boolean;
        /**
         * Whether the input table is a regular expression, if this option and Is Table Prefix are true at the same time, the judgment priority of this option is higher than Is Table Prefix.
         */
        isTableRegular?: boolean;
        /**
         * Format library1.table1 field 1,field 2;library 2.table2 field 2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns?: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat?: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema?: boolean;
        /**
         * MySQL connection Id.
         */
        resource: string;
        /**
         * database name of signal table.
         */
        signalDatabase?: string;
        /**
         * whether to Copy inventory information (schema_only does not copy, initial full amount), the default is initial.
         */
        snapshotMode?: string;
        /**
         * The name of the MySQL data table,  is the non-system table in all the monitored databases, which can be separated by, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name, when a regular expression needs to be filled in, the format is data database name.data table name.
         */
        table: string;
        /**
         * Regular expression for routing events to specific topics, defaults to (.*).
         */
        topicRegex?: string;
        /**
         * TopicRegex, $1, $2.
         */
        topicReplacement?: string;
    }

    export interface DatahubTaskTargetResourceMySqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull?: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement?: boolean;
        /**
         * Column Name.
         */
        columnName?: string;
        /**
         * current ColumnSize.
         */
        columnSize?: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits?: string;
        /**
         * Database table default parameters.
         */
        defaultValue?: string;
        /**
         * Database table extra fields.
         */
        extraInfo?: string;
        /**
         * The key name of the message.
         */
        jsonKey?: string;
        /**
         * message type.
         */
        type?: string;
    }

    export interface DatahubTaskTargetResourceMySqlParamDropCls {
        /**
         * cls LogSet id.
         */
        dropClsLogSet?: string;
        /**
         * account.
         */
        dropClsOwneruin?: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion?: string;
        /**
         * cls topic.
         */
        dropClsTopicId?: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskTargetResourcePostgreSqlParam {
        /**
         * Upstream data format (JSON|Debezium), required when the database synchronization mode matches the default field.
         */
        dataFormat?: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode?: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField?: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskTargetResourcePostgreSqlParamDataTargetRecordMapping[];
        /**
         * PostgreSQL database name.
         */
        database: string;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage?: boolean;
        /**
         * Whether the input table is a regular expression.
         */
        isTableRegular?: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns?: string;
        /**
         * (decoderbufs/pgoutput), default decoderbufs.
         */
        pluginName: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema?: boolean;
        /**
         * PostgreSQL connection Id.
         */
        resource: string;
        /**
         * never|initial, default initial.
         */
        snapshotMode?: string;
        /**
         * PostgreSQL tableName, * is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of Schema name.Data table name, and you need to fill in a regular expression When, the format is Schema name.data table name.
         */
        table: string;
    }

    export interface DatahubTaskTargetResourcePostgreSqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull?: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement?: boolean;
        /**
         * Column Name.
         */
        columnName?: string;
        /**
         * current ColumnSize.
         */
        columnSize?: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits?: string;
        /**
         * Database table default parameters.
         */
        defaultValue?: string;
        /**
         * Database table extra fields.
         */
        extraInfo?: string;
        /**
         * The key name of the message.
         */
        jsonKey?: string;
        /**
         * message type.
         */
        type?: string;
    }

    export interface DatahubTaskTargetResourceScfParam {
        /**
         * The maximum number of messages sent in each batch, the default is 1000.
         */
        batchSize?: number;
        /**
         * SCF function name.
         */
        functionName: string;
        /**
         * The number of retries after the SCF call fails, the default is 5.
         */
        maxRetries?: number;
        /**
         * SCF cloud function namespace, the default is default.
         */
        namespace?: string;
        /**
         * SCF cloud function version and alias, the default is DEFAULT.
         */
        qualifier?: string;
    }

    export interface DatahubTaskTargetResourceSqlServerParam {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * SQLServer connection Id.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode?: string;
        /**
         * SQLServer table, *is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface DatahubTaskTargetResourceTdwParam {
        /**
         * Tdw bid.
         */
        bid: string;
        /**
         * default true.
         */
        isDomestic?: boolean;
        /**
         * TDW address, defalt tl-tdbank-tdmanager.tencent-distribute.com.
         */
        tdwHost?: string;
        /**
         * TDW port, default 8099.
         */
        tdwPort?: number;
        /**
         * Tdw tid.
         */
        tid: string;
    }

    export interface DatahubTaskTargetResourceTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType?: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType?: string;
        /**
         * The topic name of the topic sold separately.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime?: number;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTransformParam {
        /**
         * Analysis result.
         */
        analyseResults?: outputs.Ckafka.DatahubTaskTransformParamAnalyseResult[];
        /**
         * parsing format, JSON | DELIMITER| REGULAR.
         */
        analysisFormat: string;
        /**
         * Raw data.
         */
        content: string;
        /**
         * Whether to keep parsing failure data.
         */
        failureParam: outputs.Ckafka.DatahubTaskTransformParamFailureParam;
        /**
         * filter.
         */
        filterParams?: outputs.Ckafka.DatahubTaskTransformParamFilterParam[];
        /**
         * Map.
         */
        mapParams?: outputs.Ckafka.DatahubTaskTransformParamMapParam[];
        /**
         * output format.
         */
        outputFormat: string;
        /**
         * delimiter, regular expression.
         */
        regex?: string;
        /**
         * Test Results.
         */
        result?: string;
        /**
         * Data source, TOPIC pulls from the source topic, CUSTOMIZE custom.
         */
        sourceType: string;
        /**
         * Whether the underlying engine uses eb.
         */
        useEventBus?: boolean;
    }

    export interface DatahubTaskTransformParamAnalyseResult {
        /**
         * key.
         */
        key: string;
        /**
         * Type, DEFAULT default, DATE system default - timestamp, CUSTOMIZE custom, MAPPING mapping.
         */
        type?: string;
        /**
         * value.
         */
        value?: string;
    }

    export interface DatahubTaskTransformParamFailureParam {
        /**
         * dlq type, CKAFKA|TOPIC.
         */
        dlqType?: string;
        /**
         * Ckafka type dlq.
         */
        kafkaParam?: outputs.Ckafka.DatahubTaskTransformParamFailureParamKafkaParam;
        /**
         * retry times.
         */
        maxRetryAttempts?: number;
        /**
         * retry interval.
         */
        retryInterval?: number;
        /**
         * DIP Topic type dead letter queue.
         */
        topicParam?: outputs.Ckafka.DatahubTaskTransformParamFailureParamTopicParam;
        /**
         * type, DLQ dead letter queue, IGNORE_ERROR|DROP.
         */
        type: string;
    }

    export interface DatahubTaskTransformParamFailureParamKafkaParam {
        /**
         * Whether to compress when writing to the Topic, if it is not enabled, fill in none, if it is enabled, fill in open.
         */
        compressionType?: string;
        /**
         * enable dead letter queue.
         */
        enableToleration?: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, from beginning:earliest, from latest:latest, from specific time:timestamp.
         */
        offsetType?: string;
        /**
         * the partition num of the topic.
         */
        partitionNum?: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit?: number;
        /**
         * instance resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName?: string;
        /**
         * whether the cluster is built by yourself instead of cloud product.
         */
        selfBuilt: boolean;
        /**
         * when Offset type timestamp is required.
         */
        startTime?: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings?: outputs.Ckafka.DatahubTaskTransformParamFailureParamKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic?: string;
        /**
         * Topic id.
         */
        topicId?: string;
        /**
         * Does the used topic need to be automatically created (currently only supports SOURCE inflow tasks, if you do not use to distribute to multiple topics, you need to fill in the topic name that needs to be automatically created in the Topic field).
         */
        useAutoCreateTopic?: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping?: boolean;
        /**
         * Zone ID.
         */
        zoneId?: number;
    }

    export interface DatahubTaskTransformParamFailureParamKafkaParamTableMapping {
        /**
         * database name.
         */
        database: string;
        /**
         * table name,use, to separate.
         */
        table: string;
        /**
         * Topic name.
         */
        topic: string;
        /**
         * Topic ID.
         */
        topicId: string;
    }

    export interface DatahubTaskTransformParamFailureParamTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType?: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType?: string;
        /**
         * The topic name of the topic sold separately.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime?: number;
        /**
         * Topic TopicId.
         */
        topicId?: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTransformParamFilterParam {
        /**
         * Key.
         */
        key: string;
        /**
         * Matching mode, prefix matches PREFIX, suffix matches SUFFIX, contains matches CONTAINS, except matches EXCEPT, value matches NUMBER, IP matches IP.
         */
        matchMode: string;
        /**
         * REGULAR.
         */
        type?: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface DatahubTaskTransformParamMapParam {
        /**
         * key.
         */
        key: string;
        /**
         * Type, DEFAULT default, DATE system default - timestamp, CUSTOMIZE custom, MAPPING mapping.
         */
        type?: string;
        /**
         * value.
         */
        value?: string;
    }

    export interface DatahubTaskTransformsParam {
        /**
         * data process.
         */
        batchAnalyse?: outputs.Ckafka.DatahubTaskTransformsParamBatchAnalyse;
        /**
         * Raw data.
         */
        content: string;
        /**
         * fail process.
         */
        failureParam?: outputs.Ckafka.DatahubTaskTransformsParamFailureParam;
        /**
         * processing chain.
         */
        fieldChains: outputs.Ckafka.DatahubTaskTransformsParamFieldChain[];
        /**
         * filter.
         */
        filterParams?: outputs.Ckafka.DatahubTaskTransformsParamFilterParam[];
        /**
         * Whether to keep the data source Topic metadata information (source Topic, Partition, Offset), the default is false.
         */
        keepMetadata?: boolean;
        /**
         * output format, JSON, ROW, default JSON.
         */
        outputFormat?: string;
        /**
         * result.
         */
        result?: string;
        /**
         * The output format is ROW Required.
         */
        rowParam?: outputs.Ckafka.DatahubTaskTransformsParamRowParam;
        /**
         * data source.
         */
        sourceType?: string;
    }

    export interface DatahubTaskTransformsParamBatchAnalyse {
        /**
         * ONE BY ONE single output, MERGE combined output.
         */
        format: string;
    }

    export interface DatahubTaskTransformsParamFailureParam {
        /**
         * dlq type, CKAFKA|TOPIC.
         */
        dlqType?: string;
        /**
         * Ckafka type dlq.
         */
        kafkaParam?: outputs.Ckafka.DatahubTaskTransformsParamFailureParamKafkaParam;
        /**
         * retry times.
         */
        maxRetryAttempts?: number;
        /**
         * retry interval.
         */
        retryInterval?: number;
        /**
         * DIP Topic type dead letter queue.
         */
        topicParam?: outputs.Ckafka.DatahubTaskTransformsParamFailureParamTopicParam;
        /**
         * type, DLQ dead letter queue, IGNORE_ERROR|DROP.
         */
        type: string;
    }

    export interface DatahubTaskTransformsParamFailureParamKafkaParam {
        /**
         * Whether to compress when writing to the Topic, if it is not enabled, fill in none, if it is enabled, fill in open.
         */
        compressionType?: string;
        /**
         * enable dead letter queue.
         */
        enableToleration?: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, from beginning:earliest, from latest:latest, from specific time:timestamp.
         */
        offsetType?: string;
        /**
         * the partition num of the topic.
         */
        partitionNum?: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit?: number;
        /**
         * instance resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName?: string;
        /**
         * whether the cluster is built by yourself instead of cloud product.
         */
        selfBuilt: boolean;
        /**
         * when Offset type timestamp is required.
         */
        startTime?: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings?: outputs.Ckafka.DatahubTaskTransformsParamFailureParamKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic?: string;
        /**
         * Topic id.
         */
        topicId?: string;
        /**
         * Does the used topic need to be automatically created (currently only supports SOURCE inflow tasks, if you do not use to distribute to multiple topics, you need to fill in the topic name that needs to be automatically created in the Topic field).
         */
        useAutoCreateTopic?: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping?: boolean;
        /**
         * Zone ID.
         */
        zoneId?: number;
    }

    export interface DatahubTaskTransformsParamFailureParamKafkaParamTableMapping {
        /**
         * database name.
         */
        database: string;
        /**
         * table name,use, to separate.
         */
        table: string;
        /**
         * Topic name.
         */
        topic: string;
        /**
         * Topic ID.
         */
        topicId: string;
    }

    export interface DatahubTaskTransformsParamFailureParamTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType?: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple?: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType?: string;
        /**
         * The topic name of the topic sold separately.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime?: number;
        /**
         * Topic TopicId.
         */
        topicId?: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTransformsParamFieldChain {
        /**
         * analyze.
         */
        analyse: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyse;
        /**
         * Parsing results in JSON format.
         */
        analyseJsonResult?: string;
        /**
         * Analysis result.
         */
        analyseResults?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResult[];
        /**
         * Test Results.
         */
        result?: string;
        /**
         * data processing.
         */
        sMTs?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMT[];
        /**
         * secondary analysis.
         */
        secondaryAnalyse?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyse;
        /**
         * Secondary parsing results in JSON format.
         */
        secondaryAnalyseJsonResult?: string;
        /**
         * Secondary Analysis Results.
         */
        secondaryAnalyseResults?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResult[];
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyse {
        /**
         * Parsing format, JSON, DELIMITER delimiter, REGULAR regular extraction, SOURCE processing all results of the upper layer.
         */
        format: string;
        /**
         * KEY to be processed again - KEY expression.
         */
        inputValue?: string;
        /**
         * KEY to be processed again - mode.
         */
        inputValueType?: string;
        /**
         * delimiter, regular expression.
         */
        regex?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResult {
        /**
         * key.
         */
        key: string;
        /**
         * Operation, DATE system preset - timestamp, CUSTOMIZE customization, MAPPING mapping, JSONPATH.
         */
        operate: string;
        /**
         * OriginalValue.
         */
        originalValue?: string;
        /**
         * data type, ORIGINAL, STRING, INT64, FLOAT64, BOOLEAN, MAP, ARRAY.
         */
        schemeType: string;
        /**
         * value.
         */
        value?: string;
        /**
         * VALUE process.
         */
        valueOperate?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperate;
        /**
         * VALUE process chain.
         */
        valueOperates?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperate[];
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperate {
        /**
         * Time conversion, required when TYPE=DATE.
         */
        date?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateDate;
        /**
         * Json Path replacement, must pass when TYPE=JSON PATH REPLACE.
         */
        jsonPathReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateJsonPathReplace;
        /**
         * Key-value secondary analysis, must be passed when TYPE=KV.
         */
        kV?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateKV;
        /**
         * Regular replacement, required when TYPE=REGEX REPLACE.
         */
        regexReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateRegexReplace;
        /**
         * replace, TYPE=REPLACE is required.
         */
        replace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateReplace;
        /**
         * result.
         */
        result?: string;
        /**
         * The value supports one split and multiple values, required when TYPE=SPLIT.
         */
        split?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSplit;
        /**
         * Substr, TYPE=SUBSTR is required.
         */
        substr?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSubstr;
        /**
         * Processing mode, REPLACE replacement, SUBSTR interception, DATE date conversion, TRIM removal of leading and trailing spaces, REGEX REPLACE regular replacement, URL DECODE, LOWERCASE conversion to lowercase.
         */
        type: string;
        /**
         * Url parsing.
         */
        urlDecode?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateUrlDecode;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateDate {
        /**
         * Time format.
         */
        format?: string;
        /**
         * input type, string|unix.
         */
        targetType?: string;
        /**
         * default GMT+8.
         */
        timeZone?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateJsonPathReplace {
        /**
         * Replacement value, Jsonpath expression or string.
         */
        newValue: string;
        /**
         * Replaced value, Jsonpath expression.
         */
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateKV {
        /**
         * delimiter.
         */
        delimiter: string;
        /**
         * Keep the source Key, the default is false not to keep.
         */
        keepOriginalKey?: string;
        /**
         * Key-value secondary analysis delimiter.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateRegexReplace {
        /**
         * new value.
         */
        newValue: string;
        /**
         * Regular.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateReplace {
        /**
         * new value.
         */
        newValue: string;
        /**
         * been replaced value.
         */
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSplit {
        /**
         * delimiter.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSubstr {
        /**
         * cut-off position.
         */
        end: number;
        /**
         * interception starting position.
         */
        start: number;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateUrlDecode {
        /**
         * code.
         */
        charsetName?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMT {
        /**
         * KEY.
         */
        key: string;
        /**
         * Operation, DATE system preset - timestamp, CUSTOMIZE customization, MAPPING mapping, JSONPATH.
         */
        operate: string;
        /**
         * OriginalValue.
         */
        originalValue?: string;
        /**
         * data type, ORIGINAL, STRING, INT64, FLOAT64, BOOLEAN, MAP, ARRAY.
         */
        schemeType: string;
        /**
         * VALUE.
         */
        value?: string;
        /**
         * VALUE process.
         */
        valueOperate?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperate;
        /**
         * VALUE process chain.
         */
        valueOperates?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperate[];
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperate {
        /**
         * Time conversion, required when TYPE=DATE.
         */
        date?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateDate;
        /**
         * Json Path replacement, must pass when TYPE=JSON PATH REPLACE.
         */
        jsonPathReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateJsonPathReplace;
        /**
         * Key-value secondary analysis, must be passed when TYPE=KV.
         */
        kV?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateKV;
        /**
         * Regular replacement, required when TYPE=REGEX REPLACE.
         */
        regexReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateRegexReplace;
        /**
         * replace, TYPE=REPLACE is required.
         */
        replace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateReplace;
        /**
         * result.
         */
        result?: string;
        /**
         * The value supports one split and multiple values, required when TYPE=SPLIT.
         */
        split?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateSplit;
        /**
         * Substr, TYPE=SUBSTR is required.
         */
        substr?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateSubstr;
        /**
         * Processing mode, REPLACE replacement, SUBSTR interception, DATE date conversion, TRIM removal of leading and trailing spaces, REGEX REPLACE regular replacement, URL DECODE, LOWERCASE conversion to lowercase.
         */
        type: string;
        /**
         * Url parsing.
         */
        urlDecode?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateUrlDecode;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateDate {
        /**
         * Time format.
         */
        format?: string;
        /**
         * input type, string|unix.
         */
        targetType?: string;
        /**
         * default GMT+8.
         */
        timeZone?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateJsonPathReplace {
        /**
         * Replacement value, Jsonpath expression or string.
         */
        newValue: string;
        /**
         * Replaced value, Jsonpath expression.
         */
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateKV {
        /**
         * delimiter.
         */
        delimiter: string;
        /**
         * Keep the source Key, the default is false not to keep.
         */
        keepOriginalKey?: string;
        /**
         * Key-value secondary analysis delimiter.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateRegexReplace {
        /**
         * new value.
         */
        newValue: string;
        /**
         * Regular.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateReplace {
        /**
         * new value.
         */
        newValue: string;
        /**
         * been replaced value.
         */
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateSplit {
        /**
         * delimiter.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateSubstr {
        /**
         * cut-off position.
         */
        end: number;
        /**
         * interception starting position.
         */
        start: number;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateUrlDecode {
        /**
         * code.
         */
        charsetName?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyse {
        /**
         * delimiter.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResult {
        /**
         * KEY.
         */
        key: string;
        /**
         * Operation, DATE system preset - timestamp, CUSTOMIZE customization, MAPPING mapping, JSONPATH.
         */
        operate: string;
        /**
         * OriginalValue.
         */
        originalValue?: string;
        /**
         * data type, ORIGINAL, STRING, INT64, FLOAT64, BOOLEAN, MAP, ARRAY.
         */
        schemeType: string;
        /**
         * VALUE.
         */
        value?: string;
        /**
         * VALUE process.
         */
        valueOperate?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperate;
        /**
         * VALUE process chain.
         */
        valueOperates?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperate[];
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperate {
        /**
         * Time conversion, required when TYPE=DATE.
         */
        date?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateDate;
        /**
         * Json Path replacement, must pass when TYPE=JSON PATH REPLACE.
         */
        jsonPathReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateJsonPathReplace;
        /**
         * Key-value secondary analysis, must be passed when TYPE=KV.
         */
        kV?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateKV;
        /**
         * Regular replacement, required when TYPE=REGEX REPLACE.
         */
        regexReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateRegexReplace;
        /**
         * replace, TYPE=REPLACE is required.
         */
        replace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateReplace;
        /**
         * result.
         */
        result?: string;
        /**
         * The value supports one split and multiple values, required when TYPE=SPLIT.
         */
        split?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSplit;
        /**
         * Substr, TYPE=SUBSTR is required.
         */
        substr?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSubstr;
        /**
         * Processing mode, REPLACE replacement, SUBSTR interception, DATE date conversion, TRIM removal of leading and trailing spaces, REGEX REPLACE regular replacement, URL DECODE, LOWERCASE conversion to lowercase.
         */
        type: string;
        /**
         * Url parsing.
         */
        urlDecode?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateUrlDecode;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateDate {
        /**
         * Time format.
         */
        format?: string;
        /**
         * input type, string|unix.
         */
        targetType?: string;
        /**
         * default GMT+8.
         */
        timeZone?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateJsonPathReplace {
        /**
         * Replacement value, Jsonpath expression or string.
         */
        newValue: string;
        /**
         * Replaced value, Jsonpath expression.
         */
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateKV {
        /**
         * delimiter.
         */
        delimiter: string;
        /**
         * Keep the source Key, the default is false not to keep.
         */
        keepOriginalKey?: string;
        /**
         * Key-value secondary analysis delimiter.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateRegexReplace {
        /**
         * new value.
         */
        newValue: string;
        /**
         * Regular.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateReplace {
        /**
         * new value.
         */
        newValue: string;
        /**
         * been replaced value.
         */
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSplit {
        /**
         * delimiter.
         */
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSubstr {
        /**
         * cut-off position.
         */
        end: number;
        /**
         * interception starting position.
         */
        start: number;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateUrlDecode {
        /**
         * code.
         */
        charsetName?: string;
    }

    export interface DatahubTaskTransformsParamFilterParam {
        /**
         * Key.
         */
        key: string;
        /**
         * Matching mode, prefix matches PREFIX, suffix matches SUFFIX, contains matches CONTAINS, except matches EXCEPT, value matches NUMBER, IP matches IP.
         */
        matchMode: string;
        /**
         * REGULAR.
         */
        type?: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface DatahubTaskTransformsParamRowParam {
        /**
         * delimiter.
         */
        entryDelimiter?: string;
        /**
         * key, value delimiter.
         */
        keyValueDelimiter?: string;
        /**
         * row content, KEY_VALUE, VALUE.
         */
        rowContent: string;
    }

    export interface GetAclsAclList {
        /**
         * Host substr used for querying.
         */
        host: string;
        /**
         * ACL operation mode.
         */
        operationType: string;
        /**
         * ACL permission type, valid values are `UNKNOWN`, `ANY`, `DENY`, `ALLOW`, and `ALLOW` by default. Currently, CKafka supports `ALLOW` (equivalent to allow list), and other fields will be used for future ACLs compatible with open-source Kafka.
         */
        permissionType: string;
        /**
         * User which can access. `*` means that any user can access.
         */
        principal: string;
        /**
         * ACL resource name, which is related to `resourceType`. For example, if `resourceType` is `TOPIC`, this field indicates the topic name; if `resourceType` is `GROUP`, this field indicates the group name.
         */
        resourceName: string;
        /**
         * ACL resource type. Valid values are `UNKNOWN`, `ANY`, `TOPIC`, `GROUP`, `CLUSTER`, `TRANSACTIONAL_ID`. Currently, only `TOPIC` is available, and other fields will be used for future ACLs compatible with open-source Kafka.
         */
        resourceType: string;
    }

    export interface GetConnectResourceResult {
        /**
         * Resource List.
         */
        connectResourceLists: outputs.Ckafka.GetConnectResourceResultConnectResourceList[];
        /**
         * Number of connection sources.
         */
        totalCount: number;
    }

    export interface GetConnectResourceResultConnectResourceList {
        /**
         * ClickHouse configuration, returned when Type is CLICKHOUSE.
         */
        clickhouseConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListClickhouseConnectParam[];
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Ctsdb configuration, returned when Type is CTSDB.
         */
        ctsdbConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListCtsdbConnectParam[];
        /**
         * The current step of the connection source.
         */
        currentStep: string;
        /**
         * The number of Datahub tasks associated with this connection source.
         */
        datahubTaskCount: number;
        /**
         * Description.
         */
        description: string;
        /**
         * Doris Configuration, returned when Type is DORIS.
         */
        dorisConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListDorisConnectParam[];
        /**
         * Dts configuration, returned when Type is DTS.
         */
        dtsConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListDtsConnectParam[];
        /**
         * Error Messages.
         */
        errorMessage: string;
        /**
         * Es configuration, return when Type is ES.
         */
        esConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListEsConnectParam[];
        /**
         * Kafka configuration, returned when Type is KAFKA.
         */
        kafkaConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListKafkaConnectParam[];
        /**
         * Mariadb configuration, returned when Type is MARIADB.
         */
        mariaDbConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListMariaDbConnectParam[];
        /**
         * Mongo DB configuration, returned when Type is MONGODB.
         */
        mongoDbConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListMongoDbConnectParam[];
        /**
         * Mysql configuration, returned when Type is MYSQL or TDSQL C MYSQL.
         */
        mysqlConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListMysqlConnectParam[];
        /**
         * Postgresql configuration, returned when Type is POSTGRESQL or TDSQL C POSTGRESQL.
         */
        postgreSqlConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListPostgreSqlConnectParam[];
        /**
         * Resource id.
         */
        resourceId: string;
        /**
         * Resource name.
         */
        resourceName: string;
        /**
         * SQL Server configuration, returned when Type is SQLSERVER.
         */
        sqlServerConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListSqlServerConnectParam[];
        /**
         * Resource status.
         */
        status: number;
        /**
         * Step List.
         */
        stepLists: string[];
        /**
         * Creation progress percentage.
         */
        taskProgress: number;
        /**
         * connection source type.
         */
        type: string;
    }

    export interface GetConnectResourceResultConnectResourceListClickhouseConnectParam {
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Whether the connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListCtsdbConnectParam {
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListDorisConnectParam {
        /**
         * Doris's http load balancing connection port, usually mapped to be's 8040 port.
         */
        bePort: number;
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Whether the connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListDtsConnectParam {
        /**
         * The id of the Dts consumer group.
         */
        groupId: string;
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Topic subscribed by Dts.
         */
        topic: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListEsConnectParam {
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Whether the connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListKafkaConnectParam {
        /**
         * Broker address for Kafka connection, required for self-build.
         */
        brokerAddress: string;
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * Instance resource region of CKafka connection source, required when crossing regions.
         */
        region: string;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Whether the connection source is a self-built cluster.
         */
        selfBuilt: boolean;
    }

    export interface GetConnectResourceResultConnectResourceListMariaDbConnectParam {
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListMongoDbConnectParam {
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Whether the connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListMysqlConnectParam {
        /**
         * Required when type is TDSQL C_POSTGRESQL.
         */
        clusterId: string;
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Whether the connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListPostgreSqlConnectParam {
        /**
         * Required when type is TDSQL C_POSTGRESQL.
         */
        clusterId: string;
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Whether the connection source is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListSqlServerConnectParam {
        /**
         * Whether to update to the associated Dip task.
         */
        isUpdate: boolean;
        /**
         * The password of the connection source.
         */
        password: string;
        /**
         * SQLServer port.
         */
        port: number;
        /**
         * Instance resource of connection source.
         */
        resource: string;
        /**
         * Instance VIP of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        serviceVip: string;
        /**
         * The vpc Id of the connection source, when it is a Tencent Cloud instance, it is required.
         */
        uniqVpcId: string;
        /**
         * The username of the connection source.
         */
        userName: string;
    }

    export interface GetDatahubGroupOffsetsTopicList {
        /**
         * The topic partition array, where each element is a json object.
         */
        partitions: outputs.Ckafka.GetDatahubGroupOffsetsTopicListPartition[];
        /**
         * topic name.
         */
        topic: string;
    }

    export interface GetDatahubGroupOffsetsTopicListPartition {
        /**
         * Error Code.
         */
        errorCode: number;
        /**
         * The number of unconsumed messages.
         */
        lag: number;
        /**
         * partition Log End Offset.
         */
        logEndOffset: number;
        /**
         * Usually an empty string.
         */
        metadata: string;
        /**
         * consumer offset.
         */
        offset: number;
        /**
         * topic partitionId.
         */
        partition: number;
    }

    export interface GetDatahubTaskTaskList {
        /**
         * CreateTime.
         */
        createTime: string;
        /**
         * Datahub Id.
         */
        datahubId: string;
        /**
         * ErrorMessage.
         */
        errorMessage: string;
        /**
         * data resource.
         */
        sourceResources: outputs.Ckafka.GetDatahubTaskTaskListSourceResource[];
        /**
         * Status, -1 failed to create, 0 to create, 1 to run, 2 to delete, 3 to deleted, 4 to delete failed, 5 to pause, 6 to pause, 7 to pause, 8 to resume, 9 to resume failed.
         */
        status: number;
        /**
         * StepList.
         */
        stepLists: string[];
        /**
         * Target Resource.
         */
        targetResources: outputs.Ckafka.GetDatahubTaskTaskListTargetResource[];
        /**
         * Task Current Step.
         */
        taskCurrentStep: string;
        /**
         * task ID.
         */
        taskId: string;
        /**
         * TaskName.
         */
        taskName: string;
        /**
         * Creation progress percentage.
         */
        taskProgress: number;
        /**
         * Task type, SOURCE|SINK.
         */
        taskType: string;
    }

    export interface GetDatahubTaskTaskListSourceResource {
        /**
         * ClickHouse config, Type CLICKHOUSE requierd.
         */
        clickHouseParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClickHouseParam[];
        /**
         * Cls configuration, Required when Type is CLS.
         */
        clsParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClsParam[];
        /**
         * Cos configuration, required when Type is COS.
         */
        cosParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceCosParam[];
        /**
         * Ctsdb configuration, Required when Type is CTSDB.
         */
        ctsdbParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceCtsdbParam[];
        /**
         * Dts configuration, required when Type is DTS.
         */
        dtsParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceDtsParam[];
        /**
         * Es configuration, required when Type is ES.
         */
        esParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParam[];
        /**
         * EB configuration, required when type is EB.
         */
        eventBusParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEventBusParam[];
        /**
         * ckafka configuration, required when Type is KAFKA.
         */
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceKafkaParam[];
        /**
         * MariaDB configuration, Required when Type is MARIADB.
         */
        mariaDbParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMariaDbParam[];
        /**
         * MongoDB config, Required when Type is MONGODB.
         */
        mongoDbParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMongoDbParam[];
        /**
         * MySQL configuration, Required when Type is MYSQL.
         */
        mySqlParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMySqlParam[];
        /**
         * PostgreSQL configuration, Required when Type is POSTGRESQL or TDSQL C_POSTGRESQL.
         */
        postgreSqlParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourcePostgreSqlParam[];
        /**
         * Scf configuration, Required when Type is SCF.
         */
        scfParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceScfParam[];
        /**
         * SQLServer configuration, Required when Type is SQLSERVER.
         */
        sqlServerParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceSqlServerParam[];
        /**
         * Tdw configuration, required when Type is TDW.
         */
        tdwParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceTdwParam[];
        /**
         * Topic configuration, Required when Type is Topic.
         */
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceTopicParam[];
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceClickHouseParam {
        /**
         * ClickHouse cluster.
         */
        cluster: string;
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClickHouseParamDropCl[];
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * Mongo DB connection ip.
         */
        ip: string;
        /**
         * MongoDB database password.
         */
        password: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * ClickHouse schema.
         */
        schemas: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClickHouseParamSchema[];
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * instance vip.
         */
        serviceVip: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Resource Type.
         */
        type: string;
        /**
         * instance vpc id.
         */
        uniqVpcId: string;
        /**
         * MongoDB database user name.
         */
        userName: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceClickHouseParamDropCl {
        /**
         * cls LogSet id.
         */
        dropClsLogSet: string;
        /**
         * account.
         */
        dropClsOwneruin: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion: string;
        /**
         * cls topic.
         */
        dropClsTopicId: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceClickHouseParamSchema {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * Column Name.
         */
        columnName: string;
        /**
         * The key name of the message.
         */
        jsonKey: string;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceClsParam {
        /**
         * key for data in non-json format.
         */
        contentKey: string;
        /**
         * Whether the produced information is in json format.
         */
        decodeJson: boolean;
        /**
         * LogSet id.
         */
        logSet: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Specify the content of a field in the message as the time of the cls log. The format of the field content needs to be a second-level timestamp.
         */
        timeField: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceCosParam {
        /**
         * The size of aggregated messages MB.
         */
        aggregateBatchSize: number;
        /**
         * time interval.
         */
        aggregateInterval: number;
        /**
         * cos bucket name.
         */
        bucketName: string;
        /**
         * Partition format formatted according to strptime time.
         */
        directoryTimeFormat: string;
        /**
         * The file format after message aggregation csv|json.
         */
        formatOutputType: string;
        /**
         * ObjectKey.
         */
        objectKey: string;
        /**
         * Dumped object directory prefix.
         */
        objectKeyPrefix: string;
        /**
         * region code.
         */
        region: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceCtsdbParam {
        /**
         * Ctsdb metric.
         */
        ctsdbMetric: string;
        /**
         * Resource.
         */
        resource: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceDtsParam {
        /**
         * Dts consumer group Id.
         */
        groupId: string;
        /**
         * Dts consumer group passwd.
         */
        groupPassword: string;
        /**
         * Dts account.
         */
        groupUser: string;
        /**
         * Mongo DB connection ip.
         */
        ip: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * False to synchronize the original data, true to synchronize the parsed json format data, the default is true.
         */
        tranSql: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParam {
        /**
         * key for data in non-json format.
         */
        contentKey: string;
        /**
         * When the message dumped to ES is the binlog of Database, if you need to synchronize database operations, that is, fill in the primary key of the database table when adding, deleting, and modifying operations to ES.
         */
        databasePrimaryKey: string;
        /**
         * Es date suffix.
         */
        dateFormat: string;
        /**
         * The field name of the document ID value dumped into Es.
         */
        documentIdField: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropCl[];
        /**
         * dead letter queue.
         */
        dropDlqs: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlq[];
        /**
         * Whether Es discards messages in non-json format.
         */
        dropInvalidJsonMessage: boolean;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * Es index name.
         */
        index: string;
        /**
         * Es custom index name type, STRING, JSONPATH, the default is STRING.
         */
        indexType: string;
        /**
         * MongoDB database password.
         */
        password: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * instance vip.
         */
        serviceVip: string;
        /**
         * instance vpc id.
         */
        uniqVpcId: string;
        /**
         * MongoDB database user name.
         */
        userName: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropCl {
        /**
         * cls LogSet id.
         */
        dropClsLogSet: string;
        /**
         * account.
         */
        dropClsOwneruin: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion: string;
        /**
         * cls topic.
         */
        dropClsTopicId: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlq {
        /**
         * dlq type, CKAFKA|TOPIC.
         */
        dlqType: string;
        /**
         * ckafka configuration, required when Type is KAFKA.
         */
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParam[];
        /**
         * retry times.
         */
        maxRetryAttempts: number;
        /**
         * retry interval.
         */
        retryInterval: number;
        /**
         * Topic configuration, Required when Type is Topic.
         */
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlqTopicParam[];
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * ConnectorSyncType.
         */
        connectorSyncType: string;
        /**
         * enable dead letter queue.
         */
        enableToleration: boolean;
        /**
         * KeepPartition.
         */
        keepPartition: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * the partition num of the topic.
         */
        partitionNum: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping: boolean;
        /**
         * Zone ID.
         */
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParamTableMapping {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlqTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceEventBusParam {
        /**
         * SCF function name.
         */
        functionName: string;
        /**
         * SCF cloud function namespace, the default is default.
         */
        namespace: string;
        /**
         * SCF cloud function version and alias, the default is DEFAULT.
         */
        qualifier: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceKafkaParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * ConnectorSyncType.
         */
        connectorSyncType: string;
        /**
         * enable dead letter queue.
         */
        enableToleration: boolean;
        /**
         * KeepPartition.
         */
        keepPartition: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * the partition num of the topic.
         */
        partitionNum: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping: boolean;
        /**
         * Zone ID.
         */
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListSourceResourceKafkaParamTableMapping {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMariaDbParam {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema: boolean;
        /**
         * Resource.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMongoDbParam {
        /**
         * MongoDB collection.
         */
        collection: string;
        /**
         * Whether to copy the stock data, the default parameter is true.
         */
        copyExisting: boolean;
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * Mongo DB connection ip.
         */
        ip: string;
        /**
         * Listening event type, if it is empty, it means select all. Values include insert, update, replace, delete, invalidate, drop, dropdatabase, rename, used between multiple types, separated by commas.
         */
        listeningEvent: string;
        /**
         * MongoDB database password.
         */
        password: string;
        /**
         * aggregation pipeline.
         */
        pipeline: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Master-slave priority, default master node.
         */
        readPreference: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * MongoDB database user name.
         */
        userName: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMySqlParam {
        /**
         * the name of the column to be monitored.
         */
        dataSourceIncrementColumn: string;
        /**
         * TIMESTAMP indicates that the incremental column is of timestamp type, INCREMENT indicates that the incremental column is of self-incrementing id type.
         */
        dataSourceIncrementMode: string;
        /**
         * TABLE indicates that the read item is a table, QUERY indicates that the read item is a query.
         */
        dataSourceMonitorMode: string;
        /**
         * When DataMonitorMode=TABLE, pass in the Table that needs to be read; when DataMonitorMode=QUERY, pass in the query sql statement that needs to be read.
         */
        dataSourceMonitorResource: string;
        /**
         * HEAD means copy stock + incremental data, TAIL means copy only incremental data.
         */
        dataSourceStartFrom: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMySqlParamDataTargetRecordMapping[];
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * The Topic that stores the Ddl information of My SQL, if it is empty, it will not be stored by default.
         */
        ddlTopic: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMySqlParamDropCl[];
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix: boolean;
        /**
         * Whether the input table is a regular expression.
         */
        isTableRegular: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema: boolean;
        /**
         * Resource.
         */
        resource: string;
        /**
         * database name of signal table.
         */
        signalDatabase: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Regular expression for routing events to specific topics, defaults to (.*).
         */
        topicRegex: string;
        /**
         * TopicRegex, $1, $2.
         */
        topicReplacement: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMySqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement: boolean;
        /**
         * Column Name.
         */
        columnName: string;
        /**
         * current ColumnSize.
         */
        columnSize: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits: string;
        /**
         * Database table default parameters.
         */
        defaultValue: string;
        /**
         * Database table extra fields.
         */
        extraInfo: string;
        /**
         * The key name of the message.
         */
        jsonKey: string;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMySqlParamDropCl {
        /**
         * cls LogSet id.
         */
        dropClsLogSet: string;
        /**
         * account.
         */
        dropClsOwneruin: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion: string;
        /**
         * cls topic.
         */
        dropClsTopicId: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourcePostgreSqlParam {
        /**
         * Upstream data format (JSON|Debezium), required when the database synchronization mode matches the default field.
         */
        dataFormat: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourcePostgreSqlParamDataTargetRecordMapping[];
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * Whether the input table is a regular expression.
         */
        isTableRegular: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns: string;
        /**
         * (decoderbufs/pgoutput), default decoderbufs.
         */
        pluginName: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema: boolean;
        /**
         * Resource.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface GetDatahubTaskTaskListSourceResourcePostgreSqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement: boolean;
        /**
         * Column Name.
         */
        columnName: string;
        /**
         * current ColumnSize.
         */
        columnSize: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits: string;
        /**
         * Database table default parameters.
         */
        defaultValue: string;
        /**
         * Database table extra fields.
         */
        extraInfo: string;
        /**
         * The key name of the message.
         */
        jsonKey: string;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceScfParam {
        /**
         * The maximum number of messages sent in each batch, the default is 1000.
         */
        batchSize: number;
        /**
         * SCF function name.
         */
        functionName: string;
        /**
         * The number of retries after the SCF call fails, the default is 5.
         */
        maxRetries: number;
        /**
         * SCF cloud function namespace, the default is default.
         */
        namespace: string;
        /**
         * SCF cloud function version and alias, the default is DEFAULT.
         */
        qualifier: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceSqlServerParam {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceTdwParam {
        /**
         * Tdw bid.
         */
        bid: string;
        /**
         * default true.
         */
        isDomestic: boolean;
        /**
         * TDW address, defalt tl-tdbank-tdmanager.tencent-distribute.com.
         */
        tdwHost: string;
        /**
         * TDW port, default 8099.
         */
        tdwPort: number;
        /**
         * Tdw tid.
         */
        tid: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResource {
        /**
         * ClickHouse config, Type CLICKHOUSE requierd.
         */
        clickHouseParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClickHouseParam[];
        /**
         * Cls configuration, Required when Type is CLS.
         */
        clsParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClsParam[];
        /**
         * Cos configuration, required when Type is COS.
         */
        cosParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceCosParam[];
        /**
         * Ctsdb configuration, Required when Type is CTSDB.
         */
        ctsdbParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceCtsdbParam[];
        /**
         * Dts configuration, required when Type is DTS.
         */
        dtsParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceDtsParam[];
        /**
         * Es configuration, required when Type is ES.
         */
        esParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParam[];
        /**
         * EB configuration, required when type is EB.
         */
        eventBusParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEventBusParam[];
        /**
         * ckafka configuration, required when Type is KAFKA.
         */
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceKafkaParam[];
        /**
         * MariaDB configuration, Required when Type is MARIADB.
         */
        mariaDbParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMariaDbParam[];
        /**
         * MongoDB config, Required when Type is MONGODB.
         */
        mongoDbParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMongoDbParam[];
        /**
         * MySQL configuration, Required when Type is MYSQL.
         */
        mySqlParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMySqlParam[];
        /**
         * PostgreSQL configuration, Required when Type is POSTGRESQL or TDSQL C_POSTGRESQL.
         */
        postgreSqlParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourcePostgreSqlParam[];
        /**
         * Scf configuration, Required when Type is SCF.
         */
        scfParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceScfParam[];
        /**
         * SQLServer configuration, Required when Type is SQLSERVER.
         */
        sqlServerParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceSqlServerParam[];
        /**
         * Tdw configuration, required when Type is TDW.
         */
        tdwParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceTdwParam[];
        /**
         * Topic configuration, Required when Type is Topic.
         */
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceTopicParam[];
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceClickHouseParam {
        /**
         * ClickHouse cluster.
         */
        cluster: string;
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClickHouseParamDropCl[];
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * Mongo DB connection ip.
         */
        ip: string;
        /**
         * MongoDB database password.
         */
        password: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * ClickHouse schema.
         */
        schemas: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClickHouseParamSchema[];
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * instance vip.
         */
        serviceVip: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Resource Type.
         */
        type: string;
        /**
         * instance vpc id.
         */
        uniqVpcId: string;
        /**
         * MongoDB database user name.
         */
        userName: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceClickHouseParamDropCl {
        /**
         * cls LogSet id.
         */
        dropClsLogSet: string;
        /**
         * account.
         */
        dropClsOwneruin: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion: string;
        /**
         * cls topic.
         */
        dropClsTopicId: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceClickHouseParamSchema {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * Column Name.
         */
        columnName: string;
        /**
         * The key name of the message.
         */
        jsonKey: string;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceClsParam {
        /**
         * key for data in non-json format.
         */
        contentKey: string;
        /**
         * Whether the produced information is in json format.
         */
        decodeJson: boolean;
        /**
         * LogSet id.
         */
        logSet: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Specify the content of a field in the message as the time of the cls log. The format of the field content needs to be a second-level timestamp.
         */
        timeField: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceCosParam {
        /**
         * The size of aggregated messages MB.
         */
        aggregateBatchSize: number;
        /**
         * time interval.
         */
        aggregateInterval: number;
        /**
         * cos bucket name.
         */
        bucketName: string;
        /**
         * Partition format formatted according to strptime time.
         */
        directoryTimeFormat: string;
        /**
         * The file format after message aggregation csv|json.
         */
        formatOutputType: string;
        /**
         * ObjectKey.
         */
        objectKey: string;
        /**
         * Dumped object directory prefix.
         */
        objectKeyPrefix: string;
        /**
         * region code.
         */
        region: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceCtsdbParam {
        /**
         * Ctsdb metric.
         */
        ctsdbMetric: string;
        /**
         * Resource.
         */
        resource: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceDtsParam {
        /**
         * Dts consumer group Id.
         */
        groupId: string;
        /**
         * Dts consumer group passwd.
         */
        groupPassword: string;
        /**
         * Dts account.
         */
        groupUser: string;
        /**
         * Mongo DB connection ip.
         */
        ip: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * False to synchronize the original data, true to synchronize the parsed json format data, the default is true.
         */
        tranSql: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParam {
        /**
         * key for data in non-json format.
         */
        contentKey: string;
        /**
         * When the message dumped to ES is the binlog of Database, if you need to synchronize database operations, that is, fill in the primary key of the database table when adding, deleting, and modifying operations to ES.
         */
        databasePrimaryKey: string;
        /**
         * Es date suffix.
         */
        dateFormat: string;
        /**
         * The field name of the document ID value dumped into Es.
         */
        documentIdField: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropCl[];
        /**
         * dead letter queue.
         */
        dropDlqs: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlq[];
        /**
         * Whether Es discards messages in non-json format.
         */
        dropInvalidJsonMessage: boolean;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * Es index name.
         */
        index: string;
        /**
         * Es custom index name type, STRING, JSONPATH, the default is STRING.
         */
        indexType: string;
        /**
         * MongoDB database password.
         */
        password: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * instance vip.
         */
        serviceVip: string;
        /**
         * instance vpc id.
         */
        uniqVpcId: string;
        /**
         * MongoDB database user name.
         */
        userName: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropCl {
        /**
         * cls LogSet id.
         */
        dropClsLogSet: string;
        /**
         * account.
         */
        dropClsOwneruin: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion: string;
        /**
         * cls topic.
         */
        dropClsTopicId: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlq {
        /**
         * dlq type, CKAFKA|TOPIC.
         */
        dlqType: string;
        /**
         * ckafka configuration, required when Type is KAFKA.
         */
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParam[];
        /**
         * retry times.
         */
        maxRetryAttempts: number;
        /**
         * retry interval.
         */
        retryInterval: number;
        /**
         * Topic configuration, Required when Type is Topic.
         */
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlqTopicParam[];
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * ConnectorSyncType.
         */
        connectorSyncType: string;
        /**
         * enable dead letter queue.
         */
        enableToleration: boolean;
        /**
         * KeepPartition.
         */
        keepPartition: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * the partition num of the topic.
         */
        partitionNum: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping: boolean;
        /**
         * Zone ID.
         */
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParamTableMapping {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlqTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceEventBusParam {
        /**
         * SCF function name.
         */
        functionName: string;
        /**
         * SCF cloud function namespace, the default is default.
         */
        namespace: string;
        /**
         * SCF cloud function version and alias, the default is DEFAULT.
         */
        qualifier: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceKafkaParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * ConnectorSyncType.
         */
        connectorSyncType: string;
        /**
         * enable dead letter queue.
         */
        enableToleration: boolean;
        /**
         * KeepPartition.
         */
        keepPartition: boolean;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * the partition num of the topic.
         */
        partitionNum: number;
        /**
         * Qps(query per seconds) limit.
         */
        qpsLimit: number;
        /**
         * Resource.
         */
        resource: string;
        /**
         * instance name.
         */
        resourceName: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * maps of table to topic, required when multi topic is selected.
         */
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceKafkaParamTableMapping[];
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
        /**
         * whether to use multi table.
         */
        useTableMapping: boolean;
        /**
         * Zone ID.
         */
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListTargetResourceKafkaParamTableMapping {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Topic name, use `,` when more than 1 topic.
         */
        topic: string;
        /**
         * Topic TopicId.
         */
        topicId: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMariaDbParam {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema: boolean;
        /**
         * Resource.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMongoDbParam {
        /**
         * MongoDB collection.
         */
        collection: string;
        /**
         * Whether to copy the stock data, the default parameter is true.
         */
        copyExisting: boolean;
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * Mongo DB connection ip.
         */
        ip: string;
        /**
         * Listening event type, if it is empty, it means select all. Values include insert, update, replace, delete, invalidate, drop, dropdatabase, rename, used between multiple types, separated by commas.
         */
        listeningEvent: string;
        /**
         * MongoDB database password.
         */
        password: string;
        /**
         * aggregation pipeline.
         */
        pipeline: string;
        /**
         * MongoDB connection port.
         */
        port: number;
        /**
         * Master-slave priority, default master node.
         */
        readPreference: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * Whether it is a self-built cluster.
         */
        selfBuilt: boolean;
        /**
         * MongoDB database user name.
         */
        userName: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMySqlParam {
        /**
         * the name of the column to be monitored.
         */
        dataSourceIncrementColumn: string;
        /**
         * TIMESTAMP indicates that the incremental column is of timestamp type, INCREMENT indicates that the incremental column is of self-incrementing id type.
         */
        dataSourceIncrementMode: string;
        /**
         * TABLE indicates that the read item is a table, QUERY indicates that the read item is a query.
         */
        dataSourceMonitorMode: string;
        /**
         * When DataMonitorMode=TABLE, pass in the Table that needs to be read; when DataMonitorMode=QUERY, pass in the query sql statement that needs to be read.
         */
        dataSourceMonitorResource: string;
        /**
         * HEAD means copy stock + incremental data, TAIL means copy only incremental data.
         */
        dataSourceStartFrom: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMySqlParamDataTargetRecordMapping[];
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * The Topic that stores the Ddl information of My SQL, if it is empty, it will not be stored by default.
         */
        ddlTopic: string;
        /**
         * When the member parameter Drop Invalid Message To Cls is set to true, the Drop Invalid Message parameter is invalid.
         */
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMySqlParamDropCl[];
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * If the value is all, DDL data and DML data will also be written to the selected topic; if the value is dml, only DML data will be written to the selected topic.
         */
        includeContentChanges: string;
        /**
         * If the value is true, and the value of the binlog rows query log events configuration item in My SQL is ON, the data flowing into the topic contains the original SQL statement; if the value is false, the data flowing into the topic does not contain Original SQL statement.
         */
        includeQuery: boolean;
        /**
         * When the Table input is a prefix, the value of this item is true, otherwise it is false.
         */
        isTablePrefix: boolean;
        /**
         * Whether the input table is a regular expression.
         */
        isTableRegular: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns: string;
        /**
         * output format, DEFAULT, CANAL_1, CANAL_2.
         */
        outputFormat: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema: boolean;
        /**
         * Resource.
         */
        resource: string;
        /**
         * database name of signal table.
         */
        signalDatabase: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
        /**
         * Regular expression for routing events to specific topics, defaults to (.*).
         */
        topicRegex: string;
        /**
         * TopicRegex, $1, $2.
         */
        topicReplacement: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMySqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement: boolean;
        /**
         * Column Name.
         */
        columnName: string;
        /**
         * current ColumnSize.
         */
        columnSize: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits: string;
        /**
         * Database table default parameters.
         */
        defaultValue: string;
        /**
         * Database table extra fields.
         */
        extraInfo: string;
        /**
         * The key name of the message.
         */
        jsonKey: string;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMySqlParamDropCl {
        /**
         * cls LogSet id.
         */
        dropClsLogSet: string;
        /**
         * account.
         */
        dropClsOwneruin: string;
        /**
         * The region where the cls is delivered.
         */
        dropClsRegion: string;
        /**
         * cls topic.
         */
        dropClsTopicId: string;
        /**
         * Whether to deliver to cls.
         */
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourcePostgreSqlParam {
        /**
         * Upstream data format (JSON|Debezium), required when the database synchronization mode matches the default field.
         */
        dataFormat: string;
        /**
         * INSERT means insert using Insert mode, UPSERT means insert using Upsert mode.
         */
        dataTargetInsertMode: string;
        /**
         * When DataInsertMode=UPSERT, pass in the primary key that the current upsert depends on.
         */
        dataTargetPrimaryKeyField: string;
        /**
         * Mapping relationship between tables and messages.
         */
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourcePostgreSqlParamDataTargetRecordMapping[];
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * Whether to discard messages that fail to parse, the default is true.
         */
        dropInvalidMessage: boolean;
        /**
         * Whether the input table is a regular expression.
         */
        isTableRegular: boolean;
        /**
         * Format  library1.table1:field 1,field2;library2.table2:field2, between tables; (semicolon) separated, between fields, (comma) separated. The table that is not specified defaults to the primary key of the table.
         */
        keyColumns: string;
        /**
         * (decoderbufs/pgoutput), default decoderbufs.
         */
        pluginName: string;
        /**
         * If the value is true, the message will carry the schema corresponding to the message structure, if the value is false, it will not carry.
         */
        recordWithSchema: boolean;
        /**
         * Resource.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface GetDatahubTaskTaskListTargetResourcePostgreSqlParamDataTargetRecordMapping {
        /**
         * Whether the message is allowed to be empty.
         */
        allowNull: boolean;
        /**
         * Whether it is an auto-increment column.
         */
        autoIncrement: boolean;
        /**
         * Column Name.
         */
        columnName: string;
        /**
         * current ColumnSize.
         */
        columnSize: string;
        /**
         * current Column DecimalDigits.
         */
        decimalDigits: string;
        /**
         * Database table default parameters.
         */
        defaultValue: string;
        /**
         * Database table extra fields.
         */
        extraInfo: string;
        /**
         * The key name of the message.
         */
        jsonKey: string;
        /**
         * Resource Type.
         */
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceScfParam {
        /**
         * The maximum number of messages sent in each batch, the default is 1000.
         */
        batchSize: number;
        /**
         * SCF function name.
         */
        functionName: string;
        /**
         * The number of retries after the SCF call fails, the default is 5.
         */
        maxRetries: number;
        /**
         * SCF cloud function namespace, the default is default.
         */
        namespace: string;
        /**
         * SCF cloud function version and alias, the default is DEFAULT.
         */
        qualifier: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceSqlServerParam {
        /**
         * SQLServer database name.
         */
        database: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * schema_only|initial default initial.
         */
        snapshotMode: string;
        /**
         * SQLServer table, is the non-system table in all the monitored databases, you can use, to monitor multiple data tables, but the data table needs to be filled in the format of data database name.data table name.
         */
        table: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceTdwParam {
        /**
         * Tdw bid.
         */
        bid: string;
        /**
         * default true.
         */
        isDomestic: boolean;
        /**
         * TDW address, defalt tl-tdbank-tdmanager.tencent-distribute.com.
         */
        tdwHost: string;
        /**
         * TDW port, default 8099.
         */
        tdwPort: number;
        /**
         * Tdw tid.
         */
        tid: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceTopicParam {
        /**
         * Whether to perform compression when writing a topic, if it is not enabled, fill in none, if it is enabled, you can choose one of gzip, snappy, lz4 to fill in.
         */
        compressionType: string;
        /**
         * 1 source topic message is amplified into msg Multiple and written to the target topic (this parameter is currently only applicable to ckafka flowing into ckafka).
         */
        msgMultiple: number;
        /**
         * Offset type, initial position earliest, latest position latest, time point position timestamp.
         */
        offsetType: string;
        /**
         * Resource.
         */
        resource: string;
        /**
         * It must be passed when the Offset type is timestamp, and the time stamp is passed, accurate to the second.
         */
        startTime: number;
        /**
         * Topic TopicId.
         */
        topicId: string;
        /**
         * whether the used topic need to be automatically created (currently only supports SOURCE inflow tasks).
         */
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTopicTopicList {
        /**
         * name.
         */
        name: string;
        /**
         * Remark.
         */
        note: string;
        /**
         * number of partitions.
         */
        partitionNum: number;
        /**
         * Expiration.
         */
        retentionMs: number;
        /**
         * Status, 1 in use, 2 in deletion.
         */
        status: number;
        /**
         * Topic Id.
         */
        topicId: string;
        /**
         * Topic name.
         */
        topicName: string;
    }

    export interface GetGroupGroupList {
        /**
         * groupId.
         */
        group: string;
        /**
         * The protocol used by this group.
         */
        protocol: string;
    }

    export interface GetGroupInfoResult {
        /**
         * Error code, normally 0.
         */
        errorCode: string;
        /**
         * Kafka consumer group.
         */
        group: string;
        /**
         * This array contains information only if state is Stable and protocolType is consumer.
         */
        members: outputs.Ckafka.GetGroupInfoResultMember[];
        /**
         * Common consumer partition allocation algorithms are as follows (the default option for Kafka consumer SDK is range)  range|roundrobin|sticky.
         */
        protocol: string;
        /**
         * The protocol type selected by the consumption group is normally the consumer, but some systems use their own protocol, such as kafka-connect, which uses connect. Only the standard consumer protocol, this interface knows the format of the specific allocation method, and can analyze the specific partition allocation.
         */
        protocolType: string;
        /**
         * Group state description (commonly Empty, Stable, and Dead states): Dead: The consumption group does not exist Empty: The consumption group does not currently have any consumer subscriptions PreparingRebalance: The consumption group is in the rebalance state CompletingRebalance: The consumption group is in the rebalance state Stable: Each consumer in the consumption group has joined and is in a stable state.
         */
        state: string;
    }

    export interface GetGroupInfoResultMember {
        /**
         * Stores the partition information assigned to the consumer.
         */
        assignments: outputs.Ckafka.GetGroupInfoResultMemberAssignment[];
        /**
         * Generally store the customer&#39;s IP address.
         */
        clientHost: string;
        /**
         * The client.id information set by the client consumer SDK itself.
         */
        clientId: string;
        /**
         * ID that the coordinator generated for consumer.
         */
        memberId: string;
    }

    export interface GetGroupInfoResultMemberAssignment {
        /**
         * topic list.
         */
        topics: outputs.Ckafka.GetGroupInfoResultMemberAssignmentTopic[];
        /**
         * assignment version information.
         */
        version: number;
    }

    export interface GetGroupInfoResultMemberAssignmentTopic {
        /**
         * Allocated partition information.
         */
        partitions: number[];
        /**
         * Assigned topic name.
         */
        topic: string;
    }

    export interface GetGroupOffsetsTopicList {
        /**
         * he topic partition array, where each element is a json object.
         */
        partitions: outputs.Ckafka.GetGroupOffsetsTopicListPartition[];
        /**
         * topicName.
         */
        topic: string;
    }

    export interface GetGroupOffsetsTopicListPartition {
        /**
         * ErrorCode.
         */
        errorCode: number;
        /**
         * The number of unconsumed messages.
         */
        lag: number;
        /**
         * The latest offset of the current partition.
         */
        logEndOffset: number;
        /**
         * When consumers submit messages, they can pass in metadata for other purposes. Currently, it is usually an empty string.
         */
        metadata: string;
        /**
         * The offset of the position.
         */
        offset: number;
        /**
         * topic partitionId.
         */
        partition: number;
    }

    export interface GetInstancesFilter {
        /**
         * The field that needs to be filtered.
         */
        name: string;
        /**
         * The filtered value of the field.
         */
        values: string[];
    }

    export interface GetInstancesInstanceList {
        /**
         * Instance bandwidth, in Mbps.
         */
        bandwidth: number;
        /**
         * The time when the instance was created.
         */
        createTime: number;
        /**
         * ckafka sale type. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        cvm: number;
        /**
         * The storage size of the instance, in GB.
         */
        diskSize: number;
        /**
         * Disk Type. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        diskType: string;
        /**
         * The instance expiration time.
         */
        expireTime: number;
        /**
         * Instance status int: 1 indicates health, 2 indicates alarm, and 3 indicates abnormal instance status.
         */
        healthy: number;
        /**
         * Instance status information.
         */
        healthyMessage: string;
        /**
         * The instance ID.
         */
        instanceId: string;
        /**
         * The instance name.
         */
        instanceName: string;
        /**
         * ckafka instance type. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        instanceType: string;
        /**
         * Whether it is an internal customer. A value of 1 indicates an internal customer.
         */
        isInternal: number;
        /**
         * The maximum number of Partitions for the current specifications. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        maxPartitionNumber: number;
        /**
         * The maximum number of topics in the current specifications. Note: This field may return null, indicating that a valid value could not be retrieved..
         */
        maxTopicNumber: number;
        /**
         * The current number of instances. Note: This field may return null, indicating that a valid value could not be retrieved..
         */
        partitionNumber: number;
        /**
         * The Internet bandwidth value. Note: This field may return null, indicating that a valid value could not be retrieved..
         */
        publicNetwork: number;
        /**
         * The type of Internet bandwidth. Note: This field may return null, indicating that a valid value could not be retrieved..
         */
        publicNetworkChargeType: string;
        /**
         * Schedule the upgrade configuration time. Note: This field may return null, indicating that a valid value could not be retrieved..
         */
        rebalanceTime: string;
        /**
         * Whether the instance is renewed, the int enumeration value: 1 indicates auto-renewal, and 2 indicates that it is not automatically renewed.
         */
        renewFlag: number;
        /**
         * (Filter Criteria) The status of the instance. 0: Create, 1: Run, 2: Delete, do not fill the default return all.
         */
        status: number;
        /**
         * Subnet id.
         */
        subnetId: string;
        /**
         * Tag information.
         */
        tags: outputs.Ckafka.GetInstancesInstanceListTag[];
        /**
         * The number of topics.
         */
        topicNum: number;
        /**
         * Kafka version information. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        version: string;
        /**
         * Virtual IP.
         */
        vip: string;
        /**
         * Virtual IP entities.
         */
        vipList: outputs.Ckafka.GetInstancesInstanceListVipList;
        /**
         * VpcId, if empty, indicates that it is the underlying network.
         */
        vpcId: string;
        /**
         * Virtual PORT.
         */
        vport: string;
        /**
         * Availability Zone ID.
         */
        zoneId: number;
        /**
         * Across Availability Zones. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        zoneIds: number[];
    }

    export interface GetInstancesInstanceListTag {
        /**
         * Matches the tag key value.
         */
        tagKey: string;
        /**
         * Tag Value.
         */
        tagValue: string;
    }

    export interface GetInstancesInstanceListVipList {
        /**
         * Virtual IP.
         */
        vip: string;
        /**
         * Virtual PORT.
         */
        vport: string;
    }

    export interface GetRegionResult {
        /**
         * area name.
         */
        areaName: string;
        /**
         * Whether to support ipv6, 0: means not supported, 1: means supported.
         */
        ipv6: number;
        /**
         * Whether to support cross-availability zones, 0: means not supported, 1: means supported.
         */
        multiZone: number;
        /**
         * Region Code.
         */
        regionCode: string;
        /**
         * Region Code(V3 version).
         */
        regionCodeV3: string;
        /**
         * region ID.
         */
        regionId: number;
        /**
         * geographical name.
         */
        regionName: string;
        /**
         * NONE: The default value does not support any special models CVM: Supports CVM types.
         */
        support: string;
    }

    export interface GetTaskStatusResult {
        /**
         * OutPut Info.
         */
        output: string;
        /**
         * Status.
         */
        status: number;
    }

    export interface GetTopicFlowRankingResult {
        /**
         * ConsumeSpeed.
         */
        consumeSpeeds: outputs.Ckafka.GetTopicFlowRankingResultConsumeSpeed[];
        /**
         * TopicFlow.
         */
        topicFlows: outputs.Ckafka.GetTopicFlowRankingResultTopicFlow[];
        /**
         * TopicMessageHeapRanking.
         */
        topicMessageHeaps: outputs.Ckafka.GetTopicFlowRankingResultTopicMessageHeap[];
    }

    export interface GetTopicFlowRankingResultConsumeSpeed {
        /**
         * ConsumerGroupName.
         */
        consumerGroupName: string;
        /**
         * Speed.
         */
        speed: number;
    }

    export interface GetTopicFlowRankingResultTopicFlow {
        /**
         * Topic MessageHeap.
         */
        messageHeap: number;
        /**
         * PartitionNum.
         */
        partitionNum: number;
        /**
         * ReplicaNum.
         */
        replicaNum: number;
        /**
         * topicId.
         */
        topicId: string;
        /**
         * topicName.
         */
        topicName: string;
        /**
         * TopicTraffic.
         */
        topicTraffic: string;
    }

    export interface GetTopicFlowRankingResultTopicMessageHeap {
        /**
         * Topic MessageHeap.
         */
        messageHeap: number;
        /**
         * PartitionNum.
         */
        partitionNum: number;
        /**
         * ReplicaNum.
         */
        replicaNum: number;
        /**
         * topicId.
         */
        topicId: string;
        /**
         * topicName.
         */
        topicName: string;
        /**
         * TopicTraffic.
         */
        topicTraffic: string;
    }

    export interface GetTopicProduceConnectionResult {
        /**
         * ip address.
         */
        ipAddr: string;
        /**
         * Is the supported version.
         */
        isUnSupportVersion: boolean;
        /**
         * connect time.
         */
        time: string;
    }

    export interface GetTopicSubscribeGroupGroupsInfo {
        /**
         * Error code, normally 0.
         */
        errorCode: string;
        /**
         * Kafka consumer group.
         */
        group: string;
        /**
         * This array contains information only if state is Stable and protocolType is consumer.
         */
        members: outputs.Ckafka.GetTopicSubscribeGroupGroupsInfoMember[];
        /**
         * Common consumer partition allocation algorithms are as follows (the default option for Kafka consumer SDK is range) range|roundrobin| sticky.
         */
        protocol: string;
        /**
         * The protocol type selected by the consumption group is normally the consumer, but some systems use their own protocol, such as kafka-connect, which uses connect. Only the standard consumer protocol, this interface knows the format of the specific allocation method, and can analyze the specific partition allocation.
         */
        protocolType: string;
        /**
         * Group state description (commonly Empty, Stable, and Dead states): Dead: The consumption group does not exist Empty: The consumption group does not currently have any consumer subscriptions PreparingRebalance: The consumption group is in the rebalance state CompletingRebalance: The consumption group is in the rebalance state Stable: Each consumer in the consumption group has joined and is in a stable state.
         */
        state: string;
    }

    export interface GetTopicSubscribeGroupGroupsInfoMember {
        /**
         * Stores the partition information assigned to the consumer.
         */
        assignments: outputs.Ckafka.GetTopicSubscribeGroupGroupsInfoMemberAssignment[];
        /**
         * Generally store the customer&#39;s IP address.
         */
        clientHost: string;
        /**
         * The client.id information set by the client consumer SDK itself.
         */
        clientId: string;
        /**
         * ID that the coordinator generated for consumer.
         */
        memberId: string;
    }

    export interface GetTopicSubscribeGroupGroupsInfoMemberAssignment {
        /**
         * topic list.
         */
        topics: outputs.Ckafka.GetTopicSubscribeGroupGroupsInfoMemberAssignmentTopic[];
        /**
         * assignment version information.
         */
        version: number;
    }

    export interface GetTopicSubscribeGroupGroupsInfoMemberAssignmentTopic {
        /**
         * partition list.
         */
        partitions: number[];
        /**
         * topic name.
         */
        topic: string;
    }

    export interface GetTopicSyncReplicaTopicInSyncReplicaList {
        /**
         * BeginOffset.
         */
        beginOffset: number;
        /**
         * EndOffset.
         */
        endOffset: number;
        /**
         * ISR.
         */
        inSyncReplica: string;
        /**
         * Leader Id.
         */
        leader: number;
        /**
         * Message Count.
         */
        messageCount: number;
        /**
         * Out Of Sync Replica.
         */
        outOfSyncReplica: string;
        /**
         * partition name.
         */
        partition: string;
        /**
         * replica set.
         */
        replica: string;
    }

    export interface GetTopicsInstanceList {
        /**
         * Clear log policy, log clear mode. `delete`: logs are deleted according to the storage time, `compact`: logs are compressed according to the key, `compact, delete`: logs are compressed according to the key and will be deleted according to the storage time.
         */
        cleanUpPolicy: string;
        /**
         * Create time of the CKafka topic.
         */
        createTime: string;
        /**
         * Whether to open the IP Whitelist. `true`: open, `false`: close.
         */
        enableWhiteList: boolean;
        /**
         * Data backup cos bucket: the bucket address that is dumped to cos.
         */
        forwardCosBucket: string;
        /**
         * Periodic frequency of data backup to cos.
         */
        forwardInterval: number;
        /**
         * Data backup cos status. `1`: do not open data backup, `0`: open data backup.
         */
        forwardStatus: number;
        /**
         * IP Whitelist count.
         */
        ipWhiteListCount: number;
        /**
         * Max message bytes.
         */
        maxMessageBytes: number;
        /**
         * CKafka topic note description.
         */
        note: string;
        /**
         * The number of partition.
         */
        partitionNum: number;
        /**
         * The number of replica.
         */
        replicaNum: number;
        /**
         * Message can be selected. Retention time(unit ms).
         */
        retention: number;
        /**
         * Segment scrolling time, in ms.
         */
        segment: number;
        /**
         * Number of bytes rolled by shard.
         */
        segmentBytes: number;
        /**
         * Min number of sync replicas.
         */
        syncReplicaMinNum: number;
        /**
         * ID of the CKafka topic.
         */
        topicId: string;
        /**
         * Name of the CKafka topic. It must start with a letter, the rest can contain letters, numbers and dashes(-). The length range is from 1 to 64.
         */
        topicName: string;
        /**
         * Whether to allow unsynchronized replicas to be selected as leader, default is `false`, `true: `allowed, `false`: not allowed.
         */
        uncleanLeaderElectionEnable: boolean;
    }

    export interface GetUsersUserList {
        /**
         * Account name used when query ckafka users' infos. Could be a substr of user name.
         */
        accountName: string;
        /**
         * Creation time of the account.
         */
        createTime: string;
        /**
         * The last update time of the account.
         */
        updateTime: string;
    }

    export interface GetZoneResult {
        /**
         * User exclusive cluster information.
         */
        clusterInfos: outputs.Ckafka.GetZoneResultClusterInfo[];
        /**
         * Maximum purchased bandwidth in Mbs.
         */
        maxBandwidth: number;
        /**
         * The maximum number of purchased instances.
         */
        maxBuyInstanceNum: number;
        /**
         * Postpaid message unit price.
         */
        messagePrices: outputs.Ckafka.GetZoneResultMessagePrice[];
        /**
         * Physical Exclusive Edition Configuration.
         */
        physical: string;
        /**
         * Professional Edition configuration.
         */
        profession: string;
        /**
         * Public network bandwidth.
         */
        publicNetwork: string;
        /**
         * Public network bandwidth configuration.
         */
        publicNetworkLimit: string;
        /**
         * Purchase Standard Edition Configuration.
         */
        standard: string;
        /**
         * Standard Edition S2 configuration.
         */
        standardS2: string;
        /**
         * Postpaid unit price.
         */
        unitPrices: outputs.Ckafka.GetZoneResultUnitPrice[];
        /**
         * zone list.
         */
        zoneLists: outputs.Ckafka.GetZoneResultZoneList[];
    }

    export interface GetZoneResultClusterInfo {
        /**
         * The current available bandwidth of the cluster in MBs.
         */
        availableBandWidth: number;
        /**
         * The current available disk of the cluster, in GB.
         */
        availableDiskSize: number;
        /**
         * ClusterId.
         */
        clusterId: number;
        /**
         * ClusterName.
         */
        clusterName: string;
        /**
         * Maximum cluster bandwidth in MBs.
         */
        maxBandWidth: number;
        /**
         * The largest disk in the cluster, in GB.
         */
        maxDiskSize: number;
        /**
         * zone id.
         */
        zoneId: number;
        /**
         * The availability zone where the cluster node is located. If the cluster is a cross-availability zone cluster, it includes multiple availability zones where the cluster node is located.
         */
        zoneIds: number[];
    }

    export interface GetZoneResultMessagePrice {
        /**
         * discount price.
         */
        realTotalCost: number;
        /**
         * original price.
         */
        totalCost: number;
    }

    export interface GetZoneResultUnitPrice {
        /**
         * discount price.
         */
        realTotalCost: number;
        /**
         * original price.
         */
        totalCost: number;
    }

    export interface GetZoneResultZoneList {
        /**
         * app id.
         */
        appId: number;
        /**
         * extra flag.
         */
        exflag: string;
        /**
         * Manually set flags.
         */
        flag: boolean;
        /**
         * internal APP.
         */
        isInternalApp: number;
        /**
         * Standard Edition Sold Out Information.
         */
        salesInfos: outputs.Ckafka.GetZoneResultZoneListSalesInfo[];
        /**
         * json object, key is model, value true is sold out, false is not sold out.
         */
        soldOut: string;
        /**
         * zone id.
         */
        zoneId: string;
        /**
         * zone name.
         */
        zoneName: string;
        /**
         * zone status.
         */
        zoneStatus: number;
    }

    export interface GetZoneResultZoneListSalesInfo {
        /**
         * Manually set flags.
         */
        flag: boolean;
        /**
         * Professional Edition, Standard Edition flag.
         */
        platform: string;
        /**
         * json object, key is model, value true is sold out, false is not sold out.
         */
        soldOut: boolean;
        /**
         * ckakfa version(1.1.1/2.4.2/0.10.2).
         */
        version: string;
    }

    export interface InstanceConfig {
        /**
         * Automatic creation. true: enabled, false: not enabled.
         */
        autoCreateTopicEnable: boolean;
        /**
         * If auto.create.topic.enable is set to true and this value is not set, 3 will be used by default.
         */
        defaultNumPartitions: number;
        /**
         * If auto.create.topic.enable is set to true but this value is not set, 2 will be used by default.
         */
        defaultReplicationFactor: number;
    }

    export interface InstanceDynamicRetentionConfig {
        /**
         * Minimum retention time, in minutes.
         */
        bottomRetention: number;
        /**
         * Disk quota threshold (in percentage) for triggering the message retention time change event.
         */
        diskQuotaPercentage: number;
        /**
         * Whether the dynamic message retention time configuration is enabled. 0: disabled; 1: enabled.
         */
        enable: number;
        /**
         * Percentage by which the message retention time is shortened each time.
         */
        stepForwardPercentage: number;
    }

    export interface InstanceTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface RouteBrokerVipList {
        /**
         * Virtual IP.
         */
        vip: string;
        /**
         * Virtual port.
         */
        vport: string;
    }

    export interface RouteVipList {
        /**
         * Virtual IP.
         */
        vip: string;
        /**
         * Virtual port.
         */
        vport: string;
    }

}

export namespace Clb {
    export interface AttachmentTarget {
        /**
         * Eni IP address of the backend server, conflict with `instanceId` but must specify one of them.
         */
        eniIp?: string;
        /**
         * CVM Instance Id of the backend server, conflict with `eniIp` but must specify one of them.
         */
        instanceId?: string;
        /**
         * Port of the backend server. Valid value ranges: (0~65535).
         */
        port: number;
        /**
         * Forwarding weight of the backend service. Valid value ranges: (0~100). defaults to `10`.
         */
        weight?: number;
    }

    export interface FunctionTargetsAttachmentFunctionTargets {
        /**
         * Information about cloud functions.Note: This field may return null, indicating that no valid value can be obtained.
         */
        function: outputs.Clb.FunctionTargetsAttachmentFunctionTargetsFunction;
        /**
         * Weight. The default is `10`.
         */
        weight?: number;
    }

    export interface FunctionTargetsAttachmentFunctionTargetsFunction {
        /**
         * The name of function.
         */
        functionName: string;
        /**
         * The namespace of function.
         */
        functionNamespace: string;
        /**
         * The version name or alias of the function.
         */
        functionQualifier: string;
        /**
         * Identifies the type of FunctionQualifier parameter, possible values: VERSION, ALIAS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        functionQualifierType?: string;
    }

    export interface GetAttachmentsAttachmentList {
        /**
         * ID of the CLB to be queried.
         */
        clbId: string;
        /**
         * ID of the CLB listener to be queried.
         */
        listenerId: string;
        /**
         * Type of protocol within the listener, and available values include `TCP`, `UDP`, `HTTP`, `HTTPS` and `TCP_SSL`. NOTES: `TCP_SSL` is testing internally, please apply if you need to use.
         */
        protocolType: string;
        /**
         * ID of the CLB listener rule. If the protocol of listener is `HTTP`/`HTTPS`, this para is required.
         */
        ruleId: string;
        /**
         * Information of the backends to be attached.
         */
        targets: outputs.Clb.GetAttachmentsAttachmentListTarget[];
    }

    export interface GetAttachmentsAttachmentListTarget {
        /**
         * Elastic network card unique ID.
         */
        eniIp: string;
        /**
         * Id of the backend server.
         */
        instanceId: string;
        /**
         * Port of the backend server.
         */
        port: number;
        /**
         * Forwarding weight of the backend service, the range of [0, 100], defaults to `10`.
         */
        weight: number;
    }

    export interface GetClusterResourcesClusterResourceSet {
        /**
         * Cluster ID.
         */
        clusterId: string;
        /**
         * cluster name.
         */
        clusterName: string;
        /**
         * clusters zone.
         */
        clustersZones: outputs.Clb.GetClusterResourcesClusterResourceSetClustersZone[];
        /**
         * Is it idle.
         */
        idle: string;
        /**
         * Isp.
         */
        isp: string;
        /**
         * Loadbalance Id.
         */
        loadBalancerId: string;
        /**
         * vip.
         */
        vip: string;
    }

    export interface GetClusterResourcesClusterResourceSetClustersZone {
        /**
         * Availability master zone where the cluster is located.
         */
        masterZones: string[];
        /**
         * Availability slave zone where the cluster is located.
         */
        slaveZones: string[];
    }

    export interface GetClusterResourcesFilter {
        /**
         * Filter name.
         */
        name: string;
        /**
         * Filter values.
         */
        values: string[];
    }

    export interface GetCrossTargetsCrossTargetSet {
        /**
         * ENI ID of the CVM instance.
         */
        eniId: string;
        /**
         * ID of the CVM instance.Note: This field may return null, indicating that no valid value was found.
         */
        instanceId: string;
        /**
         * Name of the CVM instance. Note: This field may return null, indicating that no valid value was found.
         */
        instanceName: string;
        /**
         * IP address of the CVM or ENI instance.
         */
        ip: string;
        /**
         * VPC ID of the CLB instance.
         */
        localVpcId: string;
        /**
         * Region of the CVM or ENI instance.
         */
        region: string;
        /**
         * VPC ID of the CVM or ENI instance.
         */
        vpcId: string;
        /**
         * VPC name of the CVM or ENI instance.
         */
        vpcName: string;
    }

    export interface GetCrossTargetsFilter {
        /**
         * Filter name.
         */
        name: string;
        /**
         * Filter values.
         */
        values: string[];
    }

    export interface GetExclusiveClustersClusterSet {
        /**
         * cluster ID.
         */
        clusterId: string;
        /**
         * cluster name.
         */
        clusterName: string;
        /**
         * Dedicated layer-7 tag. Note: this field may return null, indicating that no valid values can be obtained.
         */
        clusterTag: string;
        /**
         * cluster type: TGW, STGW, VPCGW.
         */
        clusterType: string;
        /**
         * clusters version.
         */
        clustersVersion: string;
        /**
         * Availability zone where the cluster is located.
         */
        clustersZones: outputs.Clb.GetExclusiveClustersClusterSetClustersZone[];
        /**
         * Cluster disaster recovery type:SINGLE-ZONE, DISASTER-RECOVERY, MUTUAL-DISASTER-RECOVERY.
         */
        disasterRecoveryType: string;
        /**
         * Maximum number of new http connections.
         */
        httpMaxNewConn: number;
        /**
         * Http Qps.
         */
        httpQps: number;
        /**
         * Maximum number of new https connections.
         */
        httpsMaxNewConn: number;
        /**
         * Https Qps.
         */
        httpsQps: number;
        /**
         * The total number of free resources in the cluster.
         */
        idleResourceCount: number;
        /**
         * Isp: BGP, CMCC,CUCC,CTCC,INTERNAL.
         */
        isp: string;
        /**
         * Total number of forwarders in the cluster.
         */
        loadBalanceDirectorCount: number;
        /**
         * Maximum number of connections.
         */
        maxConn: number;
        /**
         * Maximum incoming Bandwidth.
         */
        maxInFlow: number;
        /**
         * Maximum incoming packet.
         */
        maxInPkg: number;
        /**
         * Maximum number of new connections.
         */
        maxNewConn: number;
        /**
         * Maximum output bandwidth.
         */
        maxOutFlow: number;
        /**
         * Maximum output packet.
         */
        maxOutPkg: number;
        /**
         * cluster network type.
         */
        network: string;
        /**
         * The total number of resources in the cluster.
         */
        resourceCount: number;
        /**
         * .
         */
        zone: string;
    }

    export interface GetExclusiveClustersClusterSetClustersZone {
        /**
         * Availability master zone where the cluster is located.
         */
        masterZones: string[];
        /**
         * Availability slave zone where the cluster is located.
         */
        slaveZones: string[];
    }

    export interface GetExclusiveClustersFilter {
        /**
         * Filter name.
         */
        name: string;
        /**
         * Filter value array.
         */
        values: string[];
    }

    export interface GetIdleInstancesIdleLoadBalancer {
        /**
         * The load balancing hostname.Note: This field may return null, indicating that no valid values can be obtained.
         */
        domain: string;
        /**
         * CLB type. Value range: 1 (CLB); 0 (classic CLB).
         */
        forward: number;
        /**
         * The reason why the load balancer is considered idle. NO_RULES: No rules configured. NO_RS: The rules are not associated with servers.
         */
        idleReason: string;
        /**
         * CLB instance ID.
         */
        loadBalancerId: string;
        /**
         * CLB instance name.
         */
        loadBalancerName: string;
        /**
         * CLB instance region.
         */
        region: string;
        /**
         * CLB instance status, including:0: Creating; 1: Running.
         */
        status: number;
        /**
         * CLB instance VIP.
         */
        vip: string;
    }

    export interface GetInstanceByCertIdCertSet {
        /**
         * Certificate ID.
         */
        certId: string;
        /**
         * List of CLB instances associated with certificate. Note: this field may return null, indicating that no valid values can be obtained.
         */
        loadBalancers: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancer[];
    }

    export interface GetInstanceByCertIdCertSetLoadBalancer {
        /**
         * IP version. Valid values: ipv4, ipv6. Note: this field may return null, indicating that no valid values can be obtained.
         */
        addressIPVersion: string;
        /**
         * IPv6 address of a CLB instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        addressIPv6: string;
        /**
         * Anycast CLB publishing region. For non-anycast CLB, this field returns an empty string. Note: This field may return null, indicating that no valid values can be obtained.
         */
        anycastZone: string;
        /**
         * Cluster ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        attributeFlags: string[];
        /**
         * backup zone.
         */
        backupZoneSets: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerBackupZoneSet[];
        /**
         * Billing mode of CLB instance. Valid values: PREPAID (monthly subscription), POSTPAID_BY_HOUR (pay as you go). Note: this field may return null, indicating that no valid values can be obtained.
         */
        chargeType: string;
        /**
         * Cluster ID. Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterIds: string[];
        /**
         * Dedicated layer-7 tag. Note: this field may return null, indicating that no valid values can be obtained.
         */
        clusterTag: string;
        /**
         * Custom configuration ID at the CLB instance level. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configId: string;
        /**
         * CLB instance creation time. Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Domain name of the CLB instance. It is only available for public classic CLBs. This parameter will be discontinued soon. Please use LoadBalancerDomain instead. Note: This field may return null, indicating that no valid values can be obtained.
         */
        domain: string;
        /**
         * Private network dedicated cluster. Note: this field may return null, indicating that no valid values can be obtained.
         */
        exclusiveClusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveCluster[];
        /**
         * CLB instance expiration time, which takes effect only for prepaid instances. Note: This field may return null, indicating that no valid values can be obtained.
         */
        expireTime: string;
        /**
         * Reserved field which can be ignored generally.Note: This field may return null, indicating that no valid values can be obtained.
         */
        extraInfos: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExtraInfo[];
        /**
         * CLB type identifier. Value range: 1 (CLB); 0 (classic CLB).
         */
        forward: number;
        /**
         * Health check logset ID of CLB CLS. Note: this field may return null, indicating that no valid values can be obtained.
         */
        healthLogSetId: string;
        /**
         * Health check log topic ID of CLB CLS. Note: this field may return null, indicating that no valid values can be obtained.
         */
        healthLogTopicId: string;
        /**
         * This field is meaningful only when the IP address version is ipv6. Valid values: IPv6Nat64, IPv6FullChain. Note: this field may return null, indicating that no valid values can be obtained.
         */
        ipv6Mode: string;
        /**
         * Whether VIP is blocked. Note: this field may return null, indicating that no valid values can be obtained.
         */
        isBlock: boolean;
        /**
         * Time blocked or unblocked. Note: this field may return null, indicating that no valid values can be obtained.
         */
        isBlockTime: string;
        /**
         * Whether an Anti-DDoS Pro instance can be bound. Note: This field may return null, indicating that no valid values can be obtained.
         */
        isDdos: boolean;
        /**
         * CLB instance isolation time. Note: This field may return null, indicating that no valid values can be obtained.
         */
        isolatedTime: string;
        /**
         * 0: not isolated; 1: isolated. Note: This field may return null, indicating that no valid values can be obtained.
         */
        isolation: number;
        /**
         * Domain name of the CLB instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        loadBalancerDomain: string;
        /**
         * CLB instance ID.
         */
        loadBalancerId: string;
        /**
         * CLB instance name.
         */
        loadBalancerName: string;
        /**
         * Whether a real server opens the traffic from a CLB instance to the internet. Note: this field may return null, indicating that no valid values can be obtained.
         */
        loadBalancerPassToTarget: boolean;
        /**
         * CLB instance network type:OPEN: public network; INTERNAL: private network.
         */
        loadBalancerType: string;
        /**
         * List of VIPs of a CLB instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        loadBalancerVips: string[];
        /**
         * Whether the IP type is the local BGP.
         */
        localBgp: boolean;
        /**
         * Log information. Only the public network CLB that have HTTP or HTTPS listeners can generate logs. Note: This field may return null, indicating that no valid values can be obtained.
         */
        log: string;
        /**
         * Logset ID of CLB Log Service (CLS). Note: This field may return null, indicating that no valid values can be obtained.
         */
        logSetId: string;
        /**
         * Log topic ID of CLB Log Service (CLS). Note: This field may return null, indicating that no valid values can be obtained.
         */
        logTopicId: string;
        /**
         * Primary AZ. Note: This field may return null, indicating that no valid values can be obtained.
         */
        masterZones: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerMasterZone[];
        /**
         * If the layer-7 listener of an IPv6FullChain CLB instance is enabled, the CLB instance can be bound with an IPv4 and an IPv6 CVM instance simultaneously. Note: this field may return null, indicating that no valid values can be obtained.
         */
        mixIpTarget: boolean;
        /**
         * CLB instance network attributes. Note: This field may return null, indicating that no valid values can be obtained.
         */
        networkAttributes: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerNetworkAttribute[];
        /**
         * Whether it is an NFV CLB instance. No returned information: no; l7nfv: yes. Note: this field may return null, indicating that no valid values can be obtained.
         */
        nfvInfo: string;
        /**
         * VPC ID in a numeric form. Note: This field may return null, indicating that no valid values can be obtained.
         */
        numericalVpcId: number;
        /**
         * Protective CLB identifier. Value range: 1 (protective), 0 (non-protective). Note: This field may return null, indicating that no valid values can be obtained.
         */
        openBgp: number;
        /**
         * Prepaid billing attributes of a CLB instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        prepaidAttributes: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerPrepaidAttribute[];
        /**
         * ID of the project to which a CLB instance belongs. 0: default project.
         */
        projectId: number;
        /**
         * Security group of a CLB instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        secureGroups: string[];
        /**
         * Specification of the LCU-supported instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        slaType: string;
        /**
         * SNAT is enabled for all private network classic CLB created before December 2016. Note: This field may return null, indicating that no valid values can be obtained.
         */
        snat: boolean;
        /**
         * SnatIp list after SnatPro load balancing is enabled. Note: this field may return null, indicating that no valid values can be obtained.
         */
        snatIps: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerSnatIp[];
        /**
         * Whether to enable SnatPro. Note: this field may return null, indicating that no valid values can be obtained.
         */
        snatPro: boolean;
        /**
         * CLB instance status, including:0: creating; 1: running. Note: This field may return null, indicating that no valid values can be obtained.
         */
        status: number;
        /**
         * Last status change time of a CLB instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        statusTime: string;
        /**
         * Subnet where a CLB instance resides (meaningful only for private network VPC CLB). Note: This field may return null, indicating that no valid values can be obtained.
         */
        subnetId: string;
        /**
         * CLB instance tag information. Note: This field may return null, indicating that no valid values can be obtained.
         */
        tags: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerTag[];
        /**
         * Basic information of a backend server bound to a CLB instance. Note: This field may return null, indicating that no valid values can be obtained.
         */
        targetRegionInfos: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerTargetRegionInfo[];
        /**
         * ISP to which a CLB IP address belongs. Note: This field may return null, indicating that no valid values can be obtained.
         */
        vipIsp: string;
        /**
         * VPC ID Note: This field may return null, indicating that no valid values can be obtained.
         */
        vpcId: string;
        /**
         * Availability zone of a VPC-based private network CLB instance. Note: this field may return null, indicating that no valid values can be obtained.
         */
        zones: string[];
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerBackupZoneSet {
        /**
         * Whether the AZ is an edge zone. Values: true, false. Note: This field may return null, indicating that no valid values can be obtained.
         */
        edgeZone: boolean;
        /**
         * Whether the AZ is the LocalZone, e.g., false. Note: This field may return null, indicating that no valid values can be obtained.
         */
        localZone: boolean;
        /**
         * Unique AZ ID in a numeric form, such as 100001. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zone: string;
        /**
         * .
         */
        zoneId: number;
        /**
         * AZ name, such as Guangzhou Zone 1. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zoneName: string;
        /**
         * AZ region, e.g., ap-guangzhou. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zoneRegion: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveCluster {
        /**
         * vpcgw cluster. Note: this field may return null, indicating that no valid values can be obtained.
         */
        classicalClusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterClassicalCluster[];
        /**
         * Layer-4 dedicated cluster list. Note: this field may return null, indicating that no valid values can be obtained.
         */
        l4Clusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL4Cluster[];
        /**
         * Layer-7 dedicated cluster list. Note: this field may return null, indicating that no valid values can be obtained.
         */
        l7Clusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL7Cluster[];
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterClassicalCluster {
        /**
         * Unique cluster ID.
         */
        clusterId: string;
        /**
         * Cluster name. Note: this field may return null, indicating that no valid values can be obtained.
         */
        clusterName: string;
        /**
         * Unique AZ ID in a numeric form, such as 100001. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zone: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL4Cluster {
        /**
         * Unique cluster ID.
         */
        clusterId: string;
        /**
         * Cluster name. Note: this field may return null, indicating that no valid values can be obtained.
         */
        clusterName: string;
        /**
         * Unique AZ ID in a numeric form, such as 100001. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zone: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL7Cluster {
        /**
         * Unique cluster ID.
         */
        clusterId: string;
        /**
         * Cluster name. Note: this field may return null, indicating that no valid values can be obtained.
         */
        clusterName: string;
        /**
         * Unique AZ ID in a numeric form, such as 100001. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zone: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExtraInfo {
        /**
         * TgwGroup name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        tgwGroupName: string;
        /**
         * Whether to enable VIP direct connection. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zhiTong: boolean;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerMasterZone {
        /**
         * Whether the AZ is an edge zone. Values: true, false. Note: This field may return null, indicating that no valid values can be obtained.
         */
        edgeZone: boolean;
        /**
         * Whether the AZ is the LocalZone, e.g., false. Note: This field may return null, indicating that no valid values can be obtained.
         */
        localZone: boolean;
        /**
         * Unique AZ ID in a numeric form, such as 100001. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zone: string;
        /**
         * .
         */
        zoneId: number;
        /**
         * AZ name, such as Guangzhou Zone 1. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zoneName: string;
        /**
         * AZ region, e.g., ap-guangzhou. Note: This field may return null, indicating that no valid values can be obtained.
         */
        zoneRegion: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerNetworkAttribute {
        /**
         * Bandwidth package type, such as SINGLEISP. Note: This field may return null, indicating that no valid values can be obtained.
         */
        bandwidthpkgSubType: string;
        /**
         * TRAFFIC_POSTPAID_BY_HOUR: hourly pay-as-you-go by traffic; BANDWIDTH_POSTPAID_BY_HOUR: hourly pay-as-you-go by bandwidth; BANDWIDTH_PACKAGE: billed by bandwidth package (currently, this method is supported only if the ISP is specified).
         */
        internetChargeType: string;
        /**
         * Maximum outbound bandwidth in Mbps, which applies only to public network CLB. Value range: 0-65,535. Default value: 10.
         */
        internetMaxBandwidthOut: number;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerPrepaidAttribute {
        /**
         * Cycle, indicating the number of months (reserved field). Note: This field may return null, indicating that no valid values can be obtained.
         */
        period: number;
        /**
         * Renewal type. AUTO_RENEW: automatic renewal; MANUAL_RENEW: manual renewal. Note: This field may return null, indicating that no valid values can be obtained.
         */
        renewFlag: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerSnatIp {
        /**
         * IP address, such as 192.168.0.1.
         */
        ip: string;
        /**
         * Subnet where a CLB instance resides (meaningful only for private network VPC CLB). Note: This field may return null, indicating that no valid values can be obtained.
         */
        subnetId: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerTag {
        /**
         * Tag key.
         */
        tagKey: string;
        /**
         * Tag value.
         */
        tagValue: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerTargetRegionInfo {
        /**
         * Region of the target, such as ap-guangzhou.
         */
        region: string;
        /**
         * VPC ID Note: This field may return null, indicating that no valid values can be obtained.
         */
        vpcId: string;
    }

    export interface GetInstanceDetailFilter {
        /**
         * Filter name.
         */
        name: string;
        /**
         * Filter value array.
         */
        values: string[];
    }

    export interface GetInstanceDetailLoadBalancerDetailSet {
        /**
         * CLB instance VIP.Note: this field may return null, indicating that no valid values can be obtained.
         */
        address: string;
        /**
         * IP version of the CLB instance. Valid values: IPv4, IPv6.Note: this field may return null, indicating that no valid values can be obtained.
         */
        addressIpVersion: string;
        /**
         * IPv6 VIP address of the CLB instance.Note: this field may return null, indicating that no valid values can be obtained.
         */
        addressIpv6: string;
        /**
         * ISP to which the CLB IP address belongs.Note: this field may return null, indicating that no valid values can be obtained.
         */
        addressIsp: string;
        /**
         * CLB instance billing mode.Note: this field may return null, indicating that no valid values can be obtained.
         */
        chargeType: string;
        /**
         * Custom configuration IDs of CLB instances. Multiple IDs must be separated by commas (,).Note: This field may return null, indicating that no valid values can be obtained.
         */
        configId: string;
        /**
         * CLB instance creation time.Note: this field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Domain name of the forwarding rule.Note: this field may return null, indicating that no valid values can be obtained.
         */
        domain: string;
        /**
         * List o domain names associated with the forwarding ruleNote: This field may return `null`, indicating that no valid values can be obtained.
         */
        domains: string;
        /**
         * Reserved field, which can be ignored generally.Note: this field may return null, indicating that no valid values can be obtained.
         */
        extraInfos: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetExtraInfo[];
        /**
         * IPv6 address type of the CLB instance. Valid values: IPv6Nat64, IPv6FullChain.Note: this field may return null, indicating that no valid values can be obtained.
         */
        ipv6Mode: string;
        /**
         * 0: not isolated; 1: isolated.Note: this field may return null, indicating that no valid values can be obtained.
         */
        isolation: number;
        /**
         * CLB listener ID.Note: this field may return null, indicating that no valid values can be obtained.
         */
        listenerId: string;
        /**
         * Domain name of the CLB instance.Note: This field may return null, indicating that no valid values can be obtained.
         */
        loadBalancerDomain: string;
        /**
         * CLB instance ID.
         */
        loadBalancerId: string;
        /**
         * CLB instance name.
         */
        loadBalancerName: string;
        /**
         * Whether the CLB instance is billed by IP.Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        loadBalancerPassToTarget: number;
        /**
         * CLB instance network type:Public: public network; Private: private network.Note: this field may return null, indicating that no valid values can be obtained.
         */
        loadBalancerType: string;
        /**
         * Forwarding rule ID.Note: this field may return null, indicating that no valid values can be obtained.
         */
        locationId: string;
        /**
         * CLB instance network attribute.Note: this field may return null, indicating that no valid values can be obtained.
         */
        networkAttributes: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetNetworkAttribute[];
        /**
         * Listener port.Note: this field may return null, indicating that no valid values can be obtained.
         */
        port: number;
        /**
         * Pay-as-you-go attribute of the CLB instance.Note: this field may return null, indicating that no valid values can be obtained.
         */
        prepaidAttributes: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetPrepaidAttribute[];
        /**
         * ID of the project to which the CLB instance belongs. 0: default project.Note: this field may return null, indicating that no valid values can be obtained.
         */
        projectId: number;
        /**
         * Listener protocol.Note: this field may return null, indicating that no valid values can be obtained.
         */
        protocol: string;
        /**
         * List of the security groups bound to the CLB instance.Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        securityGroups: string[];
        /**
         * The secondary zone of multi-AZ CLB instanceNote: This field may return `null`, indicating that no valid values can be obtained.
         */
        slaveZones: string[];
        /**
         * Whether SNI is enabled. This parameter is only meaningful for HTTPS listeners.Note: This field may return `null`, indicating that no valid values can be obtained.
         */
        sniSwitch: number;
        /**
         * CLB instance status, including:0: creating; 1: running.Note: this field may return null, indicating that no valid values can be obtained.
         */
        status: number;
        /**
         * CLB instance tag information.Note: this field may return null, indicating that no valid values can be obtained.
         */
        tags: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetTag[];
        /**
         * Address of target real servers.Note: this field may return null, indicating that no valid values can be obtained.
         */
        targetAddress: string;
        /**
         * Health status of the target real server.Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        targetHealth: string;
        /**
         * ID of target real servers.Note: this field may return null, indicating that no valid values can be obtained.
         */
        targetId: string;
        /**
         * Listening port of target real servers.Note: this field may return null, indicating that no valid values can be obtained.
         */
        targetPort: number;
        /**
         * Forwarding weight of target real servers.Note: this field may return null, indicating that no valid values can be obtained.
         */
        targetWeight: number;
        /**
         * Forwarding rule path.Note: this field may return null, indicating that no valid values can be obtained.
         */
        url: string;
        /**
         * ID of the VPC instance to which the CLB instance belongs.Note: this field may return null, indicating that no valid values can be obtained.
         */
        vpcId: string;
        /**
         * Availability zone where the CLB instance resides.Note: this field may return null, indicating that no valid values can be obtained.
         */
        zone: string;
        /**
         * The AZ of private CLB instance. This is only available for beta users.Note: This field may return `null`, indicating that no valid values can be obtained.
         */
        zones: string[];
    }

    export interface GetInstanceDetailLoadBalancerDetailSetExtraInfo {
        /**
         * TgwGroup nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        tgwGroupName: string;
        /**
         * Whether to enable VIP direct connectionNote: This field may return null, indicating that no valid values can be obtained.
         */
        zhiTong: boolean;
    }

    export interface GetInstanceDetailLoadBalancerDetailSetNetworkAttribute {
        /**
         * Bandwidth package type, such as SINGLEISPNote: This field may return null, indicating that no valid values can be obtained.
         */
        bandwidthPkgSubType: string;
        /**
         * TRAFFIC_POSTPAID_BY_HOUR: hourly pay-as-you-go by traffic; BANDWIDTH_POSTPAID_BY_HOUR: hourly pay-as-you-go by bandwidth;BANDWIDTH_PACKAGE: billed by bandwidth package (currently, this method is supported only if the ISP is specified).
         */
        internetChargeType: string;
        /**
         * Maximum outbound bandwidth in Mbps, which applies only to public network CLB. Value range: 0-65,535. Default value: 10.
         */
        internetMaxBandwidthOut: number;
    }

    export interface GetInstanceDetailLoadBalancerDetailSetPrepaidAttribute {
        /**
         * Cycle, indicating the number of months (reserved field)Note: This field may return null, indicating that no valid values can be obtained.
         */
        period: number;
        /**
         * Renewal type. AUTO_RENEW: automatic renewal; MANUAL_RENEW: manual renewalNote: This field may return null, indicating that no valid values can be obtained.
         */
        renewFlag: string;
    }

    export interface GetInstanceDetailLoadBalancerDetailSetTag {
        /**
         * Tag key.
         */
        tagKey: string;
        /**
         * Tag value.
         */
        tagValue: string;
    }

    export interface GetInstanceTrafficLoadBalancerTraffic {
        /**
         * CLB domain name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        domain: string;
        /**
         * CLB instance ID.
         */
        loadBalancerId: string;
        /**
         * CLB instance name.
         */
        loadBalancerName: string;
        /**
         * Maximum outbound bandwidth in Mbps.
         */
        outBandwidth: number;
        /**
         * CLB instance region.
         */
        region: string;
        /**
         * CLB instance VIP.
         */
        vip: string;
    }

    export interface GetInstancesClbList {
        /**
         * IP version, only applicable to open CLB. Valid values are `IPV4`, `IPV6` and `IPv6FullChain`.
         */
        addressIpVersion: string;
        /**
         * ID of the CLB to be queried.
         */
        clbId: string;
        /**
         * Name of the CLB to be queried.
         */
        clbName: string;
        /**
         * The virtual service address table of the CLB.
         */
        clbVips: string[];
        /**
         * Create time of the CLB.
         */
        createTime: string;
        /**
         * Max bandwidth out, only applicable to open CLB. Valid value ranges is [1, 2048]. Unit is MB.
         */
        internetBandwidthMaxOut: number;
        /**
         * Internet charge type, only applicable to open CLB. Valid values are `TRAFFIC_POSTPAID_BY_HOUR`, `BANDWIDTH_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
         */
        internetChargeType: string;
        /**
         * Whether this available zone is local zone, This field maybe null, means cannot get a valid value.
         */
        localZone: boolean;
        /**
         * Type of CLB instance, and available values include `OPEN` and `INTERNAL`.
         */
        networkType: string;
        /**
         * Project ID of the CLB.
         */
        projectId: number;
        /**
         * ID set of the security groups.
         */
        securityGroups: string[];
        /**
         * The status of CLB.
         */
        status: number;
        /**
         * Latest state transition time of CLB.
         */
        statusTime: string;
        /**
         * ID of the subnet.
         */
        subnetId: string;
        /**
         * The available tags within this CLB.
         */
        tags: {[key: string]: any};
        /**
         * Region information of backend service are attached the CLB.
         */
        targetRegionInfoRegion: string;
        /**
         * VpcId information of backend service are attached the CLB.
         */
        targetRegionInfoVpcId: string;
        /**
         * Network operator, only applicable to open CLB. Valid values are `CMCC`(China Mobile), `CTCC`(Telecom), `CUCC`(China Unicom) and `BGP`. If this ISP is specified, network billing method can only use the bandwidth package billing (BANDWIDTH_PACKAGE).
         */
        vipIsp: string;
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * Available zone unique id(string representation), This field maybe null, means cannot get a valid value.
         */
        zone: string;
        /**
         * Available zone unique id(numerical representation), This field maybe null, means cannot get a valid value.
         */
        zoneId: number;
        /**
         * Available zone name, This field maybe null, means cannot get a valid value.
         */
        zoneName: string;
        /**
         * Region that this available zone belong to, This field maybe null, means cannot get a valid value.
         */
        zoneRegion: string;
    }

    export interface GetListenerRulesRuleList {
        /**
         * ID of the client certificate. NOTES: Only supports listeners of 'HTTPS' and 'TCP_SSL' protocol.
         */
        certificateCaId: string;
        /**
         * ID of the server certificate. NOTES: Only supports listeners of 'HTTPS'  and 'TCP_SSL' protocol.
         */
        certificateId: string;
        /**
         * Type of SSL Mode, and available values inclue 'UNIDIRECTIONAL', 'MUTUAL'.NOTES: Only supports listeners of 'HTTPS'  and 'TCP_SSL' protocol.
         */
        certificateSslMode: string;
        /**
         * ID of the CLB to be queried.
         */
        clbId: string;
        /**
         * Domain name of the forwarding rule to be queried.
         */
        domain?: string;
        /**
         * Health threshold of health check, and the default is `3`. If a success result is returned for the health check three consecutive times, the CVM is identified as healthy. The value range is 2-10. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        healthCheckHealthNum: number;
        /**
         * HTTP Status Code. The default is 31 and value range is 1-31. 1 means the return value '1xx' is health. 2 means the return value '2xx' is health. 4 means the return value '3xx' is health. 8 means the return value 4xx is health. 16 means the return value '5xx' is health. If you want multiple return codes to indicate health, need to add the corresponding values. NOTES: The 'HTTP' health check of the 'TCP' listener only supports specifying one health check status code. NOTES: Only supports listeners of 'HTTP' and 'HTTPS' protocol.
         */
        healthCheckHttpCode: number;
        /**
         * Domain name of health check. NOTES: Only supports listeners of 'HTTPS' and 'HTTP' protocol.
         */
        healthCheckHttpDomain: string;
        /**
         * Methods of health check. NOTES: Only supports listeners of 'HTTPS' and 'HTTP' protocol. The default is 'HEAD', the available value include 'HEAD' and 'GET'.
         */
        healthCheckHttpMethod: string;
        /**
         * Path of health check. NOTES: Only supports listeners of 'HTTPS' and 'HTTP' protocol.
         */
        healthCheckHttpPath: string;
        /**
         * Interval time of health check. The value range is 2-300 sec, and the default is `5` sec. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        healthCheckIntervalTime: number;
        /**
         * Indicates whether health check is enabled.
         */
        healthCheckSwitch: boolean;
        /**
         * Unhealth threshold of health check, and the default is `3`. If a success result is returned for the health check three consecutive times, the CVM is identified as unhealthy. The value range is 2-10. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        healthCheckUnhealthNum: number;
        /**
         * Indicate to set HTTP2 protocol or not.
         */
        http2Switch: boolean;
        /**
         * ID of the CLB listener to be queried.
         */
        listenerId: string;
        /**
         * ID of the forwarding rule to be queried.
         */
        ruleId: string;
        /**
         * Scheduling method of the forwarding rule of thr CLB listener, and available values include `WRR`, `IP HASH` and `LEAST_CONN`. The default is `WRR`.
         */
        scheduler: string;
        /**
         * Time of session persistence within the CLB listener. NOTES: Available when scheduler is specified as 'WRR'. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        sessionExpireTime: number;
        /**
         * Url of the forwarding rule to be queried.
         */
        url?: string;
    }

    export interface GetListenersByTargetsBackend {
        /**
         * Private network IP to be queried, which can be of the CVM or ENI.
         */
        privateIp: string;
        /**
         * VPC ID.
         */
        vpcId: string;
    }

    export interface GetListenersByTargetsLoadBalancer {
        /**
         * Listener rule.
         */
        listeners: outputs.Clb.GetListenersByTargetsLoadBalancerListener[];
        /**
         * String ID of the CLB instance.
         */
        loadBalancerId: string;
        /**
         * CLB instance region.
         */
        region: string;
        /**
         * VIP of the CLB instance.
         */
        vip: string;
    }

    export interface GetListenersByTargetsLoadBalancerListener {
        /**
         * End port of the listener. Note: this field may return null, indicating that no valid values can be obtained.
         */
        endPort: number;
        /**
         * Listener ID.
         */
        listenerId: string;
        /**
         * Port bound to the real server.
         */
        port: number;
        /**
         * Listener protocol.
         */
        protocol: string;
        /**
         * Bound rule. Note: this field may return null, indicating that no valid values can be obtained.
         */
        rules: outputs.Clb.GetListenersByTargetsLoadBalancerListenerRule[];
        /**
         * Object bound to the layer-4 listener. Note: this field may return null, indicating that no valid values can be obtained.
         */
        targets: outputs.Clb.GetListenersByTargetsLoadBalancerListenerTarget[];
    }

    export interface GetListenersByTargetsLoadBalancerListenerRule {
        /**
         * Domain name.
         */
        domain: string;
        /**
         * Rule ID.
         */
        locationId: string;
        /**
         * Object bound to the layer-4 listener. Note: this field may return null, indicating that no valid values can be obtained.
         */
        targets: outputs.Clb.GetListenersByTargetsLoadBalancerListenerRuleTarget[];
        /**
         * url.
         */
        url: string;
    }

    export interface GetListenersByTargetsLoadBalancerListenerRuleTarget {
        /**
         * Port bound to the real server.
         */
        port: number;
        /**
         * Private network IP to be queried, which can be of the CVM or ENI.
         */
        privateIp: string;
        /**
         * Private network IP type, which can be cvm or eni.
         */
        type: string;
        /**
         * VPC ID.
         */
        vpcId: number;
        /**
         * Weight of the real server. Note: this field may return null, indicating that no valid values can be obtained.
         */
        weight: number;
    }

    export interface GetListenersByTargetsLoadBalancerListenerTarget {
        /**
         * Port bound to the real server.
         */
        port: number;
        /**
         * Private network IP to be queried, which can be of the CVM or ENI.
         */
        privateIp: string;
        /**
         * Private network IP type, which can be cvm or eni.
         */
        type: string;
        /**
         * VPC ID.
         */
        vpcId: number;
        /**
         * Weight of the real server. Note: this field may return null, indicating that no valid values can be obtained.
         */
        weight: number;
    }

    export interface GetListenersListenerList {
        /**
         * Id of the client certificate. It must be set when SSLMode is `mutual`. NOTES: only supported by listeners of `HTTPS` and `TCP_SSL` protocol.
         */
        certificateCaId: string;
        /**
         * Id of the server certificate. It must be set when protocol is `HTTPS` or `TCP_SSL`. NOTES: only supported by listeners of `HTTPS` and `TCP_SSL` protocol and must be set when it is available.
         */
        certificateId: string;
        /**
         * Type of certificate, and available values inclue `UNIDIRECTIONAL`, `MUTUAL`. NOTES: Only supports listeners of `HTTPS` and `TCP_SSL` protocol and must be set when it is available.
         */
        certificateSslMode: string;
        /**
         * Id of the CLB to be queried.
         */
        clbId: string;
        /**
         * Health check protocol.
         */
        healthCheckContextType: string;
        /**
         * Health threshold of health check, and the default is `3`. If a success result is returned for the health check three consecutive times, the CVM is identified as healthy. The value range is 2-10. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        healthCheckHealthNum: number;
        /**
         * HTTP health check code of TCP listener.
         */
        healthCheckHttpCode: number;
        /**
         * HTTP health check domain of TCP listener.
         */
        healthCheckHttpDomain: string;
        /**
         * HTTP health check method of TCP listener.
         */
        healthCheckHttpMethod: string;
        /**
         * HTTP health check path of TCP listener.
         */
        healthCheckHttpPath: string;
        /**
         * The HTTP version of the backend service.
         */
        healthCheckHttpVersion: string;
        /**
         * Interval time of health check. The value range is 2-300 sec, and the default is `5` sec. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        healthCheckIntervalTime: number;
        /**
         * The health check port is the port of the backend service.
         */
        healthCheckPort: number;
        /**
         * It represents the result returned by the health check.
         */
        healthCheckRecvContext: string;
        /**
         * It represents the content of the request sent by the health check.
         */
        healthCheckSendContext: string;
        /**
         * Indicates whether health check is enabled.
         */
        healthCheckSwitch: boolean;
        /**
         * Response timeout of health check. The value range is 2-60 sec, and the default is `2` sec. Response timeout needs to be less than check interval. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration.
         */
        healthCheckTimeOut: number;
        /**
         * Protocol used for health check.
         */
        healthCheckType: string;
        /**
         * Unhealthy threshold of health check, and the default is `3`. If a success result is returned for the health check three consecutive times, the CVM is identified as unhealthy. The value range is 2-10. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        healthCheckUnhealthNum: number;
        /**
         * Id of the listener to be queried.
         */
        listenerId: string;
        /**
         * Name of the CLB listener.
         */
        listenerName: string;
        /**
         * Port of the CLB listener.
         */
        port: number;
        /**
         * Type of protocol within the listener, and available values are `TCP`, `UDP`, `HTTP`, `HTTPS` and `TCP_SSL`.
         */
        protocol: string;
        /**
         * Scheduling method of the CLB listener, and available values are `WRR` and `LEAST_CONN`. The default is `WRR`. NOTES: The listener of 'HTTP' and `HTTPS` protocol additionally supports the `IP HASH` method. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        scheduler: string;
        /**
         * Time of session persistence within the CLB listener. NOTES: TCP/UDP/TCP_SSL listener allows direct configuration, HTTP/HTTPS listener needs to be configured in tencentcloud_clb_listener_rule.
         */
        sessionExpireTime: number;
        /**
         * Indicates whether SNI is enabled. NOTES: Only supported by `HTTPS` protocol.
         */
        sniSwitch: boolean;
    }

    export interface GetRedirectionsRedirectionList {
        /**
         * ID of the CLB to be queried.
         */
        clbId: string;
        /**
         * ID of source listener to be queried.
         */
        sourceListenerId: string;
        /**
         * Rule ID of source listener to be queried.
         */
        sourceRuleId: string;
        /**
         * ID of target listener to be queried.
         */
        targetListenerId: string;
        /**
         * Rule ID of target listener to be queried.
         */
        targetRuleId: string;
    }

    export interface GetResourcesFilter {
        /**
         * Filter name.
         */
        name: string;
        /**
         * Filter value array.
         */
        values: string[];
    }

    export interface GetResourcesZoneResourceSet {
        /**
         * Whether the AZ is an edge zone. Values: true, false.
         */
        edgeZone: boolean;
        /**
         * IP version. Values: IPv4, IPv6, and IPv6_Nat.
         */
        ipVersion: string;
        /**
         * Whether the AZ is a LocalZone. Values: true, false.
         */
        localZone: boolean;
        /**
         * Primary AZ, such as ap-guangzhou-1.
         */
        masterZone: string;
        /**
         * List of resources. Note: This field may return null, indicating that no valid values can be obtained.
         */
        resourceSets: outputs.Clb.GetResourcesZoneResourceSetResourceSet[];
        /**
         * Secondary AZ, such as ap-guangzhou-2. Note: This field may return null, indicating that no valid values can be obtained.
         */
        slaveZone: string;
        /**
         * Region of the AZ, such as ap-guangzhou.
         */
        zoneRegion: string;
        /**
         * Type of resources in the zone. Values: SHARED, EXCLUSIVE.
         */
        zoneResourceType: string;
    }

    export interface GetResourcesZoneResourceSetResourceSet {
        /**
         * Available resources. Note: This field may return null, indicating that no valid values can be obtaine.
         */
        availabilitySets: outputs.Clb.GetResourcesZoneResourceSetResourceSetAvailabilitySet[];
        /**
         * ISP information, such as CMCC, CUCC, CTCC, BGP, and INTERNAL.
         */
        isp: string;
        /**
         * Specific ISP resource information, Vaules: CMCC, CUCC, CTCC, BGP, and INTERNAL.
         */
        types: string[];
    }

    export interface GetResourcesZoneResourceSetResourceSetAvailabilitySet {
        /**
         * Whether the resource is available. Values: Available, Unavailable.
         */
        availability: string;
        /**
         * Specific ISP resource information, Vaules: CMCC, CUCC, CTCC, BGP, and INTERNAL.
         */
        type: string;
    }

    export interface GetTargetGroupListFilter {
        /**
         * Filter name.
         */
        name: string;
        /**
         * Filter value array.
         */
        values: string[];
    }

    export interface GetTargetGroupListTargetGroupSet {
        /**
         * Array of associated rules. Note: this field may return null, indicating that no valid values can be obtained.
         */
        associatedRules: outputs.Clb.GetTargetGroupListTargetGroupSetAssociatedRule[];
        /**
         * Target group creation time.
         */
        createdTime: string;
        /**
         * Default port of target group. Note: this field may return null, indicating that no valid values can be obtained.
         */
        port: number;
        /**
         * Target group ID.
         */
        targetGroupId: string;
        /**
         * Target group name.
         */
        targetGroupName: string;
        /**
         * Target group modification time.
         */
        updatedTime: string;
        /**
         * vpcid of target group.
         */
        vpcId: string;
    }

    export interface GetTargetGroupListTargetGroupSetAssociatedRule {
        /**
         * Domain name of associated forwarding rule. Note: this field may return null, indicating that no valid values can be obtained.
         */
        domain: string;
        /**
         * ID of associated listener.
         */
        listenerId: string;
        /**
         * Listener name.
         */
        listenerName: string;
        /**
         * ID of associated CLB instance.
         */
        loadBalancerId: string;
        /**
         * CLB instance name.
         */
        loadBalancerName: string;
        /**
         * ID of associated forwarding rule. Note: this field may return null, indicating that no valid values can be obtained.
         */
        locationId: string;
        /**
         * Default port of target group. Note: this field may return null, indicating that no valid values can be obtained.
         */
        port: number;
        /**
         * Protocol type of associated listener, such as HTTP or TCP.
         */
        protocol: string;
        /**
         * URL of associated forwarding rule. Note: this field may return null, indicating that no valid values can be obtained.
         */
        url: string;
    }

    export interface GetTargetGroupsList {
        /**
         * List of associated rules.
         */
        associatedRuleLists: outputs.Clb.GetTargetGroupsListAssociatedRuleList[];
        /**
         * Creation time of the target group.
         */
        createTime: string;
        /**
         * Port of target group.
         */
        port: number;
        /**
         * ID of Target group. Mutually exclusive with `vpcId` and `targetGroupName`. `targetGroupId` is preferred.
         */
        targetGroupId: string;
        /**
         * List of backend servers bound to the target group.
         */
        targetGroupInstanceLists: outputs.Clb.GetTargetGroupsListTargetGroupInstanceList[];
        /**
         * Name of target group. Mutually exclusive with `targetGroupId`. `targetGroupId` is preferred.
         */
        targetGroupName: string;
        /**
         * Modification time of the target group.
         */
        updateTime: string;
        /**
         * Target group VPC ID. Mutually exclusive with `targetGroupId`. `targetGroupId` is preferred.
         */
        vpcId: string;
    }

    export interface GetTargetGroupsListAssociatedRuleList {
        /**
         * Forwarding rule domain.
         */
        domain: string;
        /**
         * Listener ID.
         */
        listenerId: string;
        /**
         * Listener name.
         */
        listenerName: string;
        /**
         * Listener port.
         */
        listenerPort: number;
        /**
         * Load balance ID.
         */
        loadBalancerId: string;
        /**
         * Load balance name.
         */
        loadBalancerName: string;
        /**
         * Forwarding rule ID.
         */
        locationId: string;
        /**
         * Listener protocol type.
         */
        protocol: string;
        /**
         * Forwarding rule URL.
         */
        url: string;
    }

    export interface GetTargetGroupsListTargetGroupInstanceList {
        /**
         * ID of Elastic Network Interface.
         */
        eniId: string;
        /**
         * ID of backend service.
         */
        instanceId: string;
        /**
         * The instance name of the backend service.
         */
        instanceName: string;
        /**
         * Intranet IP list of back-end services.
         */
        privateIpAddresses: any[];
        /**
         * List of external network IP of back-end services.
         */
        publicIpAddresses: any[];
        /**
         * The time the backend service was bound.
         */
        registeredTime: string;
        /**
         * Port of backend service.
         */
        serverPort: number;
        /**
         * Type of backend service.
         */
        serverType: string;
        /**
         * Forwarding weight of back-end services.
         */
        weight: number;
    }

    export interface GetTargetHealthLoadBalancer {
        /**
         * List of listeners. Note: This field may return null, indicating that no valid values can be obtained.
         */
        listeners: outputs.Clb.GetTargetHealthLoadBalancerListener[];
        /**
         * CLB instance ID.
         */
        loadBalancerId: string;
        /**
         * CLB instance name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        loadBalancerName: string;
    }

    export interface GetTargetHealthLoadBalancerListener {
        /**
         * Listener ID.
         */
        listenerId: string;
        /**
         * Listener name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        listenerName: string;
        /**
         * Port bound to the target.
         */
        port: number;
        /**
         * Listener protocol.
         */
        protocol: string;
        /**
         * List of forwarding rules of the listener. Note: This field may return null, indicating that no valid values can be obtained.
         */
        rules: outputs.Clb.GetTargetHealthLoadBalancerListenerRule[];
    }

    export interface GetTargetHealthLoadBalancerListenerRule {
        /**
         * Domain name of the forwarding rule. Note: This field may return null, indicating that no valid values can be obtained.
         */
        domain: string;
        /**
         * Forwarding rule ID.
         */
        locationId: string;
        /**
         * Health status of the real server bound to this rule. Note: this field may return null, indicating that no valid values can be obtained.
         */
        targets: outputs.Clb.GetTargetHealthLoadBalancerListenerRuleTarget[];
        /**
         * Forwarding rule Url. Note: This field may return null, indicating that no valid values can be obtained.
         */
        url: string;
    }

    export interface GetTargetHealthLoadBalancerListenerRuleTarget {
        /**
         * Current health status. true: healthy; false: unhealthy.
         */
        healthStatus: boolean;
        /**
         * Detailed information about the current health status. Alive: healthy; Dead: exceptional; Unknown: check not started/checking/unknown status.
         */
        healthStatusDetail: string;
        /**
         * Private IP of the target.
         */
        ip: string;
        /**
         * Port bound to the target.
         */
        port: number;
        /**
         * Instance ID of the target, such as ins-12345678.
         */
        targetId: string;
    }

    export interface InstanceSnatIp {
        /**
         * Snat IP address, If set to empty will auto allocated.
         */
        ip?: string;
        /**
         * Snat subnet ID.
         */
        subnetId: string;
    }

    export interface ReplaceCertForLbsCertificate {
        /**
         * Content of the uploaded client certificate. When SSLMode = mutual, if there is no CertCaId, this parameter is required.
         */
        certCaContent?: string;
        /**
         * ID of a client certificate. When the listener adopts mutual authentication (i.e., SSLMode = mutual), if you leave this parameter empty, you must upload the client certificate, including CertCaContent and CertCaName.
         */
        certCaId?: string;
        /**
         * Name of the uploaded client CA certificate. When SSLMode = mutual, if there is no CertCaId, this parameter is required.
         */
        certCaName?: string;
        /**
         * Content of the uploaded server certificate. If there is no CertId, this parameter is required.
         */
        certContent?: string;
        /**
         * ID of a server certificate. If you leave this parameter empty, you must upload the certificate, including CertContent, CertKey, and CertName.
         */
        certId?: string;
        /**
         * Key of the uploaded server certificate. If there is no CertId, this parameter is required.
         */
        certKey?: string;
        /**
         * Name of the uploaded server certificate. If there is no CertId, this parameter is required.
         */
        certName?: string;
        /**
         * Authentication type. Value range: UNIDIRECTIONAL (unidirectional authentication), MUTUAL (mutual authentication).
         */
        sslMode?: string;
    }

    export interface SnatIpIp {
        /**
         * Snat IP.
         */
        ip: string;
        /**
         * Subnet ID.
         */
        subnetId: string;
    }

    export interface TargetGroupAttachmentsAssociation {
        /**
         * Listener ID.
         */
        listenerId?: string;
        /**
         * CLB instance ID, when the binding target is target group, loadBalancerId in associations is required.
         */
        loadBalancerId?: string;
        /**
         * Forwarding rule ID.
         */
        locationId?: string;
        /**
         * Target group ID, when the binding target is clb, the targetGroupId in associations is required.
         */
        targetGroupId?: string;
    }

    export interface TargetGroupTargetGroupInstance {
        /**
         * The internal ip of target group instance.
         */
        bindIp: string;
        /**
         * The new port of target group instance.
         */
        newPort?: number;
        /**
         * The port of target group instance.
         */
        port: number;
        /**
         * The weight of target group instance.
         */
        weight?: number;
    }

}

export namespace Clickhouse {
    export interface AccountPermissionDatabasePrivilegeList {
        /**
         * Database name.
         */
        databaseName: string;
        /**
         * Database privileges. Valid valuse: SELECT, INSERT_ALL, ALTER, TRUNCATE, DROP_TABLE, CREATE_TABLE, DROP_DATABASE.
         */
        databasePrivileges?: string[];
        /**
         * Table privilege list.
         */
        tablePrivilegeLists?: outputs.Clickhouse.AccountPermissionDatabasePrivilegeListTablePrivilegeList[];
    }

    export interface AccountPermissionDatabasePrivilegeListTablePrivilegeList {
        /**
         * Table name.
         */
        tableName: string;
        /**
         * Table privileges. Valid values: SELECT, INSERT_ALL, ALTER, TRUNCATE, DROP_TABLE.
         */
        tablePrivileges: string[];
    }

    export interface BackupStrategyDataBackupStrategy {
        /**
         * Back up the list of tables.
         */
        backUpTables: outputs.Clickhouse.BackupStrategyDataBackupStrategyBackUpTable[];
        /**
         * Execution hour.
         */
        executeHour: number;
        /**
         * Retention days.
         */
        retainDays: number;
        /**
         * The day of the week is separated by commas. For example: 2 represents Tuesday.
         */
        weekDays: string;
    }

    export interface BackupStrategyDataBackupStrategyBackUpTable {
        /**
         * Database.
         */
        database: string;
        /**
         * Table ip.
         */
        ips: string;
        /**
         * Ip address of cvm.
         */
        rip: string;
        /**
         * Table.
         */
        table: string;
        /**
         * Back up the list of tables.
         */
        totalBytes: number;
        /**
         * Virtual clusters.
         */
        vCluster: string;
        /**
         * ZK path.
         */
        zooPath: string;
    }

    export interface BackupStrategyMetaBackupStrategy {
        /**
         * Execution hour.
         */
        executeHour?: number;
        /**
         * Retention days.
         */
        retainDays?: number;
        /**
         * The day of the week is separated by commas. For example: 2 represents Tuesday.
         */
        weekDays?: string;
    }

    export interface GetBackupJobDetailTableContent {
        /**
         * Database.
         */
        database: string;
        /**
         * Ips.
         */
        ips: string;
        /**
         * Ip address of cvm.
         */
        rip: string;
        /**
         * Table.
         */
        table: string;
        /**
         * Total bytes.
         */
        totalBytes: number;
        /**
         * Virtual cluster.
         */
        vCluster: string;
        /**
         * ZK path.
         */
        zooPath: string;
    }

    export interface GetBackupJobsBackUpJob {
        /**
         * Back up size.
         */
        backUpSize: number;
        /**
         * Back up create time.
         */
        backUpTime: string;
        /**
         * Back up type.
         */
        backUpType: string;
        /**
         * Back up expire time.
         */
        expireTime: string;
        /**
         * Back up job id.
         */
        jobId: number;
        /**
         * Job status.
         */
        jobStatus: string;
        /**
         * Back up job name.
         */
        snapshot: string;
    }

    export interface GetBackupTablesAvailableTable {
        /**
         * Database.
         */
        database: string;
        /**
         * Table ips.
         */
        ips: string;
        /**
         * Ip address of cvm.
         */
        rip: string;
        /**
         * Table.
         */
        table: string;
        /**
         * Table total bytes.
         */
        totalBytes: number;
        /**
         * Virtual cluster.
         */
        vCluster: string;
        /**
         * Zk path.
         */
        zooPath: string;
    }

    export interface GetInstanceNodesInstanceNodesList {
        /**
         * Name of the clickhouse cluster to which it belongs.
         */
        cluster: string;
        /**
         * CPU cores.
         */
        core: number;
        /**
         * Disk size.
         */
        diskSize: number;
        /**
         * Disk type.
         */
        diskType: string;
        /**
         * IP Address.
         */
        ip: string;
        /**
         * When true, it indicates that the chproxy process has been deployed on the node.
         */
        isChProxy: boolean;
        /**
         * Memory size.
         */
        memory: number;
        /**
         * Group information to which the node belongs.
         */
        nodeGroups: outputs.Clickhouse.GetInstanceNodesInstanceNodesListNodeGroup[];
        /**
         * VPC IP.
         */
        rip: string;
        /**
         * Model, such as S1.
         */
        spec: string;
    }

    export interface GetInstanceNodesInstanceNodesListNodeGroup {
        /**
         * Group Name.
         */
        groupName: string;
        /**
         * Copy variable name.
         */
        replicaName: string;
        /**
         * Fragmented variable name.
         */
        shardName: string;
    }

    export interface GetSpecAttachCbsSpec {
        /**
         * Number of disks.
         */
        diskCount: number;
        /**
         * Disk type description.
         */
        diskDesc: string;
        /**
         * Disk type.
         */
        diskType: string;
        /**
         * Maximum disk size, unit G.
         */
        maxDiskSize: number;
        /**
         * Minimum disk size, unit G.
         */
        minDiskSize: number;
    }

    export interface GetSpecCommonSpec {
        /**
         * Whether it is available, false means sold out.
         */
        available: boolean;
        /**
         * Specification description information.
         */
        computeSpecDesc: string;
        /**
         * Number of cpu cores.
         */
        cpu: number;
        /**
         * Data disk description information.
         */
        dataDisks: outputs.Clickhouse.GetSpecCommonSpecDataDisk[];
        /**
         * Specification name.
         */
        displayName: string;
        /**
         * Inventory.
         */
        instanceQuota: number;
        /**
         * Maximum number of nodes limit.
         */
        maxNodeSize: number;
        /**
         * Memory size, unit G.
         */
        mem: number;
        /**
         * Specification name.
         */
        name: string;
        /**
         * System disk description information.
         */
        systemDisks: outputs.Clickhouse.GetSpecCommonSpecSystemDisk[];
        /**
         * Classification tags, STANDARD/BIGDATA/HIGHIO respectively represent standard/big data/high IO.
         */
        type: string;
    }

    export interface GetSpecCommonSpecDataDisk {
        /**
         * Number of disks.
         */
        diskCount: number;
        /**
         * Disk type description.
         */
        diskDesc: string;
        /**
         * Disk type.
         */
        diskType: string;
        /**
         * Maximum disk size, unit G.
         */
        maxDiskSize: number;
        /**
         * Minimum disk size, unit G.
         */
        minDiskSize: number;
    }

    export interface GetSpecCommonSpecSystemDisk {
        /**
         * Number of disks.
         */
        diskCount: number;
        /**
         * Disk type description.
         */
        diskDesc: string;
        /**
         * Disk type.
         */
        diskType: string;
        /**
         * Maximum disk size, unit G.
         */
        maxDiskSize: number;
        /**
         * Minimum disk size, unit G.
         */
        minDiskSize: number;
    }

    export interface GetSpecDataSpec {
        /**
         * Whether it is available, false means sold out.
         */
        available: boolean;
        /**
         * Specification description information.
         */
        computeSpecDesc: string;
        /**
         * Number of cpu cores.
         */
        cpu: number;
        /**
         * Data disk description information.
         */
        dataDisks: outputs.Clickhouse.GetSpecDataSpecDataDisk[];
        /**
         * Specification name.
         */
        displayName: string;
        /**
         * Inventory.
         */
        instanceQuota: number;
        /**
         * Maximum number of nodes limit.
         */
        maxNodeSize: number;
        /**
         * Memory size, unit G.
         */
        mem: number;
        /**
         * Specification name.
         */
        name: string;
        /**
         * System disk description information.
         */
        systemDisks: outputs.Clickhouse.GetSpecDataSpecSystemDisk[];
        /**
         * Classification tags, STANDARD/BIGDATA/HIGHIO respectively represent standard/big data/high IO.
         */
        type: string;
    }

    export interface GetSpecDataSpecDataDisk {
        /**
         * Number of disks.
         */
        diskCount: number;
        /**
         * Disk type description.
         */
        diskDesc: string;
        /**
         * Disk type.
         */
        diskType: string;
        /**
         * Maximum disk size, unit G.
         */
        maxDiskSize: number;
        /**
         * Minimum disk size, unit G.
         */
        minDiskSize: number;
    }

    export interface GetSpecDataSpecSystemDisk {
        /**
         * Number of disks.
         */
        diskCount: number;
        /**
         * Disk type description.
         */
        diskDesc: string;
        /**
         * Disk type.
         */
        diskType: string;
        /**
         * Maximum disk size, unit G.
         */
        maxDiskSize: number;
        /**
         * Minimum disk size, unit G.
         */
        minDiskSize: number;
    }

    export interface InstanceCommonSpec {
        /**
         * Node count. NOTE: Only support value 3.
         */
        count: number;
        /**
         * Disk size.
         */
        diskSize: number;
        /**
         * Spec name.
         */
        specName: string;
    }

    export interface InstanceDataSpec {
        /**
         * Data spec count.
         */
        count: number;
        /**
         * Disk size.
         */
        diskSize: number;
        /**
         * Spec name.
         */
        specName: string;
    }

    export interface KeyvalConfigItems {
        /**
         * Instance config key.
         */
        confKey: string;
        /**
         * Instance config value.
         */
        confValue: string;
    }

    export interface XmlConfigModifyConfContext {
        /**
         * Configuration file name.
         */
        fileName: string;
        /**
         * Path to save configuration file.
         */
        filePath?: string;
        /**
         * New content of configuration file, base64 encoded.
         */
        newConfValue: string;
    }

}

export namespace Cls {
    export interface AlarmAlarmTarget {
        /**
         * search end time of offset.
         */
        endTimeOffset: number;
        /**
         * logset id.
         */
        logsetId: string;
        /**
         * the number of alarm object.
         */
        number: number;
        /**
         * query rules.
         */
        query: string;
        /**
         * search start time of offset.
         */
        startTimeOffset: number;
        /**
         * topic id.
         */
        topicId: string;
    }

    export interface AlarmAnalysis {
        /**
         * configuration.
         */
        configInfos?: outputs.Cls.AlarmAnalysisConfigInfo[];
        /**
         * analysis content.
         */
        content: string;
        /**
         * analysis name.
         */
        name: string;
        /**
         * analysis type.
         */
        type: string;
    }

    export interface AlarmAnalysisConfigInfo {
        /**
         * key.
         */
        key: string;
        /**
         * value.
         */
        value: string;
    }

    export interface AlarmCallBack {
        /**
         * callback body.
         */
        body: string;
        /**
         * callback headers.
         */
        headers?: string[];
    }

    export interface AlarmMonitorTime {
        /**
         * time period or point in time.
         */
        time: number;
        /**
         * Period for periodic execution, Fixed for regular execution.
         */
        type: string;
    }

    export interface AlarmNoticeNoticeReceiver {
        /**
         * end time allowed to receive messages.
         */
        endTime?: string;
        /**
         * index.
         */
        index?: number;
        /**
         * receiver channels, Email,Sms,WeChat or Phone.
         */
        receiverChannels: string[];
        /**
         * receiver id.
         */
        receiverIds: number[];
        /**
         * receiver type, Uin or Group.
         */
        receiverType: string;
        /**
         * start time allowed to receive messages.
         */
        startTime?: string;
    }

    export interface AlarmNoticeWebCallback {
        /**
         * abandoned.
         */
        body?: string;
        /**
         * callback type, WeCom or Http.
         */
        callbackType: string;
        /**
         * abandoned.
         */
        headers?: string[];
        /**
         * index.
         */
        index?: number;
        /**
         * Method, POST or PUT.
         */
        method?: string;
        /**
         * callback url.
         */
        url: string;
    }

    export interface CkafkaConsumerCkafka {
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * instance name.
         */
        instanceName: string;
        /**
         * topic id of ckafka.
         */
        topicId: string;
        /**
         * topic name of ckafka.
         */
        topicName: string;
        /**
         * vip.
         */
        vip: string;
        /**
         * vport.
         */
        vport: string;
    }

    export interface CkafkaConsumerContent {
        /**
         * whether to deliver the TAG info.
         */
        enableTag: boolean;
        /**
         * metadata info list.
         */
        metaFields: string[];
        /**
         * whether to tiling tag json.
         */
        tagJsonNotTiled?: boolean;
        /**
         * delivery timestamp precision,1 for second, 2 for millisecond.
         */
        timestampAccuracy?: number;
    }

    export interface ConfigExcludePath {
        /**
         * Type. Valid values: File, Path.
         */
        type?: string;
        /**
         * Specific content corresponding to Type.
         */
        value?: string;
    }

    export interface ConfigExtraContainerFile {
        /**
         * Container name.
         */
        container: string;
        /**
         * Pod label to be excluded.
         */
        excludeLabels?: string[];
        /**
         * Namespaces to be excluded, separated by separators, such as A, B.
         */
        excludeNamespace?: string;
        /**
         * log name.
         */
        filePattern: string;
        /**
         * Pod label info.
         */
        includeLabels?: string[];
        /**
         * Log Path.
         */
        logPath: string;
        /**
         * Namespace. There can be multiple namespaces, separated by separators, such as A, B.
         */
        namespace: string;
        /**
         * Workload info.
         */
        workload?: outputs.Cls.ConfigExtraContainerFileWorkload;
    }

    export interface ConfigExtraContainerFileWorkload {
        /**
         * container name.
         */
        container?: string;
        /**
         * workload type.
         */
        kind: string;
        /**
         * workload name.
         */
        name: string;
        /**
         * namespace.
         */
        namespace?: string;
    }

    export interface ConfigExtraContainerStdout {
        /**
         * Is all containers.
         */
        allContainers: boolean;
        /**
         * Pod label to be excluded.
         */
        excludeLabels?: string[];
        /**
         * Namespaces to be excluded, separated by separators, such as A, B.
         */
        excludeNamespace?: string;
        /**
         * Pod label info.
         */
        includeLabels?: string[];
        /**
         * Namespace. There can be multiple namespaces, separated by separators, such as A, B.
         */
        namespace?: string;
        /**
         * Workload info.
         */
        workloads?: outputs.Cls.ConfigExtraContainerStdoutWorkload[];
    }

    export interface ConfigExtraContainerStdoutWorkload {
        /**
         * container name.
         */
        container?: string;
        /**
         * workload type.
         */
        kind: string;
        /**
         * workload name.
         */
        name: string;
        /**
         * namespace.
         */
        namespace?: string;
    }

    export interface ConfigExtraExcludePath {
        /**
         * Type. Valid values: File, Path.
         */
        type?: string;
        /**
         * Specific content corresponding to Type.
         */
        value?: string;
    }

    export interface ConfigExtraExtractRule {
        /**
         * Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
         */
        backtracking: number;
        /**
         * First-Line matching rule, which is valid only if logType is multilineLog or fullregex_log.
         */
        beginRegex?: string;
        /**
         * Delimiter for delimited log, which is valid only if logType is delimiter_log.
         */
        delimiter?: string;
        /**
         * Log keys to be filtered and the corresponding regex.
         */
        filterKeyRegexes?: outputs.Cls.ConfigExtraExtractRuleFilterKeyRegex[];
        /**
         * Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if logType is delimiter_log. jsonLog logs use the key of JSON itself.
         */
        keys?: string[];
        /**
         * Full log matching rule, which is valid only if logType is fullregex_log.
         */
        logRegex?: string;
        /**
         * Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
         */
        timeFormat?: string;
        /**
         * Time field key name. timeKey and timeFormat must appear in pair.
         */
        timeKey?: string;
        /**
         * Unmatched log key.
         */
        unMatchLogKey?: string;
        /**
         * Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface ConfigExtraExtractRuleFilterKeyRegex {
        /**
         * Log key to be filtered.
         */
        key?: string;
        /**
         * Filter rule regex corresponding to key.
         */
        regex?: string;
    }

    export interface ConfigExtraHostFile {
        /**
         * Metadata info.
         */
        customLabels?: string[];
        /**
         * Log file name.
         */
        filePattern: string;
        /**
         * Log file dir.
         */
        logPath: string;
    }

    export interface ConfigExtractRule {
        /**
         * syslog system log collection specifies the address and port that the collector listens to.
         */
        address?: string;
        /**
         * Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
         */
        backtracking?: number;
        /**
         * First-Line matching rule, which is valid only if logType is multilineLog or fullregex_log.
         */
        beginRegex?: string;
        /**
         * Delimiter for delimited log, which is valid only if logType is delimiter_log.
         */
        delimiter?: string;
        /**
         * Log keys to be filtered and the corresponding regex.
         */
        filterKeyRegexes?: outputs.Cls.ConfigExtractRuleFilterKeyRegex[];
        /**
         * GBK encoding. Default 0.
         */
        isGbk?: number;
        /**
         * standard json. Default 0.
         */
        jsonStandard?: number;
        /**
         * Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if logType is delimiter_log. jsonLog logs use the key of JSON itself.
         */
        keys?: string[];
        /**
         * Full log matching rule, which is valid only if logType is fullregex_log.
         */
        logRegex?: string;
        /**
         * metadata tags.
         */
        metaTags?: outputs.Cls.ConfigExtractRuleMetaTag[];
        /**
         * metadata type.
         */
        metadataType?: number;
        /**
         * parse protocol.
         */
        parseProtocol?: string;
        /**
         * metadata path regex.
         */
        pathRegex?: string;
        /**
         * syslog protocol, tcp or udp.
         */
        protocol?: string;
        /**
         * Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
         */
        timeFormat?: string;
        /**
         * Time field key name. timeKey and timeFormat must appear in pair.
         */
        timeKey?: string;
        /**
         * Unmatched log key.
         */
        unMatchLogKey?: string;
        /**
         * Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
         */
        unMatchUpLoadSwitch?: boolean;
    }

    export interface ConfigExtractRuleFilterKeyRegex {
        /**
         * Log key to be filtered.
         */
        key?: string;
        /**
         * Filter rule regex corresponding to key.
         */
        regex?: string;
    }

    export interface ConfigExtractRuleMetaTag {
        /**
         * tag key.
         */
        key?: string;
        /**
         * tag value.
         */
        value?: string;
    }

    export interface CosRechargeExtractRuleInfo {
        /**
         * syslog address.
         */
        address?: string;
        /**
         * backtracking data volume in incremental acquisition mode.
         */
        backtracking?: number;
        /**
         * begin line regex.
         */
        beginRegex?: string;
        /**
         * log delimiter.
         */
        delimiter?: string;
        /**
         * rules that need to filter logs.
         */
        filterKeyRegexes?: outputs.Cls.CosRechargeExtractRuleInfoFilterKeyRegex[];
        /**
         * gbk encoding.
         */
        isGbk?: number;
        /**
         * is standard json.
         */
        jsonStandard?: number;
        /**
         * key list.
         */
        keys?: string[];
        /**
         * log regex.
         */
        logRegex?: string;
        /**
         * metadata tag list.
         */
        metaTags?: outputs.Cls.CosRechargeExtractRuleInfoMetaTag[];
        /**
         * metadata type.
         */
        metadataType?: number;
        /**
         * parse protocol.
         */
        parseProtocol?: string;
        /**
         * metadata path regex.
         */
        pathRegex?: string;
        /**
         * syslog protocol.
         */
        protocol?: string;
        /**
         * time format.
         */
        timeFormat?: string;
        /**
         * time key.
         */
        timeKey?: string;
        /**
         * parsing failure log key.
         */
        unMatchLogKey?: string;
        /**
         * whether to upload the parsing failure log.
         */
        unMatchUpLoadSwitch?: boolean;
    }

    export interface CosRechargeExtractRuleInfoFilterKeyRegex {
        /**
         * need filter log key.
         */
        key: string;
        /**
         * need filter log regex.
         */
        regex: string;
    }

    export interface CosRechargeExtractRuleInfoMetaTag {
        /**
         * metadata key.
         */
        key?: string;
        /**
         * metadata value.
         */
        value?: string;
    }

    export interface CosShipperCompress {
        /**
         * Compression format. Valid values: gzip, lzop, none (no compression).
         */
        format: string;
    }

    export interface CosShipperContent {
        /**
         * CSV format content description.Note: this field may return null, indicating that no valid values can be obtained.
         */
        csv?: outputs.Cls.CosShipperContentCsv;
        /**
         * Content format. Valid values: json, csv.
         */
        format: string;
        /**
         * JSON format content description.Note: this field may return null, indicating that no valid values can be obtained.
         */
        json?: outputs.Cls.CosShipperContentJson;
    }

    export interface CosShipperContentCsv {
        /**
         * Field delimiter.
         */
        delimiter: string;
        /**
         * Field delimiter.
         */
        escapeChar: string;
        /**
         * Names of keys.Note: this field may return null, indicating that no valid values can be obtained.
         */
        keys: string[];
        /**
         * Content used to populate non-existing fields.
         */
        nonExistingField: string;
        /**
         * Whether to print key on the first row of the CSV file.
         */
        printKey: boolean;
    }

    export interface CosShipperContentJson {
        /**
         * Enablement flag.
         */
        enableTag: boolean;
        /**
         * Metadata information list
         * Note: this field may return null, indicating that no valid values can be obtained..
         */
        metaFields: string[];
    }

    export interface CosShipperFilterRule {
        /**
         * Filter rule key.
         */
        key: string;
        /**
         * Filter rule.
         */
        regex: string;
        /**
         * Filter rule value.
         */
        value: string;
    }

    export interface DataTransformDstResource {
        /**
         * alias.
         */
        alias: string;
        /**
         * dst topic id.
         */
        topicId: string;
    }

    export interface GetMachineGroupConfigsConfig {
        /**
         * scrape config id.
         */
        configId: string;
        /**
         * create time.
         */
        createTime: string;
        /**
         * Collection path blocklist.
         */
        excludePaths: outputs.Cls.GetMachineGroupConfigsConfigExcludePath[];
        /**
         * Extraction rule. If ExtractRule is set, LogType must be set.
         */
        extractRules: outputs.Cls.GetMachineGroupConfigsConfigExtractRule[];
        /**
         * style of log format.
         */
        logFormat: string;
        /**
         * log type.
         */
        logType: string;
        /**
         * scrape config name.
         */
        name: string;
        /**
         * topicid.
         */
        output: string;
        /**
         * scrape log path.
         */
        path: string;
        /**
         * update time.
         */
        updateTime: string;
        /**
         * user define rule.
         */
        userDefineRule: string;
    }

    export interface GetMachineGroupConfigsConfigExcludePath {
        /**
         * Type. Valid values: File, Path.
         */
        type: string;
        /**
         * tag value.
         */
        value: string;
    }

    export interface GetMachineGroupConfigsConfigExtractRule {
        /**
         * syslog system log collection specifies the address and port that the collector listens to.
         */
        address: string;
        /**
         * Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
         */
        backtracking: number;
        /**
         * First-Line matching rule, which is valid only if logType is multilineLog or fullregex_log.
         */
        beginRegex: string;
        /**
         * Delimiter for delimited log, which is valid only if logType is delimiter_log.
         */
        delimiter: string;
        /**
         * Log keys to be filtered and the corresponding regex.
         */
        filterKeyRegexes: outputs.Cls.GetMachineGroupConfigsConfigExtractRuleFilterKeyRegex[];
        /**
         * GBK encoding. Default 0.
         */
        isGbk: number;
        /**
         * standard json. Default 0.
         */
        jsonStandard: number;
        /**
         * Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if logType is delimiter_log. jsonLog logs use the key of JSON itself.
         */
        keys: string[];
        /**
         * Full log matching rule, which is valid only if logType is fullregex_log.
         */
        logRegex: string;
        /**
         * metadata tags.
         */
        metaTags: outputs.Cls.GetMachineGroupConfigsConfigExtractRuleMetaTag[];
        /**
         * metadata type.
         */
        metadataType: number;
        /**
         * parse protocol.
         */
        parseProtocol: string;
        /**
         * metadata path regex.
         */
        pathRegex: string;
        /**
         * syslog protocol, tcp or udp.
         */
        protocol: string;
        /**
         * Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
         */
        timeFormat: string;
        /**
         * Time field key name. timeKey and timeFormat must appear in pair.
         */
        timeKey: string;
        /**
         * Unmatched log key.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface GetMachineGroupConfigsConfigExtractRuleFilterKeyRegex {
        /**
         * tag key.
         */
        key: string;
        /**
         * Filter rule regex corresponding to key.
         */
        regex: string;
    }

    export interface GetMachineGroupConfigsConfigExtractRuleMetaTag {
        /**
         * tag key.
         */
        key: string;
        /**
         * tag value.
         */
        value: string;
    }

    export interface GetMachinesMachine {
        /**
         * if open auto update flag.
         */
        autoUpdate: number;
        /**
         * code of update operation.
         */
        errCode: number;
        /**
         * msg of update operation.
         */
        errMsg: string;
        /**
         * ip of machine.
         */
        ip: string;
        /**
         * offline time of machine.
         */
        offlineTime: string;
        /**
         * status of machine.
         */
        status: number;
        /**
         * machine update status.
         */
        updateStatus: number;
        /**
         * current machine version.
         */
        version: string;
    }

    export interface GetShipperTasksTask {
        /**
         * end time(ms).
         */
        endTime: number;
        /**
         * detail info.
         */
        message: string;
        /**
         * end time of current task (ms).
         */
        rangeEnd: number;
        /**
         * start time of current task (ms).
         */
        rangeStart: number;
        /**
         * shipper id.
         */
        shipperId: string;
        /**
         * start time(ms).
         */
        startTime: number;
        /**
         * status of current shipper task.
         */
        status: string;
        /**
         * task id.
         */
        taskId: string;
        /**
         * topic id.
         */
        topicId: string;
    }

    export interface IndexRule {
        /**
         * The key value index is automatically configured. If it is empty, it means that the function is not enabled.
         */
        dynamicIndex?: outputs.Cls.IndexRuleDynamicIndex;
        /**
         * Full-Text index configuration.
         */
        fullText?: outputs.Cls.IndexRuleFullText;
        /**
         * Key-Value index configuration.
         */
        keyValue?: outputs.Cls.IndexRuleKeyValue;
        /**
         * Metafield index configuration.
         */
        tag?: outputs.Cls.IndexRuleTag;
    }

    export interface IndexRuleDynamicIndex {
        /**
         * index automatic configuration switch.
         */
        status: boolean;
    }

    export interface IndexRuleFullText {
        /**
         * Case sensitivity.
         */
        caseSensitive: boolean;
        /**
         * Whether Chinese characters are contained.
         */
        containZH: boolean;
        /**
         * Full-Text index delimiter. Each character in the string represents a delimiter.
         */
        tokenizer: string;
    }

    export interface IndexRuleKeyValue {
        /**
         * Case sensitivity.
         */
        caseSensitive: boolean;
        /**
         * Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
         */
        keyValues?: outputs.Cls.IndexRuleKeyValueKeyValue[];
    }

    export interface IndexRuleKeyValueKeyValue {
        /**
         * When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
         */
        key: string;
        /**
         * Field index description information.
         */
        value?: outputs.Cls.IndexRuleKeyValueKeyValueValue;
    }

    export interface IndexRuleKeyValueKeyValueValue {
        /**
         * Whether Chinese characters are contained.
         */
        containZH?: boolean;
        /**
         * Whether the analysis feature is enabled for the field.
         */
        sqlFlag?: boolean;
        /**
         * Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
         */
        tokenizer?: string;
        /**
         * Field type. Valid values: long, text, double.
         */
        type: string;
    }

    export interface IndexRuleTag {
        /**
         * Case sensitivity.
         */
        caseSensitive: boolean;
        /**
         * Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
         */
        keyValues?: outputs.Cls.IndexRuleTagKeyValue[];
    }

    export interface IndexRuleTagKeyValue {
        /**
         * When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
         */
        key: string;
        /**
         * Field index description information.
         */
        value?: outputs.Cls.IndexRuleTagKeyValueValue;
    }

    export interface IndexRuleTagKeyValueValue {
        /**
         * Whether Chinese characters are contained.
         */
        containZH?: boolean;
        /**
         * Whether the analysis feature is enabled for the field.
         */
        sqlFlag?: boolean;
        /**
         * Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
         */
        tokenizer?: string;
        /**
         * Field type. Valid values: long, text, double.
         */
        type: string;
    }

    export interface KafkaRechargeLogRechargeRule {
        /**
         * default time from.
         */
        defaultTimeSrc?: number;
        /**
         * user default time.
         */
        defaultTimeSwitch: boolean;
        /**
         * encoding format.
         */
        encodingFormat: number;
        /**
         * log key list.
         */
        keys: string[];
        /**
         * log regex.
         */
        logRegex?: string;
        /**
         * metadata.
         */
        metadatas: string[];
        /**
         * recharge type.
         */
        rechargeType: string;
        /**
         * time format.
         */
        timeFormat?: string;
        /**
         * time key.
         */
        timeKey?: string;
        /**
         * time regex.
         */
        timeRegex?: string;
        /**
         * time zone.
         */
        timeZone?: string;
        /**
         * parse failed log key.
         */
        unMatchLogKey?: string;
        /**
         * is push parse failed log.
         */
        unMatchLogSwitch?: boolean;
        /**
         * parse failed log time from.
         */
        unMatchLogTimeSrc?: number;
    }

    export interface KafkaRechargeProtocol {
        /**
         * encryption type.
         */
        mechanism?: string;
        /**
         * user password.
         */
        password?: string;
        /**
         * protocol type.
         */
        protocol?: string;
        /**
         * username.
         */
        userName?: string;
    }

    export interface MachineGroupMachineGroupType {
        /**
         * Machine group type. Valid values: ip: the IP addresses of collection machines are stored in Values of the machine group; label: the tags of the machines are stored in Values of the machine group.
         */
        type: string;
        /**
         * Machine description list.
         */
        values: string[];
    }

    export interface ScheduledSqlDstResource {
        /**
         * topic type.
         */
        bizType?: number;
        /**
         * metric name.
         */
        metricName?: string;
        /**
         * topic region.
         */
        region?: string;
        /**
         * dst topic id.
         */
        topicId: string;
    }

}

export namespace Cos {
    export interface BatchManifest {
        /**
         * The location information of the list of objects.
         */
        location: outputs.Cos.BatchManifestLocation;
        /**
         * Format information that describes the list of objects. If it is a CSV file, this element describes the fields contained in the manifest.
         */
        spec: outputs.Cos.BatchManifestSpec;
    }

    export interface BatchManifestLocation {
        /**
         * Specifies the etag of the object list. Length 1-1024 bytes.
         */
        etag: string;
        /**
         * Specifies the unique resource identifier of the object manifest, which is 1-1024 bytes long.
         */
        objectArn: string;
        /**
         * Specifies the version of the object manifest ID, which is 1-1024 bytes long.
         */
        objectVersionId?: string;
    }

    export interface BatchManifestSpec {
        /**
         * Describes the fields contained in the listing, which you need to use to specify CSV file fields when Format is COSBatchOperations_CSV_V1. Legal fields are: Ignore, Bucket, Key, VersionId.
         */
        fields?: string[];
        /**
         * Specifies the format information for the list of objects. Legal fields are: COSBatchOperations_CSV_V1, COSInventoryReport_CSV_V1.
         */
        format: string;
    }

    export interface BatchOperation {
        /**
         * Specifies the specific parameters for the batch restore operation for archive storage type objects in the inventory.
         */
        cosInitiateRestoreObject?: outputs.Cos.BatchOperationCosInitiateRestoreObject;
        /**
         * Specifies the specific parameters for the batch copy operation on the objects in the list.
         */
        cosPutObjectCopy?: outputs.Cos.BatchOperationCosPutObjectCopy;
    }

    export interface BatchOperationCosInitiateRestoreObject {
        /**
         * Sets the number of days after which the copy will be automatically expired and deleted, an integer in the range of 1-365.
         */
        expirationInDays: number;
        /**
         * Select archive recovery model. Available values: Bulk, Standard.
         */
        jobTier: string;
    }

    export interface BatchOperationCosPutObjectCopy {
        /**
         * This element specifies how ACL is copied. Valid values:
         * - Copy: inherits the source object ACL
         * - Replaced: replace source ACL
         * - Add: add a new ACL based on the source ACL.
         */
        accessControlDirective?: string;
        /**
         * Controls the specific access to the object.
         */
        accessControlGrants?: outputs.Cos.BatchOperationCosPutObjectCopyAccessControlGrants;
        /**
         * Defines the ACL property of the object. Valid values: private, public-read.
         */
        cannedAccessControlList?: string;
        /**
         * This element specifies whether to copy object metadata from the source object or replace it with metadata in the < NewObjectMetadata > element. Valid values are: Copy, Replaced, Add. Copy: inherit source object metadata; Replaced: replace source metadata; Add: add new metadata based on source metadata.
         */
        metadataDirective?: string;
        /**
         * When the object is modified after the specified time, the operation is performed, otherwise 412 is returned.
         */
        modifiedSinceConstraint?: number;
        /**
         * Configure the metadata for the object.
         */
        newObjectMetadata?: outputs.Cos.BatchOperationCosPutObjectCopyNewObjectMetadata;
        /**
         * The label of the configuration object, which must be specified when the < TaggingDirective > value is Replace or Add.
         */
        newObjectTaggings?: outputs.Cos.BatchOperationCosPutObjectCopyNewObjectTagging[];
        /**
         * Specifies whether the prefix of the source object needs to be replaced. A value of true indicates the replacement object prefix, which needs to be used with <ResourcesPrefix> and <TargetKeyPrefix>. Default value: false.
         */
        prefixReplace?: boolean;
        /**
         * This field is valid only when the < PrefixReplace > value is true. Specify the source object prefix to be replaced, and the replacement directory should end with `/`. Can be empty with a maximum length of 1024 bytes.
         */
        resourcesPrefix?: string;
        /**
         * Sets the storage level of the object. Enumerated value: STANDARD,STANDARD_IA. Default value: STANDARD.
         */
        storageClass?: string;
        /**
         * This element specifies whether to copy the object tag from the source object or replace it with the tag in the < NewObjectTagging > element. Valid values are: Copy, Replaced, Add. Copy: inherits the source object tag; Replaced: replaces the source tag; Add: adds a new tag based on the source tag.
         */
        taggingDirective?: string;
        /**
         * This field is valid only when the <PrefixReplace> value is true. This value represents the replaced prefix, and the replacement directory should end with /. Can be empty with a maximum length of 1024 bytes.
         */
        targetKeyPrefix?: string;
        /**
         * Sets the target bucket for the Copy. Use qcs to specify, for example, qcs::cos:ap-chengdu:uid/1250000000:examplebucket-1250000000.
         */
        targetResource: string;
        /**
         * When the object has not been modified after the specified time, the operation is performed, otherwise 412 is returned.
         */
        unmodifiedSinceConstraint?: number;
    }

    export interface BatchOperationCosPutObjectCopyAccessControlGrants {
        /**
         * User name.
         */
        displayName?: string;
        /**
         * User ID (UIN) in qcs format. For example: qcs::cam::uin/100000000001:uin/100000000001.
         */
        identifier: string;
        /**
         * Specify a permission to be granted. Enumerated value: READ,WRITE,FULL_CONTROL.
         */
        permission: string;
        /**
         * Specifies the type of Identifier. Currently, only user ID is supported. Enumerated value: ID.
         */
        typeIdentifier: string;
    }

    export interface BatchOperationCosPutObjectCopyNewObjectMetadata {
        /**
         * The caching instructions defined in RFC 2616 are saved as object metadata.
         */
        cacheControl?: string;
        /**
         * The file name defined in RFC 2616 is saved as object metadata.
         */
        contentDisposition?: string;
        /**
         * The encoding format defined in RFC 2616 is saved as object metadata.
         */
        contentEncoding?: string;
        /**
         * The content types defined in RFC 2616 are saved as object metadata.
         */
        contentType?: string;
        /**
         * The cache expiration time defined in RFC 2616 is saved as object metadata.
         */
        httpExpiresDate?: string;
        /**
         * Server encryption algorithm. Currently, only AES256 is supported.
         */
        sseAlgorithm?: string;
        /**
         * Includes user-defined metadata.
         */
        userMetadatas?: outputs.Cos.BatchOperationCosPutObjectCopyNewObjectMetadataUserMetadata[];
    }

    export interface BatchOperationCosPutObjectCopyNewObjectMetadataUserMetadata {
        /**
         * key.
         */
        key: string;
        /**
         * value.
         */
        value: string;
    }

    export interface BatchOperationCosPutObjectCopyNewObjectTagging {
        /**
         * key.
         */
        key: string;
        /**
         * value.
         */
        value: string;
    }

    export interface BatchReport {
        /**
         * Delivery bucket for task completion reports.
         */
        bucket: string;
        /**
         * Whether to output the task completion report.
         */
        enabled: string;
        /**
         * Task completion report format information. Legal value: Report_CSV_V1.
         */
        format: string;
        /**
         * Prefix information for the task completion report. Length 0-256 bytes.
         */
        prefix?: string;
        /**
         * Task completion report the task information that needs to be recorded to determine whether to record the execution information of all operations or the information of failed operations. Legal values: AllTasks, FailedTasksOnly.
         */
        reportScope: string;
    }

    export interface BucketCorsRule {
        /**
         * Specifies which headers are allowed.
         */
        allowedHeaders: string[];
        /**
         * Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
         */
        allowedMethods: string[];
        /**
         * Specifies which origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specifies expose header in the response.
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketDomainCertificateAttachmentDomainCertificate {
        /**
         * Certificate info.
         */
        certificate: outputs.Cos.BucketDomainCertificateAttachmentDomainCertificateCertificate;
        /**
         * The name of domain.
         */
        domain: string;
    }

    export interface BucketDomainCertificateAttachmentDomainCertificateCertificate {
        /**
         * Certificate type.
         */
        certType: string;
        /**
         * Custom certificate.
         */
        customCert: outputs.Cos.BucketDomainCertificateAttachmentDomainCertificateCertificateCustomCert;
    }

    export interface BucketDomainCertificateAttachmentDomainCertificateCertificateCustomCert {
        /**
         * Public key of certificate.
         */
        cert: string;
        /**
         * Private key of certificate.
         */
        privateKey: string;
    }

    export interface BucketInventoryDestination {
        /**
         * ID of the bucket owner.
         */
        accountId?: string;
        /**
         * Bucket name.
         */
        bucket: string;
        /**
         * Server-side encryption for the inventory result.
         */
        encryption?: outputs.Cos.BucketInventoryDestinationEncryption;
        /**
         * Format of the inventory result. Valid value: CSV.
         */
        format: string;
        /**
         * Prefix of the inventory result.
         */
        prefix?: string;
    }

    export interface BucketInventoryDestinationEncryption {
        /**
         * Encryption with COS-managed key. This field can be left empty.
         */
        sseCos?: string;
    }

    export interface BucketInventoryFilter {
        /**
         * Creation time range of the objects to analyze.
         */
        period?: outputs.Cos.BucketInventoryFilterPeriod;
        /**
         * Prefix of the objects to analyze.
         */
        prefix?: string;
    }

    export interface BucketInventoryFilterPeriod {
        /**
         * Creation end time of the objects to analyze. The parameter is a timestamp in seconds, for example, 1568688762.
         */
        endTime?: string;
        /**
         * Creation start time of the objects to analyze. The parameter is a timestamp in seconds, for example, 1568688761.
         */
        startTime?: string;
    }

    export interface BucketInventoryOptionalFields {
        /**
         * Optional analysis items to include in the inventory result. The optional fields include Size, LastModifiedDate, StorageClass, ETag, IsMultipartUploaded, ReplicationStatus, Tag, Crc64, and x-cos-meta-*.
         */
        fields?: string[];
    }

    export interface BucketInventorySchedule {
        /**
         * Frequency of the inventory job. Enumerated values: Daily, Weekly.
         */
        frequency: string;
    }

    export interface BucketLifecycleRule {
        /**
         * Set the maximum time a multipart upload is allowed to remain running.
         */
        abortIncompleteMultipartUpload?: outputs.Cos.BucketLifecycleRuleAbortIncompleteMultipartUpload;
        /**
         * Specifies a period in the object's expire (documented below).
         */
        expiration?: outputs.Cos.BucketLifecycleRuleExpiration;
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        filterPrefix: string;
        /**
         * A unique identifier for the rule. It can be up to 255 characters.
         */
        id?: string;
        /**
         * Specifies when non current object versions shall expire.
         */
        nonCurrentExpiration?: outputs.Cos.BucketLifecycleRuleNonCurrentExpiration;
        /**
         * Specifies a period in the non current object's transitions.
         */
        nonCurrentTransitions?: outputs.Cos.BucketLifecycleRuleNonCurrentTransition[];
        /**
         * Specifies a period in the object's transitions (documented below).
         */
        transitions?: outputs.Cos.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleAbortIncompleteMultipartUpload {
        /**
         * Specifies the number of days after the multipart upload starts that the upload must be completed. The maximum value is 3650.
         */
        daysAfterInitiation: number;
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * Indicates whether the delete marker of an expired object will be removed.
         */
        deleteMarker?: boolean;
    }

    export interface BucketLifecycleRuleNonCurrentExpiration {
        /**
         * Number of days after non current object creation when the specific rule action takes effect. The maximum value is 3650.
         */
        nonCurrentDays?: number;
    }

    export interface BucketLifecycleRuleNonCurrentTransition {
        /**
         * Number of days after non current object creation when the specific rule action takes effect.
         */
        nonCurrentDays?: number;
        /**
         * Specifies the storage class to which you want the non current object to transition. Available values include `STANDARD_IA`, `MAZ_STANDARD_IA`, `INTELLIGENT_TIERING`, `MAZ_INTELLIGENT_TIERING`, `ARCHIVE`, `DEEP_ARCHIVE`. For more information, please refer to: https://cloud.tencent.com/document/product/436/33417.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * Specifies the storage class to which you want the object to transition. Available values include `STANDARD_IA`, `MAZ_STANDARD_IA`, `INTELLIGENT_TIERING`, `MAZ_INTELLIGENT_TIERING`, `ARCHIVE`, `DEEP_ARCHIVE`. For more information, please refer to: https://cloud.tencent.com/document/product/436/33417.
         */
        storageClass: string;
    }

    export interface BucketOriginDomainRule {
        /**
         * Specify domain host.
         */
        domain: string;
        /**
         * Domain status, default: `ENABLED`.
         */
        status?: string;
        /**
         * Specify origin domain type, available values: `REST`, `WEBSITE`, `ACCELERATE`, default: `REST`.
         */
        type?: string;
    }

    export interface BucketOriginPullRule {
        /**
         * Specifies the custom headers that you can add for COS to access your origin server.
         */
        customHttpHeaders?: {[key: string]: any};
        /**
         * Specifies the pass through headers when accessing the origin server.
         */
        followHttpHeaders?: string[];
        /**
         * Specifies whether to pass through COS request query string when accessing the origin server.
         */
        followQueryString?: boolean;
        /**
         * Specifies whether to follow 3XX redirect to another origin server to pull data from.
         */
        followRedirection?: boolean;
        /**
         * Allows only a domain name or IP address. You can optionally append a port number to the address.
         */
        host: string;
        /**
         * Triggers the origin-pull rule when the requested file name matches this prefix.
         */
        prefix?: string;
        /**
         * Priority of origin-pull rules, do not set the same value for multiple rules.
         */
        priority: number;
        /**
         * the protocol used for COS to access the specified origin server. The available value include `HTTP`, `HTTPS` and `FOLLOW`.
         */
        protocol?: string;
        /**
         * If `true`, COS will not return 3XX status code when pulling data from an origin server. Current available zone: ap-beijing, ap-shanghai, ap-singapore, ap-mumbai.
         */
        syncBackToSource?: boolean;
    }

    export interface BucketReplicaRule {
        /**
         * Destination bucket identifier, format: `qcs::cos:<region>::<bucketname-appid>`. NOTE: destination bucket must enable versioning.
         */
        destinationBucket: string;
        /**
         * Storage class of destination, available values: `STANDARD`, `INTELLIGENT_TIERING`, `STANDARD_IA`. default is following current class of destination.
         */
        destinationStorageClass?: string;
        /**
         * Name of a specific rule.
         */
        id?: string;
        /**
         * Prefix matching policy. Policies cannot overlap; otherwise, an error will be returned. To match the root directory, leave this parameter empty.
         */
        prefix?: string;
        /**
         * Status identifier, available values: `Enabled`, `Disabled`.
         */
        status: string;
    }

    export interface BucketWebsite {
        /**
         * `Endpoint` of the static website.
         */
        endpoint: string;
        /**
         * An absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * COS returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument?: string;
    }

    export interface GetBatchsJob {
        /**
         * Job creation time.
         */
        creationTime: string;
        /**
         * Mission description. The length is limited to 0-256 bytes.
         */
        description: string;
        /**
         * Job ID. The length is limited to 1-64 bytes.
         */
        jobId: string;
        /**
         * Actions performed on objects in a batch processing job. For example, COSPutObjectCopy.
         */
        operation: string;
        /**
         * Mission priority. Tasks with higher values will be given priority. The priority size is limited to 0-2147483647.
         */
        priority: number;
        /**
         * Summary of the status of task implementation. Describe the total number of operations performed in this task, the number of successful operations, and the number of failed operations.
         */
        progressSummaries: outputs.Cos.GetBatchsJobProgressSummary[];
        /**
         * Task execution status. Legal parameter values include Active, Cancelled, Cancelling, Complete, Completing, Failed, Failing, New, Paused, Pausing, Preparing, Ready, Suspended.
         */
        status: string;
        /**
         * The end time of the batch processing job.
         */
        terminationDate: string;
    }

    export interface GetBatchsJobProgressSummary {
        /**
         * The current failed Operand.
         */
        numberOfTasksFailed: number;
        /**
         * The current successful Operand.
         */
        numberOfTasksSucceeded: number;
        /**
         * Total Operand.
         */
        totalNumberOfTasks: number;
    }

    export interface GetBucketInventorysInventory {
        /**
         * Information about the inventory result destination.
         */
        destinations: outputs.Cos.GetBucketInventorysInventoryDestination[];
        /**
         * Filters objects prefixed with the specified value to analyze.
         */
        filters: outputs.Cos.GetBucketInventorysInventoryFilter[];
        /**
         * Whether to enable the inventory. true or false.
         */
        id: string;
        /**
         * Whether to include object versions in the inventory. All or No.
         */
        includedObjectVersions: string;
        /**
         * Whether to enable the inventory. true or false.
         */
        isEnabled: string;
        /**
         * Analysis items to include in the inventory result	.
         */
        optionalFields?: outputs.Cos.GetBucketInventorysInventoryOptionalField[];
        /**
         * Inventory job cycle.
         */
        schedules: outputs.Cos.GetBucketInventorysInventorySchedule[];
    }

    export interface GetBucketInventorysInventoryDestination {
        /**
         * ID of the bucket owner.
         */
        accountId: string;
        /**
         * Bucket.
         */
        bucket: string;
        /**
         * Server-side encryption for the inventory result.
         */
        encryptions: outputs.Cos.GetBucketInventorysInventoryDestinationEncryption[];
        /**
         * Format of the inventory result. Valid value: CSV.
         */
        format: string;
        /**
         * Prefix of the objects to analyze.
         */
        prefix: string;
    }

    export interface GetBucketInventorysInventoryDestinationEncryption {
        /**
         * Encryption with COS-managed key. This field can be left empty.
         */
        sseCos: string;
    }

    export interface GetBucketInventorysInventoryFilter {
        /**
         * Creation time range of the objects to analyze.
         */
        periods: outputs.Cos.GetBucketInventorysInventoryFilterPeriod[];
        /**
         * Prefix of the objects to analyze.
         */
        prefix: string;
    }

    export interface GetBucketInventorysInventoryFilterPeriod {
        /**
         * Creation end time of the objects to analyze. The parameter is a timestamp in seconds, for example, 1568688762.
         */
        endTime: string;
        /**
         * Creation start time of the objects to analyze. The parameter is a timestamp in seconds, for example, 1568688761.
         */
        startTime: string;
    }

    export interface GetBucketInventorysInventoryOptionalField {
        /**
         * Optional analysis items to include in the inventory result. The optional fields include Size, LastModifiedDate, StorageClass, ETag, IsMultipartUploaded, ReplicationStatus, Tag, Crc64, and x-cos-meta-*.
         */
        fields: string[];
    }

    export interface GetBucketInventorysInventorySchedule {
        /**
         * Frequency of the inventory job. Enumerated values: Daily, Weekly.
         */
        frequency: string;
    }

    export interface GetBucketMultipartUploadsUpload {
        /**
         * The starting time of multipart upload.
         */
        initiated: string;
        /**
         * Used to represent the information of the initiator of this upload.
         */
        initiators: outputs.Cos.GetBucketMultipartUploadsUploadInitiator[];
        /**
         * Name of the Object.
         */
        key: string;
        /**
         * Information used to represent the owner of these chunks.
         */
        owners: outputs.Cos.GetBucketMultipartUploadsUploadOwner[];
        /**
         * Used to represent the storage level of a chunk. Enumerated value: STANDARD,STANDARD_IA,ARCHIVE.
         */
        storageClass: string;
        /**
         * Mark the ID of this multipart upload.
         */
        uploadId: string;
    }

    export interface GetBucketMultipartUploadsUploadInitiator {
        /**
         * Abbreviation for user identity ID (UIN).
         */
        displayName: string;
        /**
         * The user's unique CAM identity ID.
         */
        id: string;
    }

    export interface GetBucketMultipartUploadsUploadOwner {
        /**
         * Abbreviation for user identity ID (UIN).
         */
        displayName: string;
        /**
         * The user's unique CAM identity ID.
         */
        id: string;
    }

    export interface GetBucketsBucketList {
        /**
         * Bucket access control configurations.
         */
        acl: string;
        /**
         * Bucket verbose acl configurations.
         */
        aclBody: string;
        /**
         * Bucket name, the format likes `<bucket>-<appid>`.
         */
        bucket: string;
        /**
         * A list of CORS rule configurations.
         */
        corsRules: outputs.Cos.GetBucketsBucketListCorsRule[];
        /**
         * The URL of this cos bucket.
         */
        cosBucketUrl: string;
        /**
         * The lifecycle configuration of a bucket.
         */
        lifecycleRules: outputs.Cos.GetBucketsBucketListLifecycleRule[];
        /**
         * Bucket origin domain rules.
         */
        originDomainRules: outputs.Cos.GetBucketsBucketListOriginDomainRule[];
        /**
         * Bucket Origin-Pull rules.
         */
        originPullRules: outputs.Cos.GetBucketsBucketListOriginPullRule[];
        /**
         * Tags to filter bucket.
         */
        tags: {[key: string]: any};
        /**
         * A list of one element containing configuration parameters used when the bucket is used as a website.
         */
        websites: outputs.Cos.GetBucketsBucketListWebsite[];
    }

    export interface GetBucketsBucketListCorsRule {
        /**
         * Specifies which headers are allowed.
         */
        allowedHeaders: string[];
        /**
         * Specifies which methods are allowed. Can be GET, PUT, POST, DELETE or HEAD.
         */
        allowedMethods: string[];
        /**
         * Specifies which origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specifies expose header in the response.
         */
        exposeHeaders: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds: number;
    }

    export interface GetBucketsBucketListLifecycleRule {
        /**
         * Set the maximum time a multipart upload is allowed to remain running.
         */
        abortIncompleteMultipartUploads: outputs.Cos.GetBucketsBucketListLifecycleRuleAbortIncompleteMultipartUpload[];
        /**
         * Specifies a period in the object's expire.
         */
        expirations: outputs.Cos.GetBucketsBucketListLifecycleRuleExpiration[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        filterPrefix: string;
        /**
         * Specifies when non current object versions shall expire.
         */
        nonCurrentExpirations: outputs.Cos.GetBucketsBucketListLifecycleRuleNonCurrentExpiration[];
        /**
         * Specifies when to transition objects of non current versions and the target storage class.
         */
        nonCurrentTransitions: outputs.Cos.GetBucketsBucketListLifecycleRuleNonCurrentTransition[];
        /**
         * Specifies a period in the object's transitions.
         */
        transitions: outputs.Cos.GetBucketsBucketListLifecycleRuleTransition[];
    }

    export interface GetBucketsBucketListLifecycleRuleAbortIncompleteMultipartUpload {
        /**
         * Specifies the number of days after the multipart upload starts that the upload must be completed. The maximum value is 3650.
         */
        daysAfterInitiation: number;
    }

    export interface GetBucketsBucketListLifecycleRuleExpiration {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days: number;
    }

    export interface GetBucketsBucketListLifecycleRuleNonCurrentExpiration {
        /**
         * Number of days after non current object creation when the specific rule action takes effect.
         */
        nonCurrentDays: number;
    }

    export interface GetBucketsBucketListLifecycleRuleNonCurrentTransition {
        /**
         * Number of days after non current object creation when the specific rule action takes effect.
         */
        nonCurrentDays: number;
        /**
         * Specifies the storage class to which you want the object to transition. Available values include STANDARD, STANDARD_IA and ARCHIVE.
         */
        storageClass: string;
    }

    export interface GetBucketsBucketListLifecycleRuleTransition {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days: number;
        /**
         * Specifies the storage class to which you want the object to transition. Available values include STANDARD, STANDARD_IA and ARCHIVE.
         */
        storageClass: string;
    }

    export interface GetBucketsBucketListOriginDomainRule {
        /**
         * Specify domain host.
         */
        domain: string;
        /**
         * Domain status, default: `ENABLED`.
         */
        status?: string;
        /**
         * Specify origin domain type, available values: `REST`, `WEBSITE`, `ACCELERATE`, default: `REST`.
         */
        type?: string;
    }

    export interface GetBucketsBucketListOriginPullRule {
        /**
         * Specifies the custom headers that you can add for COS to access your origin server.
         */
        customHttpHeaders?: {[key: string]: any};
        /**
         * Specifies the pass through headers when accessing the origin server.
         */
        followHttpHeaders?: string[];
        /**
         * Specifies whether to pass through COS request query string when accessing the origin server.
         */
        followQueryString?: boolean;
        /**
         * Specifies whether to follow 3XX redirect to another origin server to pull data from.
         */
        followRedirection?: boolean;
        /**
         * Allows only a domain name or IP address. You can optionally append a port number to the address.
         */
        host: string;
        /**
         * Triggers the origin-pull rule when the requested file name matches this prefix.
         */
        prefix?: string;
        /**
         * Priority of origin-pull rules, do not set the same value for multiple rules.
         */
        priority: number;
        /**
         * the protocol used for COS to access the specified origin server. The available value include `HTTP`, `HTTPS` and `FOLLOW`.
         */
        protocol?: string;
        /**
         * If `true`, COS will not return 3XX status code when pulling data from an origin server. Currently available zone: ap-beijing, ap-shanghai, ap-singapore, ap-mumbai.
         */
        syncBackToSource?: boolean;
    }

    export interface GetBucketsBucketListWebsite {
        /**
         * An absolute path to the document to return in case of a 4XX error.
         */
        errorDocument: string;
        /**
         * COS returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument: string;
    }

}

export namespace Csip {
    export interface RiskCenterAsset {
        /**
         * Multi-cloud asset unique idNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        arn?: string;
        /**
         * Ip/ domain name/asset id, database id, etc.
         */
        asset?: string;
        /**
         * Asset nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        assetName?: string;
        /**
         * Asset classificationNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        assetType?: string;
        /**
         * Asset typeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        instanceType?: string;
        /**
         * RegionNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        region?: string;
    }

    export interface RiskCenterTaskAdvanceCfg {
        /**
         * Configure advanced risk Settings.
         */
        cfgRisks?: outputs.Csip.RiskCenterTaskAdvanceCfgCfgRisk[];
        /**
         * Advanced Port Risk Configuration.
         */
        portRisks?: outputs.Csip.RiskCenterTaskAdvanceCfgPortRisk[];
        /**
         * Advanced vulnerability risk configuration.
         */
        vulRisks?: outputs.Csip.RiskCenterTaskAdvanceCfgVulRisk[];
        /**
         * Weak password risk advanced configuration.
         */
        weakPwdRisks?: outputs.Csip.RiskCenterTaskAdvanceCfgWeakPwdRisk[];
    }

    export interface RiskCenterTaskAdvanceCfgCfgRisk {
        /**
         * Whether to enable, 0- No, 1- Enable.
         */
        enable: number;
        /**
         * Detection item ID.
         */
        itemId: string;
        /**
         * Resource type.
         */
        resourceType: string;
    }

    export interface RiskCenterTaskAdvanceCfgPortRisk {
        /**
         * Detection item type, 0-system defined, 1-user-defined.
         */
        checkType: number;
        /**
         * Description of detection items.
         */
        detail: string;
        /**
         * Whether to enable, 0- No, 1- Enable.
         */
        enable: number;
        /**
         * Port collection, separated by commas.
         */
        portSets: string;
    }

    export interface RiskCenterTaskAdvanceCfgVulRisk {
        /**
         * Whether to enable, 0- No, 1- Enable.
         */
        enable: number;
        /**
         * Risk ID.
         */
        riskId: string;
    }

    export interface RiskCenterTaskAdvanceCfgWeakPwdRisk {
        /**
         * Detection item ID.
         */
        checkItemId: number;
        /**
         * Whether to enable, 0- No, 1- Enable.
         */
        enable: number;
    }

}

export namespace Css {
    export interface GetBackupStreamStreamInfoList {
        /**
         * Backup stream info.
         */
        backupLists: outputs.Css.GetBackupStreamStreamInfoListBackupList[];
        /**
         * Group name.
         */
        hostGroupName: string;
        /**
         * Optimal switch, 1-enable, 0-disable.
         */
        optimalEnable: number;
        /**
         * Stream id.
         */
        streamName: string;
    }

    export interface GetBackupStreamStreamInfoListBackupList {
        /**
         * Push path.
         */
        appName: string;
        /**
         * Push domain.
         */
        domainName: string;
        /**
         * Master stream flag.
         */
        masterFlag: number;
        /**
         * UTC time, eg, 2018-06-29T19:00:00Z.
         */
        publishTime: string;
        /**
         * Source from.
         */
        sourceFrom: string;
        /**
         * Push stream sequence.
         */
        upstreamSequence: string;
    }

    export interface GetDeliverLogDownListLogInfoList {
        /**
         * File size, in bytes.
         */
        fileSize: number;
        /**
         * Log name.
         */
        logName: string;
        /**
         * Log time. UTC format, for example: 2018-11-29T19:00:00Z.Note:Beijing time is UTC time + 8 hours, formatted according to the ISO 8601 standard, see ISO date format description for details.
         */
        logTime: string;
        /**
         * Log download address.
         */
        logUrl: string;
    }

    export interface GetDomainsDomainList {
        /**
         * Is there a CName to the fixed rule domain name: 0: No. 1: Yes.
         */
        bCName: number;
        /**
         * add time.Note: This field is Beijing time (UTC+8 time zone).
         */
        createTime: string;
        /**
         * The cname information used by the current client.
         */
        currentCName: string;
        /**
         * 0 normal live broadcast 1 slow live broadcast default 0.
         */
        isDelayLive: number;
        /**
         * 0: Standard live broadcast. 1: Mini program live broadcast. Note: This field may return null, indicating that no valid value can be obtained.
         */
        isMiniProgramLive: number;
        /**
         * Live domain name.
         */
        name: string;
        /**
         * Playing area, this parameter is meaningful only when DomainType=1. 1: Domestic.2: Global.3: Overseas.
         */
        playType: number;
        /**
         * Failure parameter, can be ignored. Note: This field is Beijing time (UTC+8 time zone).
         */
        rentExpireTime: string;
        /**
         * invalid parameter, can be ignored.
         */
        rentTag: number;
        /**
         * Domain Status: 0: disable. 1: Enabled.
         */
        status: number;
        /**
         * The domain name corresponding to the cname.
         */
        targetDomain: string;
        /**
         * Domain Type: 0: push stream. 1: Play.
         */
        type: number;
    }

    export interface GetMonitorReportDiagnoseResult {
        /**
         * The information about low frame rate.Note: This field may return null, indicating that no valid value was found.
         */
        lowFrameRateResults: string[];
        /**
         * The information about the stream interruption.Note: This field may return null, indicating that no valid value was found.
         */
        streamBrokenResults: string[];
        /**
         * The information about the stream format diagnosis.Note: This field may return null, indicating that no valid value was found.
         */
        streamFormatResults: string[];
    }

    export interface GetMonitorReportMpsResult {
        /**
         * The result of intelligent speech recognition.Note: This field may return null, indicating that no valid value was found.
         */
        aiAsrResults: string[];
        /**
         * The result of intelligent text recognition.Note: This field may return null, indicating that no valid value was found.
         */
        aiOcrResults: string[];
    }

    export interface GetPadTemplatesTemplate {
        /**
         * Template create time.
         */
        createTime: string;
        /**
         * Description info.
         */
        description: string;
        /**
         * Maximum pad duration.Value range: 0 - positive infinity.Unit: milliseconds.
         */
        maxDuration: number;
        /**
         * Template id.
         */
        templateId: number;
        /**
         * Template name.
         */
        templateName: string;
        /**
         * Pad content type: 1: Image, 2: Video. Default value: 1.
         */
        type: number;
        /**
         * Template modify time.
         */
        updateTime: string;
        /**
         * Pad content.
         */
        url: string;
        /**
         * Stream interruption waiting time.Value range: 0-30000.Unit: milliseconds.
         */
        waitDuration: number;
    }

    export interface GetPullStreamTaskStatusTaskStatusInfo {
        /**
         * The duration of the VOD source file, in seconds.
         */
        fileDuration: number;
        /**
         * Current use source url.
         */
        fileUrl: string;
        /**
         * The number of times a VOD source task is played in a loop.
         */
        loopedTimes: number;
        /**
         * The URL of the next progress VOD file.
         */
        nextFileUrl: string;
        /**
         * The playback offset of the VOD source, in seconds.
         */
        offsetTime: number;
        /**
         * The latest heartbeat reporting time in UTC format, for example: 2022-02-11T10:00:00Z.Note: UTC time is 8 hours ahead of Beijing time.
         */
        reportTime: string;
        /**
         * Real run status:active,inactive.
         */
        runStatus: string;
    }

    export interface GetStreamMonitorListLiveStreamMonitor {
        /**
         * The list of input indices for enabling intelligent speech recognition.Note: This field may return null, indicating that no valid value is available.
         */
        aiAsrInputIndexLists: number[];
        /**
         * Whether to enable format diagnosis. Note: This field may return null, indicating that no valid value is available.
         */
        aiFormatDiagnose: number;
        /**
         * The list of input indices for enabling intelligent text recognition.Note: This field may return null, indicating that no valid value is available.
         */
        aiOcrInputIndexLists: number[];
        /**
         * Whether to store monitoring events in the monitoring report and allow querying of the monitoring report.Note: This field may return null, indicating that no valid value is available.
         */
        allowMonitorReport: number;
        /**
         * The language for intelligent speech recognition:0: Disabled1: Chinese2: English3: Japanese4: KoreanNote: This field may return null, indicating that no valid value is available.
         */
        asrLanguage: number;
        /**
         * The list of input indices for the output audio.Note: This field may return null, indicating that no valid value is available.
         */
        audibleInputIndexLists: number[];
        /**
         * Whether to enable stream disconnection detection.Note: This field may return null, indicating that no valid value is available.
         */
        checkStreamBroken: number;
        /**
         * Whether to enable low frame rate detection.Note: This field may return null, indicating that no valid value is available.
         */
        checkStreamLowFrameRate: number;
        /**
         * The creation time of the monitoring task, in Unix timestamp format.Note: This field may return null, indicating that no valid value is available.
         */
        createTime: number;
        /**
         * The input stream information for the monitoring task.Note: This field may return null, indicating that no valid value is available.
         */
        inputLists: outputs.Css.GetStreamMonitorListLiveStreamMonitorInputList[];
        /**
         * Monitoring task ID.Note: This field may return null, indicating that no valid value is available.
         */
        monitorId: string;
        /**
         * Monitoring task name. Up to 128 bytes.Note: This field may return null, indicating that no valid value is available.
         */
        monitorName: string;
        /**
         * The notification policy for monitoring events.Note: This field may return null, indicating that no valid value is available.
         */
        notifyPolicies: outputs.Css.GetStreamMonitorListLiveStreamMonitorNotifyPolicy[];
        /**
         * The language for intelligent text recognition:0: Disabled1: Chinese and EnglishNote: This field may return null, indicating that no valid value is available.
         */
        ocrLanguage: number;
        /**
         * Monitoring task output information.Note: This field may return null, indicating that no valid value is available.
         */
        outputInfos: outputs.Css.GetStreamMonitorListLiveStreamMonitorOutputInfo[];
        /**
         * The last start time of the monitoring task, in Unix timestamp format.Note: This field may return null, indicating that no valid value is available.
         */
        startTime: number;
        /**
         * The status of the monitoring task.  0: Represents idle.  1: Represents monitoring in progress.Note: This field may return null, indicating that no valid value is available.
         */
        status: number;
        /**
         * The last stop time of the monitoring task, in Unix timestamp format.Note: This field may return null, indicating that no valid value is available.
         */
        stopTime: number;
        /**
         * The update time of the monitoring task, in Unix timestamp format.Note: This field may return null, indicating that no valid value is available.
         */
        updateTime: number;
    }

    export interface GetStreamMonitorListLiveStreamMonitorInputList {
        /**
         * Description of the monitoring task.It should be within 256 bytes.Note: This field may return null, indicating that no valid value is available.
         */
        description: string;
        /**
         * The push path for the input stream to be monitored.It should be within 32 bytes and can only contain letters, numbers, `-`, `_`, and `.` characters.Note: This field may return null, indicating that no valid value is available.
         */
        inputApp: string;
        /**
         * The push domain for the input stream to be monitored.It should be within 128 bytes and can only be filled with an enabled push domain.Note: This field may return null, indicating that no valid value is available.
         */
        inputDomain: string;
        /**
         * The name of the input stream for the monitoring task.It should be within 256 bytes and can only contain letters, numbers, `-`, `_`, and `.` characters.Note: This field may return null, indicating that no valid value is available.
         */
        inputStreamName: string;
        /**
         * The push URL for the input stream to be monitored. In most cases, this parameter is not required.Note: This field may return null, indicating that no valid value is available.
         */
        inputUrl: string;
    }

    export interface GetStreamMonitorListLiveStreamMonitorNotifyPolicy {
        /**
         * The callback URL for notifications. It should be of length [0,512] and only support URLs with the http and https types.Note: This field may return null, indicating that no valid value is available.
         */
        callbackUrl: string;
        /**
         * The type of notification policy: Range [0,1]  0: Represents no notification policy is used.  1: Represents the use of a global callback policy, where all events are notified to the CallbackUrl.Note: This field may return null, indicating that no valid value is available.
         */
        notifyPolicyType: number;
    }

    export interface GetStreamMonitorListLiveStreamMonitorOutputInfo {
        /**
         * The playback path for the monitoring task.It should be within 32 bytes and can only contain letters, numbers, `-`, `_`, and `.` characters.Note: This field may return null, indicating that no valid value is available.
         */
        outputApp: string;
        /**
         * The playback domain for the monitoring task.It should be within 128 bytes and can only be filled with an enabled playback domain.Note: This field may return null, indicating that no valid value is available.
         */
        outputDomain: string;
        /**
         * The height of the output stream in pixels for the monitoring task. The range is [1, 1080]. It is recommended to be at least 100 pixels.Note: This field may return null, indicating that no valid value is available.
         */
        outputStreamHeight: number;
        /**
         * The name of the output stream for the monitoring task.If not specified, the system will generate a name automatically.The name should be within 256 bytes and can only contain letters, numbers, `-`, `_`, and `.` characters.Note: This field may return null, indicating that no valid value is available.
         */
        outputStreamName: string;
        /**
         * The width of the output stream in pixels for the monitoring task. The range is [1, 1920]. It is recommended to be at least 100 pixels.Note: This field may return null, indicating that no valid value is available.
         */
        outputStreamWidth: number;
    }

    export interface GetTimeShiftRecordDetailRecordList {
        /**
         * The ending time of the query range is specified in Unix timestamp.
         */
        endTime: number;
        /**
         * The identifier for the time-shift recording session.
         */
        sid: string;
        /**
         * The starting time of the query range is specified in Unix timestamp.
         */
        startTime: number;
    }

    export interface GetTimeShiftStreamListStreamList {
        /**
         * The push path.
         */
        appName: string;
        /**
         * The push domain.
         */
        domain: string;
        /**
         * The group the push domain belongs to.
         */
        domainGroup: string;
        /**
         * The storage duration (seconds) of the recording.Note: This field may return null, indicating that no valid values can be obtained.
         */
        duration: number;
        /**
         * The end time, which must be a Unix timestamp.
         */
        endTime: number;
        /**
         * The start time, which must be a Unix timestamp.
         */
        startTime: number;
        /**
         * The stream name.
         */
        streamName: string;
        /**
         * The stream type. `0`: The original stream; `1`: The watermarked stream; `2`: The transcoded stream.
         */
        streamType: number;
        /**
         * The transcoding template ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        transCodeId: number;
    }

    export interface GetWatermarksWatermarkList {
        /**
         * The time when the watermark was added.Note: Beijing time (UTC+8) is used.
         */
        createTime: string;
        /**
         * Watermark height.
         */
        height: number;
        /**
         * Watermark image URL.
         */
        pictureUrl: string;
        /**
         * Current status. 0: not used. 1: in use.
         */
        status: number;
        /**
         * Watermark ID.
         */
        watermarkId: number;
        /**
         * Watermark name.
         */
        watermarkName: string;
        /**
         * Watermark width.
         */
        width: number;
        /**
         * Display position: X-axis offset.
         */
        xPosition: number;
        /**
         * Display position: Y-axis offset.
         */
        yPosition: number;
    }

    export interface GetXp2pDetailInfoListDataInfoList {
        /**
         * AppId. Note: This field may return null, indicating that no valid value is available.
         */
        appId: string;
        /**
         * CDN traffic.
         */
        cdnBytes: number;
        /**
         * Online numbers.
         */
        onlinePeople: number;
        /**
         * P2P traffic.
         */
        p2pBytes: number;
        /**
         * Request numbers.
         */
        request: number;
        /**
         * Success numbers.
         */
        requestSuccess: number;
        /**
         * Stream ID.Note: This field may return null, indicating that no valid value is available.
         */
        streamName: string;
        /**
         * People count.
         */
        stuckPeople: number;
        /**
         * Count.
         */
        stuckTimes: number;
        /**
         * The requested format for time in UTC with one-minute granularity is yyyy-mm-ddTHH:MM:SSZ. This format follows the ISO 8601 standard and is commonly used for representing timestamps in UTC. For more information and examples, you can refer to the link provided: https://cloud.tencent.com/document/product/266/11732#I.
         */
        time: string;
        /**
         * The type array can be used to specify the type of media content to be queried. The two available options are live for live streaming and vod for video on demand. If no type is specified, the query will include both live and VOD content by default.
         */
        type: string;
    }

    export interface PlayDomainCertAttachmentDomainInfo {
        /**
         * domain name.
         */
        domainName: string;
        /**
         * Whether to enable the https rule for the domain name. 1: enable, 0: disabled, -1: remain unchanged.
         */
        status: number;
    }

    export interface PullStreamTaskWatermarkList {
        /**
         * pic height.
         */
        height: number;
        /**
         * position type, 0:left top, 1:right top, 2:right bot, 3: left bot.
         */
        location: number;
        /**
         * watermark picture url.
         */
        pictureUrl: string;
        /**
         * pic width.
         */
        width: number;
        /**
         * x position.
         */
        xPosition: number;
        /**
         * y position.
         */
        yPosition: number;
    }

    export interface RecordTemplateAacParam {
        /**
         * Classification of on-demand applications. This field may return null, indicating that no valid value can be obtained.
         */
        classId?: number;
        /**
         * Whether to enable recording in the current format. The default value is 0. 0: No, 1: Yes.
         */
        enable?: number;
        /**
         * Task flow. Note: This field may return null, indicating that no valid value can be obtained.
         */
        procedure?: string;
        /**
         * Recording interval. Unit: second, default: 1800. Value range: 30-7200. This parameter is invalid for HLS. When recording HLS, a file is generated from streaming to streaming.
         */
        recordInterval?: number;
        /**
         * Video storage strategy. Normal: standard storage. Cold: low frequency storage. Note: This field may return null, indicating that no valid value can be obtained.
         */
        storageMode?: string;
        /**
         * Recording storage duration. Unit: second. Value range: 0 - 1500 days. 0: indicates permanent storage.
         */
        storageTime?: number;
        /**
         * Record file name.Special placeholders supported are: `StreamID`: Stream ID,`StartYear`: Start time - year,`StartMonth`: Start time - month,`StartDay`: Start time - day,`StartHour`: Start time - hour,`StartMinute`: Start time - minutes,`StartSecond`: Start time - seconds,`StartMillisecond`: Start time - milliseconds,`EndYear`: End time - year,`EndMonth`: End time - month,`EndDay`: End time - day,`EndHour`: End time - hour,`EndMinute`: End time - minutes,`EndSecond`: End time - seconds,`EndMillisecond`: End time - millisecondsIf the default recording file name is not set as ,`StreamID`,`StartYear`,`StartMonth`,`StartDay`,`StartHour`,`StartMinute`,`StartSecond`,`EndYear`,`EndMonth`,`EndDay`,`EndHour`,`EndMinute`,`EndSecond`.
         */
        vodFileName?: string;
        /**
         * The ID of the on-demand sub app.
         */
        vodSubAppId?: number;
    }

    export interface RecordTemplateFlvParam {
        /**
         * Classification of on-demand applications. Note: This field may return null, indicating that no valid value can be obtained.
         */
        classId?: number;
        /**
         * Whether to enable recording in the current format. The default value is 0. 0: No, 1: Yes.
         */
        enable?: number;
        /**
         * Task flow. This field may return null, indicating that no valid value can be obtained.
         */
        procedure?: string;
        /**
         * Recording interval.  Unit: second, default: 1800.  Value range: 30-7200.  This parameter is invalid for HLS. When recording HLS, a file is generated from streaming to streaming.
         */
        recordInterval?: number;
        /**
         * Video storage strategy. Normal: standard storage. Cold: low frequency storage. This field may return null, indicating that no valid value can be obtained.
         */
        storageMode?: string;
        /**
         * Recording storage duration.  Unit: second. Value range: 0 - 1500 days.  0: indicates permanent storage.
         */
        storageTime?: number;
        /**
         * Record file name.Special placeholders supported are: `StreamID`: Stream ID,`StartYear`: Start time - year,`StartMonth`: Start time - month,`StartDay`: Start time - day,`StartHour`: Start time - hour,`StartMinute`: Start time - minutes,`StartSecond`: Start time - seconds,`StartMillisecond`: Start time - milliseconds,`EndYear`: End time - year,`EndMonth`: End time - month,`EndDay`: End time - day,`EndHour`: End time - hour,`EndMinute`: End time - minutes,`EndSecond`: End time - seconds,`EndMillisecond`: End time - millisecondsIf the default recording file name is not set as ,`StreamID`_ ,`StartYear`-,`StartMonth`-,`StartDay`-,`StartHour`-,`StartMinute`-,`StartSecond`_ ,`EndYear`-,`EndMonth`-,`EndDay`-,`EndHour`-,`EndMinute`-,`EndSecond`.
         */
        vodFileName?: string;
        /**
         * The ID of the vodSub app.
         */
        vodSubAppId?: number;
    }

    export interface RecordTemplateFlvSpecialParam {
        /**
         * Whether to enable the transfer while recording is valid only in the flv format.
         */
        uploadInRecording?: boolean;
    }

    export interface RecordTemplateHlsParam {
        /**
         * Classification of on-demand applications. Note: This field may return null, indicating that no valid value can be obtained.
         */
        classId?: number;
        /**
         * Whether to enable recording in the current format. The default value is 0. 0: No, 1: Yes.
         */
        enable?: number;
        /**
         * Task flow. Note: This field may return null, indicating that no valid value can be obtained.
         */
        procedure?: string;
        /**
         * Recording interval. Unit: second, default: 1800. Value range: 30-7200. This parameter is invalid for HLS. When recording HLS, a file is generated from streaming to streaming.
         */
        recordInterval?: number;
        /**
         * Video storage strategy. Normal: standard storage. Cold: low frequency storage. Note: This field may return null, indicating that no valid value can be obtained.
         */
        storageMode?: string;
        /**
         * Recording storage duration. Unit: second. Value range: 0 - 1500 days. 0: indicates permanent storage.
         */
        storageTime?: number;
        /**
         * Record file name.Special placeholders supported are: `StreamID`: Stream ID,`StartYear`: Start time - year,`StartMonth`: Start time - month,`StartDay`: Start time - day,`StartHour`: Start time - hour,`StartMinute`: Start time - minutes,`StartSecond`: Start time - seconds,`StartMillisecond`: Start time - milliseconds,`EndYear`: End time - year,`EndMonth`: End time - month,`EndDay`: End time - day,`EndHour`: End time - hour,`EndMinute`: End time - minutes,`EndSecond`: End time - seconds,`EndMillisecond`: End time - millisecondsIf the default recording file name is not set as ,`StreamID`,`StartYear`,`StartMonth`,`StartDay`,`StartHour`,`StartMinute`,`StartSecond`,`EndYear`,`EndMonth`,`EndDay`,`EndHour`,`EndMinute`,`EndSecond`.
         */
        vodFileName?: string;
        /**
         * The ID of the vodSub app.
         */
        vodSubAppId?: number;
    }

    export interface RecordTemplateHlsSpecialParam {
        /**
         * HLS freewheeling timeout. Value range [0, 1800].
         */
        flowContinueDuration?: number;
    }

    export interface RecordTemplateMp3Param {
        /**
         * Classification of vod applications. Note: This field may return null, indicating that no valid value can be obtained.
         */
        classId?: number;
        /**
         * Whether to enable recording in the current format. The default value is 0. 0: No, 1: Yes.
         */
        enable?: number;
        /**
         * Task flow. Note: This field may return null, indicating that no valid value can be obtained.
         */
        procedure?: string;
        /**
         * Recording interval. Unit: second, default: 1800. Value range: 30-7200. This parameter is invalid for HLS. When recording HLS, a file is generated from streaming to streaming.
         */
        recordInterval?: number;
        /**
         * Video storage strategy. Normal: standard storage. Cold: low frequency storage. Note: This field may return null, indicating that no valid value can be obtained.
         */
        storageMode?: string;
        /**
         * Recording storage duration. Unit: second. Value range: 0 - 1500 days. 0: indicates permanent storage.
         */
        storageTime?: number;
        /**
         * Record file name.Special placeholders supported are: `StreamID`: Stream ID,`StartYear`: Start time - year,`StartMonth`: Start time - month,`StartDay`: Start time - day,`StartHour`: Start time - hour,`StartMinute`: Start time - minutes,`StartSecond`: Start time - seconds,`StartMillisecond`: Start time - milliseconds,`EndYear`: End time - year,`EndMonth`: End time - month,`EndDay`: End time - day,`EndHour`: End time - hour,`EndMinute`: End time - minutes,`EndSecond`: End time - seconds,`EndMillisecond`: End time - millisecondsIf the default recording file name is not set as ,`StreamID`,`StartYear`,`StartMonth`,`StartDay`,`StartHour`,`StartMinute`, `StartSecond`,`EndYear`,`EndMonth`,`EndDay`,`EndHour`,`EndMinute`,`EndSecond`.
         */
        vodFileName?: string;
        /**
         * The ID of the on-demand sub app.
         */
        vodSubAppId?: number;
    }

    export interface RecordTemplateMp4Param {
        /**
         * Classification of on-demand applications. Note: This field may return null, indicating that no valid value can be obtained.
         */
        classId?: number;
        /**
         * Whether to enable recording in the current format. The default value is 0. 0: No, 1: Yes.
         */
        enable?: number;
        /**
         * Task flow. Note: This field may return null, indicating that no valid value can be obtained.
         */
        procedure?: string;
        /**
         * Recording interval. Unit: second, default: 1800. Value range: 30-7200. This parameter is invalid for HLS. When recording HLS, a file is generated from streaming to streaming.
         */
        recordInterval?: number;
        /**
         * Video storage strategy. Normal: standard storage. Cold: low frequency storage. Note: This field may return null, indicating that no valid value can be obtained.
         */
        storageMode?: string;
        /**
         * Recording storage duration. Unit: second. Value range: 0 - 1500 days. 0: indicates permanent storage.
         */
        storageTime?: number;
        /**
         * Record file name.Special placeholders supported are: `StreamID`: Stream ID,`StartYear`: Start time - year,`StartMonth`: Start time - month,`StartDay`: Start time - day,`StartHour`: Start time - hour,`StartMinute`: Start time - minutes,`StartSecond`: Start time - seconds,`StartMillisecond`: Start time - milliseconds,`EndYear`: End time - year,`EndMonth`: End time - month,`EndDay`: End time - day,`EndHour`: End time - hour,`EndMinute`: End time - minutes,`EndSecond`: End time - seconds,`EndMillisecond`: End time - millisecondsIf the default recording file name is not set as ,`StreamID`,`StartYear`,`StartMonth`,`StartDay`,`StartHour`,`StartMinute`,`StartSecond`,`EndYear`,`EndMonth`,`EndDay`,`EndHour`,`EndMinute`,`EndSecond`.
         */
        vodFileName?: string;
        /**
         * The ID of the on-demand sub app.
         */
        vodSubAppId?: number;
    }

    export interface StreamMonitorInputList {
        /**
         * Description content.limit 256 bytes.
         */
        description?: string;
        /**
         * Wait monitor input push path.limit 32 bytes.
         */
        inputApp?: string;
        /**
         * Wait monitor input push domain.limit 128 bytes.
         */
        inputDomain?: string;
        /**
         * Wait monitor input stream name.limit 256 bytes.
         */
        inputStreamName: string;
        /**
         * Wait monitor input stream push url.
         */
        inputUrl?: string;
    }

    export interface StreamMonitorNotifyPolicy {
        /**
         * Callback url.limit [0,512].only http or https.
         */
        callbackUrl?: string;
        /**
         * Notify policy type.0: not notify.1: use global policy.
         */
        notifyPolicyType?: number;
    }

    export interface StreamMonitorOutputInfo {
        /**
         * Monitor task play path.limit 32 bytes.
         */
        outputApp?: string;
        /**
         * Monitor task output play domain.limit 128 bytes.
         */
        outputDomain?: string;
        /**
         * Monitor task output height, limit[1, 1080].
         */
        outputStreamHeight: number;
        /**
         * Monitor task output stream name.limit 256 bytes.
         */
        outputStreamName?: string;
        /**
         * Output stream width, limit[1, 1920].
         */
        outputStreamWidth: number;
    }

}

export namespace Cvm {
    export interface ChcConfigBmcVirtualPrivateCloud {
        /**
         * Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
         */
        asVpcGateway?: boolean;
        /**
         * Number of IPv6 addresses randomly generated for the ENI.
         */
        ipv6AddressCount: number;
        /**
         * Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
         */
        privateIpAddresses: string[];
        /**
         * VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
         */
        subnetId: string;
        /**
         * VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
         */
        vpcId: string;
    }

    export interface ChcConfigDeployVirtualPrivateCloud {
        /**
         * Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
         */
        asVpcGateway?: boolean;
        /**
         * Number of IPv6 addresses randomly generated for the ENI.
         */
        ipv6AddressCount: number;
        /**
         * Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
         */
        privateIpAddresses: string[];
        /**
         * VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
         */
        subnetId: string;
        /**
         * VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
         */
        vpcId: string;
    }

    export interface GetChcDeniedActionsChcHostDeniedActionSet {
        /**
         * CHC instance ID.
         */
        chcId: string;
        /**
         * Actions not allowed for the current CHC instance.
         */
        denyActions: string[];
        /**
         * CHC instance status.
         */
        state: string;
    }

    export interface GetChcHostsChcHostSet {
        /**
         * Out-of-band network IPNote: This field may return null, indicating that no valid values can be obtained.
         */
        bmcIp: string;
        /**
         * MAC address assigned under the out-of-band networkNote: This field may return null, indicating that no valid values can be obtained.
         */
        bmcMac: string;
        /**
         * Out-of-band network security group IDNote: This field may return null, indicating that no valid values can be obtained.
         */
        bmcSecurityGroupIds: string[];
        /**
         * Out-of-band networkNote: This field may return null, indicating that no valid values can be obtained.
         */
        bmcVirtualPrivateClouds: outputs.Cvm.GetChcHostsChcHostSetBmcVirtualPrivateCloud[];
        /**
         * CHC host ID.
         */
        chcId: string;
        /**
         * CPU cores of the CHC hostNote: This field may return null, indicating that no valid values can be obtained.
         */
        cpu: number;
        /**
         * Server creation time.
         */
        createdTime: string;
        /**
         * ID of the associated CVMNote: This field may return null, indicating that no valid values can be obtained.
         */
        cvmInstanceId: string;
        /**
         * Deployment network IPNote: This field may return null, indicating that no valid values can be obtained.
         */
        deployIp: string;
        /**
         * MAC address assigned under the deployment networkNote: This field may return null, indicating that no valid values can be obtained.
         */
        deployMac: string;
        /**
         * Deployment network security group IDNote: This field may return null, indicating that no valid values can be obtained.
         */
        deploySecurityGroupIds: string[];
        /**
         * Deployment networkNote: This field may return null, indicating that no valid values can be obtained.
         */
        deployVirtualPrivateClouds: outputs.Cvm.GetChcHostsChcHostSetDeployVirtualPrivateCloud[];
        /**
         * Device typeNote: This field may return null, indicating that no valid values can be obtained.
         */
        deviceType: string;
        /**
         * Disk capacity of the CHC hostNote: This field may return null, indicating that no valid values can be obtained.
         */
        disk: string;
        /**
         * Instance hardware description, including CPU cores, memory capacity and disk capacity.Note: This field may return null, indicating that no valid values can be obtained.
         */
        hardwareDescription: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * CHC host status&lt;br/&gt;&lt;ul&gt;&lt;li&gt;REGISTERED: The CHC host is registered, but the out-of-band network and deployment network are not configured.&lt;/li&gt;&lt;li&gt;VPC_READY: The out-of-band network and deployment network are configured.&lt;/li&gt;&lt;li&gt;PREPARED: It&#39;s ready and can be associated with a CVM.&lt;/li&gt;&lt;li&gt;ONLINE: It&#39;s already associated with a CVM.&lt;/li&gt;&lt;/ul&gt;.
         */
        instanceState: string;
        /**
         * Memory capacity of the CHC host (unit: GB)Note: This field may return null, indicating that no valid values can be obtained.
         */
        memory: number;
        /**
         * Availability zone.
         */
        placements: outputs.Cvm.GetChcHostsChcHostSetPlacement[];
        /**
         * Server serial number.
         */
        serialNumber: string;
        /**
         * Management typeHOSTING: HostingTENANT: LeasingNote: This field may return null, indicating that no valid values can be obtained.
         */
        tenantType: string;
    }

    export interface GetChcHostsChcHostSetBmcVirtualPrivateCloud {
        /**
         * Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
         */
        asVpcGateway: boolean;
        /**
         * Number of IPv6 addresses randomly generated for the ENI.
         */
        ipv6AddressCount: number;
        /**
         * Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
         */
        privateIpAddresses: string[];
        /**
         * VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
         */
        subnetId: string;
        /**
         * VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
         */
        vpcId: string;
    }

    export interface GetChcHostsChcHostSetDeployVirtualPrivateCloud {
        /**
         * Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC. Valid values:&lt;br&gt;&lt;li&gt;TRUE: yes;&lt;br&gt;&lt;li&gt;FALSE: no&lt;br&gt;&lt;br&gt;Default: FALSE.
         */
        asVpcGateway: boolean;
        /**
         * Number of IPv6 addresses randomly generated for the ENI.
         */
        ipv6AddressCount: number;
        /**
         * Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
         */
        privateIpAddresses: string[];
        /**
         * VPC subnet ID in the format subnet-xxx. To obtain valid subnet IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call DescribeSubnets and look for the unSubnetId fields in the response. If you specify DEFAULT for both SubnetId and VpcId when creating an instance, the default VPC will be used.
         */
        subnetId: string;
        /**
         * VPC ID in the format of vpc-xxx. To obtain valid VPC IDs, you can log in to the [console](https://console.tencentcloud.com/vpc/vpc?rid=1) or call the DescribeVpcEx API and look for the unVpcId fields in the response. If you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
         */
        vpcId: string;
    }

    export interface GetChcHostsChcHostSetPlacement {
        /**
         * The ID of the CDH to which the instance belongs, only used as an output parameter.
         */
        hostId: string;
        /**
         * ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
         */
        hostIds: string[];
        /**
         * IPs of the hosts to create CVMs.
         */
        hostIps: string[];
        /**
         * ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
         */
        projectId: number;
        /**
         * ID of the availability zone where the instance resides. You can call the [DescribeZones](https://www.tencentcloud.com/document/product/213/35071) API and obtain the ID in the returned Zone field.
         */
        zone: string;
    }

    export interface GetChcHostsFilter {
        /**
         * Filter name.
         */
        name: string;
        /**
         * Filter values.
         */
        values: string[];
    }

    export interface GetImageSharePermissionSharePermissionSet {
        /**
         * ID of the account with which the image is shared.
         */
        accountId: string;
        /**
         * Time when an image was shared.
         */
        createdTime: string;
    }

    export interface GetImportImageOsImportImageOsListSupported {
        /**
         * Supported Linux OS Note: This field may return null, indicating that no valid values can be obtained.
         */
        linuxes: string[];
        /**
         * Supported Windows OS Note: This field may return null, indicating that no valid values can be obtained.
         */
        windows: string[];
    }

    export interface GetImportImageOsImportImageOsVersionSet {
        /**
         * Supported operating system architecture.
         */
        architectures: string[];
        /**
         * Operating system type.
         */
        osName: string;
        /**
         * Supported operating system versions.
         */
        osVersions: string[];
    }

    export interface GetInstancesModificationFilter {
        /**
         * Fields to be filtered.
         */
        name: string;
        /**
         * Value of the field.
         */
        values: string[];
    }

    export interface GetInstancesModificationInstanceTypeConfigStatusList {
        /**
         * Configuration information.
         */
        instanceTypeConfigs: outputs.Cvm.GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfig[];
        /**
         * Status description information.
         */
        message: string;
        /**
         * State description.
         */
        status: string;
    }

    export interface GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfig {
        /**
         * The number of CPU kernels, in cores.
         */
        cpu: number;
        /**
         * The number of FPGA kernels, in cores.
         */
        fpga: number;
        /**
         * The number of GPU kernels, in cores.
         */
        gpu: number;
        /**
         * Instance family.
         */
        instanceFamily: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Memory capacity (in GB).
         */
        memory: number;
        /**
         * Availability zone.
         */
        zone: string;
    }

    export interface ImportImageTagSpecification {
        /**
         * Resource type. Valid values: instance (CVM), host (CDH), image (for image), and keypair (for key). Note: This field may return null, indicating that no valid values can be obtained.
         */
        resourceType: string;
        /**
         * Tag pairs Note: This field may return null, indicating that no valid values can be obtained.
         */
        tags: outputs.Cvm.ImportImageTagSpecificationTag[];
    }

    export interface ImportImageTagSpecificationTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface LaunchTemplateActionTimer {
        /**
         * Execution time.
         */
        actionTime?: string;
        /**
         * Extended data.
         */
        externals?: outputs.Cvm.LaunchTemplateActionTimerExternals;
        /**
         * Timer name.
         */
        timerAction?: string;
    }

    export interface LaunchTemplateActionTimerExternals {
        /**
         * Release address.
         */
        releaseAddress?: boolean;
        /**
         * HDD local storage attributes.
         */
        storageBlockAttr?: outputs.Cvm.LaunchTemplateActionTimerExternalsStorageBlockAttr;
        /**
         * Unsupported network type.
         */
        unsupportNetworks?: string[];
    }

    export interface LaunchTemplateActionTimerExternalsStorageBlockAttr {
        /**
         * The maximum capacity of HDD local storage.
         */
        maxSize: number;
        /**
         * The minimum capacity of HDD local storage.
         */
        minSize: number;
        /**
         * The type of HDD local storage.
         */
        type: string;
    }

    export interface LaunchTemplateDataDisk {
        /**
         * Cloud Dedicated Cluster(CDC) ID.
         */
        cdcId?: string;
        /**
         * Whether the data disk is destroyed along with the instance, true or false.
         */
        deleteWithInstance?: boolean;
        /**
         * Data disk ID.
         */
        diskId?: string;
        /**
         * The size of the data disk.
         */
        diskSize: number;
        /**
         * The type of data disk.
         */
        diskType?: string;
        /**
         * Whether the data disk is encrypted, TRUE or FALSE.
         */
        encrypt?: boolean;
        /**
         * The id of custom CMK.
         */
        kmsKeyId?: string;
        /**
         * Data disk snapshot ID.
         */
        snapshotId?: string;
        /**
         * Cloud disk performance, MB/s.
         */
        throughputPerformance?: number;
    }

    export interface LaunchTemplateEnhancedService {
        /**
         * Enable TencentCloud Automation Tools(TAT).
         */
        automationService?: outputs.Cvm.LaunchTemplateEnhancedServiceAutomationService;
        /**
         * Enable cloud monitor service.
         */
        monitorService?: outputs.Cvm.LaunchTemplateEnhancedServiceMonitorService;
        /**
         * Enable cloud security service.
         */
        securityService?: outputs.Cvm.LaunchTemplateEnhancedServiceSecurityService;
    }

    export interface LaunchTemplateEnhancedServiceAutomationService {
        /**
         * Whether to enable TencentCloud Automation Tools(TAT), TRUE or FALSE.
         */
        enabled?: boolean;
    }

    export interface LaunchTemplateEnhancedServiceMonitorService {
        /**
         * Whether to enable cloud monitor service, TRUE or FALSE.
         */
        enabled?: boolean;
    }

    export interface LaunchTemplateEnhancedServiceSecurityService {
        /**
         * Whether to enable cloud security service, TRUE or FALSE.
         */
        enabled?: boolean;
    }

    export interface LaunchTemplateInstanceChargePrepaid {
        /**
         * The period of purchasing instances.
         */
        period: number;
        /**
         * Automatic renew flag.
         */
        renewFlag?: string;
    }

    export interface LaunchTemplateInstanceMarketOptions {
        /**
         * Market option type, currently only supports value: spot.
         */
        marketType?: string;
        /**
         * Bidding related options.
         */
        spotOptions: outputs.Cvm.LaunchTemplateInstanceMarketOptionsSpotOptions;
    }

    export interface LaunchTemplateInstanceMarketOptionsSpotOptions {
        /**
         * Bidding.
         */
        maxPrice: string;
        /**
         * Bidding request type, currently only supported type: one-time.
         */
        spotInstanceType?: string;
    }

    export interface LaunchTemplateInternetAccessible {
        /**
         * The ID of bandwidth package.
         */
        bandwidthPackageId?: string;
        /**
         * The type of internet charge.
         */
        internetChargeType?: string;
        /**
         * Internet outbound bandwidth upper limit, Mbps.
         */
        internetMaxBandwidthOut?: number;
        /**
         * Whether to allocate public network IP, TRUE or FALSE.
         */
        publicIpAssigned?: boolean;
    }

    export interface LaunchTemplateLoginSettings {
        /**
         * Keep the original settings of the mirror.
         */
        keepImageLogin?: string;
        /**
         * List of key ID.
         */
        keyIds?: string[];
        /**
         * The login password of instance.
         */
        password?: string;
    }

    export interface LaunchTemplatePlacement {
        /**
         * The CDH ID list of the instance(input).
         */
        hostIds?: string[];
        /**
         * Specify the host machine ip.
         */
        hostIps?: string[];
        /**
         * The project ID of the instance.
         */
        projectId?: number;
        /**
         * The available zone ID of the instance.
         */
        zone: string;
    }

    export interface LaunchTemplateSystemDisk {
        /**
         * Cloud Dedicated Cluster(CDC) ID.
         */
        cdcId?: string;
        /**
         * System disk ID.
         */
        diskId?: string;
        /**
         * The size of system disk.
         */
        diskSize?: number;
        /**
         * The type of system disk.
         */
        diskType?: string;
    }

    export interface LaunchTemplateTagSpecification {
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * Tag list.
         */
        tags: outputs.Cvm.LaunchTemplateTagSpecificationTag[];
    }

    export interface LaunchTemplateTagSpecificationTag {
        /**
         * The key of tag.
         */
        key: string;
        /**
         * The value of tag.
         */
        value: string;
    }

    export interface LaunchTemplateVersionActionTimer {
        /**
         * Execution time, displayed according to ISO8601 standard, and UTC time is used. The format is YYYY-MM-DDThh:mm:ssZ. For example, 2018-05-29T11:26:40Z, the execution must be at least 5 minutes later than the current time.
         */
        actionTime: string;
        /**
         * Additional data.
         */
        externals: outputs.Cvm.LaunchTemplateVersionActionTimerExternals;
        /**
         * Timer name. Currently TerminateInstances is the only supported value.
         */
        timerAction: string;
    }

    export interface LaunchTemplateVersionActionTimerExternals {
        /**
         * Release address.
         */
        releaseAddress: boolean;
        /**
         * Information on local HDD storage.
         */
        storageBlockAttr: outputs.Cvm.LaunchTemplateVersionActionTimerExternalsStorageBlockAttr;
        /**
         * Not supported network.
         */
        unsupportNetworks: string[];
    }

    export interface LaunchTemplateVersionActionTimerExternalsStorageBlockAttr {
        /**
         * Maximum capacity of local HDD storage.
         */
        maxSize: number;
        /**
         * Minimum capacity of local HDD storage.
         */
        minSize: number;
        /**
         * Local HDD storage type. Value: LOCAL_PRO.
         */
        type: string;
    }

    export interface LaunchTemplateVersionDataDisk {
        /**
         * ID of the dedicated cluster to which the instance belongs.
         */
        cdcId: string;
        /**
         * Whether to terminate the data disk when its CVM is terminated. Default value: `true`.
         */
        deleteWithInstance: boolean;
        /**
         * System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
         */
        diskId: string;
        /**
         * Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type.
         */
        diskSize: number;
        /**
         * The type of data disk.
         */
        diskType: string;
        /**
         * Specifies whether the data disk is encrypted.
         */
        encrypt: boolean;
        /**
         * ID of the custom CMK in the format of UUID or `kms-abcd1234`.
         */
        kmsKeyId: string;
        /**
         * Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk. Note: This field may return null, indicating that no valid value is found.
         */
        snapshotId: string;
        /**
         * Cloud disk performance in MB/s.
         */
        throughputPerformance: number;
    }

    export interface LaunchTemplateVersionEnhancedService {
        /**
         * Whether to enable the TAT service. If this parameter is not specified, the TAT service is enabled for public images and disabled for other images by default.
         */
        automationService: outputs.Cvm.LaunchTemplateVersionEnhancedServiceAutomationService;
        /**
         * Enables cloud monitor service. If this parameter is not specified, the cloud monitor service will be enabled by default.
         */
        monitorService: outputs.Cvm.LaunchTemplateVersionEnhancedServiceMonitorService;
        /**
         * Enables cloud security service. If this parameter is not specified, the cloud security service will be enabled by default.
         */
        securityService: outputs.Cvm.LaunchTemplateVersionEnhancedServiceSecurityService;
    }

    export interface LaunchTemplateVersionEnhancedServiceAutomationService {
        /**
         * Whether to enable the TAT service.
         */
        enabled: boolean;
    }

    export interface LaunchTemplateVersionEnhancedServiceMonitorService {
        /**
         * Whether to enable Cloud Monitor.
         */
        enabled: boolean;
    }

    export interface LaunchTemplateVersionEnhancedServiceSecurityService {
        /**
         * Whether to enable Cloud Security.
         */
        enabled: boolean;
    }

    export interface LaunchTemplateVersionInstanceChargePrepaid {
        /**
         * Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
         */
        period: number;
        /**
         * Auto renewal flag. Valid values: NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically &lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
         */
        renewFlag: string;
    }

    export interface LaunchTemplateVersionInstanceMarketOptions {
        /**
         * Market option type. Currently spot is the only supported value.
         */
        marketType: string;
        /**
         * Options related to bidding.
         */
        spotOptions: outputs.Cvm.LaunchTemplateVersionInstanceMarketOptionsSpotOptions;
    }

    export interface LaunchTemplateVersionInstanceMarketOptionsSpotOptions {
        /**
         * Bidding price.
         */
        maxPrice: string;
        /**
         * Bidding request type. Currently only one-time is supported.
         */
        spotInstanceType: string;
    }

    export interface LaunchTemplateVersionInternetAccessible {
        /**
         * Bandwidth package ID.
         */
        bandwidthPackageId: string;
        /**
         * Network connection billing plan.
         */
        internetChargeType: string;
        /**
         * The maximum outbound bandwidth of the public network, in Mbps. The default value is 0 Mbps.
         */
        internetMaxBandwidthOut: number;
        /**
         * Whether to assign a public IP.
         */
        publicIpAssigned: boolean;
    }

    export interface LaunchTemplateVersionLoginSettings {
        /**
         * Whether to keep the original settings of an image.
         */
        keepImageLogin: string;
        /**
         * List of key IDs. After an instance is associated with a key, you can access the instance with the private key in the key pair.
         */
        keyIds: string[];
        /**
         * Login password of the instance.
         */
        password: string;
    }

    export interface LaunchTemplateVersionPlacement {
        /**
         * ID list of CDHs from which the instance can be created. If you have purchased CDHs and specify this parameter, the instances you purchase will be randomly deployed on the CDHs.
         */
        hostIds: string[];
        /**
         * IPs of the hosts to create CVMs.
         */
        hostIps: string[];
        /**
         * ID of the project to which the instance belongs. This parameter can be obtained from the projectId returned by DescribeProject. If this is left empty, the default project is used.
         */
        projectId: number;
        /**
         * ID of the availability zone where the instance resides. You can call the DescribeZones API and obtain the ID in the returned Zone field.
         */
        zone: string;
    }

    export interface LaunchTemplateVersionSystemDisk {
        /**
         * ID of the dedicated cluster to which the instance belongs.
         */
        cdcId: string;
        /**
         * System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter. It is only used as a response parameter for APIs such as DescribeInstances, and cannot be used as a request parameter for APIs such as RunInstances.
         */
        diskId: string;
        /**
         * System disk size; unit: GB; default value: 50 GB.
         */
        diskSize: number;
        /**
         * The type of system disk. Default value: the type of hard disk currently in stock.
         */
        diskType: string;
    }

    export interface LaunchTemplateVersionTagSpecification {
        /**
         * The type of resource that the tag is bound to.
         */
        resourceType: string;
        /**
         * List of tags.
         */
        tags: outputs.Cvm.LaunchTemplateVersionTagSpecificationTag[];
    }

    export interface LaunchTemplateVersionTagSpecificationTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface LaunchTemplateVersionVirtualPrivateCloud {
        /**
         * Whether to use a CVM instance as a public gateway. The public gateway is only available when the instance has a public IP and resides in a VPC.
         */
        asVpcGateway: boolean;
        /**
         * Number of IPv6 addresses randomly generated for the ENI.
         */
        ipv6AddressCount: number;
        /**
         * Array of VPC subnet IPs. You can use this parameter when creating instances or modifying VPC attributes of instances. Currently you can specify multiple IPs in one subnet only when creating multiple instances at the same time.
         */
        privateIpAddresses: string[];
        /**
         * VPC subnet ID in the format subnet-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
         */
        subnetId: string;
        /**
         * VPC ID in the format of vpc-xxx, if you specify DEFAULT for both VpcId and SubnetId when creating an instance, the default VPC will be used.
         */
        vpcId: string;
    }

    export interface LaunchTemplateVirtualPrivateCloud {
        /**
         * Is it used as a Public network gateway, TRUE or FALSE.
         */
        asVpcGateway?: boolean;
        /**
         * The number of ipv6 addresses for Elastic Network Interface.
         */
        ipv6AddressCount?: number;
        /**
         * The address of private ip.
         */
        privateIpAddresses?: string[];
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The id of VPC.
         */
        vpcId: string;
    }

    export interface ModifyInstanceDiskTypeDataDisk {
        /**
         * ID of the dedicated cluster to which the instance belongs.
         */
        cdcId?: string;
        /**
         * Whether to terminate the data disk when its CVM is terminated. Valid values:
         * - TRUE: terminate the data disk when its CVM is terminated. This value only supports pay-as-you-go cloud disks billed on an hourly basis.
         * - FALSE: retain the data disk when its CVM is terminated.
         * Default value: TRUE.
         */
        deleteWithInstance?: boolean;
        /**
         * Data disk ID. Note that it's not available for LOCAL_BASIC and LOCAL_SSD disks.
         */
        diskId?: string;
        /**
         * Data disk size (in GB). The minimum adjustment increment is 10 GB. The value range varies by data disk type. The default value is 0, indicating that no data disk is purchased. For more information, see the product documentation.
         */
        diskSize: number;
        /**
         * Data disk type. Valid values:
         * - LOCAL_BASIC: local hard disk;
         * - LOCAL_SSD: local SSD hard disk;
         * - LOCAL_NVME: local NVME hard disk, which is strongly related to InstanceType and cannot be specified;
         * - LOCAL_PRO: local HDD hard disk, which is strongly related to InstanceType and cannot be specified;
         * - CLOUD_BASIC: ordinary cloud disk;
         * - CLOUD_PREMIUM: high-performance cloud disk;
         * - CLOUD_SSD:SSD cloud disk;
         * - CLOUD_HSSD: enhanced SSD cloud disk;
         * - CLOUD_TSSD: extremely fast SSD cloud disk;
         * - CLOUD_BSSD: general-purpose SSD cloud disk;
         * Default value: LOCAL_BASIC.
         */
        diskType?: string;
        /**
         * Specifies whether the data disk is encrypted. Valid values:
         * - TRUE: encrypted
         * - FALSE: not encrypted
         * Default value: FALSE.
         */
        encrypt?: boolean;
        /**
         * ID of the custom CMK in the format of UUID or kms-abcd1234. This parameter is used to encrypt cloud disks.
         */
        kmsKeyId?: string;
        /**
         * Data disk snapshot ID. The size of the selected data disk snapshot must be smaller than that of the data disk.
         */
        snapshotId?: string;
        /**
         * Cloud disk performance, in MB/s.
         */
        throughputPerformance?: number;
    }

    export interface ModifyInstanceDiskTypeSystemDisk {
        /**
         * ID of the dedicated cluster to which the instance belongs.
         */
        cdcId?: string;
        /**
         * System disk ID. System disks whose type is LOCAL_BASIC or LOCAL_SSD do not have an ID and do not support this parameter.
         */
        diskId?: string;
        /**
         * System disk size; unit: GB; default value: 50 GB.
         */
        diskSize?: number;
        /**
         * System disk type. Valid values:- LOCAL_BASIC: local disk
         * - LOCAL_SSD: local SSD disk
         * - CLOUD_BASIC: ordinary cloud disk
         * - CLOUD_SSD: SSD cloud disk
         * - CLOUD_PREMIUM: Premium cloud storage
         * - CLOUD_BSSD: Balanced SSD
         * The disk currently in stock will be used by default.
         */
        diskType?: string;
    }

    export interface RenewHostHostChargePrepaid {
        /**
         * The duration of purchasing an instance, unit: month. Value range: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36.
         */
        period: number;
        /**
         * Auto renewal flag. Valid values:&lt;br&gt;&lt;li&gt;NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically&lt;br&gt;&lt;li&gt;NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically&lt;br&gt;&lt;li&gt;DISABLE_NOTIFY_AND_MANUAL_RENEW: neither notify upon expiration nor renew automatically&lt;br&gt;&lt;br&gt;Default value: NOTIFY_AND_AUTO_RENEWIf this parameter is specified as NOTIFY_AND_AUTO_RENEW, the instance will be automatically renewed on a monthly basis if the account balance is sufficient.
         */
        renewFlag?: string;
    }

    export interface RenewInstanceInstanceChargePrepaid {
        /**
         * Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60. Note: This field may return null, indicating that no valid value is found.
         */
        period: number;
        /**
         * Auto renewal flag. Valid values:
         */
        renewFlag?: string;
    }

}

export namespace Cwp {
    export interface GetMachinesSimpleFilter {
        /**
         * exact match. true or false.
         */
        exactMatch?: boolean;
        /**
         * Only supported Keywords, Version and TagId.
         */
        name: string;
        /**
         * If `name` is `Keywords`: enter keyword query; If `name` is `Version`: enter PRO_VERSION: Professional Edition | BASIC_VERSION: Basic | Flagship: Flagship | ProtectedMachines: Professional+Flagship | UnFlagship: Non Flagship | PRO_POST_PAY: Professional Edition Pay by Volume | PRO_PRE_PAY: Professional Edition Monthly Package query; If `name` is `TagId`: enter tag ID query.
         */
        values: string[];
    }

    export interface GetMachinesSimpleMachine {
        /**
         * Cloud tags detailNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        cloudTags: outputs.Cwp.GetMachinesSimpleMachineCloudTag[];
        /**
         * Instance IDNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        instanceId: string;
        /**
         * Instance status.
         */
        instanceState: string;
        /**
         * Paid version or not. true: yes; false: no.
         */
        isProVersion: boolean;
        /**
         * Core Version.
         */
        kernelVersion: string;
        /**
         * License Order ObjectNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        licenseOrders: outputs.Cwp.GetMachinesSimpleMachineLicenseOrder[];
        /**
         * Machine Internal net IP.
         */
        machineIp: string;
        /**
         * Machine name.
         */
        machineName: string;
        /**
         * Machine OS System.
         */
        machineOs: string;
        /**
         * Service types. -CVM: Cloud Virtual Machine; -ECM: Edge Computing Machine; -LH: Lighthouse; -Other: Mixed cloud; -ALL: All server types.
         */
        machineType: string;
        /**
         * Machine Outer net IP.
         */
        machineWanIp: string;
        /**
         * Payment model. POSTPAY: Pay as you go; PREPAY: Monthly subscription.
         */
        payMode: string;
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Protection Version. -BASIC_VERSION: Basic Version; -PRO_VERSION: Pro Version -Flagship: Flagship Version; -GENERAL_DISCOUNT: CWP-LH Version.
         */
        protectType: string;
        /**
         * Cloud server sole UUID.
         */
        quuid: string;
        /**
         * Region detail.
         */
        regionInfos: outputs.Cwp.GetMachinesSimpleMachineRegionInfo[];
        /**
         * Tag.
         */
        tags: outputs.Cwp.GetMachinesSimpleMachineTag[];
        /**
         * Cwp client sole UUID.
         */
        uuid: string;
    }

    export interface GetMachinesSimpleMachineCloudTag {
        /**
         * Tag key.
         */
        tagKey: string;
        /**
         * Tag value.
         */
        tagValue: string;
    }

    export interface GetMachinesSimpleMachineLicenseOrder {
        /**
         * License ID.
         */
        licenseId: number;
        /**
         * License Types.
         */
        licenseType: number;
        /**
         * Resource ID.
         */
        resourceId: string;
        /**
         * Order types.
         */
        sourceType: number;
        /**
         * License Order Status.
         */
        status: number;
    }

    export interface GetMachinesSimpleMachineRegionInfo {
        /**
         * Region, Such as ap-guangzhou, ap-shanghai, ap-beijing.
         */
        region: string;
        /**
         * Region Code.
         */
        regionCode: string;
        /**
         * Region ID.
         */
        regionId: number;
        /**
         * Regional Chinese name.
         */
        regionName: string;
        /**
         * Regional English name.
         */
        regionNameEn: string;
    }

    export interface GetMachinesSimpleMachineTag {
        /**
         * Only supported Keywords, Version and TagId.
         */
        name: string;
        /**
         * Relevance tag id.
         */
        rid: number;
        /**
         * Tag ID.
         */
        tagId: number;
    }

}

export namespace Cynosdb {
    export interface AccountPrivilegesDatabasePrivilege {
        /**
         * Database.
         */
        db: string;
        /**
         * Database privileges.
         */
        privileges: string[];
    }

    export interface AccountPrivilegesTablePrivilege {
        /**
         * Database name.
         */
        db: string;
        /**
         * Table privileges.
         */
        privileges: string[];
        /**
         * Table name.
         */
        tableName: string;
    }

    export interface AuditLogFileFilter {
        /**
         * Affects the number of rows. Indicates that the audit log whose number of affected rows is greater than this value is filtered.
         */
        affectRows?: number;
        /**
         * The name of database.
         */
        dbNames?: string[];
        /**
         * Execution time. The unit is: ms. Indicates to filter audit logs whose execution time is greater than this value.
         */
        execTime?: number;
        /**
         * Client host.
         */
        hosts?: string[];
        /**
         * The name of audit policy.
         */
        policyNames?: string[];
        /**
         * Return the number of rows.
         */
        sentRows?: number;
        /**
         * SQL statement. Support fuzzy matching.
         */
        sql?: string;
        /**
         * SQL type. currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
         */
        sqlType?: string;
        /**
         * SQL type. Supports simultaneous query of multiple types. currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
         */
        sqlTypes?: string[];
        /**
         * SQL statement. Support passing multiple sql statements.
         */
        sqls?: string[];
        /**
         * The name of table.
         */
        tableNames?: string[];
        /**
         * The ID of thread.
         */
        threadIds?: string[];
        /**
         * User name.
         */
        users?: string[];
    }

    export interface ClusterDatabasesUserHostPrivilege {
        /**
         * .
         */
        dbHost: string;
        /**
         * .
         */
        dbPrivilege: string;
        /**
         * Authorized Users.
         */
        dbUserName: string;
    }

    export interface ClusterParamItem {
        /**
         * Param expected value to set.
         */
        currentValue: string;
        /**
         * Name of param, e.g. `characterSetServer`.
         */
        name: string;
        /**
         * Param old value, indicates the value which already set, this value is required when modifying current_value.
         */
        oldValue?: string;
    }

    export interface ClusterRoGroupAddr {
        /**
         * IP address for read-write connection.
         */
        ip: string;
        /**
         * Port of CynosDB cluster.
         */
        port: number;
    }

    export interface ClusterRoGroupInstance {
        /**
         * ID of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
    }

    export interface ClusterRwGroupAddr {
        /**
         * IP address for read-write connection.
         */
        ip: string;
        /**
         * Port of CynosDB cluster.
         */
        port: number;
    }

    export interface ClusterRwGroupInstance {
        /**
         * ID of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
    }

    export interface ExportInstanceErrorLogsErrorLogItemExport {
        /**
         * log content.
         */
        content: string;
        /**
         * Log level, optional values note, warning, error.
         */
        level: string;
        /**
         * time.
         */
        timestamp: string;
    }

    export interface GetAccountAllGrantPrivilegesAccount {
        /**
         * Account.
         */
        accountName: string;
        /**
         * Host, default `%`.
         */
        host?: string;
    }

    export interface GetAccountAllGrantPrivilegesDatabasePrivilege {
        /**
         * Database name.
         */
        db: string;
        /**
         * Permission List.
         */
        privileges: string[];
    }

    export interface GetAccountAllGrantPrivilegesTablePrivilege {
        /**
         * Database name.
         */
        db: string;
        /**
         * Permission List.
         */
        privileges: string[];
        /**
         * Table Name.
         */
        tableName: string;
    }

    export interface GetAccountsAccountSet {
        /**
         * Account name of database.
         */
        accountName: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * The account description of database.
         */
        description: string;
        /**
         * Host.
         */
        host: string;
        /**
         * Maximum number of user connections.
         */
        maxUserConnections: number;
        /**
         * Update time.
         */
        updateTime: string;
    }

    export interface GetAuditLogsFilter {
        /**
         * Affects the number of rows. Indicates that filtering affects audit logs with rows greater than this value.
         */
        affectRows?: number;
        /**
         * Database name.
         */
        dbNames?: string[];
        /**
         * Execution time. Unit: ms. Indicates audit logs with a filter execution time greater than this value.
         */
        execTime?: number;
        /**
         * Client address.
         */
        hosts?: string[];
        /**
         * Audit policy name.
         */
        policyNames?: string[];
        /**
         * Returns the number of rows.
         */
        sentRows?: number;
        /**
         * SQL statement. Supports fuzzy matching.
         */
        sql?: string;
        /**
         * SQL type. Currently supported: SELECT, Insert, UPDATE, DELETE, CREATE, DROP, ALT, SET, REPLACE, EXECUTE.
         */
        sqlType?: string;
        /**
         * SQL type. Supports simultaneous querying of multiple types. Currently supported: SELECT, Insert, UPDATE, DELETE, CREATE, DROP, ALT, SET, REPLACE, EXECUTE.
         */
        sqlTypes?: string[];
        /**
         * SQL statement. Supports passing multiple SQL statements.
         */
        sqls?: string[];
        /**
         * Table name.
         */
        tableNames?: string[];
        /**
         * Thread ID.
         */
        threadIds?: string[];
        /**
         * User name.
         */
        users?: string[];
    }

    export interface GetAuditLogsItem {
        /**
         * Affects the number of rows. Indicates that filtering affects audit logs with rows greater than this value.
         */
        affectRows: number;
        /**
         * Database name.
         */
        dbName: string;
        /**
         * Error code.
         */
        errCode: number;
        /**
         * Execution time. Unit: ms. Indicates audit logs with a filter execution time greater than this value.
         */
        execTime: number;
        /**
         * Client address.
         */
        host: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Audit policy name.
         */
        policyName: string;
        /**
         * Returns the number of rows.
         */
        sentRows: number;
        /**
         * SQL statement. Supports fuzzy matching.
         */
        sql: string;
        /**
         * SQL type. Currently supported: SELECT, Insert, UPDATE, DELETE, CREATE, DROP, ALT, SET, REPLACE, EXECUTE.
         */
        sqlType: string;
        /**
         * Table name.
         */
        tableName: string;
        /**
         * Thread ID.
         */
        threadId: number;
        /**
         * Timestamp.
         */
        timestamp: string;
        /**
         * User name.
         */
        user: string;
    }

    export interface GetClusterDetailDatabasesDbInfo {
        /**
         * User appid note: This field may return null, indicating that a valid value cannot be obtained.
         */
        appId: number;
        /**
         * Character Set Type.
         */
        characterSet: string;
        /**
         * Cluster ID.
         */
        clusterId: string;
        /**
         * Capture Rules.
         */
        collateRule: string;
        /**
         * Creation time note: This field may return null, indicating that a valid value cannot be obtained.
         */
        createTime: string;
        /**
         * Database ID note: This field may return null, indicating that a valid value cannot be obtained.
         */
        dbId: number;
        /**
         * Database Name.
         */
        dbName: string;
        /**
         * Database note: This field may return null, indicating that a valid value cannot be obtained.
         */
        description: string;
        /**
         * Database Status.
         */
        status: string;
        /**
         * User Uin note: This field may return null, indicating that a valid value cannot be obtained.
         */
        uin: string;
        /**
         * Update time note: This field may return null, indicating that a valid value cannot be obtained.
         */
        updateTime: string;
        /**
         * User permission note: This field may return null, indicating that a valid value cannot be obtained.
         */
        userHostPrivileges: outputs.Cynosdb.GetClusterDetailDatabasesDbInfoUserHostPrivilege[];
    }

    export interface GetClusterDetailDatabasesDbInfoUserHostPrivilege {
        /**
         * Database host.
         */
        dbHost: string;
        /**
         * User permission note: This field may return null, indicating that a valid value cannot be obtained.
         */
        dbPrivilege: string;
        /**
         * DbUserName.
         */
        dbUserName: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoList {
        /**
         * User app id.
         */
        appId: number;
        /**
         * The ID of cluster.
         */
        clusterId: string;
        /**
         * Created time.
         */
        createdTime: string;
        /**
         * Deleted time.
         */
        deletedTime: string;
        /**
         * The ID of instance group.
         */
        instanceGrpId: string;
        /**
         * Instance groups contain instance information.
         */
        instanceSets: outputs.Cynosdb.GetClusterInstanceGroupsInstanceGrpInfoListInstanceSet[];
        /**
         * Status.
         */
        status: string;
        /**
         * Instance group type. ha-ha group; ro-read-only group.
         */
        type: string;
        /**
         * Updated time.
         */
        updatedTime: string;
        /**
         * Intranet IP.
         */
        vip: string;
        /**
         * Intranet port.
         */
        vport: number;
        /**
         * Public domain name.
         */
        wanDomain: string;
        /**
         * Public IP.
         */
        wanIp: string;
        /**
         * Public port.
         */
        wanPort: number;
        /**
         * Public status.
         */
        wanStatus: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoListInstanceSet {
        /**
         * User app id.
         */
        appId: number;
        /**
         * Business type.Note: This field may return null, indicating that no valid value can be obtained.
         */
        businessType: string;
        /**
         * The ID of cluster.
         */
        clusterId: string;
        /**
         * The name of cluster.
         */
        clusterName: string;
        /**
         * Cpu, unit: CORE.
         */
        cpu: number;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Cynos kernel version.
         */
        cynosVersion: string;
        /**
         * Database type.
         */
        dbType: string;
        /**
         * Database version.
         */
        dbVersion: string;
        /**
         * Destroy deadline.
         */
        destroyDeadlineText: string;
        /**
         * Instance destroy time.
         */
        destroyTime: string;
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * Instance role.
         */
        instanceRole: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Whether to freeze.Note: This field may return null, indicating that no valid value can be obtained.
         */
        isFreeze: string;
        /**
         * Isolate time.
         */
        isolateTime: string;
        /**
         * Serverless instance maxmum cpu.
         */
        maxCpu: number;
        /**
         * Memory, unit: GB.
         */
        memory: number;
        /**
         * Serverless instance minimum cpu.
         */
        minCpu: number;
        /**
         * Net type.
         */
        netType: number;
        /**
         * Pay mode.
         */
        payMode: number;
        /**
         * Instance expiration time.
         */
        periodEndTime: string;
        /**
         * Physical zone.
         */
        physicalZone: string;
        /**
         * Task being processed.
         */
        processingTask: string;
        /**
         * The id of project.
         */
        projectId: number;
        /**
         * Region.
         */
        region: string;
        /**
         * Renew flag.
         */
        renewFlag: number;
        /**
         * Resource tags.Note: This field may return null, indicating that no valid value can be obtained.
         */
        resourceTags: outputs.Cynosdb.GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetResourceTag[];
        /**
         * Serverless instance status, optional values:resumepause.
         */
        serverlessStatus: string;
        /**
         * Status.
         */
        status: string;
        /**
         * Instance state Chinese description.
         */
        statusDesc: string;
        /**
         * Storage, unit: GB.
         */
        storage: number;
        /**
         * Prepaid Storage Id.Note: This field may return null, indicating that no valid value can be obtained..
         */
        storageId: string;
        /**
         * Storage payment type.
         */
        storagePayMode: number;
        /**
         * Subnet ID.
         */
        subnetId: string;
        /**
         * Task list.Note: This field may return null, indicating that no valid value can be obtained.
         */
        tasks: outputs.Cynosdb.GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetTask[];
        /**
         * User Uin.
         */
        uin: string;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * Intranet IP.
         */
        vip: string;
        /**
         * VPC network ID.
         */
        vpcId: string;
        /**
         * Intranet port.
         */
        vport: number;
        /**
         * Public domain name.
         */
        wanDomain: string;
        /**
         * Public IP.
         */
        wanIp: string;
        /**
         * Public port.
         */
        wanPort: number;
        /**
         * Public status.
         */
        wanStatus: string;
        /**
         * Availability zone.
         */
        zone: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetResourceTag {
        /**
         * The key of tag.
         */
        tagKey: string;
        /**
         * The value of tag.
         */
        tagValue: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetTask {
        /**
         * Task ID (cluster ID|instance group ID|instance ID).Note: This field may return null, indicating that no valid value can be obtained.
         */
        objectId: string;
        /**
         * Object type.Note: This field may return null, indicating that no valid value can be obtained.
         */
        objectType: string;
        /**
         * Task auto-increment ID.Note: This field may return null, indicating that no valid value can be obtained.
         */
        taskId: number;
        /**
         * Task status.Note: This field may return null, indicating that no valid value can be obtained.
         */
        taskStatus: string;
        /**
         * Task type.Note: This field may return null, indicating that no valid value can be obtained.
         */
        taskType: string;
    }

    export interface GetClusterParamLogsClusterParamLog {
        /**
         * Cluster ID.
         */
        clusterId: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Current value.
         */
        currentValue: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Parameter Name.
         */
        paramName: string;
        /**
         * modify state.
         */
        status: string;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * Modified value.
         */
        updateValue: string;
    }

    export interface GetClusterParamsItem {
        /**
         * Current value.
         */
        currentValue: string;
        /**
         * Default value.
         */
        default: string;
        /**
         * The description of parameter.
         */
        description: string;
        /**
         * When the parameter is enum/string/bool, the optional value list.Note: This field may return null, indicating that no valid value can be obtained.
         */
        enumValues: string[];
        /**
         * Function.Note: This field may return null, indicating that no valid value can be obtained.
         */
        func: string;
        /**
         * Is it a function.Note: This field may return null, indicating that no valid value can be obtained.
         */
        isFunc: boolean;
        /**
         * Is it a global parameter.Note: This field may return null, indicating that no valid value can be obtained.
         */
        isGlobal: number;
        /**
         * Matching type, multiVal, regex is used when the parameter type is string.
         */
        matchType: string;
        /**
         * Match the target value, when multiVal, each key is divided by `;`.
         */
        matchValue: string;
        /**
         * The maximum value when the parameter type is float/integer.
         */
        max: string;
        /**
         * The minimum value when the parameter type is float/integer.
         */
        min: string;
        /**
         * Whether to reboot.
         */
        needReboot: number;
        /**
         * Parameter name.
         */
        paramName: string;
        /**
         * Parameter type: integer/float/string/enum/bool.
         */
        paramType: string;
    }

    export interface GetClusterTable {
        /**
         * Database name.
         */
        database: string;
        /**
         * Table Name List Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        tables: string[];
    }

    export interface GetClustersClusterList {
        /**
         * Auto renew flag. Valid values are `0`(MANUAL_RENEW), `1`(AUTO_RENEW). Only works for PREPAID cluster.
         */
        autoRenewFlag: number;
        /**
         * The available zone of the CynosDB Cluster.
         */
        availableZone: string;
        /**
         * The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. Default value is `POSTPAID_BY_HOUR`.
         */
        chargeType: string;
        /**
         * ID of the cluster to be queried.
         */
        clusterId: string;
        /**
         * Storage limit of CynosDB cluster instance, unit in GB.
         */
        clusterLimit: number;
        /**
         * Name of the cluster to be queried.
         */
        clusterName: string;
        /**
         * Status of the Cynosdb cluster.
         */
        clusterStatus: string;
        /**
         * Creation time of the CynosDB cluster.
         */
        createTime: string;
        /**
         * Type of CynosDB, and available values include `MYSQL`, `POSTGRESQL`.
         */
        dbType: string;
        /**
         * Version of CynosDB, which is related to `dbType`. For `MYSQL`, available value is `5.7`.
         */
        dbVersion: string;
        /**
         * Port of CynosDB cluster.
         */
        port: number;
        /**
         * ID of the project to be queried.
         */
        projectId: number;
        /**
         * ID of the subnet within this VPC.
         */
        subnetId: string;
        /**
         * ID of the VPC.
         */
        vpcId: string;
    }

    export interface GetDescribeInstanceErrorLogsErrorLog {
        /**
         * Note to log content: This field may return null, indicating that a valid value cannot be obtained.
         */
        content: string;
        /**
         * Log level note: This field may return null, indicating that a valid value cannot be obtained.
         */
        level: string;
        /**
         * Log timestamp note: This field may return null, indicating that a valid value cannot be obtained.
         */
        timestamp: number;
    }

    export interface GetDescribeInstanceSlowQueriesBinlog {
        /**
         * Binlog file ID.
         */
        binlogId: number;
        /**
         * Binlog file name.
         */
        fileName: string;
        /**
         * File size in bytes.
         */
        fileSize: number;
        /**
         * Latest transaction time.
         */
        finishTime: string;
        /**
         * start time.
         */
        startTime: string;
    }

    export interface GetInstanceSlowQueriesSlowQuery {
        /**
         * Database name.
         */
        database: string;
        /**
         * Lock duration in seconds.
         */
        lockTime: number;
        /**
         * Execution time in seconds.
         */
        queryTime: number;
        /**
         * Scan Rows.
         */
        rowsExamined: number;
        /**
         * Return the number of rows.
         */
        rowsSent: number;
        /**
         * SQL statement md5.
         */
        sqlMd5: string;
        /**
         * SQL template.
         */
        sqlTemplate: string;
        /**
         * SQL statement.
         */
        sqlText: string;
        /**
         * Execution timestamp.
         */
        timestamp: number;
        /**
         * Client host.
         */
        userHost: string;
        /**
         * user name.
         */
        userName: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * ID of the cluster.
         */
        clusterId?: string;
        /**
         * Creation time of the CynosDB instance.
         */
        createTime: string;
        /**
         * The number of CPU cores of the Cynosdb instance.
         */
        instanceCpuCore: number;
        /**
         * ID of the Cynosdb instance to be queried.
         */
        instanceId?: string;
        /**
         * Memory capacity of the Cynosdb instance, unit in GB.
         */
        instanceMemorySize: number;
        /**
         * Name of the Cynosdb instance to be queried.
         */
        instanceName: string;
        /**
         * Status of the Cynosdb instance.
         */
        instanceStatus: string;
        /**
         * Storage size of the Cynosdb instance, unit in GB.
         */
        instanceStorageSize: number;
        /**
         * Instance type. `ro` for readonly instance, `rw` for read and write instance.
         */
        instanceType: string;
    }

    export interface GetParamTemplatesItem {
        /**
         * Database mode, optional values: NORMAL, SERVERLESS.
         */
        dbMode: string;
        /**
         * Engine version.
         */
        engineVersion: string;
        /**
         * The ID of template.
         */
        id: number;
        /**
         * Parameter template details.Note: This field may return null, indicating that no valid value can be obtained.
         */
        paramInfoSets: outputs.Cynosdb.GetParamTemplatesItemParamInfoSet[];
        /**
         * The description of template.
         */
        templateDescription: string;
        /**
         * The name of template.
         */
        templateName: string;
    }

    export interface GetParamTemplatesItemParamInfoSet {
        /**
         * Current value.
         */
        currentValue: string;
        /**
         * Default value.
         */
        default: string;
        /**
         * The description of parameter.
         */
        description: string;
        /**
         * An optional set of value types when the parameter type is enum.Note: This field may return null, indicating that no valid value can be obtained.
         */
        enumValues: string[];
        /**
         * The maximum value when the parameter type is float/integer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        max: string;
        /**
         * The minimum value when the parameter type is float/integer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        min: string;
        /**
         * Whether to reboot.
         */
        needReboot: number;
        /**
         * The name of parameter.
         */
        paramName: string;
        /**
         * Parameter type: integer/float/string/enum.
         */
        paramType: string;
    }

    export interface GetProjectSecurityGroupsGroup {
        /**
         * Creation time, time format: yyyy mm dd hh: mm: ss.
         */
        createTime: string;
        /**
         * Inbound Rules.
         */
        inbounds: outputs.Cynosdb.GetProjectSecurityGroupsGroupInbound[];
        /**
         * Outbound rules.
         */
        outbounds: outputs.Cynosdb.GetProjectSecurityGroupsGroupOutbound[];
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Security Group ID.
         */
        securityGroupId: string;
        /**
         * Security Group Name.
         */
        securityGroupName: string;
        /**
         * Security Group Notes.
         */
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsGroupInbound {
        /**
         * Action.
         */
        action: string;
        /**
         * Address module.
         */
        addressModule: string;
        /**
         * Cidr Ip.
         */
        cidrIp: string;
        /**
         * Description.
         */
        desc: string;
        /**
         * id.
         */
        id: string;
        /**
         * Ip protocol.
         */
        ipProtocol: string;
        /**
         * Port range.
         */
        portRange: string;
        /**
         * Service module.
         */
        serviceModule: string;
    }

    export interface GetProjectSecurityGroupsGroupOutbound {
        /**
         * Action.
         */
        action: string;
        /**
         * Address module.
         */
        addressModule: string;
        /**
         * Cidr Ip.
         */
        cidrIp: string;
        /**
         * Description.
         */
        desc: string;
        /**
         * id.
         */
        id: string;
        /**
         * Ip protocol.
         */
        ipProtocol: string;
        /**
         * Port range.
         */
        portRange: string;
        /**
         * Service module.
         */
        serviceModule: string;
    }

    export interface GetProxyNodeFilter {
        /**
         * Exact match or not.
         */
        exactMatch?: boolean;
        /**
         * Search Fields. Supported: Status, ProxyNodeId, ClusterId.
         */
        name?: string;
        /**
         * Search String.
         */
        names: string[];
        /**
         * Operator.
         */
        operator?: string;
        /**
         * Search String.
         */
        values: string[];
    }

    export interface GetProxyNodeProxyNodeInfo {
        /**
         * User AppID.
         */
        appId: number;
        /**
         * Cluster ID.
         */
        clusterId: string;
        /**
         * Database Agent Node CPU.
         */
        cpu: number;
        /**
         * Database Agent Node Memory.
         */
        mem: number;
        /**
         * Database Agent Group ID.
         */
        proxyGroupId: string;
        /**
         * The current number of connections of the node. The DescribeProxyNodes interface does not return a value for this field.
         */
        proxyNodeConnections: number;
        /**
         * Database Agent Node ID.
         */
        proxyNodeId: string;
        /**
         * region.
         */
        region: string;
        /**
         * Database Agent Node Status.
         */
        status: string;
        /**
         * Availability Zone.
         */
        zone: string;
    }

    export interface GetResourcePackageListResourcePackageList {
        /**
         * AppID note: This field may return null, indicating that a valid value cannot be obtained.
         */
        appId: number;
        /**
         * Note for binding instance information: This field may return null, indicating that a valid value cannot be obtained.
         */
        bindInstanceInfos: outputs.Cynosdb.GetResourcePackageListResourcePackageListBindInstanceInfo[];
        /**
         * Expiration time: August 1st, 2022 00:00:00 Attention: This field may return null, indicating that a valid value cannot be obtained.
         */
        expireTime: string;
        /**
         * Resource package usage note: This field may return null, indicating that a valid value cannot be obtained.
         */
        hasQuota: boolean;
        /**
         * Resource Package Unique ID.
         */
        packageId: string;
        /**
         * Resource Package Name.
         */
        packageName: string;
        /**
         * Resource package usage region China - common in mainland China, overseas - common in Hong Kong, Macao, Taiwan, and overseas.
         */
        packageRegion: string;
        /**
         * Attention to the total amount of resource packages: This field may return null, indicating that a valid value cannot be obtained.
         */
        packageTotalSpec: number;
        /**
         * Resource package type CCU - Compute resource package, DISK - Storage resource package.
         */
        packageType: string;
        /**
         * Resource package usage note: This field may return null, indicating that a valid value cannot be obtained.
         */
        packageUsedSpec: number;
        /**
         * Effective time: July 1st, 2022 00:00:00 Attention: This field may return null, indicating that a valid value cannot be obtained.
         */
        startTime: string;
        /**
         * Resource package status creating - creating; Using - In use; Expired - has expired; Normal_ Finish - used up; Apply_ Refund - Applying for a refund; Refund - The fee has been refunded.
         */
        status: string;
    }

    export interface GetResourcePackageListResourcePackageListBindInstanceInfo {
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Region of instance.
         */
        instanceRegion: string;
        /**
         * Instance type.
         */
        instanceType: string;
    }

    export interface GetResourcePackageSaleSpecsDetail {
        /**
         * Resource package validity period, in days. Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        expireDay: number;
        /**
         * The maximum number of resources in the current version of the resource package, calculated in units of resources; Storage resource: GB Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        maxPackageSpec: number;
        /**
         * The minimum number of resources in the current version of the resource package, calculated in units of resources; Storage resource: GB Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        minPackageSpec: number;
        /**
         * Resource package usage region China - common in mainland China, overseas - common in Hong Kong, Macao, Taiwan, and overseas.
         */
        packageRegion: string;
        /**
         * Resource package type CCU - Computing resource package DISK - Storage resource package.
         */
        packageType: string;
        /**
         * Resource package version base basic version, common general version, enterprise enterprise version Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        packageVersion: string;
    }

    export interface GetRollbackTimeRangeRollbackTimeRange {
        /**
         * Effective regression time range end time point (obsolete) Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        timeRangeEnd: string;
        /**
         * Effective regression time range start time point (obsolete) Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        timeRangeStart: string;
    }

    export interface GetZoneConfigList {
        /**
         * Instance CPU, unit: core.
         */
        cpu: number;
        /**
         * Machine type.
         */
        machineType: string;
        /**
         * Max io bandwidth.
         */
        maxIoBandwidth: number;
        /**
         * The maximum available storage for the instance, unit GB.
         */
        maxStorageSize: number;
        /**
         * Instance memory, unit: GB.
         */
        memory: number;
        /**
         * Minimum available storage of the instance, unit: GB.
         */
        minStorageSize: number;
        /**
         * Regional inventory information.
         */
        zoneStockInfos: outputs.Cynosdb.GetZoneConfigListZoneStockInfo[];
    }

    export interface GetZoneConfigListZoneStockInfo {
        /**
         * Has stock.
         */
        hasStock: boolean;
        /**
         * Availability zone.
         */
        zone: string;
    }

    export interface GetZoneRegionSet {
        /**
         * Database type.
         */
        dbType: string;
        /**
         * Regional module support.
         */
        modules: outputs.Cynosdb.GetZoneRegionSetModule[];
        /**
         * Region in English.
         */
        region: string;
        /**
         * Region ID.
         */
        regionId: number;
        /**
         * Region name in Chinese.
         */
        regionZh: string;
        /**
         * List of available zones for sale.
         */
        zoneSets: outputs.Cynosdb.GetZoneRegionSetZoneSet[];
    }

    export interface GetZoneRegionSetModule {
        /**
         * Is zone on sale, optional values: yes, no.
         */
        isDisable: string;
        /**
         * Module name.
         */
        moduleName: string;
    }

    export interface GetZoneRegionSetZoneSet {
        /**
         * Whether the user have zone permissionsNote: This field may return null, indicating that no valid value can be obtained.
         */
        hasPermission: boolean;
        /**
         * Does it support normal clusters, 0:Not supported 1:Support.
         */
        isSupportNormal: number;
        /**
         * Does it support serverless clusters, 0:Not supported 1:Support.
         */
        isSupportServerless: number;
        /**
         * Is zone Rdma.
         */
        isWholeRdmaZone: string;
        /**
         * Physical zone.
         */
        physicalZone: string;
        /**
         * Zone name in English.
         */
        zone: string;
        /**
         * ZoneId.
         */
        zoneId: number;
        /**
         * Zone name in Chinesee.
         */
        zoneZh: string;
    }

    export interface InstanceParamInstanceParamList {
        /**
         * Current value of parameter.
         */
        currentValue: string;
        /**
         * Parameter Name.
         */
        paramName: string;
    }

    export interface ParamTemplateParamList {
        /**
         * Current value.
         */
        currentValue: string;
        /**
         * Parameter Name.
         */
        paramName: string;
    }

    export interface ProxyEndPointInstanceWeight {
        /**
         * Instance Id.
         */
        instanceId: string;
        /**
         * Instance Weight.
         */
        weight: number;
    }

    export interface ProxyProxyZone {
        /**
         * Number of proxy nodes.
         */
        proxyNodeCount?: number;
        /**
         * Proxy node availability zone.
         */
        proxyNodeZone?: string;
    }

    export interface ProxyRoInstance {
        /**
         * instance id.
         */
        instanceId?: string;
        /**
         * weight.
         */
        weight?: number;
    }

    export interface RollBackClusterRollbackDatabase {
        /**
         * New database name.
         */
        newDatabase: string;
        /**
         * Old database name.
         */
        oldDatabase: string;
    }

    export interface RollBackClusterRollbackTable {
        /**
         * New database name.
         */
        database: string;
        /**
         * Tables.
         */
        tables: outputs.Cynosdb.RollBackClusterRollbackTableTable[];
    }

    export interface RollBackClusterRollbackTableTable {
        /**
         * New table name.
         */
        newTable: string;
        /**
         * Old table name.
         */
        oldTable: string;
    }

}

export namespace Dayu {
    export interface CcHttpPolicyRuleList {
        /**
         * Operator of the rule. Valid values: `include`, `notInclude`, `equal`.
         */
        operator?: string;
        /**
         * Key of the rule. Valid values: `host`, `cgi`, `ua`, `referer`.
         */
        skey?: string;
        /**
         * Rule value, then length should be less than 31 bytes.
         */
        value?: string;
    }

    export interface CcHttpsPolicyRuleList {
        /**
         * Operator of the rule. Valid values are `include` and `equal`.
         */
        operator: string;
        /**
         * Key of the rule. Valid values are `cgi`, `ua` and `referer`.
         */
        skey: string;
        /**
         * Rule value, then length should be less than 31 bytes.
         */
        value: string;
    }

    export interface CcPolicyV2CcBlackWhiteIp {
        /**
         * Blacklist and whitelist IP addresses.
         */
        blackWhiteIp: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Domain.
         */
        domain: string;
        /**
         * Modify time.
         */
        modifyTime: string;
        /**
         * Protocol.
         */
        protocol: string;
        /**
         * IP type, value [black(blacklist IP), white (whitelist IP)].
         */
        type: string;
    }

    export interface CcPolicyV2CcGeoIpPolicy {
        /**
         * User action, drop or arg.
         */
        action: string;
        /**
         * The list of region IDs that the user selects to block.
         */
        areaLists: number[];
        /**
         * Create time.
         */
        createTime: string;
        /**
         * domain.
         */
        domain: string;
        /**
         * Modify time.
         */
        modifyTime: string;
        /**
         * Protocol, preferably HTTP, HTTPS.
         */
        protocol: string;
        /**
         * Regional types, divided into china, oversea and customized.
         */
        regionType: string;
    }

    export interface CcPolicyV2CcPrecisionPolicy {
        /**
         * Domain.
         */
        domain: string;
        /**
         * Ip address.
         */
        ip: string;
        /**
         * Policy mode (discard or captcha).
         */
        policyAction: string;
        /**
         * Policy Id.
         */
        policyId: string;
        /**
         * A list of policies.
         */
        policys: outputs.Dayu.CcPolicyV2CcPrecisionPolicyPolicy[];
        /**
         * Protocol.
         */
        protocol: string;
    }

    export interface CcPolicyV2CcPrecisionPolicyPolicy {
        /**
         * Configuration item types, currently only support value.
         */
        fieldName: string;
        /**
         * Configuration fields with the desirable values cgi, ua, cookie, referer, accept, srcip.
         */
        fieldType: string;
        /**
         * Configure the value.
         */
        value: string;
        /**
         * Configure the item-value comparison mode, which can be taken as the value of evaluate, not_equal, include.
         */
        valueOperator: string;
    }

    export interface CcPolicyV2CcPrecisionReqLimit {
        /**
         * Domain.
         */
        domain: string;
        /**
         * Instance id.
         */
        instanceId: string;
        /**
         * Ip address.
         */
        ip: string;
        /**
         * Protection rating, the optional value of default means default policy, loose means loose, and strict means strict.
         */
        level: string;
        /**
         * The CC Frequency Limit Policy Item field.
         */
        policys: outputs.Dayu.CcPolicyV2CcPrecisionReqLimitPolicy[];
        /**
         * Protocol, preferably HTTP, HTTPS.
         */
        protocol: string;
    }

    export interface CcPolicyV2CcPrecisionReqLimitPolicy {
        /**
         * The frequency limit policy mode, the optional value of arg indicates the verification code, and drop indicates the discard.
         */
        action: string;
        /**
         * Cookies, one of the three policy entries can only be filled in.
         */
        cookie?: string;
        /**
         * The duration of the frequency limit policy can be taken from 1 to 86400 per second.
         */
        executeDuration: number;
        /**
         * The policy item is compared, and the optional value include indicates inclusion, and equal means equal.
         */
        mode: string;
        /**
         * Statistical period, take values 1, 10, 30, 60, in seconds.
         */
        period: number;
        /**
         * The number of requests, the value is 1 to 20000.
         */
        requestNum: number;
        /**
         * Uri, one of the three policy entries can only be filled in.
         */
        uri?: string;
        /**
         * User-Agent, only one of the three policy entries can be filled in.
         */
        userAgent?: string;
    }

    export interface CcPolicyV2Threshold {
        /**
         * domain.
         */
        domain: string;
        /**
         * Cleaning threshold, -1 indicates that the `default` mode is turned on.
         */
        threshold: number;
    }

    export interface DdosIpAttachmentV2BoundIpList {
        /**
         * Category of product that can be bound. Valid values: public (CVM and CLB), bm (BM), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), and other (hosted IP). This field is required when you perform binding.
         */
        bizType?: string;
        /**
         * Sub-product category. Valid values: cvm (CVM), lb (Load balancer), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), eip (BM EIP) and other (managed IP). This field is required when you perform binding.
         */
        deviceType?: string;
        /**
         * Anti-DDoS instance ID of the IP. This field is required only when the instance is bound to an IP. For example, this field InstanceId will be eni-* if the instance ID is bound to an ENI IP; none if there is no instance to bind to a managed IP.
         */
        instanceId?: string;
        /**
         * IP address.
         */
        ip: string;
    }

    export interface DdosPolicyDropOption {
        /**
         * The number of new connections based on destination IP that trigger suppression of connections. Valid value ranges: (0~4294967295).
         */
        badConnThreshold: number;
        /**
         * Indicate whether to check null connection or not.
         */
        checkSyncConn: boolean;
        /**
         * Connection timeout of abnormal connection check. Valid value ranges: (0~65535).
         */
        connTimeout: number;
        /**
         * The limit of concurrent connections based on destination IP. Valid value ranges: (0~4294967295).
         */
        dConnLimit: number;
        /**
         * The limit of new connections based on destination IP. Valid value ranges: (0~4294967295).
         */
        dNewLimit: number;
        /**
         * Indicate whether to drop abroad traffic or not.
         */
        dropAbroad: boolean;
        /**
         * Indicate whether to drop ICMP protocol or not.
         */
        dropIcmp: boolean;
        /**
         * Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
         */
        dropOther: boolean;
        /**
         * Indicate whether to drop TCP protocol or not.
         */
        dropTcp: boolean;
        /**
         * Indicate to drop UDP protocol or not.
         */
        dropUdp: boolean;
        /**
         * The limit of ICMP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
         */
        icmpMbpsLimit: number;
        /**
         * Indicate to enable null connection or not.
         */
        nullConnEnable: boolean;
        /**
         * The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate. Valid value ranges: (0~4294967295)(Mbps).
         */
        otherMbpsLimit: number;
        /**
         * The limit of concurrent connections based on source IP. Valid value ranges: (0~4294967295).
         */
        sConnLimit: number;
        /**
         * The limit of new connections based on source IP. Valid value ranges: (0~4294967295).
         */
        sNewLimit: number;
        /**
         * The limit of syn of abnormal connection check. Valid value ranges: (0~100).
         */
        synLimit: number;
        /**
         * The percentage of syn in ack of abnormal connection check. Valid value ranges: (0~100).
         */
        synRate?: number;
        /**
         * The limit of TCP traffic. Valid value ranges: (0~4294967295)(Mbps).
         */
        tcpMbpsLimit: number;
        /**
         * The limit of UDP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
         */
        udpMbpsLimit: number;
    }

    export interface DdosPolicyPacketFilter {
        /**
         * Action of port to take. Valid values: `drop`, `dropBlack`,`dropRst`,`dropBlackRst`,`transmit`.`drop`(drop the packet), `dropBlack`(drop the packet and black the ip),`dropRst`(drop the packet and disconnect),`dropBlackRst`(drop the packet, black the ip and disconnect),`transmit`(transmit the packet).
         */
        action?: string;
        /**
         * End port of the destination. Valid value ranges: (0~65535). It must be greater than `dStartPort`.
         */
        dEndPort?: number;
        /**
         * Start port of the destination. Valid value ranges: (0~65535).
         */
        dStartPort?: number;
        /**
         * The depth of match. Valid value ranges: (0~1500).
         */
        depth?: number;
        /**
         * Indicate whether to include the key word/regular expression or not.
         */
        isInclude?: boolean;
        /**
         * Indicate whether to check load or not, `beginL5` means to match and `noMatch` means not.
         */
        matchBegin?: string;
        /**
         * The key word or regular expression.
         */
        matchStr?: string;
        /**
         * Match type. Valid values: `sunday` and `pcre`. `sunday` means key word match while `pcre` means regular match.
         */
        matchType?: string;
        /**
         * The offset of match. Valid value ranges: (0~1500).
         */
        offset?: number;
        /**
         * The max length of the packet. Valid value ranges: (0~1500)(Mbps). It must be greater than `pktLengthMin`.
         */
        pktLengthMax?: number;
        /**
         * The minimum length of the packet. Valid value ranges: (0~1500)(Mbps).
         */
        pktLengthMin?: number;
        /**
         * Protocol. Valid values: `tcp`, `udp`, `icmp`, `all`.
         */
        protocol?: string;
        /**
         * End port of the source. Valid value ranges: (0~65535). It must be greater than `sStartPort`.
         */
        sEndPort?: number;
        /**
         * Start port of the source. Valid value ranges: (0~65535).
         */
        sStartPort?: number;
    }

    export interface DdosPolicyPortFilter {
        /**
         * Action of port to take. Valid values: `drop`, `transmit`.
         */
        action?: string;
        /**
         * End port. Valid value ranges: (0~65535). It must be greater than `startPort`.
         */
        endPort?: number;
        /**
         * The type of forbidden port. Valid values: `0`, `1`, `2`. `0` for destination ports make effect, `1` for source ports make effect. `2` for both destination and source ports.
         */
        kind?: number;
        /**
         * Protocol. Valid values are `tcp`, `udp`, `icmp`, `all`.
         */
        protocol?: string;
        /**
         * Start port. Valid value ranges: (0~65535).
         */
        startPort?: number;
    }

    export interface DdosPolicyV2Acl {
        /**
         * Action, optional values: drop, transmit, forward.
         */
        action: string;
        /**
         * The destination port ends, and the value range is 0~65535.
         */
        dPortEnd: number;
        /**
         * The destination port starts, and the value range is 0~65535.
         */
        dPortStart: number;
        /**
         * Protocol type, desirable values tcp, udp, all.
         */
        forwardProtocol: string;
        /**
         * Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        priority: number;
        /**
         * The source port ends, and the acceptable value ranges from 0 to 65535.
         */
        sPortEnd: number;
        /**
         * The source port starts, and the value range is 0~65535.
         */
        sPortStart: number;
    }

    export interface DdosPolicyV2BlackWhiteIp {
        /**
         * Ip of resource instance.
         */
        ip: string;
        /**
         * IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
         */
        ipType: string;
    }

    export interface DdosPolicyV2DdosConnectLimit {
        /**
         * Based on connection suppression trigger threshold, value range [0,4294967295].
         */
        badConnThreshold: number;
        /**
         * Abnormal connection detection condition, connection timeout, value range [0,65535].
         */
        connTimeout: number;
        /**
         * Concurrent connection control based on destination IP+ destination port.
         */
        dstConnLimit: number;
        /**
         * Limit on the number of news per second based on the destination IP.
         */
        dstNewLimit: number;
        /**
         * Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
         */
        nullConnEnable: number;
        /**
         * Concurrent connection control based on source IP + destination IP.
         */
        sdConnLimit: number;
        /**
         * The limit on the number of news per second based on source IP + destination IP.
         */
        sdNewLimit: number;
        /**
         * Anomaly connection detection condition, syn threshold, value range [0,100].
         */
        synLimit: number;
        /**
         * Anomalous connection detection condition, percentage of syn ack, value range [0,100].
         */
        synRate: number;
    }

    export interface DdosPolicyV2DdosGeoIpBlockConfig {
        /**
         * Block action, take the value [`drop`, `trans`].
         */
        action: string;
        /**
         * When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
         */
        areaLists: number[];
        /**
         * Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
         */
        regionType: string;
    }

    export interface DdosPolicyV2DdosSpeedLimitConfig {
        /**
         * Bandwidth bps.
         */
        bandwidth: number;
        /**
         * List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
         */
        dstPortList: string;
        /**
         * Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
         */
        mode: number;
        /**
         * Packet rate pps.
         */
        packetRate: number;
        /**
         * IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
         */
        protocolList: string;
    }

    export interface DdosPolicyV2PacketFilter {
        /**
         * Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
         */
        action: string;
        /**
         * The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
         */
        dPortEnd: number;
        /**
         * From the destination port, take the value 0~65535.
         */
        dPortStart: number;
        /**
         * Detection depth from the detection position, value [0,1500].
         */
        depth: number;
        /**
         * Second detection depth starting from the second detection position, value [0,1500].
         */
        depth2: number;
        /**
         * Whether to include the detected value, take the value [0 (included),1 (not included)].
         */
        isNot: number;
        /**
         * Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
         */
        isNot2: number;
        /**
         * Detect position, take the value [beginL3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), noMatch (mismatch)].
         */
        matchBegin: string;
        /**
         * The second detection position. take the value [beginL3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), noMatch (mismatch)].
         */
        matchBegin2: string;
        /**
         * When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
         */
        matchLogic: string;
        /**
         * Detection type, value [sunday (keyword),pcre (regular expression)].
         */
        matchType: string;
        /**
         * The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
         */
        matchType2: string;
        /**
         * Offset from detection position, value range [0, Depth].
         */
        offset: number;
        /**
         * Offset from the second detection position, value range [0,Depth2].
         */
        offset2: number;
        /**
         * The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
         */
        pktlenMax: number;
        /**
         * Minimum message length, 1-1500.
         */
        pktlenMin: number;
        /**
         * Protocol, value [tcp udp icmp all].
         */
        protocol: string;
        /**
         * End source port, take the value 1~65535, must be greater than or equal to the starting source port.
         */
        sPortEnd: number;
        /**
         * Start the source port, take the value 0~65535.
         */
        sPortStart: number;
        /**
         * Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
         */
        str: string;
        /**
         * The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
         */
        str2: string;
    }

    export interface DdosPolicyV2ProtocolBlockConfig {
        /**
         * ICMP block, value [0 (block off), 1 (block on)].
         */
        dropIcmp: number;
        /**
         * Other block, value [0 (block off), 1 (block on)].
         */
        dropOther: number;
        /**
         * TCP block, value [0 (block off), 1 (block on)].
         */
        dropTcp: number;
        /**
         * UDP block, value [0 (block off), 1 (block on)].
         */
        dropUdp: number;
    }

    export interface DdosPolicyV2WaterPrintConfig {
        /**
         * List of forwarding listeners to which the watermark belongs.
         */
        listeners: outputs.Dayu.DdosPolicyV2WaterPrintConfigListener[];
        /**
         * Watermark offset, value range: [0-100].
         */
        offset: number;
        /**
         * Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
         */
        openStatus: number;
        /**
         * Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
         */
        verify: string;
    }

    export interface DdosPolicyV2WaterPrintConfigListener {
        /**
         * Forwarding protocol, value [TCP, UDP].
         */
        forwardProtocol: string;
        /**
         * Lower limit of forwarding listening port. Values: [1-65535].
         */
        frontendPort: number;
        /**
         * Upper limit of forwarding listening port. Values: [1-65535].
         */
        frontendPortEnd: number;
    }

    export interface DdosPolicyWatermarkFilter {
        /**
         * Indicate whether to auto-remove the watermark or not.
         */
        autoRemove?: boolean;
        /**
         * The offset of watermark. Valid value ranges: (0~1500).
         */
        offset?: number;
        /**
         * Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
         */
        openSwitch?: boolean;
        /**
         * Port range of TCP, the format is like `2000-3000`.
         */
        tcpPortLists?: string[];
        /**
         * Port range of TCP, the format is like `2000-3000`.
         */
        udpPortLists?: string[];
    }

    export interface DdosPolicyWatermarkKey {
        /**
         * Content of the watermark.
         */
        content: string;
        /**
         * Create time of the DDoS policy.
         */
        createTime?: string;
        /**
         * Id of the watermark.
         */
        id: string;
        /**
         * Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
         */
        openSwitch: boolean;
    }

    export interface GetCcHttpPoliciesList {
        /**
         * Action mode.
         */
        action: string;
        /**
         * Create time of the CC self-define http policy.
         */
        createTime: string;
        /**
         * Max frequency per minute.
         */
        frequency: number;
        /**
         * IP of the CC self-define http policy.
         */
        ipLists: string[];
        /**
         * Name of the CC http policy to be queried.
         */
        name: string;
        /**
         * Id of the CC http policy to be queried.
         */
        policyId: string;
        /**
         * ID of the resource that the CC http policy works for.
         */
        resourceId: string;
        /**
         * Type of the resource that the CC http policy works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
         */
        resourceType: string;
        /**
         * Rule list of the CC self-define http policy.
         */
        ruleLists: outputs.Dayu.GetCcHttpPoliciesListRuleList[];
        /**
         * Match mode.
         */
        smode: string;
        /**
         * Indicate the CC self-define http policy takes effect or not.
         */
        switch: boolean;
    }

    export interface GetCcHttpPoliciesListRuleList {
        /**
         * Operator of the rule.
         */
        operator: string;
        /**
         * Key of the rule.
         */
        skey: string;
        /**
         * Rule value.
         */
        value: string;
    }

    export interface GetCcHttpsPoliciesList {
        /**
         * Action mode.
         */
        action: string;
        /**
         * Create time of the CC self-define https policy.
         */
        createTime: string;
        /**
         * Domain that the CC self-define https policy works for.
         */
        domain: string;
        /**
         * Ip of the CC self-define https policy.
         */
        ipLists: string[];
        /**
         * Name of the CC https policy to be queried.
         */
        name: string;
        /**
         * Id of the CC https policy to be queried.
         */
        policyId: string;
        /**
         * Id of the resource that the CC https policy works for.
         */
        resourceId: string;
        /**
         * Type of the resource that the CC https policy works for, valid value is `bgpip`.
         */
        resourceType: string;
        /**
         * Rule id of the domain that the CC self-define https policy works for.
         */
        ruleId: string;
        /**
         * Rule list of the CC self-define https policy.
         */
        ruleLists: outputs.Dayu.GetCcHttpsPoliciesListRuleList[];
        /**
         * Indicate the CC self-define https policy takes effect or not.
         */
        switch: boolean;
    }

    export interface GetCcHttpsPoliciesListRuleList {
        /**
         * Operator of the rule.
         */
        operator: string;
        /**
         * Key of the rule.
         */
        skey: string;
        /**
         * Rule value.
         */
        value: string;
    }

    export interface GetDdosPoliciesList {
        /**
         * Black ip list.
         */
        blackIps?: string[];
        /**
         * Create time of the DDoS policy.
         */
        createTime: string;
        /**
         * Option list of abnormal check of the DDoS policy.
         */
        dropOptions: outputs.Dayu.GetDdosPoliciesListDropOption[];
        /**
         * Name of the DDoS policy.
         */
        name: string;
        /**
         * Message filter options list.
         */
        packetFilters: outputs.Dayu.GetDdosPoliciesListPacketFilter[];
        /**
         * ID of the DDoS policy to be query.
         */
        policyId: string;
        /**
         * Port limits of abnormal check of the DDoS policy.
         */
        portFilters: outputs.Dayu.GetDdosPoliciesListPortFilter[];
        /**
         * Id of policy case that the DDoS policy works for.
         */
        sceneId: string;
        /**
         * Watermark policy options, and only support one watermark policy at most.
         */
        watermarkFilters: outputs.Dayu.GetDdosPoliciesListWatermarkFilter[];
        /**
         * Watermark content.
         */
        watermarkKeys: outputs.Dayu.GetDdosPoliciesListWatermarkKey[];
        /**
         * White ip list.
         */
        whiteIps?: string[];
    }

    export interface GetDdosPoliciesListDropOption {
        /**
         * The number of new connections based on destination IP that trigger suppression of connections.
         */
        badConnThreshold: number;
        /**
         * Indicate whether to check null connection or not.
         */
        checkSyncConn: boolean;
        /**
         * Connection timeout of abnormal connection check.
         */
        connTimeout: number;
        /**
         * The limit of concurrent connections based on destination IP.
         */
        dConnLimit: number;
        /**
         * The limit of new connections based on destination IP.
         */
        dNewLimit: number;
        /**
         * Indicate whether to drop abroad traffic or not.
         */
        dropAbroad: boolean;
        /**
         * Indicate whether to drop ICMP protocol or not.
         */
        dropIcmp: boolean;
        /**
         * Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
         */
        dropOther: boolean;
        /**
         * Indicate whether to drop TCP protocol or not.
         */
        dropTcp: boolean;
        /**
         * Indicate to drop UDP protocol or not.
         */
        dropUdp: boolean;
        /**
         * The limit of ICMP traffic rate.
         */
        icmpMbpsLimit: number;
        /**
         * Indicate to enable null connection or not.
         */
        nullConnEnable: boolean;
        /**
         * The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate.
         */
        otherMbpsLimit: number;
        /**
         * The limit of concurrent connections based on source IP.
         */
        sConnLimit: number;
        /**
         * The limit of new connections based on source IP.
         */
        sNewLimit: number;
        /**
         * The limit of syn of abnormal connection check.
         */
        synLimit: number;
        /**
         * The percentage of syn in ack of abnormal connection check.
         */
        synRate: number;
        /**
         * The limit of TCP traffic.
         */
        tcpMbpsLimit: number;
        /**
         * The limit of UDP traffic rate.
         */
        udpMbpsLimit: number;
    }

    export interface GetDdosPoliciesListPacketFilter {
        /**
         * Action of port to take.
         */
        action: string;
        /**
         * End port of the destination.
         */
        dEndPort: number;
        /**
         * Start port of the destination.
         */
        dStartPort: number;
        /**
         * The depth of match.
         */
        depth: number;
        /**
         * Indicate whether to include the key word/regular expression or not.
         */
        isInclude: boolean;
        /**
         * Indicate whether to check load or not.
         */
        matchBegin: string;
        /**
         * The key word or regular expression.
         */
        matchStr: string;
        /**
         * Match type.
         */
        matchType: string;
        /**
         * The offset of watermark.
         */
        offset: number;
        /**
         * The max length of the packet.
         */
        pktLengthMax: number;
        /**
         * The minimum length of the packet.
         */
        pktLengthMin: number;
        /**
         * Protocol.
         */
        protocol: string;
        /**
         * End port of the source.
         */
        sEndPort: number;
        /**
         * Start port of the source.
         */
        sStartPort: number;
    }

    export interface GetDdosPoliciesListPortFilter {
        /**
         * Action of port to take.
         */
        action: string;
        /**
         * End port.
         */
        endPort: number;
        /**
         * The type of forbidden port, and valid values are 0, 1, 2. 0 for destination port, 1 for source port and 2 for both destination and source posts.
         */
        kind: number;
        /**
         * Protocol.
         */
        protocol: string;
        /**
         * Start port.
         */
        startPort: number;
    }

    export interface GetDdosPoliciesListWatermarkFilter {
        /**
         * Indicate whether to auto-remove the watermark or not.
         */
        autoRemove: boolean;
        /**
         * The offset of watermark.
         */
        offset: number;
        /**
         * Indicate whether to auto-remove the watermark or not.
         */
        openSwitch: boolean;
        /**
         * Port range of TCP.
         */
        tcpPortLists: string[];
        /**
         * Port range of TCP.
         */
        udpPortLists: string[];
    }

    export interface GetDdosPoliciesListWatermarkKey {
        /**
         * Content of the watermark.
         */
        content: string;
        /**
         * Create time of the DDoS policy.
         */
        createTime?: string;
        /**
         * Id of the watermark.
         */
        id: string;
        /**
         * Indicate whether to auto-remove the watermark or not.
         */
        openSwitch: boolean;
    }

    export interface GetDdosPolicyAttachmentsDayuDdosPolicyAttachmentList {
        /**
         * Id of the policy to be queried.
         */
        policyId: string;
        /**
         * ID of the attached resource to be queried.
         */
        resourceId: string;
        /**
         * Type of the resource that the DDoS policy works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
         */
        resourceType: string;
    }

    export interface GetDdosPolicyCasesList {
        /**
         * App protocol set of the DDoS policy case.
         */
        appProtocols: string[];
        /**
         * App type of the DDoS policy case.
         */
        appType: string;
        /**
         * Create time of the DDoS policy case.
         */
        createTime: string;
        /**
         * Indicate whether the service involves overseas or not.
         */
        hasAbroad: string;
        /**
         * Indicate whether the service actively initiates TCP requests or not.
         */
        hasInitiateTcp: string;
        /**
         * Indicate whether the actively initiate UDP requests or not.
         */
        hasInitiateUdp: string;
        /**
         * Indicate whether the service involves VPN service or not.
         */
        hasVpn: string;
        /**
         * The max length of TCP message package.
         */
        maxTcpPackageLen: string;
        /**
         * The max length of UDP message package.
         */
        maxUdpPackageLen: string;
        /**
         * The minimum length of TCP message package.
         */
        minTcpPackageLen: string;
        /**
         * The minimum length of UDP message package.
         */
        minUdpPackageLen: string;
        /**
         * Name of the DDoS policy case.
         */
        name: string;
        /**
         * The port that actively initiates TCP requests.
         */
        peerTcpPort: string;
        /**
         * The port that actively initiates UDP requests.
         */
        peerUdpPort: string;
        /**
         * Platform set of the DDoS policy case.
         */
        platformTypes: string[];
        /**
         * Type of the resource that the DDoS policy case works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
         */
        resourceType: string;
        /**
         * ID of the DDoS policy case to be query.
         */
        sceneId: string;
        /**
         * End port of the TCP service.
         */
        tcpEndPort: string;
        /**
         * The fixed signature of TCP protocol load.
         */
        tcpFootprint: string;
        /**
         * Start port of the TCP service.
         */
        tcpStartPort: string;
        /**
         * End port of the UDP service.
         */
        udpEndPort: string;
        /**
         * The fixed signature of TCP protocol load.
         */
        udpFootprint: string;
        /**
         * Start port of the UDP service.
         */
        udpStartPort: string;
        /**
         * Web API url set.
         */
        webApiUrls: string[];
    }

    export interface GetEipList {
        /**
         * The created time of resource.
         */
        createdTime: string;
        /**
         * Eip PUBLIC IP status.
         */
        eipAddressStatus: string;
        /**
         * The ID of the bound ENI.
         */
        eipBoundRscEni: string;
        /**
         * The ID of the resource instance for the binding.
         */
        eipBoundRscIns?: string;
        /**
         * Bind the resource intranet IP.
         */
        eipBoundRscVip: string;
        eipLists: string[];
        /**
         * The expired time of resource.
         */
        expiredTime: string;
        /**
         * ID of the resource instance.
         */
        instanceId?: string;
        /**
         * The modify time of resource.
         */
        modifyTime: string;
        /**
         * The protection status of the asset instance.
         */
        protectionStatus: string;
        /**
         * The region where the asset instance is located.
         */
        region: string;
    }

    export interface GetL4RulesList {
        /**
         * The destination port of the layer 4 rule.
         */
        dPort: number;
        /**
         * Health threshold of health check.
         */
        healthCheckHealthNum: number;
        /**
         * Interval time of health check.
         */
        healthCheckInterval: number;
        /**
         * Indicates whether health check is enabled.
         */
        healthCheckSwitch: boolean;
        /**
         * HTTP Status Code. `1` means the return value `1xx` is health. `2` means the return value `2xx` is health. `4` means the return value `3xx` is health. `8` means the return value `4xx` is health. `16` means the return value `5xx` is health. If you want multiple return codes to indicate health, need to add the corresponding values.
         */
        healthCheckTimeout: number;
        /**
         * Unhealthy threshold of health check.
         */
        healthCheckUnhealthNum: number;
        /**
         * LB type of the rule, `1` for weight cycling and `2` for IP hash.
         */
        lbType: number;
        /**
         * Name of the layer 4 rule to be queried.
         */
        name: string;
        /**
         * Protocol of the rule.
         */
        protocol: string;
        /**
         * Id of the layer 4 rule to be queried.
         */
        ruleId: string;
        /**
         * The source port of the layer 4 rule.
         */
        sPort: number;
        /**
         * Indicate that the session will keep or not.
         */
        sessionSwitch: boolean;
        /**
         * Session keep time, only valid when `sessionSwitch` is true, the available value ranges from 1 to 300 and unit is second.
         */
        sessionTime: number;
        /**
         * Source list of the rule.
         */
        sourceLists: outputs.Dayu.GetL4RulesListSourceList[];
        /**
         * Source type, `1` for source of host, `2` for source of IP.
         */
        sourceType: number;
    }

    export interface GetL4RulesListSourceList {
        /**
         * Source IP or domain.
         */
        source: string;
        /**
         * Weight of the source.
         */
        weight: number;
    }

    export interface GetL4RulesV2List {
        /**
         * Bind the resource ID information.
         */
        id: string;
        /**
         * Ip of the resource.
         */
        ip: string;
        /**
         * session hold switch.
         */
        keepEnable: boolean;
        /**
         * The keeptime of the layer 4 rule.
         */
        keeptime: number;
        /**
         * LB type of the rule, `1` for weight cycling and `2` for IP hash.
         */
        lbType: number;
        /**
         * Rule modification time.
         */
        modifyTime: string;
        /**
         * Protocol of the rule.
         */
        protocol: string;
        /**
         * Corresponding regional information.
         */
        region: number;
        /**
         * Remove the watermark state.
         */
        removeSwitch: boolean;
        /**
         * ID of the 4 layer rule.
         */
        ruleId: string;
        /**
         * Name of the rule.
         */
        ruleName: string;
        /**
         * Source list of the rule.
         */
        sourceLists: outputs.Dayu.GetL4RulesV2ListSourceList[];
        /**
         * The source port of the layer 4 rule.
         */
        sourcePort: number;
        /**
         * Source type, `1` for source of host, `2` for source of IP.
         */
        sourceType: number;
        /**
         * Virtual port of resource.
         */
        virtualPort: number;
    }

    export interface GetL4RulesV2ListSourceList {
        /**
         * Source IP or domain.
         */
        source: string;
        /**
         * Weight of the source.
         */
        weight: number;
    }

    export interface GetL7RulesList {
        /**
         * Domain of the layer 7 rule to be queried.
         */
        domain: string;
        /**
         * HTTP Status Code. `1` means the return value `1xx` is health. `2` means the return value `2xx` is health. `4` means the return value `3xx` is health. `8` means the return value `4xx` is health. `16` means the return value `5xx` is health. If you want multiple return codes to indicate health, need to add the corresponding values.
         */
        healthCheckCode: number;
        /**
         * Health threshold of health check.
         */
        healthCheckHealthNum: number;
        /**
         * Interval time of health check.
         */
        healthCheckInterval: number;
        /**
         * Methods of health check.
         */
        healthCheckMethod: string;
        /**
         * Path of health check.
         */
        healthCheckPath: string;
        /**
         * Indicates whether health check is enabled.
         */
        healthCheckSwitch: boolean;
        /**
         * Unhealthy threshold of health check.
         */
        healthCheckUnhealthNum: number;
        /**
         * Name of the rule.
         */
        name: string;
        /**
         * Protocol of the rule.
         */
        protocol: string;
        /**
         * Id of the layer 7 rule to be queried.
         */
        ruleId: string;
        /**
         * Source list of the rule.
         */
        sourceLists: string[];
        /**
         * Source type, 1 for source of host, 2 for source of ip.
         */
        sourceType: number;
        /**
         * SSL id.
         */
        sslId: string;
        /**
         * Status of the rule. `0` for create/modify success, `2` for create/modify fail, `3` for delete success, `5` for waiting to be created/modified, `7` for waiting to be deleted and `8` for waiting to get SSL id.
         */
        status: number;
        /**
         * Indicate the rule will take effect or not.
         */
        switch: boolean;
        /**
         * Threshold of the rule.
         */
        threshold: number;
    }

    export interface GetL7RulesV2List {
        /**
         * CC protection status of HTTPS protocol, the value is [0 (off), 1 (on)].
         */
        ccEnable: number;
        /**
         * CC protection level of HTTPS protocol.
         */
        ccLevel: string;
        /**
         * CC protection status, value [0(off), 1(on)].
         */
        ccStatus: number;
        /**
         * CC protection threshold of HTTPS protocol.
         */
        ccThreshold: number;
        /**
         * The source of the certificate.
         */
        certType: number;
        /**
         * Domain of resource.
         */
        domain: string;
        /**
         * Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], default is off.
         */
        httpsToHttpEnable: number;
        /**
         * Id of the resource.
         */
        id: string;
        /**
         * Ip of the resource.
         */
        ip: string;
        /**
         * Session keep switch, value [0 (session keep closed), 1 (session keep open)].
         */
        keepEnable: number;
        /**
         * Session hold time, in seconds.
         */
        keepTime: number;
        /**
         * Load balancing mode, the value is [1 (weighted round-robin)].
         */
        lbType: number;
        /**
         * Modify time of resource.
         */
        modifyTime: string;
        /**
         * Protocol of resource, value range [`http`, `https`].
         */
        protocol: string;
        /**
         * The area code.
         */
        region: number;
        /**
         * Rule description.
         */
        ruleName: string;
        /**
         * Source list of the rule.
         */
        sourceLists: outputs.Dayu.GetL7RulesV2ListSourceList[];
        /**
         * Back-to-origin method, value [1 (domain name back-to-source), 2 (IP back-to-source)].
         */
        sourceType: number;
        /**
         * SSL id of the resource.
         */
        sslId: string;
        /**
         * Rule status, value [0 (rule configuration is successful), 1 (rule configuration is in effect), 2 (rule configuration fails), 3 (rule deletion is in effect), 5 (rule deletion fails), 6 (rule is waiting to be configured), 7 (rule pending deletion), 8 (rule pending configuration certificate)].
         */
        status: number;
        /**
         * Virtual port of resource.
         */
        virtualPort: number;
    }

    export interface GetL7RulesV2ListSourceList {
        /**
         * Back-to-source IP or domain name.
         */
        source: string;
        /**
         * Weight value, take value [0,100].
         */
        weight: number;
    }

    export interface L4RuleSourceList {
        /**
         * Source IP or domain, valid format of ip is like `1.1.1.1` and valid format of host source is like `abc.com`.
         */
        source: string;
        /**
         * Weight of the source, the valid value ranges from 0 to 100.
         */
        weight: number;
    }

    export interface L4RuleV2Rules {
        /**
         * session hold switch.
         */
        keepEnable: boolean;
        /**
         * The keeptime of the layer 4 rule.
         */
        keeptime: number;
        /**
         * LB type of the rule, `1` for weight cycling and `2` for IP hash.
         */
        lbType: number;
        /**
         * Protocol of the rule.
         */
        protocol: string;
        /**
         * Corresponding regional information.
         */
        region: number;
        /**
         * Remove the watermark state.
         */
        removeSwitch: boolean;
        /**
         * Name of the rule.
         */
        ruleName: string;
        /**
         * Source list of the rule.
         */
        sourceLists: outputs.Dayu.L4RuleV2RulesSourceList[];
        /**
         * The source port of the layer 4 rule.
         */
        sourcePort: number;
        /**
         * Source type, `1` for source of host, `2` for source of IP.
         */
        sourceType: number;
        /**
         * The virtual port of the layer 4 rule.
         */
        virtualPort: number;
    }

    export interface L4RuleV2RulesSourceList {
        /**
         * Source IP or domain.
         */
        source: string;
        /**
         * Weight of the source.
         */
        weight: number;
    }

    export interface L7RuleV2Rule {
        /**
         * HTTPS protocol CC protection status, value [0 (off), 1 (on)], defaule is 0.
         */
        ccEnable?: number;
        /**
         * The source of the certificate must be filled in when the forwarding protocol is https, the value [2 (Tencent Cloud Hosting Certificate)], and 0 when the forwarding protocol is http.
         */
        certType?: number;
        /**
         * Domain of the rule.
         */
        domain: string;
        /**
         * Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], do not fill in the default is off, defaule is 0.
         */
        httpsToHttpEnable?: number;
        /**
         * session hold switch.
         */
        keepEnable: number;
        /**
         * The keeptime of the layer 4 rule.
         */
        keeptime: number;
        /**
         * LB type of the rule, `1` for weight cycling and `2` for IP hash.
         */
        lbType: number;
        /**
         * Protocol of the rule.
         */
        protocol: string;
        sourceLists: outputs.Dayu.L7RuleV2RuleSourceList[];
        /**
         * Source type, `1` for source of host, `2` for source of IP.
         */
        sourceType: number;
        /**
         * When the certificate source is a Tencent Cloud managed certificate, this field must be filled in with the managed certificate ID.
         */
        sslId?: string;
    }

    export interface L7RuleV2RuleSourceList {
        /**
         * Source IP or domain.
         */
        source: string;
        /**
         * Weight of the source.
         */
        weight: number;
    }

}

export namespace Dbbrain {
    export interface GetDiagDbInstancesItem {
        /**
         * Instance audit log enable status. `ALL_AUDIT`: full audit is enabled; `RULE_AUDIT`: rule audit is enabled; `UNBOUND`: audit is not enabled.
         */
        auditPolicyStatus: string;
        /**
         * Instance audit log running status. `normal`: running; `paused`: arrears suspended.
         */
        auditRunningStatus: string;
        /**
         * number of cores.
         */
        cpu: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * resource expiration time.
         */
        deadlineTime: string;
        /**
         * cdb type.
         */
        deployMode: string;
        /**
         * database version.
         */
        engineVersion: string;
        /**
         * the number of abnormal events.
         */
        eventCount: number;
        /**
         * group ID.
         */
        groupId: string;
        /**
         * group name.
         */
        groupName: string;
        /**
         * health score.
         */
        healthScore: number;
        /**
         * cdb instance initialization flag: `0`: not initialized; `1`: initialized.
         */
        initFlag: number;
        /**
         * status of instance inspection/overview.
         */
        instanceConfs: outputs.Dbbrain.GetDiagDbInstancesItemInstanceConf[];
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * instance name.
         */
        instanceName: string;
        /**
         * instance type. `1`: MASTER; `2`: DR, `3`: RO, `4`: SDR.
         */
        instanceType: number;
        /**
         * Intranet VIPNote: This field may return null, indicating that no valid value can be obtained.
         */
        internalVip: string;
        /**
         * Intranet portNote: This field may return null, indicating that no valid value can be obtained.
         */
        internalVport: number;
        /**
         * whether it is an instance supported by DBbrain, always pass `true`.
         */
        isSupported: boolean;
        /**
         * memory, in MB.
         */
        memory: number;
        /**
         * service product type, supported values include: `mysql` - cloud database MySQL, `cynosdb` - cloud database TDSQL-C for MySQL, the default is `mysql`.
         */
        product: string;
        /**
         * region.
         */
        region: string;
        /**
         * enabled status of the instance security audit log. `ON`: security audit is enabled; `OFF`: security audit is not enabled.
         */
        secAuditStatus: string;
        /**
         * access source.
         */
        source: string;
        /**
         * Instance status: `0`: Shipping; `1`: Running normally; `4`: Destroying; `5`: Isolating.
         */
        status: number;
        /**
         * task status.
         */
        taskStatus: number;
        /**
         * subnet uniform ID.
         */
        uniqSubnetId: string;
        /**
         * the unified ID of the private network.
         */
        uniqVpcId: string;
        /**
         * intranet address.
         */
        vip: string;
        /**
         * hard disk storage, in GB.
         */
        volume: number;
        /**
         * intranet port.
         */
        vport: number;
    }

    export interface GetDiagDbInstancesItemInstanceConf {
        /**
         * database inspection switch, Yes/No.
         */
        dailyInspection: string;
        /**
         * Custom separator for redis large key analysis, only used by `redis`. Note: This field may return null, indicating that no valid value can be obtained.
         */
        keyDelimiters: string[];
        /**
         * instance overview switch, Yes/No.
         */
        overviewDisplay: string;
    }

    export interface GetDiagEventsList {
        /**
         * diag item.
         */
        diagItem: string;
        /**
         * diag type.
         */
        diagType: string;
        /**
         * end time.
         */
        endTime: string;
        /**
         * event id.
         */
        eventId: number;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * metric.
         */
        metric: string;
        /**
         * outline.
         */
        outline: string;
        /**
         * region.
         */
        region: string;
        /**
         * severity.
         */
        severity: number;
        /**
         * start time.
         */
        startTime: string;
    }

    export interface GetDiagHistoryEvent {
        /**
         * Description of the diagnostic item.
         */
        diagItem: string;
        /**
         * Diagnostic type.
         */
        diagType: string;
        /**
         * End time, such as `2019-09-11 12:13:14`, the interval between the end time and the start time can be up to 2 days.
         */
        endTime: string;
        /**
         * Event unique ID.
         */
        eventId: number;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * reserved text. Note: This field may return null, indicating that no valid value can be obtained.
         */
        metric: string;
        /**
         * Diagnostic summary.
         */
        outline: string;
        /**
         * region.
         */
        region: string;
        /**
         * severity. The severity is divided into 5 levels, according to the degree of impact from high to low: 1: Fatal, 2: Serious, 3: Warning, 4: Prompt, 5: Healthy.
         */
        severity: number;
        /**
         * Start time, such as `2019-09-10 12:13:14`.
         */
        startTime: string;
    }

    export interface GetHealthScoresData {
        /**
         * The total number of abnormal events.
         */
        eventsTotalCount: number;
        /**
         * Health level, such as: HEALTH, SUB_HEALTH, RISK, HIGH_RISK.
         */
        healthLevel: string;
        /**
         * Health score.
         */
        healthScore: number;
        /**
         * Exception details.
         */
        issueTypes: outputs.Dbbrain.GetHealthScoresDataIssueType[];
    }

    export interface GetHealthScoresDataIssueType {
        /**
         * unusual event.
         */
        events: outputs.Dbbrain.GetHealthScoresDataIssueTypeEvent[];
        /**
         * Index classification: AVAILABILITY: availability, MAINTAINABILITY: maintainability, PERFORMANCE, performance, RELIABILITY reliability.
         */
        issueType: string;
        /**
         * The total number of abnormal events.
         */
        totalCount: number;
    }

    export interface GetHealthScoresDataIssueTypeEvent {
        /**
         * Number of alerts.
         */
        count: number;
        /**
         * Diagnostic type.
         */
        diagType: string;
        /**
         * End Time.
         */
        endTime: string;
        /**
         * Event ID.
         */
        eventId: number;
        /**
         * reserved text.
         */
        metric: string;
        /**
         * overview.
         */
        outline: string;
        /**
         * Points deducted.
         */
        scoreLost: number;
        /**
         * severity. The severity is divided into 5 levels, according to the degree of impact from high to low: 1: Fatal, 2: Serious, 3: Warning, 4: Prompt, 5: Healthy.
         */
        severity: number;
        /**
         * Starting time.
         */
        startTime: string;
    }

    export interface GetMysqlProcessListProcessList {
        /**
         * The execution type of the thread, used to filter the thread list.
         */
        command: string;
        /**
         * The threads operations database, used to filter the thread list.
         */
        db: string;
        /**
         * The operating host address of the thread, used to filter the thread list.
         */
        host: string;
        /**
         * thread ID, used to filter the thread list.
         */
        id: string;
        /**
         * The threads operation statement is used to filter the thread list.
         */
        info: string;
        /**
         * The operational state of the thread, used to filter the thread list.
         */
        state: string;
        /**
         * The minimum value of the operation duration of a thread, in seconds, used to filter the list of threads whose operation duration is longer than this value.
         */
        time: string;
        /**
         * The operating account name of the thread, used to filter the thread list.
         */
        user: string;
    }

    export interface GetNoPrimaryKeyTablesNoPrimaryKeyTable {
        /**
         * Storage engine for database tables.
         */
        engine: string;
        /**
         * tableName.
         */
        tableName: string;
        /**
         * rows.
         */
        tableRows: number;
        /**
         * library name.
         */
        tableSchema: string;
        /**
         * Total space used (MB).
         */
        totalLength: number;
    }

    export interface GetRedisTopBigKeysTopKey {
        /**
         * key encoding method.
         */
        encoding: string;
        /**
         * Key expiration timestamp (in milliseconds), 0 means no expiration time is set.
         */
        expireTime: number;
        /**
         * number of elements.
         */
        itemCount: number;
        /**
         * key name.
         */
        key: string;
        /**
         * Key memory size, unit Byte.
         */
        length: number;
        /**
         * Maximum element length.
         */
        maxElementSize: number;
        /**
         * key type.
         */
        type: string;
    }

    export interface GetRedisTopKeyPrefixListItem {
        /**
         * Average element length.
         */
        aveElementSize: number;
        /**
         * The number of keys.
         */
        count: number;
        /**
         * number of elements.
         */
        itemCount: number;
        /**
         * key prefix.
         */
        keyPreIndex: string;
        /**
         * Total occupied memory (Byte).
         */
        length: number;
        /**
         * Maximum element length.
         */
        maxElementSize: number;
    }

    export interface GetSecurityAuditLogExportTasksList {
        /**
         * async request id.
         */
        asyncRequestId: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * danger level list.
         */
        dangerLevels: number[];
        /**
         * end time.
         */
        endTime: string;
        /**
         * log end time.
         */
        logEndTime: string;
        /**
         * log start time.
         */
        logStartTime: string;
        /**
         * task progress.
         */
        progress: number;
        /**
         * start time.
         */
        startTime: string;
        /**
         * status.
         */
        status: string;
        /**
         * the total size of log.
         */
        totalSize: number;
    }

    export interface GetSlowLogTimeSeriesStatsSeriesData {
        /**
         * Monitor metrics.
         */
        series: outputs.Dbbrain.GetSlowLogTimeSeriesStatsSeriesDataSeries[];
        /**
         * Statistics start time.
         */
        timestamps: number[];
    }

    export interface GetSlowLogTimeSeriesStatsSeriesDataSeries {
        /**
         * Indicator name.
         */
        metric: string;
        /**
         * Indicator unit.
         */
        unit: string;
        /**
         * Index value. Note: This field may return null, indicating that no valid value can be obtained.
         */
        values: number[];
    }

    export interface GetSlowLogTimeSeriesStatsTimeSeries {
        /**
         * total.
         */
        count: number;
        /**
         * Statistics start time.
         */
        timestamp: number;
    }

    export interface GetSlowLogTopSqlsRow {
        /**
         * Execution times.
         */
        execTimes: number;
        /**
         * SQL total lock waiting time, in seconds.
         */
        lockTime: number;
        /**
         * Average lock waiting time, in seconds.
         */
        lockTimeAvg: number;
        /**
         * Maximum lock waiting time, in seconds.
         */
        lockTimeMax: number;
        /**
         * Minimum lock waiting time, in seconds.
         */
        lockTimeMin: number;
        /**
         * The ratio of the total lock waiting time of SQL, in %.
         */
        lockTimeRatio: number;
        /**
         * MD5 value of SOL template.
         */
        md5: string;
        /**
         * Total time, in seconds.
         */
        queryTime: number;
        /**
         * Average execution time, in seconds.
         */
        queryTimeAvg: number;
        /**
         * The maximum execution time, in seconds.
         */
        queryTimeMax: number;
        /**
         * The minimum execution time, in seconds.
         */
        queryTimeMin: number;
        /**
         * Total time-consuming ratio, unit %.
         */
        queryTimeRatio: number;
        /**
         * total scan lines.
         */
        rowsExamined: number;
        /**
         * average number of lines scanned.
         */
        rowsExaminedAvg: number;
        /**
         * Maximum number of scan lines.
         */
        rowsExaminedMax: number;
        /**
         * Minimum number of scan lines.
         */
        rowsExaminedMin: number;
        /**
         * The proportion of the total number of scanned lines, unit %.
         */
        rowsExaminedRatio: number;
        /**
         * total number of rows returned.
         */
        rowsSent: number;
        /**
         * average number of rows returned.
         */
        rowsSentAvg: number;
        /**
         * Maximum number of rows returned.
         */
        rowsSentMax: number;
        /**
         * Minimum number of rows returned.
         */
        rowsSentMin: number;
        /**
         * The proportion of the total number of rows returned, in %.
         */
        rowsSentRatio: number;
        /**
         * DB name.
         */
        schema: string;
        /**
         * sql template.
         */
        sqlTemplate: string;
        /**
         * SQL with parameters (random).
         */
        sqlText: string;
    }

    export interface GetSlowLogTopSqlsSchemaList {
        /**
         * DB name.
         */
        schema: string;
    }

    export interface GetSlowLogUserHostStatsItem {
        /**
         * The number of slow logs for this source address.
         */
        count: number;
        /**
         * The ratio of the number of slow logs of the source address to the total, in %.
         */
        ratio: number;
        /**
         * source address.
         */
        userHost: string;
    }

    export interface GetSlowLogsRow {
        /**
         * database.
         */
        database: string;
        /**
         * lock time, in secondsNote: This field may return null, indicating that no valid value can be obtained.
         */
        lockTime: number;
        /**
         * Execution time, in seconds.
         */
        queryTime: number;
        /**
         * scan linesNote: This field may return null, indicating that no valid value can be obtained.
         */
        rowsExamined: number;
        /**
         * Return the number of rowsNote: This field may return null, indicating that no valid value can be obtained.
         */
        rowsSent: number;
        /**
         * sql statement.
         */
        sqlText: string;
        /**
         * Slow log start time.
         */
        timestamp: string;
        /**
         * Ip sourceNote: This field may return null, indicating that no valid value can be obtained.
         */
        userHost: string;
        /**
         * User sourceNote: This field may return null, indicating that no valid value can be obtained.
         */
        userName: string;
    }

    export interface GetSqlFiltersList {
        /**
         * create time.
         */
        createTime: string;
        /**
         * current concurrency.
         */
        currentConcurrency: number;
        /**
         * current time.
         */
        currentTime: string;
        /**
         * expire time.
         */
        expireTime: string;
        /**
         * task id.
         */
        id: number;
        /**
         * maxmum concurrency.
         */
        maxConcurrency: number;
        /**
         * origin keys.
         */
        originKeys: string;
        /**
         * origin rule.
         */
        originRule: string;
        /**
         * rejected sql count.
         */
        rejectedSqlCount: number;
        /**
         * sql type, optional value is SELECT, UPDATE, DELETE, INSERT, REPLACE.
         */
        sqlType: string;
        /**
         * task status, optional value is RUNNING, FINISHED, TERMINATED.
         */
        status: string;
    }

    export interface GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeries {
        /**
         * Spatial index data in unit time interval.
         */
        seriesDatas: outputs.Dbbrain.GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesData[];
        /**
         * databases name.
         */
        tableSchema: string;
    }

    export interface GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesData {
        /**
         * Monitor metrics.
         */
        series: outputs.Dbbrain.GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesDataSeries[];
        /**
         * The timestamp corresponding to the monitoring indicator.
         */
        timestamps: number[];
    }

    export interface GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesDataSeries {
        /**
         * Indicator name.
         */
        metric: string;
        /**
         * Indicator unit.
         */
        unit: string;
        /**
         * Index value. Note: This field may return null, indicating that no valid value can be obtained.
         */
        values: number[];
    }

    export interface GetTopSpaceSchemasTopSpaceSchema {
        /**
         * Fragmentation space (MB).
         */
        dataFree: number;
        /**
         * data space (MB).
         */
        dataLength: number;
        /**
         * Fragmentation rate (%).
         */
        fragRatio: number;
        /**
         * Index space (MB).
         */
        indexLength: number;
        /**
         * The sum (MB) of the independent physical file sizes corresponding to all tables in the library. Note: This field may return null, indicating that no valid value can be obtained.
         */
        physicalFileSize: number;
        /**
         * Number of lines.
         */
        tableRows: number;
        /**
         * library name.
         */
        tableSchema: string;
        /**
         * Total space used (MB).
         */
        totalLength: number;
    }

    export interface GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeries {
        /**
         * Storage engine for database tables.
         */
        engine: string;
        /**
         * Spatial index data in unit time interval.
         */
        seriesDatas: outputs.Dbbrain.GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesData[];
        /**
         * table name.
         */
        tableName: string;
        /**
         * databases name.
         */
        tableSchema: string;
    }

    export interface GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesData {
        /**
         * Monitor metrics.
         */
        series: outputs.Dbbrain.GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesDataSeries[];
        /**
         * The timestamp corresponding to the monitoring indicator.
         */
        timestamps: number[];
    }

    export interface GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesDataSeries {
        /**
         * Indicator name.
         */
        metric: string;
        /**
         * Indicator unit.
         */
        unit: string;
        /**
         * Index value. Note: This field may return null, indicating that no valid value can be obtained.
         */
        values: number[];
    }

    export interface GetTopSpaceTablesTopSpaceTable {
        /**
         * Fragmentation space (MB).
         */
        dataFree: number;
        /**
         * data space (MB).
         */
        dataLength: number;
        /**
         * Storage engine for database tables.
         */
        engine: string;
        /**
         * Fragmentation rate (%).
         */
        fragRatio: number;
        /**
         * Index space (MB).
         */
        indexLength: number;
        /**
         * The independent physical file size (MB) corresponding to the table.
         */
        physicalFileSize: number;
        /**
         * table name.
         */
        tableName: string;
        /**
         * Number of lines.
         */
        tableRows: number;
        /**
         * database name.
         */
        tableSchema: string;
        /**
         * Total space used (MB).
         */
        totalLength: number;
    }

    export interface ModifyDiagDbInstanceOperationInstanceConfs {
        /**
         * Database inspection switch, Yes/No.
         */
        dailyInspection?: string;
        /**
         * Instance overview switch, Yes/No.
         */
        overviewDisplay?: string;
    }

    export interface SqlFilterSessionToken {
        /**
         * password.
         */
        password: string;
        /**
         * user name.
         */
        user: string;
    }

    export interface TdsqlAuditLogFilter {
        /**
         * Number of affected rows. Indicates filtering audit logs whose affected rows are greater than this value.
         */
        affectRows?: number;
        /**
         * Database name.
         */
        dbNames?: string[];
        /**
         * Execution time. The unit is: us. It means to filter the audit logs whose execution time is greater than this value.
         */
        execTime?: number;
        /**
         * Client Address.
         */
        hosts?: string[];
        /**
         * Return the number of rows. It means to filter the audit log with the number of returned rows greater than this value.
         */
        sentRows?: number;
        /**
         * Username.
         */
        users?: string[];
    }

}

export namespace Dc {
    export interface GetAccessPointsAccessPointSet {
        /**
         * Unique access point ID.
         */
        accessPointId: string;
        /**
         * Access point name.
         */
        accessPointName: string;
        /**
         * Access point type. Valid values: `VXLAN`, `QCPL`, and `QCAR`.Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        accessPointType: string;
        /**
         * Access point regionNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        area: string;
        /**
         * Available port type at the access point. Valid values: 1000BASE-T: gigabit electrical port; 1000BASE-LX: 10 km gigabit single-mode optical port; 1000BASE-ZX: 80 km gigabit single-mode optical port; 10GBASE-LR: 10 km 10-gigabit single-mode optical port; 10GBASE-ZR: 80 km 10-gigabit single-mode optical port; 10GBASE-LH: 40 km 10-gigabit single-mode optical port; 100GBASE-LR4: 10 km 100-gigabit single-mode optical portfiber optic port.Note: this field may return `null`, indicating that no valid value is obtained.
         */
        availablePortTypes: string[];
        /**
         * City where the access point is locatedNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        city: string;
        /**
         * Latitude and longitude of the access pointNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        coordinates: outputs.Dc.GetAccessPointsAccessPointSetCoordinate[];
        /**
         * List of ISPs supported by access point.
         */
        lineOperators: string[];
        /**
         * Access point location.
         */
        location: string;
        /**
         * Access point region, which can be queried through `DescribeRegions`.You can call `DescribeRegions` to get the region ID.
         */
        regionId: string;
        /**
         * Access point status. Valid values: available, unavailable.
         */
        state: string;
    }

    export interface GetAccessPointsAccessPointSetCoordinate {
        /**
         * Latitude.
         */
        lat: number;
        /**
         * Longitude.
         */
        lng: number;
    }

    export interface GetGatewayCcnRoutesInstanceList {
        /**
         * As path list of the BGP.
         */
        asPaths: string[];
        /**
         * A network address segment of IDC.
         */
        cidrBlock: string;
        /**
         * ID of the DCG to be queried.
         */
        dcgId: string;
        /**
         * ID of the DCG route.
         */
        routeId: string;
    }

    export interface GetGatewayInstancesInstanceList {
        /**
         * Type of CCN route. Valid values: `BGP` and `STATIC`.
         */
        cnnRouteType: string;
        /**
         * Creation time of resource.
         */
        createTime: string;
        /**
         * ID of the DCG to be queried.
         */
        dcgId: string;
        /**
         * IP of the DCG.
         */
        dcgIp: string;
        /**
         * Indicates whether the BGP is enabled.
         */
        enableBgp: boolean;
        /**
         * Type of the gateway. Valid values: `NORMAL` and `NAT`. Default is `NORMAL`.
         */
        gatewayType: string;
        /**
         * Name of the DCG to be queried.
         */
        name: string;
        /**
         * Type of associated network. Valid values: `VPC` and `CCN`.
         */
        networkInstanceId: string;
        /**
         * IP of the DCG.
         */
        networkType: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * Access point ID of tne DC.
         */
        accessPointId: string;
        /**
         * Bandwidth of the DC.
         */
        bandwidth: number;
        /**
         * The circuit code provided by the operator for the DC.
         */
        circuitCode: string;
        /**
         * Creation time of resource.
         */
        createTime: string;
        /**
         * Interconnect IP of the DC within client. Note: This field may return null, indicating that no valid values are taken.
         */
        customerAddress: string;
        /**
         * Applicant email of the DC, the default is obtained from the account. Note: This field may return null, indicating that no valid values are taken.
         */
        customerEmail: string;
        /**
         * Applicant name of the DC, the default is obtained from the account. Note: This field may return null, indicating that no valid values are taken.
         */
        customerName: string;
        /**
         * Applicant phone number of the DC, the default is obtained from the account. Note: This field may return null, indicating that no valid values are taken.
         */
        customerPhone: string;
        /**
         * ID of the DC to be queried.
         */
        dcId: string;
        /**
         * Enable time of resource.
         */
        enabledTime: string;
        /**
         * Expire date of resource.
         */
        expiredTime: string;
        /**
         * Contact of reporting a faulty. Note: This field may return null, indicating that no valid values are taken.
         */
        faultReportContactPerson: string;
        /**
         * Phone number of reporting a faulty. Note: This field may return null, indicating that no valid values are taken.
         */
        faultReportContactPhone: string;
        /**
         * Operator of the DC, and available values include `ChinaTelecom`, `ChinaMobile`, `ChinaUnicom`, `In-houseWiring`, `ChinaOther` and `InternationalOperator`.
         */
        lineOperator: string;
        /**
         * The DC location where the connection is located.
         */
        location: string;
        /**
         * Name of the DC to be queried.
         */
        name: string;
        /**
         * Port type of the DC in client, and available values include `100Base-T`, `1000Base-T`, `1000Base-LX`, `10GBase-T` and `10GBase-LR`. The default value is `1000Base-LX`.
         */
        portType: string;
        /**
         * ID of the redundant DC.
         */
        redundantDcId: string;
        /**
         * State of the DC, and available values include `REJECTED`, `TOPAY`, `PAID`, `ALLOCATED`, `AVAILABLE`, `DELETING` and `DELETED`.
         */
        state: string;
        /**
         * Interconnect IP of the DC within Tencent. Note: This field may return null, indicating that no valid values are taken.
         */
        tencentAddress: string;
    }

    export interface GetInternetAddressStatisticsInternetAddressStatistic {
        /**
         * region.
         */
        region: string;
        /**
         * Number of Internet public network addresses.
         */
        subnetNum: number;
    }

    export interface GetPublicDirectConnectTunnelRoutesFilter {
        /**
         * Fields to be filtered.
         */
        name: string;
        /**
         * filter value of the field.
         */
        values: string[];
    }

    export interface GetPublicDirectConnectTunnelRoutesRoute {
        /**
         * ASPath info.
         */
        asPaths: string[];
        /**
         * Network CIDR.
         */
        destinationCidrBlock: string;
        /**
         * Route next hop ip.
         */
        nextHop: string;
        /**
         * direct connect tunnel route id.
         */
        routeId: string;
        /**
         * Route type: BGP/STATIC route.
         */
        routeType: string;
        /**
         * ENABLE: routing is enabled, DISABLE: routing is disabled.
         */
        status: string;
    }

}

export namespace Dcdb {
    export interface AccountPrivilegesAccount {
        /**
         * account host.
         */
        host: string;
        /**
         * account name.
         */
        user: string;
    }

    export interface AccountPrivilegesColumnPrivileges {
        /**
         * Database column name.
         */
        column: string;
        /**
         * The name of database.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
        /**
         * Database table name.
         */
        table: string;
    }

    export interface AccountPrivilegesDatabasePrivileges {
        /**
         * The name of database.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
    }

    export interface AccountPrivilegesTablePrivileges {
        /**
         * The name of database.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
        /**
         * Database table name.
         */
        table: string;
    }

    export interface AccountPrivilegesViewPrivileges {
        /**
         * The name of database.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
        /**
         * Database view name.
         */
        view: string;
    }

    export interface DbInstanceInitParam {
        /**
         * The name of parameter.
         */
        param: string;
        /**
         * The value of parameter.
         */
        value: string;
    }

    export interface DbInstanceResourceTag {
        /**
         * The key of tag.
         */
        tagKey: string;
        /**
         * The value of tag.
         */
        tagValue: string;
    }

    export interface DbParametersParams {
        /**
         * The name of parameter.
         */
        param: string;
        /**
         * The value of parameter.
         */
        value: string;
    }

    export interface GetAccountsList {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * If the standby machine delay exceeds the setting value of this parameter, the system will consider that the standby machine is faulty and recommend that the parameter value be greater than 10. This parameter takes effect when ReadOnly selects 1 and 2.
         */
        delayThresh: number;
        /**
         * User remarks info.
         */
        description: string;
        /**
         * From which host the user can log in (corresponding to the host field of MySQL users, UserName + Host uniquely identifies a user, in the form of IP, the IP segment ends with %; supports filling in %; if it is empty, it defaults to %).
         */
        host: string;
        /**
         * Read-only flag, 0: No, 1: The SQL request of this account is preferentially executed on the standby machine, and the host is selected for execution when the standby machine is unavailable. 2: The standby machine is preferentially selected for execution, and the operation fails when the standby machine is unavailable.
         */
        readOnly: number;
        /**
         * For read-only accounts, set the policy whether to fix the standby machine, 0: not fix the standby machine, that is, the standby machine will not disconnect from the client if it does not meet the conditions, the Proxy selects other available standby machines, 1: the standby machine will be disconnected if the conditions are not met, Make sure a connection is secured to the standby machine.
         */
        slaveConst: number;
        /**
         * Last update time.
         */
        updateTime: string;
        /**
         * User Name.
         */
        userName: string;
    }

    export interface GetDatabaseObjectsFunc {
        /**
         * The name of function.
         */
        func: string;
    }

    export interface GetDatabaseObjectsProc {
        /**
         * The name of procedure.
         */
        proc: string;
    }

    export interface GetDatabaseObjectsTable {
        /**
         * The name of table.
         */
        table: string;
    }

    export interface GetDatabaseObjectsView {
        /**
         * The name of view.
         */
        view: string;
    }

    export interface GetDatabaseTablesCol {
        /**
         * The name of column.
         */
        col: string;
        /**
         * Column type.
         */
        type: string;
    }

    export interface GetDatabasesList {
        /**
         * Database Name.
         */
        dbName: string;
    }

    export interface GetInstanceNodeInfoNodesInfo {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node role. Valid values: `master`, `slave`.
         */
        role: string;
        /**
         * Instance shard ID.
         */
        shardId: string;
    }

    export interface GetInstancesList {
        /**
         * app id.
         */
        appId: number;
        /**
         * auto renew flag.
         */
        autoRenewFlag: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * db engine.
         */
        dbEngine: string;
        /**
         * db engine version.
         */
        dbVersion: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * instance name.
         */
        instanceName: string;
        /**
         * instance type.
         */
        instanceType: number;
        /**
         * aduit support, 0:support, 1:unsupport.
         */
        isAuditSupported: number;
        /**
         * tmp instance mark.
         */
        isTmp: number;
        /**
         * isolated time.
         */
        isolatedTimestamp: string;
        /**
         * memory.
         */
        memory: number;
        /**
         * node count.
         */
        nodeCount: number;
        /**
         * pay mode.
         */
        paymode: string;
        /**
         * expired time.
         */
        periodEndTime: string;
        /**
         * project id.
         */
        projectId: number;
        /**
         * region.
         */
        region: string;
        /**
         * resource tags.
         */
        resourceTags: outputs.Dcdb.GetInstancesListResourceTag[];
        /**
         * shard count.
         */
        shardCount: number;
        /**
         * shard detail.
         */
        shardDetails: outputs.Dcdb.GetInstancesListShardDetail[];
        /**
         * status.
         */
        status: number;
        /**
         * status description.
         */
        statusDesc: string;
        /**
         * memory, the unit is GB.
         */
        storage: number;
        /**
         * subnet id, valid when IsFilterVpc is true.
         */
        subnetId: number;
        /**
         * account uin.
         */
        uin: string;
        /**
         * update time.
         */
        updateTime: string;
        /**
         * vip.
         */
        vip: string;
        /**
         * vpc id, valid when IsFilterVpc is true.
         */
        vpcId: number;
        /**
         * vport.
         */
        vport: number;
        /**
         * wan domain.
         */
        wanDomain: string;
        /**
         * wan port.
         */
        wanPort: number;
        /**
         * wan status, 0:nonactivated, 1:activated, 2:closed, 3:activating.
         */
        wanStatus: number;
        /**
         * wan vip.
         */
        wanVip: string;
    }

    export interface GetInstancesListResourceTag {
        /**
         * tag key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

    export interface GetInstancesListShardDetail {
        /**
         * cpu cores.
         */
        cpu: number;
        /**
         * shard create time.
         */
        createtime: string;
        /**
         * memory.
         */
        memory: number;
        /**
         * node count.
         */
        nodeCount: number;
        /**
         * shard id.
         */
        shardId: number;
        /**
         * shard instance id.
         */
        shardInstanceId: string;
        /**
         * shard serial id.
         */
        shardSerialId: string;
        /**
         * status.
         */
        status: number;
        /**
         * memory, the unit is GB.
         */
        storage: number;
    }

    export interface GetLogFilesFile {
        /**
         * Filename.
         */
        fileName: string;
        /**
         * File length.
         */
        length: number;
        /**
         * Last modified time of log.
         */
        mtime: number;
        /**
         * Uniform resource identifier (URI) used during log download.
         */
        uri: string;
    }

    export interface GetOrdersDeal {
        /**
         * Number of items.
         */
        count: number;
        /**
         * Order number.
         */
        dealName: string;
        /**
         * ID of the associated process, which can be used to query the process execution status.
         */
        flowId: number;
        /**
         * The ID of the created instance, which is required only for the order that creates an instance.Note: This field may return null, indicating that no valid values can be obtained.
         */
        instanceIds: string[];
        /**
         * Account.
         */
        ownerUin: string;
        /**
         * Payment mode. Valid values: 0 (postpaid), 1 (prepaid).
         */
        payMode: number;
    }

    export interface GetParametersList {
        /**
         * params constraint.
         */
        constraints: outputs.Dcdb.GetParametersListConstraint[];
        /**
         * default value.
         */
        default: string;
        /**
         * have set value.
         */
        haveSetValue: boolean;
        /**
         * need restart.
         */
        needRestart: boolean;
        /**
         * parameter name.
         */
        param: string;
        /**
         * parameter value.
         */
        value: string;
    }

    export interface GetParametersListConstraint {
        /**
         * a list of optional values of type num.
         */
        enum: string;
        /**
         * range constraint.
         */
        ranges: outputs.Dcdb.GetParametersListConstraintRange[];
        /**
         * constraint type is string.
         */
        string: string;
        /**
         * type.
         */
        type: string;
    }

    export interface GetParametersListConstraintRange {
        /**
         * max value.
         */
        max: string;
        /**
         * min value.
         */
        min: string;
    }

    export interface GetProjectSecurityGroupsGroup {
        /**
         * Creation time in the format of yyyy-mm-dd hh:mm:ss.
         */
        createTime: string;
        /**
         * Inbound rule.
         */
        inbounds: outputs.Dcdb.GetProjectSecurityGroupsGroupInbound[];
        /**
         * Outbound rule.
         */
        outbounds: outputs.Dcdb.GetProjectSecurityGroupsGroupOutbound[];
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * Security group name.
         */
        securityGroupName: string;
        /**
         * Security group remarks.
         */
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsGroupInbound {
        /**
         * Policy, which can be `ACCEPT` or `DROP`.
         */
        action: string;
        /**
         * Source IP or source IP range, such as 192.168.0.0/16.
         */
        cidrIp: string;
        /**
         * Network protocol. UDP and TCP are supported.
         */
        ipProtocol: string;
        /**
         * Port.
         */
        portRange: string;
    }

    export interface GetProjectSecurityGroupsGroupOutbound {
        /**
         * Policy, which can be `ACCEPT` or `DROP`.
         */
        action: string;
        /**
         * Source IP or source IP range, such as 192.168.0.0/16.
         */
        cidrIp: string;
        /**
         * Network protocol. UDP and TCP are supported.
         */
        ipProtocol: string;
        /**
         * Port.
         */
        portRange: string;
    }

    export interface GetProjectsProject {
        /**
         * Application ID.
         */
        appId: number;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Creator UIN.
         */
        creatorUin: number;
        /**
         * Description.
         */
        info: string;
        /**
         * Whether it is the default project. Valid values: `1` (yes), `0` (no).
         */
        isDefault: number;
        /**
         * Project name.
         */
        name: string;
        /**
         * The UIN of the resource owner (root account).
         */
        ownerUin: number;
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Source APPID.
         */
        srcAppId: number;
        /**
         * Source platform.
         */
        srcPlat: string;
        /**
         * Project status. Valid values: `0` (normal), `-1` (disabled), `3` (default project).
         */
        status: number;
    }

    export interface GetSaleInfoRegionList {
        /**
         * available zone choice.
         */
        availableChoices: outputs.Dcdb.GetSaleInfoRegionListAvailableChoice[];
        /**
         * region name(en).
         */
        region: string;
        /**
         * region id.
         */
        regionId: number;
        /**
         * region name(zh).
         */
        regionName: string;
        /**
         * list of az zone.
         */
        zoneLists: outputs.Dcdb.GetSaleInfoRegionListZoneList[];
    }

    export interface GetSaleInfoRegionListAvailableChoice {
        /**
         * master zone.
         */
        masterZones: outputs.Dcdb.GetSaleInfoRegionListAvailableChoiceMasterZone[];
        /**
         * slave zones.
         */
        slaveZones: outputs.Dcdb.GetSaleInfoRegionListAvailableChoiceSlaveZone[];
    }

    export interface GetSaleInfoRegionListAvailableChoiceMasterZone {
        /**
         * is zone on sale.
         */
        onSale: boolean;
        /**
         * zone name(en).
         */
        zone: string;
        /**
         * zone id.
         */
        zoneId: number;
        /**
         * zone name(zh).
         */
        zoneName: string;
    }

    export interface GetSaleInfoRegionListAvailableChoiceSlaveZone {
        /**
         * is zone on sale.
         */
        onSale: boolean;
        /**
         * zone name(en).
         */
        zone: string;
        /**
         * zone id.
         */
        zoneId: number;
        /**
         * zone name(zh).
         */
        zoneName: string;
    }

    export interface GetSaleInfoRegionListZoneList {
        /**
         * is zone on sale.
         */
        onSale: boolean;
        /**
         * zone name(en).
         */
        zone: string;
        /**
         * zone id.
         */
        zoneId: number;
        /**
         * zone name(zh).
         */
        zoneName: string;
    }

    export interface GetSecurityGroupsList {
        /**
         * create time.
         */
        createTime: string;
        /**
         * inbound rules.
         */
        inbounds: outputs.Dcdb.GetSecurityGroupsListInbound[];
        /**
         * outbound rules.
         */
        outbounds: outputs.Dcdb.GetSecurityGroupsListOutbound[];
        /**
         * project id.
         */
        projectId: number;
        /**
         * security group id.
         */
        securityGroupId: string;
        /**
         * security group name.
         */
        securityGroupName: string;
    }

    export interface GetSecurityGroupsListInbound {
        /**
         * policy action.
         */
        action: string;
        /**
         * cidr ip.
         */
        cidrIp: string;
        /**
         * internet protocol.
         */
        ipProtocol: string;
        /**
         * port range.
         */
        portRange: string;
    }

    export interface GetSecurityGroupsListOutbound {
        /**
         * policy action.
         */
        action: string;
        /**
         * cidr ip.
         */
        cidrIp: string;
        /**
         * internet protocol.
         */
        ipProtocol: string;
        /**
         * port range.
         */
        portRange: string;
    }

    export interface GetShardSpecSpecConfig {
        /**
         * machine type.
         */
        machine: string;
        /**
         * list of machine specifications.
         */
        specConfigInfos: outputs.Dcdb.GetShardSpecSpecConfigSpecConfigInfo[];
    }

    export interface GetShardSpecSpecConfigSpecConfigInfo {
        /**
         * CPU cores.
         */
        cpu: number;
        /**
         * maximum storage size, inGB.
         */
        maxStorage: number;
        /**
         * memory, in GB.
         */
        memory: number;
        /**
         * minimum storage size, in GB.
         */
        minStorage: number;
        /**
         * node count.
         */
        nodeCount: number;
        /**
         * product price id.
         */
        pid: number;
        /**
         * maximum QPS.
         */
        qps: number;
        /**
         * recommended usage scenarios.
         */
        suitInfo: string;
    }

    export interface GetShardsList {
        /**
         * cpu cores.
         */
        cpu: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * memory, the unit is GB.
         */
        memory: number;
        /**
         * memory usage.
         */
        memoryUsage: number;
        /**
         * node count.
         */
        nodeCount: number;
        /**
         * pay mode.
         */
        paymode: string;
        /**
         * expired time.
         */
        periodEndTime: string;
        /**
         * project id.
         */
        projectId: number;
        /**
         * proxy version.
         */
        proxyVersion: string;
        /**
         * the range of shard key.
         */
        range: string;
        /**
         * region.
         */
        region: string;
        /**
         * shard instance id.
         */
        shardInstanceId: string;
        /**
         * shard master zone.
         */
        shardMasterZone: string;
        /**
         * shard serial id.
         */
        shardSerialId: string;
        /**
         * shard slave zones.
         */
        shardSlaveZones: string[];
        /**
         * status.
         */
        status: number;
        /**
         * status description.
         */
        statusDesc: string;
        /**
         * memory, the unit is GB.
         */
        storage: number;
        /**
         * storage usage.
         */
        storageUsage: number;
        /**
         * subnet id.
         */
        subnetId: string;
        /**
         * vpc id.
         */
        vpcId: string;
        /**
         * zone.
         */
        zone: string;
    }

    export interface GetSlowLogsData {
        /**
         * Statement checksum for querying details.
         */
        checkSum: string;
        /**
         * Specific name of the database to be queried.
         */
        db: string;
        /**
         * Sample SQLNote: This field may return null, indicating that no valid values can be obtained.
         */
        exampleSql: string;
        /**
         * Abstracted SQL statement.
         */
        fingerPrint: string;
        /**
         * Host address of account.
         */
        host: string;
        /**
         * Average lock time.
         */
        lockTimeAvg: string;
        /**
         * Maximum lock time.
         */
        lockTimeMax: string;
        /**
         * Minimum lock time.
         */
        lockTimeMin: string;
        /**
         * Total statement lock time.
         */
        lockTimeSum: string;
        /**
         * Total number of statement queries.
         */
        queryCount: string;
        /**
         * Average query time.
         */
        queryTimeAvg: string;
        /**
         * Maximum query time.
         */
        queryTimeMax: string;
        /**
         * Minimum query time.
         */
        queryTimeMin: string;
        /**
         * Total statement query time.
         */
        queryTimeSum: string;
        /**
         * Number of scanned rows.
         */
        rowsExaminedSum: string;
        /**
         * Number of sent rows.
         */
        rowsSentSum: string;
        /**
         * Last execution time.
         */
        tsMax: string;
        /**
         * First execution time.
         */
        tsMin: string;
        /**
         * Account.
         */
        user: string;
    }

    export interface GetUpgradePriceAddShardConfig {
        /**
         * The number of new shards.
         */
        shardCount: number;
        /**
         * Shard memory size in GB.
         */
        shardMemory: number;
        /**
         * Shard storage capacity in GB.
         */
        shardStorage: number;
    }

    export interface GetUpgradePriceExpandShardConfig {
        /**
         * List of shard ID.
         */
        shardInstanceIds: string[];
        /**
         * Shard memory size in GB.
         */
        shardMemory: number;
        /**
         * Shard node count.
         */
        shardNodeCount?: number;
        /**
         * Shard storage capacity in GB.
         */
        shardStorage: number;
    }

    export interface GetUpgradePriceSplitShardConfig {
        /**
         * List of shard ID.
         */
        shardInstanceIds: string[];
        /**
         * Shard memory size in GB.
         */
        shardMemory: number;
        /**
         * Shard storage capacity in GB.
         */
        shardStorage: number;
        /**
         * Data split ratio, fixed at 50%.
         */
        splitRate: number;
    }

    export interface HourdbInstanceResourceTag {
        /**
         * tag key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

}

export namespace Dcx {
    export interface ExtraConfigBfdInfo {
        /**
         * detect interval.
         */
        interval?: number;
        /**
         * detect times.
         */
        probeFailedTimes?: number;
    }

    export interface ExtraConfigBgpPeer {
        /**
         * user idc BGP Asn.
         */
        asn?: number;
        /**
         * user bgp key.
         */
        authKey?: string;
    }

    export interface ExtraConfigNqaInfo {
        /**
         * detect ip.
         */
        destinationIp?: string;
        /**
         * detect interval.
         */
        interval?: number;
        /**
         * detect times.
         */
        probeFailedTimes?: number;
    }

    export interface ExtraConfigRouteFilterPrefixes {
        /**
         * user network prefixes.
         */
        cidr?: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * Bandwidth of the DC.
         */
        bandwidth: number;
        /**
         * BGP ASN of the user.
         */
        bgpAsn: number;
        /**
         * BGP key of the user.
         */
        bgpAuthKey: string;
        /**
         * Creation time of resource.
         */
        createTime: string;
        /**
         * Interconnect IP of the DC within client.
         */
        customerAddress: string;
        /**
         * ID of the DC.
         */
        dcId: string;
        /**
         * ID of the DC Gateway. Currently only new in the console.
         */
        dcgId: string;
        /**
         * ID of the dedicated tunnels to be queried.
         */
        dcxId: string;
        /**
         * Name of the dedicated tunnels to be queried.
         */
        name: string;
        /**
         * The region of the dedicated tunnel.
         */
        networkRegion: string;
        /**
         * Type of the network. Valid values: `VPC`, `BMVPC` and `CCN`. The default value is `VPC`.
         */
        networkType: string;
        /**
         * Static route, the network address of the user IDC.
         */
        routeFilterPrefixes: string[];
        /**
         * Type of the route. Valid values: `BGP` and `STATIC`. The default value is `BGP`.
         */
        routeType: string;
        /**
         * State of the dedicated tunnels. Valid values: `PENDING`, `ALLOCATING`, `ALLOCATED`, `ALTERING`, `DELETING`, `DELETED`, `COMFIRMING` and `REJECTED`.
         */
        state: string;
        /**
         * Interconnect IP of the DC within Tencent.
         */
        tencentAddress: string;
        /**
         * Vlan of the dedicated tunnels.  Valid value ranges: [0-3000]. `0` means that only one tunnel can be created for the physical connect.
         */
        vlan: number;
        /**
         * ID of the VPC or BMVPC.
         */
        vpcId: string;
    }

}

export namespace Dlc {
    export interface AddUsersToWorkGroupAttachmentAddInfo {
        /**
         * User id set, matched with CAM side uin.
         */
        userIds: string[];
        /**
         * Work group id.
         */
        workGroupId: number;
    }

    export interface AttachUserPolicyOperationPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column?: string;
        /**
         * The time when the permission was created. Leave the input parameter blank.
         */
        createTime?: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine?: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function?: string;
        /**
         * Policy id.
         */
        id?: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode?: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator?: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType?: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth?: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source?: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId?: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName?: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view?: string;
    }

    export interface AttachWorkGroupPolicyOperationPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column?: string;
        /**
         * The time when the permission was created. Leave the input parameter blank.
         */
        createTime?: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine?: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function?: string;
        /**
         * Policy id.
         */
        id?: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode?: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator?: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType?: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth?: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source?: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId?: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName?: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view?: string;
    }

    export interface BindWorkGroupsToUserAttachmentAddInfo {
        /**
         * User id, matched with CAM side uin.
         */
        userId: string;
        /**
         * Work group id set.
         */
        workGroupIds: number[];
    }

    export interface DataEngineCrontabResumeSuspendStrategy {
        /**
         * Scheduled pull-up time: For example: 8 o&amp;#39;clock on Monday is expressed as 1000000-08:00:00.
         */
        resumeTime?: string;
        /**
         * Suspend configuration: 0 (default): wait for the task to end before suspending, 1: force suspend.
         */
        suspendStrategy?: number;
        /**
         * Scheduled suspension time: For example: 20 o&amp;#39;clock on Monday is expressed as 1000000-20:00:00.
         */
        suspendTime?: string;
    }

    export interface DataEngineDataEngineConfigPair {
        /**
         * Configuration items.
         */
        configItem: string;
        /**
         * Configuration value.
         */
        configValue: string;
    }

    export interface DataEngineSessionResourceTemplate {
        /**
         * Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
         */
        driverSize?: string;
        /**
         * Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
         */
        executorMaxNumbers?: number;
        /**
         * Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
         */
        executorNums?: number;
        /**
         * Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
         */
        executorSize?: string;
    }

    export interface DetachUserPolicyOperationPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column?: string;
        /**
         * The time when the permission was created. Leave the input parameter blank.
         */
        createTime?: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine?: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function?: string;
        /**
         * Policy id.
         */
        id?: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode?: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator?: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType?: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth?: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source?: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId?: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName?: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view?: string;
    }

    export interface DetachWorkGroupPolicyOperationPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column?: string;
        /**
         * The time when the permission was created. Leave the input parameter blank.
         */
        createTime?: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine?: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function?: string;
        /**
         * Policy id.
         */
        id?: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode?: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator?: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType?: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth?: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source?: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId?: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName?: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view?: string;
    }

    export interface GetCheckDataEngineConfigPairsValidityDataEngineConfigPair {
        /**
         * Configuration item.
         */
        configItem: string;
        /**
         * Configuration value.
         */
        configValue: string;
    }

    export interface GetDescribeDataEngineDataEngine {
        /**
         * Whether to automatically start the cluster, prepay not support.
         */
        autoResume: boolean;
        /**
         * Whether to automatically suspend the cluster, prepay not support.
         */
        autoSuspend: boolean;
        /**
         * Cluster automatic suspension time, default 10 minutes.
         */
        autoSuspendTime: number;
        /**
         * Engine Image version id.
         */
        childImageVersionId: string;
        /**
         * Engine VPC network segment, just like 192.0.2.1/24.
         */
        cidrBlock: string;
        /**
         * Engine cluster type, only support: spark_cu/presto_cu.
         */
        clusterType: string;
        /**
         * Create time.
         */
        createTime: number;
        /**
         * Engine crontab resume or suspend strategy, only support: 0: Wait(default), 1: Kill.
         */
        crontabResumeSuspend: number;
        /**
         * Engine auto suspend strategy, when AutoSuspend is true, CrontabResumeSuspend must stop.
         */
        crontabResumeSuspendStrategies: outputs.Dlc.GetDescribeDataEngineDataEngineCrontabResumeSuspendStrategy[];
        /**
         * Engine unique id.
         */
        dataEngineId: string;
        /**
         * Engine name.
         */
        dataEngineName: string;
        /**
         * Whether it is the default virtual cluster.
         */
        defaultDataEngine: boolean;
        /**
         * Is it the default engine?.
         */
        defaultHouse: boolean;
        /**
         * For spark Batch ExecType, yearly and monthly cluster elastic limit.
         */
        elasticLimit: number;
        /**
         * For spark Batch ExecType, yearly and monthly cluster whether to enable elasticity.
         */
        elasticSwitch: boolean;
        /**
         * Engine exec type, only support SQL(default) or BATCH.
         */
        engineExecType: string;
        /**
         * Engine type, only support: spark/presto.
         */
        engineType: string;
        /**
         * Expire time.
         */
        expireTime: string;
        /**
         * Engine major version id.
         */
        imageVersionId: string;
        /**
         * Engine image version name.
         */
        imageVersionName: string;
        /**
         * Isolated time.
         */
        isolatedTime: string;
        /**
         * Engine max cluster size,  MaxClusters less than or equal to 10 and MaxClusters bigger than MinClusters.
         */
        maxClusters: number;
        /**
         * Maximum number of concurrent tasks in a single cluster, default 5.
         */
        maxConcurrency: number;
        /**
         * Engine description information.
         */
        message: string;
        /**
         * Engine min size, greater than or equal to 1 and MaxClusters bigger than MinClusters.
         */
        minClusters: number;
        /**
         * Engine mode, only support 1: ByAmount, 2: YearlyAndMonthly.
         */
        mode: number;
        /**
         * Network connection configuration.
         */
        networkConnectionSets: outputs.Dlc.GetDescribeDataEngineDataEngineNetworkConnectionSet[];
        /**
         * Engine permissions.
         */
        permissions: string[];
        /**
         * Reference ID.
         */
        quotaId: string;
        /**
         * Automatic renewal flag, 0, initial state, automatic renewal is not performed by default. If the user has prepaid non-stop service privileges, automatic renewal will occur. 1: Automatic renewal. 2: Make it clear that there will be no automatic renewal.
         */
        renewFlag: number;
        /**
         * Engine resource type not match, only support: Standard_CU/Memory_CU(only BATCH ExecType).
         */
        resourceType: string;
        /**
         * Reversal time.
         */
        reversalTime: string;
        /**
         * For spark Batch ExecType, cluster session resource configuration template.
         */
        sessionResourceTemplates: outputs.Dlc.GetDescribeDataEngineDataEngineSessionResourceTemplate[];
        /**
         * Engine size.
         */
        size: number;
        /**
         * Automatic recovery time, prepay not support.
         */
        spendAfter: number;
        /**
         * Whether to enable the backup cluster.
         */
        startStandbyCluster: boolean;
        /**
         * Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
         */
        state: number;
        /**
         * Operator.
         */
        subAccountUin: string;
        /**
         * Tag list.
         */
        tagLists: outputs.Dlc.GetDescribeDataEngineDataEngineTagList[];
        /**
         * Tolerable queuing time, default 0. scaling may be triggered when tasks are queued for longer than the tolerable time. if this parameter is 0, it means that capacity expansion may be triggered immediately once a task is queued.
         */
        tolerableQueueTime: number;
        /**
         * Jump address of ui.
         */
        uiURL: string;
        /**
         * Update time.
         */
        updateTime: number;
        /**
         * User&amp;#39;s nickname.
         */
        userAlias: string;
        /**
         * User appid.
         */
        userAppId: number;
        /**
         * User uin.
         */
        userUin: string;
    }

    export interface GetDescribeDataEngineDataEngineCrontabResumeSuspendStrategy {
        /**
         * Scheduled pull-up time: For example: 8 o&amp;#39;clock on Monday is expressed as 1000000-08:00:00.
         */
        resumeTime: string;
        /**
         * Suspend configuration: 0 (default): wait for the task to end before suspending, 1: force suspend.
         */
        suspendStrategy: number;
        /**
         * Scheduled suspension time: For example: 20 o&amp;#39;clock on Monday is expressed as 1000000-20:00:00.
         */
        suspendTime: string;
    }

    export interface GetDescribeDataEngineDataEngineNetworkConnectionSet {
        /**
         * User appid.
         */
        appid: number;
        /**
         * Network configuration unique identifier.
         */
        associateId: string;
        /**
         * Create time.
         */
        createTime: number;
        /**
         * Datasource connection cidr block.
         */
        datasourceConnectionCidrBlock: string;
        /**
         * Data source id (obsolete).
         */
        datasourceConnectionId: string;
        /**
         * Network configuration name.
         */
        datasourceConnectionName: string;
        /**
         * Datasource connection subnet cidr block.
         */
        datasourceConnectionSubnetCidrBlock: string;
        /**
         * Datasource subnetId.
         */
        datasourceConnectionSubnetId: string;
        /**
         * Datasource vpcid.
         */
        datasourceConnectionVpcId: string;
        /**
         * Data engine id.
         */
        houseId: string;
        /**
         * Data engine name.
         */
        houseName: string;
        /**
         * Network configuration id.
         */
        id: number;
        /**
         * Network configuration description.
         */
        networkConnectionDesc: string;
        /**
         * Network configuration type.
         */
        networkConnectionType: number;
        /**
         * Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
         */
        state: number;
        /**
         * Operator.
         */
        subAccountUin: string;
        /**
         * User uin.
         */
        uin: string;
        /**
         * Update time.
         */
        updateTime: number;
    }

    export interface GetDescribeDataEngineDataEngineSessionResourceTemplate {
        /**
         * Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
         */
        driverSize: string;
        /**
         * Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
         */
        executorMaxNumbers: number;
        /**
         * Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
         */
        executorNums: number;
        /**
         * Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
         */
        executorSize: string;
    }

    export interface GetDescribeDataEngineDataEngineTagList {
        /**
         * Tag key.
         */
        tagKey: string;
        /**
         * Tag value.
         */
        tagValue: string;
    }

    export interface GetDescribeDataEngineEventsEvent {
        /**
         * Cluster information.
         */
        clusterInfos: string[];
        /**
         * Event action.
         */
        eventsActions: string[];
        /**
         * Event time.
         */
        times: string[];
    }

    export interface GetDescribeDataEngineImageVersionsImageParentVersion {
        /**
         * Image major version description.
         */
        description: string;
        /**
         * Engine type only support: SparkSQL/PrestoSQL/SparkBatch.
         */
        engineType: string;
        /**
         * Engine major version name.
         */
        imageVersion: string;
        /**
         * Engine major version id.
         */
        imageVersionId: string;
        /**
         * Create time.
         */
        insertTime: string;
        /**
         * Whether it is a public version, only support: 1: public;/2: private.
         */
        isPublic: number;
        /**
         * Is shared engine, only support: 1:yes/2:no.
         */
        isSharedEngine: number;
        /**
         * Version status, only support: 1: initialized/2: online/3: offline.
         */
        state: number;
        /**
         * Update time.
         */
        updateTime: string;
    }

    export interface GetDescribeDataEnginePythonSparkImagesPythonSparkImage {
        /**
         * Engine Image version id.
         */
        childImageVersionId: string;
        /**
         * Spark image create time.
         */
        createTime: string;
        /**
         * Spark image description information.
         */
        description: string;
        /**
         * Spark image unique id.
         */
        sparkImageId: string;
        /**
         * Spark image name.
         */
        sparkImageVersion: string;
        /**
         * Spark image update time.
         */
        updateTime: string;
    }

    export interface GetDescribeUpdatableDataEnginesDataEngineBasicInfo {
        /**
         * User unique ID.
         */
        appId: number;
        /**
         * Create time.
         */
        createTime: number;
        /**
         * Engine unique id.
         */
        dataEngineId: string;
        /**
         * Engine name.
         */
        dataEngineName: string;
        /**
         * Engine type, valid values: PrestoSQL/SparkSQL/SparkBatch.
         */
        dataEngineType: string;
        /**
         * Returned messages.
         */
        message: string;
        /**
         * Engine state, only support: 0:Init/-1:Failed/-2:Deleted/1:Pause/2:Running/3:ToBeDelete/4:Deleting.
         */
        state: number;
        /**
         * Update time.
         */
        updateTime: number;
        /**
         * User unique uin.
         */
        userUin: string;
    }

    export interface GetDescribeUserInfoFilter {
        /**
         * Attribute name. If there are multiple Filters, the relationship between Filters is a logical OR (OR) relationship.
         */
        name: string;
        /**
         * Attribute value, if there are multiple Values in the same filter, the relationship between values under the same filter is a logical OR relationship.
         */
        values: string[];
    }

    export interface GetDescribeUserInfoUserInfo {
        /**
         * Data permission information collection.
         */
        dataPolicyInfos: outputs.Dlc.GetDescribeUserInfoUserInfoDataPolicyInfo[];
        /**
         * Engine permission collection.
         */
        enginePolicyInfos: outputs.Dlc.GetDescribeUserInfoUserInfoEnginePolicyInfo[];
        /**
         * Row filter collection.
         */
        rowFilterInfos: outputs.Dlc.GetDescribeUserInfoUserInfoRowFilterInfo[];
        /**
         * Query information type, Group: work group DataAuth: data permission EngineAuth: engine permission.
         */
        type: string;
        /**
         * User alias.
         */
        userAlias: string;
        /**
         * User description.
         */
        userDescription: string;
        /**
         * User id, the same as the sub-user uin.
         */
        userId: string;
        /**
         * User type: ADMIN: Administrator COMMON: General user.
         */
        userType: string;
        /**
         * Workgroup collection information bound to this user.
         */
        workGroupInfos: outputs.Dlc.GetDescribeUserInfoUserInfoWorkGroupInfo[];
    }

    export interface GetDescribeUserInfoUserInfoDataPolicyInfo {
        /**
         * Policy set.
         */
        policySets: outputs.Dlc.GetDescribeUserInfoUserInfoDataPolicyInfoPolicySet[];
        /**
         * Total count.
         */
        totalCount: number;
    }

    export interface GetDescribeUserInfoUserInfoDataPolicyInfoPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column: string;
        /**
         * The time the workgroup was created.
         */
        createTime: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function: string;
        /**
         * Policy id.
         */
        id: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view: string;
    }

    export interface GetDescribeUserInfoUserInfoEnginePolicyInfo {
        /**
         * Policy set.
         */
        policySets: outputs.Dlc.GetDescribeUserInfoUserInfoEnginePolicyInfoPolicySet[];
        /**
         * Total count.
         */
        totalCount: number;
    }

    export interface GetDescribeUserInfoUserInfoEnginePolicyInfoPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column: string;
        /**
         * The time the workgroup was created.
         */
        createTime: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function: string;
        /**
         * Policy id.
         */
        id: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view: string;
    }

    export interface GetDescribeUserInfoUserInfoRowFilterInfo {
        /**
         * Policy set.
         */
        policySets: outputs.Dlc.GetDescribeUserInfoUserInfoRowFilterInfoPolicySet[];
        /**
         * Total count.
         */
        totalCount: number;
    }

    export interface GetDescribeUserInfoUserInfoRowFilterInfoPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column: string;
        /**
         * The time the workgroup was created.
         */
        createTime: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function: string;
        /**
         * Policy id.
         */
        id: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view: string;
    }

    export interface GetDescribeUserInfoUserInfoWorkGroupInfo {
        /**
         * Total count.
         */
        totalCount: number;
        /**
         * Work group set.
         */
        workGroupSets: outputs.Dlc.GetDescribeUserInfoUserInfoWorkGroupInfoWorkGroupSet[];
    }

    export interface GetDescribeUserInfoUserInfoWorkGroupInfoWorkGroupSet {
        /**
         * The time the workgroup was created.
         */
        createTime: string;
        /**
         * Creator.
         */
        creator: string;
        /**
         * Work group description.
         */
        workGroupDescription: string;
        /**
         * Work group unique id.
         */
        workGroupId: number;
        /**
         * Work group name.
         */
        workGroupName: string;
    }

    export interface GetDescribeUserRolesUserRole {
        /**
         * User app ID.
         */
        appId: string;
        /**
         * Role Permissions.
         */
        arn: string;
        /**
         * COS authorization path listNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        cosPermissionLists: outputs.Dlc.GetDescribeUserRolesUserRoleCosPermissionList[];
        /**
         * Creator UinNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        creator: string;
        /**
         * Character description information.
         */
        desc: string;
        /**
         * Recently modify the time stamp.
         */
        modifyTime: number;
        /**
         * CAM strategy jsonNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        permissionJson: string;
        /**
         * Character ID.
         */
        roleId: number;
        /**
         * Role NameNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        roleName: string;
        /**
         * User ID.
         */
        uin: string;
    }

    export interface GetDescribeUserRolesUserRoleCosPermissionList {
        /**
         * COS pathNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        cosPath: string;
        /**
         * Permissions [Read, WRITE]Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        permissions: string[];
    }

    export interface GetDescribeWorkGroupInfoFilter {
        /**
         * Attribute name. If there are multiple Filters, the relationship between filters is a logical or (OR) relationship.
         */
        name: string;
        /**
         * Attribute value, if there are multiple values in the same filter, the relationship between values under the same filter is a logical or relationship.
         */
        values: string[];
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfo {
        /**
         * Data permission collection.
         */
        dataPolicyInfos: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfo[];
        /**
         * Engine permission collection.
         */
        enginePolicyInfos: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfo[];
        /**
         * Row filter information collection.
         */
        rowFilterInfos: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfo[];
        /**
         * Query information type, only support: User: user information/DataAuth: data permission/EngineAuth: engine permission.
         */
        type: string;
        /**
         * A collection of users bound to the workgroup.
         */
        userInfos: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoUserInfo[];
        /**
         * Workgroup description information.
         */
        workGroupDescription: string;
        /**
         * Work group id.
         */
        workGroupId: number;
        /**
         * Work group name.
         */
        workGroupName: string;
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfo {
        /**
         * Policy set.
         */
        policySets: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoPolicySet[];
        /**
         * Total count.
         */
        totalCount: number;
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoDataPolicyInfoPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function: string;
        /**
         * Policy id.
         */
        id: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view: string;
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfo {
        /**
         * Policy set.
         */
        policySets: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoPolicySet[];
        /**
         * Total count.
         */
        totalCount: number;
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoEnginePolicyInfoPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function: string;
        /**
         * Policy id.
         */
        id: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view: string;
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfo {
        /**
         * Policy set.
         */
        policySets: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoPolicySet[];
        /**
         * Total count.
         */
        totalCount: number;
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoRowFilterInfoPolicySet {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function: string;
        /**
         * Policy id.
         */
        id: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view: string;
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoUserInfo {
        /**
         * Total count.
         */
        totalCount: number;
        /**
         * User information collection.
         */
        userSets: outputs.Dlc.GetDescribeWorkGroupInfoWorkGroupInfoUserInfoUserSet[];
    }

    export interface GetDescribeWorkGroupInfoWorkGroupInfoUserInfoUserSet {
        /**
         * Create time.
         */
        createTime: string;
        /**
         * The creator of the current user.
         */
        creator: string;
        /**
         * User alias.
         */
        userAlias: string;
        /**
         * User description.
         */
        userDescription: string;
        /**
         * User id, matches the CAM side sub-user uin.
         */
        userId: string;
    }

    export interface UpdateRowFilterOperationPolicy {
        /**
         * For the data source name that requires authorization, only * (representing all resources at this level) is supported under the administrator level; in the case of data source level and database level authentication, only COSDataCatalog or * is supported; in data table level authentication, it is possible Fill in the user-defined data source. If left blank, it defaults to DataLakeCatalog. note: If a user-defined data source is authenticated, the permissions that dlc can manage are a subset of the accounts provided by the user when accessing the data source.
         */
        catalog: string;
        /**
         * For columns that require authorization, fill in * to represent all current columns. When the authorization type is administrator level, only * is allowed.
         */
        column?: string;
        /**
         * The time when the permission was created. Leave the input parameter blank.
         */
        createTime?: string;
        /**
         * Data engines that require authorization, fill in * to represent all current engines. when the authorization type is administrator level, only * is allowed.
         */
        dataEngine?: string;
        /**
         * Database name that requires authorization, fill in * to represent all databases under the current catalog. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level, only blanks are allowed to be filled in. For other types, the database can be specified arbitrarily.
         */
        database: string;
        /**
         * For the function name that requires authorization, fill in * to represent all functions under the current catalog. when the authorization type is administrator level, only * is allowed to be filled in. When the authorization type is data connection level, only blanks are allowed to be filled in. in other types, functions can be specified arbitrarily.
         */
        function?: string;
        /**
         * Policy id.
         */
        id?: number;
        /**
         * Authorization mode, please leave this parameter blank. COMMON: normal mode; SENIOR: advanced mode.
         */
        mode?: string;
        /**
         * Authorized permission operations provide different operations for different levels of authentication. administrator permissions: ALL, default is ALL if left blank; data connection level authentication: CREATE; database level authentication: ALL, CREATE, ALTER, DROP; data table permissions: ALL, SELECT, INSERT, ALTER, DELETE, DROP, UPDATE. note: under data table permissions, only SELECT operations are supported when the specified data source is not COSDataCatalog.
         */
        operation: string;
        /**
         * Operator, do not fill in the input parameters.
         */
        operator?: string;
        /**
         * Authorization type, currently supports eight authorization types: ADMIN: Administrator level authentication DATASOURCE: data connection level authentication DATABASE: database level authentication TABLE: Table level authentication VIEW: view level authentication FUNCTION: Function level authentication COLUMN: Column level authentication ENGINE: Data engine authentication. if left blank, the default is administrator level authentication.
         */
        policyType?: string;
        /**
         * Whether the user can perform secondary authorization. when it is true, the authorized user can re-authorize the permissions obtained this time to other sub-users. default is false.
         */
        reAuth?: boolean;
        /**
         * Permission source, please leave it blank. USER: permissions come from the user itself; WORKGROUP: permissions come from the bound workgroup.
         */
        source?: string;
        /**
         * The id of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the Source field is WORKGROUP.
         */
        sourceId?: number;
        /**
         * The name of the workgroup to which the permission belongs. this value only exists when the source of the permission is a workgroup. that is, this field has a value only when the value of the source field is WORKGROUP.
         */
        sourceName?: string;
        /**
         * For the table name that requires authorization, fill in * to represent all tables under the current database. when the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. For other types, data tables can be specified arbitrarily.
         */
        table: string;
        /**
         * For views that require authorization, fill in * to represent all views under the current database. When the authorization type is administrator level, only * is allowed to be filled in. when the authorization type is data connection level or database level, only blanks are allowed to be filled in. for other types, the view can be specified arbitrarily.
         */
        view?: string;
    }

    export interface UserDataEngineConfigDataEngineConfigPair {
        /**
         * Config key.
         */
        configItem: string;
        /**
         * Config value.
         */
        configValue: string;
    }

    export interface UserDataEngineConfigSessionResourceTemplate {
        /**
         * Engine driver size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
         */
        driverSize?: string;
        /**
         * Specify the executor max number (in a dynamic configuration scenario), the minimum value is 1, and the maximum value is less than the cluster specification (when ExecutorMaxNumbers is less than ExecutorNums, the value is set to ExecutorNums).
         */
        executorMaxNumbers?: number;
        /**
         * Specify the number of executors. The minimum value is 1 and the maximum value is less than the cluster specification.
         */
        executorNums?: number;
        /**
         * Engine executor size specification only supports: small/medium/large/xlarge/m.small/m.medium/m.large/m.xlarge.
         */
        executorSize?: string;
    }

}

export namespace Dnats {
    export interface GetInstanceDnatList {
        /**
         * Description of the NAT forward.
         */
        description?: string;
        /**
         * Network address of the EIP.
         */
        elasticIp: string;
        /**
         * Port of the EIP.
         */
        elasticPort: string;
        /**
         * ID of the NAT gateway.
         */
        natId: string;
        /**
         * Network address of the backend service.
         */
        privateIp: string;
        /**
         * Port of intranet.
         */
        privatePort: string;
        /**
         * Type of the network protocol. Valid values: `TCP` and `UDP`.
         */
        protocol: string;
        /**
         * ID of the VPC.
         */
        vpcId: string;
    }

}

export namespace Dnspod {
    export interface GetDomainAnalyticsAliasData {
        /**
         * Subtotal of resolution volume for the current statistical dimension.
         */
        datas: outputs.Dnspod.GetDomainAnalyticsAliasDataData[];
        /**
         * Domain resolution volume statistics query information.
         */
        infos: outputs.Dnspod.GetDomainAnalyticsAliasDataInfo[];
    }

    export interface GetDomainAnalyticsAliasDataData {
        /**
         * For daily statistics, it is the statistical date.
         */
        dateKey: string;
        /**
         * For hourly statistics, it is the hour of the current time (0-23), for example, when HourKey is 23, the statistical period is the resolution volume from 22:00 to 23:00. Note: This field may return null, indicating that no valid value can be obtained.
         */
        hourKey: number;
        /**
         * Subtotal of resolution volume for the current statistical dimension.
         */
        num: number;
    }

    export interface GetDomainAnalyticsAliasDataInfo {
        /**
         * DATE: Statistics by day dimension HOUR: Statistics by hour dimension.
         */
        dnsFormat: string;
        /**
         * Total resolution volume for the current statistical period.
         */
        dnsTotal: number;
        /**
         * The domain name to query for resolution volume.
         */
        domain: string;
        /**
         * The end date of the query, format: YYYY-MM-DD.
         */
        endDate: string;
        /**
         * The start date of the query, format: YYYY-MM-DD.
         */
        startDate: string;
    }

    export interface GetDomainAnalyticsData {
        /**
         * For daily statistics, it is the statistical date.
         */
        dateKey: string;
        /**
         * For hourly statistics, it is the hour of the current time (0-23), for example, when HourKey is 23, the statistical period is the resolution volume from 22:00 to 23:00. Note: This field may return null, indicating that no valid value can be obtained.
         */
        hourKey: number;
        /**
         * Subtotal of resolution volume for the current statistical dimension.
         */
        num: number;
    }

    export interface GetDomainAnalyticsInfo {
        /**
         * DATE: Statistics by day dimension HOUR: Statistics by hour dimension.
         */
        dnsFormat: string;
        /**
         * Total resolution volume for the current statistical period.
         */
        dnsTotal: number;
        /**
         * The domain name to query for resolution volume.
         */
        domain: string;
        /**
         * The end date of the query, format: YYYY-MM-DD.
         */
        endDate: string;
        /**
         * The start date of the query, format: YYYY-MM-DD.
         */
        startDate: string;
    }

    export interface GetDomainListDomainList {
        /**
         * Whether to enable CNAME acceleration, enabled: ENABLE, disabled: DISABLE.
         */
        cnameSpeedup: string;
        /**
         * Domain addition time.
         */
        createdOn: string;
        /**
         * DNS settings status, error: DNSERROR, normal: empty string.
         */
        dnsStatus: string;
        /**
         * Unique identifier assigned to the domain by the system.
         */
        domainId: number;
        /**
         * Valid DNS assigned to the domain by the system.
         */
        effectiveDns: string[];
        /**
         * Domain package level code.
         */
        grade: string;
        /**
         * Sequence number corresponding to the domain package level.
         */
        gradeLevel: number;
        /**
         * Package name.
         */
        gradeTitle: string;
        /**
         * Get domain names based on domain group id, which can be obtained through the GroupId field in DescribeDomain or DescribeDomainList interface.
         */
        groupId: number;
        /**
         * Whether it is a paid package.
         */
        isVip: string;
        /**
         * Original format of the domain.
         */
        name: string;
        /**
         * Domain owner account.
         */
        owner: string;
        /**
         * Punycode encoded domain format.
         */
        punycode: string;
        /**
         * Number of records under the domain.
         */
        recordCount: number;
        /**
         * Get domain names based on remark information.
         */
        remark: string;
        /**
         * Whether to enable search engine push optimization, YES: YES, NO: NO.
         */
        searchEnginePush: string;
        /**
         * Get domain names based on domain status. Available values are ENABLE, LOCK, PAUSE, SPAM. ENABLE: Normal LOCK: Locked PAUSE: Paused SPAM: Banned.
         */
        status: string;
        /**
         * Domain-related tag list Note: This field may return null, indicating that no valid value can be obtained.
         */
        tagLists: outputs.Dnspod.GetDomainListDomainListTagList[];
        /**
         * Default TTL value for domain resolution records.
         */
        ttl: number;
        /**
         * Domain update time.
         */
        updatedOn: string;
        /**
         * Whether the domain has VIP auto-renewal enabled, YES: YES, NO: NO, DEFAULT: DEFAULT.
         */
        vipAutoRenew: string;
        /**
         * Paid package expiration time.
         */
        vipEndAt: string;
        /**
         * Paid package activation time.
         */
        vipStartAt: string;
    }

    export interface GetDomainListDomainListTagList {
        /**
         * Field to be filtered.
         */
        tagKey: string;
        /**
         * Filter value of the field.
         */
        tagValue: string;
    }

    export interface GetDomainListTag {
        /**
         * Field to be filtered.
         */
        tagKey: string;
        /**
         * Filter value of the field.
         */
        tagValues: string[];
    }

    export interface GetRecordAnalyticsAliasData {
        /**
         * The subtotal of the resolution volume for the current statistical dimension.
         */
        datas: outputs.Dnspod.GetRecordAnalyticsAliasDataData[];
        /**
         * Subdomain resolution statistics query information.
         */
        infos: outputs.Dnspod.GetRecordAnalyticsAliasDataInfo[];
    }

    export interface GetRecordAnalyticsAliasDataData {
        /**
         * For daily statistics, it is the statistical date.
         */
        dateKey: string;
        /**
         * For hourly statistics, it is the hour of the current time for statistics (0-23), e.g., when HourKey is 23, the statistical period is the resolution volume from 22:00 to 23:00. Note: This field may return null, indicating that no valid value can be obtained.
         */
        hourKey: number;
        /**
         * The subtotal of the resolution volume for the current statistical dimension.
         */
        num: number;
    }

    export interface GetRecordAnalyticsAliasDataInfo {
        /**
         * DATE: Statistics by day dimension, HOUR: Statistics by hour dimension.
         */
        dnsFormat: string;
        /**
         * Total resolution count for the current statistical period.
         */
        dnsTotal: number;
        /**
         * The domain to query for resolution volume.
         */
        domain: string;
        /**
         * The end date of the query, format: YYYY-MM-DD.
         */
        endDate: string;
        /**
         * The start date of the query, format: YYYY-MM-DD.
         */
        startDate: string;
        /**
         * The subdomain to query for resolution volume.
         */
        subdomain: string;
    }

    export interface GetRecordAnalyticsData {
        /**
         * For daily statistics, it is the statistical date.
         */
        dateKey: string;
        /**
         * For hourly statistics, it is the hour of the current time for statistics (0-23), e.g., when HourKey is 23, the statistical period is the resolution volume from 22:00 to 23:00. Note: This field may return null, indicating that no valid value can be obtained.
         */
        hourKey: number;
        /**
         * The subtotal of the resolution volume for the current statistical dimension.
         */
        num: number;
    }

    export interface GetRecordAnalyticsInfo {
        /**
         * DATE: Statistics by day dimension, HOUR: Statistics by hour dimension.
         */
        dnsFormat: string;
        /**
         * Total resolution count for the current statistical period.
         */
        dnsTotal: number;
        /**
         * The domain to query for resolution volume.
         */
        domain: string;
        /**
         * The end date of the query, format: YYYY-MM-DD.
         */
        endDate: string;
        /**
         * The start date of the query, format: YYYY-MM-DD.
         */
        startDate: string;
        /**
         * The subdomain to query for resolution volume.
         */
        subdomain: string;
    }

    export interface GetRecordLineListLineGroupList {
        /**
         * Line ID.
         */
        lineId: string;
        /**
         * Line list.
         */
        lineLists: string[];
        /**
         * Line name.
         */
        name: string;
        /**
         * Group type.
         */
        type: string;
    }

    export interface GetRecordLineListLineList {
        /**
         * Line ID.
         */
        lineId: string;
        /**
         * Line name.
         */
        name: string;
    }

    export interface GetRecordListRecordCountInfo {
        /**
         * Number of records returned in the list.
         */
        listCount: number;
        /**
         * Number of subdomains.
         */
        subdomainCount: number;
        /**
         * Total number of records.
         */
        totalCount: number;
    }

    export interface GetRecordListRecordList {
        /**
         * Whether it is the default NS record.
         */
        defaultNs: boolean;
        /**
         * Record line.
         */
        line: string;
        /**
         * Line ID.
         */
        lineId: string;
        /**
         * Record monitoring status, normal: OK, alarm: WARN, downtime: DOWN, empty if monitoring is not set or paused.
         */
        monitorStatus: string;
        /**
         * MX value, only available for MX records Note: This field may return null, indicating that no valid value can be obtained.
         */
        mx: number;
        /**
         * Host header.
         */
        name: string;
        /**
         * Record ID.
         */
        recordId: number;
        /**
         * Get the resolution record based on the resolution record remark.
         */
        remark: string;
        /**
         * Record status, enabled: ENABLE, paused: DISABLE.
         */
        status: string;
        /**
         * Record cache time.
         */
        ttl: number;
        /**
         * Record type.
         */
        type: string;
        /**
         * Update time.
         */
        updatedOn: string;
        /**
         * Record value.
         */
        value: string;
        /**
         * Record weight, used for load balancing records. Note: This field may return null, indicating that no valid value can be obtained.
         */
        weight: number;
    }

    export interface GetRecordsRecordCountInfo {
        /**
         * The count of records returned in the list.
         */
        listCount: number;
        /**
         * The subdomain count.
         */
        subdomainCount: number;
        /**
         * The total record count.
         */
        totalCount: number;
    }

    export interface GetRecordsResult {
        /**
         * The record split zone.
         */
        line: string;
        /**
         * The split zone ID.
         */
        lineId: string;
        /**
         * The monitoring status of the record. Valid values: OK (normal), WARN (warning), and DOWN (downtime). It is empty if no monitoring is set or the monitoring is suspended.
         */
        monitorStatus: string;
        /**
         * The MX value, applicable to the MX record only.
         * Note: This field may return null, indicating that no valid values can be obtained.
         */
        mx: number;
        /**
         * The host name.
         */
        name: string;
        /**
         * Record ID.
         */
        recordId: number;
        /**
         * The record remarks.
         */
        remark: string;
        /**
         * The record status. Valid values: ENABLE (enabled), DISABLE (disabled).
         */
        status: string;
        /**
         * The record cache time.
         */
        ttl: number;
        /**
         * The record type.
         */
        type: string;
        /**
         * The update time.
         */
        updatedOn: string;
        /**
         * The record value.
         */
        value: string;
        /**
         * The record weight, which is required for round-robin DNS records.
         */
        weight: number;
    }

}

export namespace Domains {
    export interface GetInstanceList {
        /**
         * Whether the domain auto renew, 0 - manual renew, 1 - auto renew.
         */
        autoRenew: number;
        /**
         * Domain buy status.
         */
        buyStatus: string;
        /**
         * Domain code ltd.
         */
        codeTld: string;
        /**
         * Domain create time.
         */
        creationDate: string;
        /**
         * Domain ID.
         */
        domainId: string;
        /**
         * Domain name.
         */
        domainName: string;
        /**
         * Domain expiration date.
         */
        expirationDate: string;
        /**
         * Whether the domain is premium.
         */
        isPremium: boolean;
        /**
         * Domain ltd.
         */
        tld: string;
    }

}

export namespace Dts {
    export interface CompareTaskObjects {
        /**
         * object items.
         */
        objectItems: outputs.Dts.CompareTaskObjectsObjectItem[];
        /**
         * object mode.
         */
        objectMode: string;
    }

    export interface CompareTaskObjectsObjectItem {
        /**
         * database mode.
         */
        dbMode: string;
        /**
         * database name.
         */
        dbName: string;
        /**
         * schema name.
         */
        schemaName: string;
        /**
         * table mode.
         */
        tableMode: string;
        /**
         * table list.
         */
        tables: outputs.Dts.CompareTaskObjectsObjectItemTable[];
        /**
         * view mode.
         */
        viewMode: string;
        /**
         * view list.
         */
        views: outputs.Dts.CompareTaskObjectsObjectItemView[];
    }

    export interface CompareTaskObjectsObjectItemTable {
        /**
         * table name.
         */
        tableName: string;
    }

    export interface CompareTaskObjectsObjectItemView {
        /**
         * view name.
         */
        viewName: string;
    }

    export interface GetCompareTasksList {
        /**
         * compare check info.
         */
        checkProcesses: outputs.Dts.GetCompareTasksListCheckProcess[];
        /**
         * compare processing info.
         */
        compareProcesses: outputs.Dts.GetCompareTasksListCompareProcess[];
        /**
         * compare task id.
         */
        compareTaskId: string;
        /**
         * conclusion.
         */
        conclusion: string;
        /**
         * config.
         */
        configs: outputs.Dts.GetCompareTasksListConfig[];
        /**
         * create time.
         */
        createdAt: string;
        /**
         * finished time.
         */
        finishedAt: string;
        /**
         * job id.
         */
        jobId: string;
        /**
         * start time.
         */
        startedAt: string;
        /**
         * compare task status, optional value is created/readyRun/running/success/stopping/failed/canceled.
         */
        status: string;
        /**
         * compare task name.
         */
        taskName: string;
    }

    export interface GetCompareTasksListCheckProcess {
        /**
         * message.
         */
        message: string;
        /**
         * progress info.
         */
        percent: number;
        /**
         * compare task status, optional value is created/readyRun/running/success/stopping/failed/canceled.
         */
        status: string;
        /**
         * all step counts.
         */
        stepAll: number;
        /**
         * current step number.
         */
        stepNow: number;
        /**
         * step info.
         */
        steps: outputs.Dts.GetCompareTasksListCheckProcessStep[];
    }

    export interface GetCompareTasksListCheckProcessStep {
        /**
         * errors info.
         */
        errors?: outputs.Dts.GetCompareTasksListCheckProcessStepError[];
        /**
         * progress info.
         */
        percent?: number;
        /**
         * start time.
         */
        startTime?: string;
        /**
         * compare task status, optional value is created/readyRun/running/success/stopping/failed/canceled.
         */
        status?: string;
        /**
         * step id.
         */
        stepId?: string;
        /**
         * step message.
         */
        stepMessage?: string;
        /**
         * step name.
         */
        stepName?: string;
        /**
         * step number.
         */
        stepNo?: number;
        /**
         * warnings info.
         */
        warnings?: outputs.Dts.GetCompareTasksListCheckProcessStepWarning[];
    }

    export interface GetCompareTasksListCheckProcessStepError {
        /**
         * help document.
         */
        helpDoc?: string;
        /**
         * message.
         */
        message?: string;
        /**
         * solution.
         */
        solution?: string;
    }

    export interface GetCompareTasksListCheckProcessStepWarning {
        /**
         * help document.
         */
        helpDoc?: string;
        /**
         * message.
         */
        message?: string;
        /**
         * solution.
         */
        solution?: string;
    }

    export interface GetCompareTasksListCompareProcess {
        /**
         * message.
         */
        message: string;
        /**
         * progress info.
         */
        percent: number;
        /**
         * compare task status, optional value is created/readyRun/running/success/stopping/failed/canceled.
         */
        status: string;
        /**
         * all step counts.
         */
        stepAll: number;
        /**
         * current step number.
         */
        stepNow: number;
        /**
         * step info.
         */
        steps: outputs.Dts.GetCompareTasksListCompareProcessStep[];
    }

    export interface GetCompareTasksListCompareProcessStep {
        /**
         * errors info.
         */
        errors?: outputs.Dts.GetCompareTasksListCompareProcessStepError[];
        /**
         * progress info.
         */
        percent?: number;
        /**
         * start time.
         */
        startTime?: string;
        /**
         * compare task status, optional value is created/readyRun/running/success/stopping/failed/canceled.
         */
        status?: string;
        /**
         * step id.
         */
        stepId?: string;
        /**
         * step message.
         */
        stepMessage?: string;
        /**
         * step name.
         */
        stepName?: string;
        /**
         * step number.
         */
        stepNo?: number;
        /**
         * warnings info.
         */
        warnings?: outputs.Dts.GetCompareTasksListCompareProcessStepWarning[];
    }

    export interface GetCompareTasksListCompareProcessStepError {
        /**
         * help document.
         */
        helpDoc?: string;
        /**
         * message.
         */
        message?: string;
        /**
         * solution.
         */
        solution?: string;
    }

    export interface GetCompareTasksListCompareProcessStepWarning {
        /**
         * help document.
         */
        helpDoc?: string;
        /**
         * message.
         */
        message?: string;
        /**
         * solution.
         */
        solution?: string;
    }

    export interface GetCompareTasksListConfig {
        /**
         * object items.
         */
        objectItems: outputs.Dts.GetCompareTasksListConfigObjectItem[];
        /**
         * object mode.
         */
        objectMode: string;
    }

    export interface GetCompareTasksListConfigObjectItem {
        /**
         * database mode.
         */
        dbMode?: string;
        /**
         * database name.
         */
        dbName?: string;
        /**
         * schema name.
         */
        schemaName?: string;
        /**
         * table mode.
         */
        tableMode?: string;
        /**
         * table list.
         */
        tables?: outputs.Dts.GetCompareTasksListConfigObjectItemTable[];
        /**
         * view mode.
         */
        viewMode?: string;
        /**
         * view list.
         */
        views?: outputs.Dts.GetCompareTasksListConfigObjectItemView[];
    }

    export interface GetCompareTasksListConfigObjectItemTable {
        /**
         * table name.
         */
        tableName?: string;
    }

    export interface GetCompareTasksListConfigObjectItemView {
        /**
         * view name.
         */
        viewName?: string;
    }

    export interface GetMigrateDbInstancesInstance {
        /**
         * The reason of can&#39;t used in migration.
         */
        hint: string;
        /**
         * Database instance id.
         */
        instanceId: string;
        /**
         * Database instance name.
         */
        instanceName: string;
        /**
         * Can used in migration, 1-yes, 0-no.
         */
        usable: number;
        /**
         * Instance vip.
         */
        vip: string;
        /**
         * Instance port.
         */
        vport: number;
    }

    export interface GetMigrateJobsList {
        /**
         * action info.
         */
        actions: outputs.Dts.GetMigrateJobsListAction[];
        /**
         * brief message for migrate error.
         */
        briefMsg: string;
        /**
         * compare task info.
         */
        compareTasks: outputs.Dts.GetMigrateJobsListCompareTask[];
        /**
         * create time.
         */
        createTime: string;
        /**
         * destination info.
         */
        dstInfos: outputs.Dts.GetMigrateJobsListDstInfo[];
        /**
         * end time.
         */
        endTime: string;
        /**
         * expected run time.
         */
        expectRunTime: string;
        /**
         * job id.
         */
        jobId: string;
        /**
         * job name.
         */
        jobName: string;
        /**
         * run mode.
         */
        runMode?: string;
        /**
         * source info.
         */
        srcInfos: outputs.Dts.GetMigrateJobsListSrcInfo[];
        /**
         * start time.
         */
        startTime: string;
        /**
         * migrate status.
         */
        status: string;
        /**
         * step infos.
         */
        stepInfos: outputs.Dts.GetMigrateJobsListStepInfo[];
        /**
         * tag list.
         */
        tags: outputs.Dts.GetMigrateJobsListTag[];
        /**
         * trade info.
         */
        tradeInfos: outputs.Dts.GetMigrateJobsListTradeInfo[];
        /**
         * update time.
         */
        updateTime: string;
    }

    export interface GetMigrateJobsListAction {
        /**
         * all action list.
         */
        allActions: string[];
        /**
         * allowed action list.
         */
        allowedActions: string[];
    }

    export interface GetMigrateJobsListCompareTask {
        /**
         * compare task id.
         */
        compareTaskId: string;
        /**
         * migrate status.
         */
        status: string;
    }

    export interface GetMigrateJobsListDstInfo {
        /**
         * access type.
         */
        accessType: string;
        /**
         * database type.
         */
        databaseType: string;
        /**
         * db info.
         */
        infos: outputs.Dts.GetMigrateJobsListDstInfoInfo[];
        /**
         * node type.
         */
        nodeType: string;
        /**
         * region.
         */
        region: string;
    }

    export interface GetMigrateJobsListDstInfoInfo {
        /**
         * account.
         */
        account: string;
        /**
         * account mode.
         */
        accountMode: string;
        /**
         * account role.
         */
        accountRole: string;
        /**
         * ccn gateway id.
         */
        ccnGwId: string;
        /**
         * cvm instance id.
         */
        cvmInstanceId: string;
        /**
         * database kernel.
         */
        dbKernel: string;
        /**
         * engine version.
         */
        engineVersion: string;
        /**
         * host.
         */
        host: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * password.
         */
        password: string;
        /**
         * port.
         */
        port: number;
        /**
         * node role.
         */
        role: string;
        /**
         * subnet id.
         */
        subnetId: string;
        /**
         * temporary secret id.
         */
        tmpSecretId: string;
        /**
         * temporary secret key.
         */
        tmpSecretKey: string;
        /**
         * temporary token.
         */
        tmpToken: string;
        /**
         * vpn gateway id.
         */
        uniqVpnGwId: string;
        /**
         * user.
         */
        user: string;
        /**
         * vpc id.
         */
        vpcId: string;
    }

    export interface GetMigrateJobsListSrcInfo {
        /**
         * access type.
         */
        accessType: string;
        /**
         * database type.
         */
        databaseType: string;
        /**
         * extra attributes.
         */
        extraAttrs: outputs.Dts.GetMigrateJobsListSrcInfoExtraAttr[];
        /**
         * db info.
         */
        infos: outputs.Dts.GetMigrateJobsListSrcInfoInfo[];
        /**
         * node type.
         */
        nodeType: string;
        /**
         * region.
         */
        region: string;
        /**
         * supplier.
         */
        supplier: string;
    }

    export interface GetMigrateJobsListSrcInfoExtraAttr {
        /**
         * key.
         */
        key: string;
        /**
         * value.
         */
        value: string;
    }

    export interface GetMigrateJobsListSrcInfoInfo {
        /**
         * account.
         */
        account: string;
        /**
         * account mode.
         */
        accountMode: string;
        /**
         * account role.
         */
        accountRole: string;
        /**
         * ccn gateway id.
         */
        ccnGwId: string;
        /**
         * cvm instance id.
         */
        cvmInstanceId: string;
        /**
         * database kernel.
         */
        dbKernel: string;
        /**
         * engine version.
         */
        engineVersion: string;
        /**
         * host.
         */
        host: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * password.
         */
        password: string;
        /**
         * port.
         */
        port: number;
        /**
         * node role.
         */
        role: string;
        /**
         * subnet id.
         */
        subnetId: string;
        /**
         * temporary secret id.
         */
        tmpSecretId: string;
        /**
         * temporary secret key.
         */
        tmpSecretKey: string;
        /**
         * temporary token.
         */
        tmpToken: string;
        /**
         * vpn gateway id.
         */
        uniqVpnGwId: string;
        /**
         * user.
         */
        user: string;
        /**
         * vpc id.
         */
        vpcId: string;
    }

    export interface GetMigrateJobsListStepInfo {
        /**
         * master slave distance.
         */
        masterSlaveDistance: number;
        /**
         * seconds behind master.
         */
        secondsBehindMaster: number;
        /**
         * number of all steps.
         */
        stepAll: number;
        /**
         * step infos.
         */
        stepInfos: outputs.Dts.GetMigrateJobsListStepInfoStepInfo[];
        /**
         * current step.
         */
        stepNow: number;
    }

    export interface GetMigrateJobsListStepInfoStepInfo {
        /**
         * error list.
         */
        errors: outputs.Dts.GetMigrateJobsListStepInfoStepInfoError[];
        /**
         * the percent of miragtion progress.
         */
        percent: number;
        /**
         * start time.
         */
        startTime: string;
        /**
         * migrate status.
         */
        status: string;
        /**
         * step id.
         */
        stepId: string;
        /**
         * step message.
         */
        stepMessage: string;
        /**
         * step name.
         */
        stepName: string;
        /**
         * step number.
         */
        stepNo: number;
        /**
         * warning list.
         */
        warnings: outputs.Dts.GetMigrateJobsListStepInfoStepInfoWarning[];
    }

    export interface GetMigrateJobsListStepInfoStepInfoError {
        /**
         * help document.
         */
        helpDoc: string;
        /**
         * message.
         */
        message: string;
        /**
         * solution.
         */
        solution: string;
    }

    export interface GetMigrateJobsListStepInfoStepInfoWarning {
        /**
         * help document.
         */
        helpDoc: string;
        /**
         * message.
         */
        message: string;
        /**
         * solution.
         */
        solution: string;
    }

    export interface GetMigrateJobsListTag {
        /**
         * tag key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

    export interface GetMigrateJobsListTradeInfo {
        /**
         * billing type.
         */
        billingType: string;
        /**
         * deal name.
         */
        dealName: string;
        /**
         * expired time.
         */
        expireTime: string;
        /**
         * instance class.
         */
        instanceClass: string;
        /**
         * isolate reason.
         */
        isolateReason: string;
        /**
         * isolate time.
         */
        isolateTime: string;
        /**
         * last deal name.
         */
        lastDealName: string;
        /**
         * offline reason.
         */
        offlineReason: string;
        /**
         * offline time.
         */
        offlineTime: string;
        /**
         * pay type.
         */
        payType: string;
        /**
         * trade status.
         */
        tradeStatus: string;
    }

    export interface GetMigrateJobsTagFilter {
        /**
         * tag key.
         */
        tagKey?: string;
        /**
         * tag value.
         */
        tagValue?: string;
    }

    export interface GetSyncJobsList {
        /**
         * support action list for current status.
         */
        actions: string[];
        /**
         * all action list.
         */
        allActions: string[];
        /**
         * create time.
         */
        createTime: string;
        /**
         * tag list.
         */
        details: outputs.Dts.GetSyncJobsListDetail[];
        /**
         * destination access type.
         */
        dstAccessType: string;
        /**
         * destination database type.
         */
        dstDatabaseType: string;
        /**
         * destination info.
         */
        dstInfos: outputs.Dts.GetSyncJobsListDstInfo[];
        /**
         * destination region.
         */
        dstRegion: string;
        /**
         * end time.
         */
        endTime: string;
        /**
         * expected run time.
         */
        expectRunTime: string;
        /**
         * expire time.
         */
        expireTime: string;
        /**
         * job id.
         */
        jobId: string;
        /**
         * job name.
         */
        jobName: string;
        /**
         * objects.
         */
        objects: outputs.Dts.GetSyncJobsListObject[];
        /**
         * options.
         */
        options: outputs.Dts.GetSyncJobsListOption[];
        /**
         * pay mode, optional value is PrePay or PostPay.
         */
        payMode: string;
        /**
         * run mode, optional value is mmediate or Timed.
         */
        runMode: string;
        /**
         * specification.
         */
        specification: string;
        /**
         * source access type.
         */
        srcAccessType: string;
        /**
         * source database type.
         */
        srcDatabaseType: string;
        /**
         * source info.
         */
        srcInfos: outputs.Dts.GetSyncJobsListSrcInfo[];
        /**
         * source region.
         */
        srcRegion: string;
        /**
         * start time.
         */
        startTime: string;
        /**
         * status.
         */
        status: string;
        /**
         * tag list.
         */
        tags: outputs.Dts.GetSyncJobsListTag[];
    }

    export interface GetSyncJobsListDetail {
        /**
         * current step progress.
         */
        currentStepProgress: number;
        /**
         * master slave distance.
         */
        masterSlaveDistance: number;
        /**
         * message.
         */
        message: string;
        /**
         * current step progress.
         */
        progress: number;
        /**
         * seconds behind master.
         */
        secondsBehindMaster: number;
        /**
         * total step numbers.
         */
        stepAll: number;
        /**
         * step infos.
         */
        stepInfos: outputs.Dts.GetSyncJobsListDetailStepInfo[];
        /**
         * current step number.
         */
        stepNow: number;
    }

    export interface GetSyncJobsListDetailStepInfo {
        /**
         * error list.
         */
        errors: outputs.Dts.GetSyncJobsListDetailStepInfoError[];
        /**
         * current step progress.
         */
        progress: number;
        /**
         * start time.
         */
        startTime: string;
        /**
         * status.
         */
        status: string;
        /**
         * step id.
         */
        stepId: string;
        /**
         * step name.
         */
        stepName: string;
        /**
         * step number.
         */
        stepNo: number;
        /**
         * waring list.
         */
        warnings: outputs.Dts.GetSyncJobsListDetailStepInfoWarning[];
    }

    export interface GetSyncJobsListDetailStepInfoError {
        /**
         * code.
         */
        code: string;
        /**
         * help document.
         */
        helpDoc: string;
        /**
         * message.
         */
        message: string;
        /**
         * solution.
         */
        solution: string;
    }

    export interface GetSyncJobsListDetailStepInfoWarning {
        /**
         * code.
         */
        code: string;
        /**
         * help document.
         */
        helpDoc: string;
        /**
         * message.
         */
        message: string;
        /**
         * solution.
         */
        solution: string;
    }

    export interface GetSyncJobsListDstInfo {
        /**
         * account.
         */
        account: string;
        /**
         * account mode.
         */
        accountMode: string;
        /**
         * account role.
         */
        accountRole: string;
        /**
         * ccn id.
         */
        ccnId: string;
        /**
         * cvm instance id.
         */
        cvmInstanceId: string;
        /**
         * database kernel.
         */
        dbKernel: string;
        /**
         * database name.
         */
        dbName: string;
        /**
         * engine version.
         */
        engineVersion: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * ip.
         */
        ip: string;
        /**
         * password.
         */
        password: string;
        /**
         * port.
         */
        port: number;
        /**
         * region.
         */
        region: string;
        /**
         * subnet id.
         */
        subnetId: string;
        /**
         * supplier.
         */
        supplier: string;
        /**
         * temporary secret id.
         */
        tmpSecretId: string;
        /**
         * temporary secret key.
         */
        tmpSecretKey: string;
        /**
         * temporary token.
         */
        tmpToken: string;
        /**
         * dedicated gateway id.
         */
        uniqDcgId: string;
        /**
         * vpn gateway id.
         */
        uniqVpnGwId: string;
        /**
         * user.
         */
        user: string;
        /**
         * vpc id.
         */
        vpcId: string;
    }

    export interface GetSyncJobsListObject {
        /**
         * advanced objects.
         */
        advancedObjects: string[];
        /**
         * database list.
         */
        databases: outputs.Dts.GetSyncJobsListObjectDatabase[];
        /**
         * object mode.
         */
        mode: string;
    }

    export interface GetSyncJobsListObjectDatabase {
        /**
         * database mode.
         */
        dbMode: string;
        /**
         * database name.
         */
        dbName: string;
        /**
         * function mode.
         */
        functionMode: string;
        /**
         * functions.
         */
        functions: string[];
        /**
         * new database name.
         */
        newDbName: string;
        /**
         * new schema name.
         */
        newSchemaName: string;
        /**
         * procedure mode.
         */
        procedureMode: string;
        /**
         * procedures.
         */
        procedures: string[];
        /**
         * schema name.
         */
        schemaName: string;
        /**
         * table mode.
         */
        tableMode: string;
        /**
         * table list.
         */
        tables: outputs.Dts.GetSyncJobsListObjectDatabaseTable[];
        /**
         * view mode.
         */
        viewMode: string;
        /**
         * view list.
         */
        views: outputs.Dts.GetSyncJobsListObjectDatabaseView[];
    }

    export interface GetSyncJobsListObjectDatabaseTable {
        /**
         * filter condition.
         */
        filterCondition: string;
        /**
         * new table name.
         */
        newTableName: string;
        /**
         * table name.
         */
        tableName: string;
    }

    export interface GetSyncJobsListObjectDatabaseView {
        /**
         * new view name.
         */
        newViewName: string;
        /**
         * view name.
         */
        viewName: string;
    }

    export interface GetSyncJobsListOption {
        /**
         * add additional column.
         */
        addAdditionalColumn: boolean;
        /**
         * conflict handle option.
         */
        conflictHandleOptions: outputs.Dts.GetSyncJobsListOptionConflictHandleOption[];
        /**
         * conflict handle type.
         */
        conflictHandleType: string;
        /**
         * ddl options.
         */
        ddlOptions: outputs.Dts.GetSyncJobsListOptionDdlOption[];
        /**
         * deal of exist same table.
         */
        dealOfExistSameTable: string;
        /**
         * init type.
         */
        initType: string;
        /**
         * operation types.
         */
        opTypes: string[];
    }

    export interface GetSyncJobsListOptionConflictHandleOption {
        /**
         * condition column.
         */
        conditionColumn: string;
        /**
         * condition override operator.
         */
        conditionOperator: string;
        /**
         * condition order in source and destination.
         */
        conditionOrderInSrcAndDst: string;
    }

    export interface GetSyncJobsListOptionDdlOption {
        /**
         * ddl object.
         */
        ddlObject: string;
        /**
         * ddl value.
         */
        ddlValues: string[];
    }

    export interface GetSyncJobsListSrcInfo {
        /**
         * account.
         */
        account: string;
        /**
         * account mode.
         */
        accountMode: string;
        /**
         * account role.
         */
        accountRole: string;
        /**
         * ccn id.
         */
        ccnId: string;
        /**
         * cvm instance id.
         */
        cvmInstanceId: string;
        /**
         * database kernel.
         */
        dbKernel: string;
        /**
         * database name.
         */
        dbName: string;
        /**
         * engine version.
         */
        engineVersion: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * ip.
         */
        ip: string;
        /**
         * password.
         */
        password: string;
        /**
         * port.
         */
        port: number;
        /**
         * region.
         */
        region: string;
        /**
         * subnet id.
         */
        subnetId: string;
        /**
         * supplier.
         */
        supplier: string;
        /**
         * temporary secret id.
         */
        tmpSecretId: string;
        /**
         * temporary secret key.
         */
        tmpSecretKey: string;
        /**
         * temporary token.
         */
        tmpToken: string;
        /**
         * dedicated gateway id.
         */
        uniqDcgId: string;
        /**
         * vpn gateway id.
         */
        uniqVpnGwId: string;
        /**
         * user.
         */
        user: string;
        /**
         * vpc id.
         */
        vpcId: string;
    }

    export interface GetSyncJobsListTag {
        /**
         * tag key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

    export interface GetSyncJobsTagFilter {
        /**
         * tag key.
         */
        tagKey?: string;
        /**
         * tag value.
         */
        tagValue?: string;
    }

    export interface MigrateJobDstInfo {
        /**
         * AccessType.
         */
        accessType: string;
        /**
         * DatabaseType.
         */
        databaseType: string;
        /**
         * ExtraAttr.
         */
        extraAttrs?: outputs.Dts.MigrateJobDstInfoExtraAttr[];
        /**
         * Info.
         */
        infos: outputs.Dts.MigrateJobDstInfoInfo[];
        /**
         * NodeType.
         */
        nodeType: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Supplier.
         */
        supplier?: string;
    }

    export interface MigrateJobDstInfoExtraAttr {
        /**
         * Key.
         */
        key?: string;
        /**
         * Value.
         */
        value?: string;
    }

    export interface MigrateJobDstInfoInfo {
        /**
         * Account.
         */
        account?: string;
        /**
         * AccountMode.
         */
        accountMode?: string;
        /**
         * AccountRole.
         */
        accountRole?: string;
        /**
         * CcnGwId.
         */
        ccnGwId?: string;
        /**
         * CvmInstanceId.
         */
        cvmInstanceId?: string;
        /**
         * DbKernel.
         */
        dbKernel?: string;
        /**
         * EngineVersion.
         */
        engineVersion: string;
        /**
         * Host.
         */
        host?: string;
        /**
         * InstanceId.
         */
        instanceId?: string;
        /**
         * Password.
         */
        password?: string;
        /**
         * Port.
         */
        port?: number;
        /**
         * Role.
         */
        role?: string;
        /**
         * SubnetId.
         */
        subnetId?: string;
        /**
         * TmpSecretId.
         */
        tmpSecretId?: string;
        /**
         * TmpSecretKey.
         */
        tmpSecretKey?: string;
        /**
         * TmpToken.
         */
        tmpToken?: string;
        /**
         * UniqDcgId.
         */
        uniqDcgId?: string;
        /**
         * UniqVpnGwId.
         */
        uniqVpnGwId?: string;
        /**
         * User.
         */
        user?: string;
        /**
         * VpcId.
         */
        vpcId?: string;
    }

    export interface MigrateJobMigrateOption {
        /**
         * Consistency.
         */
        consistency: outputs.Dts.MigrateJobMigrateOptionConsistency;
        /**
         * Migration object option, you need to tell the migration service which library table objects to migrate.
         */
        databaseTable: outputs.Dts.MigrateJobMigrateOptionDatabaseTable;
        /**
         * ExtraAttr.
         */
        extraAttrs?: outputs.Dts.MigrateJobMigrateOptionExtraAttr[];
        /**
         * IsDstReadOnly.
         */
        isDstReadOnly?: boolean;
        /**
         * IsMigrateAccount.
         */
        isMigrateAccount?: boolean;
        /**
         * IsOverrideRoot.
         */
        isOverrideRoot?: boolean;
        /**
         * MigrateType.
         */
        migrateType: string;
    }

    export interface MigrateJobMigrateOptionConsistency {
        /**
         * ConsistencyOption.
         */
        mode?: string;
    }

    export interface MigrateJobMigrateOptionDatabaseTable {
        /**
         * AdvancedObjects.
         */
        advancedObjects: string[];
        /**
         * The database list.
         */
        databases?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabase[];
        /**
         * Object mode. eg:all,partial.
         */
        objectMode: string;
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabase {
        /**
         * DB selection mode:all (for all objects under the current object), partial (partial objects), when the ObjectMode is partial, this item is required.
         */
        dbMode?: string;
        /**
         * database name.
         */
        dbName?: string;
        /**
         * EventMode.
         */
        eventMode?: string;
        /**
         * Events.
         */
        events: string[];
        /**
         * FunctionMode.
         */
        functionMode?: string;
        /**
         * Functions.
         */
        functions: string[];
        /**
         * New database name.
         */
        newDbName?: string;
        /**
         * schema name after migration or synchronization.
         */
        newSchemaName?: string;
        /**
         * ProcedureMode.
         */
        procedureMode?: string;
        /**
         * Procedures.
         */
        procedures: string[];
        /**
         * RoleMode.
         */
        roleMode?: string;
        /**
         * Roles.
         */
        roles?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabaseRole[];
        /**
         * schema mode: all,partial.
         */
        schemaMode?: string;
        /**
         * schema name.
         */
        schemaName?: string;
        /**
         * table mode: all,partial.
         */
        tableMode?: string;
        /**
         * tables list.
         */
        tables?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabaseTable[];
        /**
         * TriggerMode.
         */
        triggerMode?: string;
        /**
         * Triggers.
         */
        triggers: string[];
        /**
         * ViewMode.
         */
        viewMode?: string;
        /**
         * Views.
         */
        views?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabaseView[];
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabaseRole {
        /**
         * NewRoleName.
         */
        newRoleName?: string;
        /**
         * RoleName.
         */
        roleName?: string;
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabaseTable {
        /**
         * new table name.
         */
        newTableName?: string;
        /**
         * table edit mode.
         */
        tableEditMode?: string;
        /**
         * table name.
         */
        tableName?: string;
        /**
         * temporary tables.
         */
        tmpTables: string[];
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabaseView {
        /**
         * NewViewName.
         */
        newViewName?: string;
        /**
         * ViewName.
         */
        viewName?: string;
    }

    export interface MigrateJobMigrateOptionExtraAttr {
        /**
         * Key.
         */
        key?: string;
        /**
         * Value.
         */
        value?: string;
    }

    export interface MigrateJobSrcInfo {
        /**
         * AccessType.
         */
        accessType: string;
        /**
         * DatabaseType.
         */
        databaseType: string;
        /**
         * ExtraAttr.
         */
        extraAttrs?: outputs.Dts.MigrateJobSrcInfoExtraAttr[];
        /**
         * Info.
         */
        infos: outputs.Dts.MigrateJobSrcInfoInfo[];
        /**
         * NodeType.
         */
        nodeType: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Supplier.
         */
        supplier?: string;
    }

    export interface MigrateJobSrcInfoExtraAttr {
        /**
         * Key.
         */
        key?: string;
        /**
         * Value.
         */
        value?: string;
    }

    export interface MigrateJobSrcInfoInfo {
        /**
         * Account.
         */
        account?: string;
        /**
         * AccountMode.
         */
        accountMode?: string;
        /**
         * AccountRole.
         */
        accountRole?: string;
        /**
         * CcnGwId.
         */
        ccnGwId?: string;
        /**
         * CvmInstanceId.
         */
        cvmInstanceId?: string;
        /**
         * DbKernel.
         */
        dbKernel?: string;
        /**
         * EngineVersion.
         */
        engineVersion: string;
        /**
         * Host.
         */
        host?: string;
        /**
         * InstanceId.
         */
        instanceId?: string;
        /**
         * Password.
         */
        password?: string;
        /**
         * Port.
         */
        port?: number;
        /**
         * Role.
         */
        role?: string;
        /**
         * SubnetId.
         */
        subnetId?: string;
        /**
         * TmpSecretId.
         */
        tmpSecretId?: string;
        /**
         * TmpSecretKey.
         */
        tmpSecretKey?: string;
        /**
         * TmpToken.
         */
        tmpToken?: string;
        /**
         * UniqDcgId.
         */
        uniqDcgId?: string;
        /**
         * UniqVpnGwId.
         */
        uniqVpnGwId?: string;
        /**
         * User.
         */
        user?: string;
        /**
         * VpcId.
         */
        vpcId?: string;
    }

    export interface MigrateServiceTag {
        /**
         * tag key.
         */
        tagKey?: string;
        /**
         * tag value.
         */
        tagValue?: string;
    }

    export interface SyncConfigDstInfo {
        /**
         * The account to which the instance belongs. This field is required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        account?: string;
        /**
         * The account to which the resource belongs is empty or self (represents resources within this account), other (represents cross-account resources). Note: This field may return null, indicating that no valid value can be obtained.
         */
        accountMode?: string;
        /**
         * The role during cross-account synchronization, only [a-zA-Z0-9-_]+ is allowed, if it is a cross-account instance, this field is required. Note: This field may return null, indicating that no valid value can be obtained.
         */
        accountRole?: string;
        /**
         * Cloud networking ID, which is required for the cloud networking access type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ccnId?: string;
        /**
         * CVM instance short ID, which is the same as the instance ID displayed on the cloud server console page. If it is a self-built instance of CVM, this field needs to be passed. Note: This field may return null, indicating that no valid value can be obtained.
         */
        cvmInstanceId?: string;
        /**
         * The network environment to which the database belongs. It is required when AccessType is Cloud Network (CCN). `UserIDC` represents the user IDC. `TencentVPC` represents Tencent Cloud VPC. Note: This field may return null, indicating that no valid value can be obtained.
         */
        databaseNetEnv?: string;
        /**
         * Database kernel type, used to distinguish different kernels in tdsql: percona, mariadb, mysql. Note: This field may return null, indicating that no valid value can be obtained.
         */
        dbKernel?: string;
        /**
         * Database name, when the database is cdwpg, it needs to be provided. Note: This field may return null, indicating that no valid value can be obtained.
         */
        dbName?: string;
        /**
         * Whether to use encrypted transmission, UnEncrypted means not to use encrypted transmission, Encrypted means to use encrypted transmission, the default is UnEncrypted. Note: This field may return null, indicating that no valid value can be obtained.
         */
        encryptConn?: string;
        /**
         * Database version, valid only when the instance is an RDS instance, ignored by other instances, the format is: 5.6 or 5.7, the default is 5.6. Note: This field may return null, indicating that no valid value can be obtained.
         */
        engineVersion?: string;
        /**
         * Database instance id. Note: This field may return null, indicating that no valid value can be obtained.
         */
        instanceId?: string;
        /**
         * The IP address of the instance, which is required when the access type is non-cdb. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ip?: string;
        /**
         * Password, required for instances that require username and password authentication for access. Note: This field may return null, indicating that no valid value can be obtained.
         */
        password: string;
        /**
         * Instance port, this item is required when the access type is non-cdb. Note: This field may return null, indicating that no valid value can be obtained.
         */
        port?: number;
        /**
         * The english name of region. Note: This field may return null, indicating that no valid value can be obtained.
         */
        region?: string;
        /**
         * The node type of tdsql mysql version, the enumeration value is proxy, set. Note: This field may return null, indicating that no valid value can be obtained.
         */
        role?: string;
        /**
         * External role id. Note: This field may return null, indicating that no valid value can be obtained.
         */
        roleExternalId?: string;
        /**
         * The subnet ID under the private network, this item is required for the private network, leased line, and VPN access methods. Note: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId?: string;
        /**
         * Cloud vendor type, when the instance is an RDS instance, fill in aliyun, in other cases fill in others, the default is others. Note: This field may return null, indicating that no valid value can be obtained.
         */
        supplier?: string;
        /**
         * Temporary key Id, required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tmpSecretId?: string;
        /**
         * Temporary key Key, required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tmpSecretKey?: string;
        /**
         * Temporary Token, required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tmpToken?: string;
        /**
         * Leased line gateway ID, which is required for the leased line access type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        uniqDcgId?: string;
        /**
         * VPN gateway ID, which is required for the VPN access type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        uniqVpnGwId?: string;
        /**
         * Username, required for instances that require username and password authentication for access. Note: This field may return null, indicating that no valid value can be obtained.
         */
        user?: string;
        /**
         * Private network ID, which is required for access methods of private network, leased line, and VPN. Note: This field may return null, indicating that no valid value can be obtained.
         */
        vpcId?: string;
    }

    export interface SyncConfigObjects {
        /**
         * For advanced object types, such as function and procedure, when an advanced object needs to be synchronized, the initialization type must include the structure initialization type, that is, the value of the Options.InitType field is Structure or Full. Note: This field may return null, indicating that no valid value can be obtained.
         */
        advancedObjects: string[];
        /**
         * Synchronization object, not null when Mode is Partial. Note: This field may return null, indicating that no valid value can be obtained.
         */
        databases: outputs.Dts.SyncConfigObjectsDatabase[];
        /**
         * Migration object type Partial (partial object). Note: This field may return null, indicating that no valid value can be obtained.
         */
        mode?: string;
        /**
         * OnlineDDL type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        onlineDdl: outputs.Dts.SyncConfigObjectsOnlineDdl;
    }

    export interface SyncConfigObjectsDatabase {
        /**
         * DB selection mode: All (for all objects under the current object), Partial (for some objects), when the Mode is Partial, this item is required. Note that synchronization of advanced objects does not depend on this value. Note: This field may return null, indicating that no valid value can be obtained.
         */
        dbMode?: string;
        /**
         * The name of the library that needs to be migrated or synchronized. This item is required when the ObjectMode is Partial. Note: This field may return null, indicating that no valid value can be obtained.
         */
        dbName?: string;
        /**
         * Event migration mode, all (for all objects under the current object), partial (partial objects). Note: This field may return null, indicating that no valid value can be obtained.
         */
        eventMode?: string;
        /**
         * When EventMode is partial, specify the name of the event to be migrated. Note: This field may return null, indicating that no valid value can be obtained.
         */
        events: string[];
        /**
         * Select the mode to be synchronized, Partial is a part, all is an entire selection. Note: This field may return null, indicating that no valid value can be obtained.
         */
        functionMode?: string;
        /**
         * Required when the FunctionMode value is Partial. Note: This field may return null, indicating that no valid value can be obtained.
         */
        functions: string[];
        /**
         * The name of the library after migration or synchronization, which is the same as the source library by default. Note: This field may return null, indicating that no valid value can be obtained.
         */
        newDbName?: string;
        /**
         * Schema name after migration or synchronization. Note: This field may return null, indicating that no valid value can be obtained.
         */
        newSchemaName?: string;
        /**
         * Select the mode to be synchronized, Partial is part, All is the whole selection. Note: This field may return null, indicating that no valid value can be obtained.
         */
        procedureMode?: string;
        /**
         * Required when the value of ProcedureMode is Partial. Note: This field may return null, indicating that no valid value can be obtained.
         */
        procedures: string[];
        /**
         * Migrated or synchronized schemaNote: This field may return null, indicating that no valid value can be obtained.
         */
        schemaName?: string;
        /**
         * Table selection mode: All (for all objects under the current object), Partial (for some objects), this item is required when the DBMode is Partial. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tableMode?: string;
        /**
         * A collection of table graph objects, when TableMode is Partial, this item needs to be filled in. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tables?: outputs.Dts.SyncConfigObjectsDatabaseTable[];
        /**
         * Trigger migration mode, all (for all objects under the current object), partial (partial objects). Note: This field may return null, indicating that no valid value can be obtained.
         */
        triggerMode?: string;
        /**
         * When TriggerMode is partial, specify the name of the trigger to be migrated. Note: This field may return null, indicating that no valid value can be obtained.
         */
        triggers: string[];
        /**
         * View selection mode: All is all view objects under the current object, Partial is part of the view objects. Note: This field may return null, indicating that no valid value can be obtained.
         */
        viewMode?: string;
        /**
         * View object collection, when ViewMode is Partial, this item needs to be filled in. Note: This field may return null, indicating that no valid value can be obtained.
         */
        views?: outputs.Dts.SyncConfigObjectsDatabaseView[];
    }

    export interface SyncConfigObjectsDatabaseTable {
        /**
         * Filter condition. Note: This field may return null, indicating that no valid value can be obtained.
         */
        filterCondition?: string;
        /**
         * New table name. Note: This field may return null, indicating that no valid value can be obtained.
         */
        newTableName?: string;
        /**
         * Table name. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tableName?: string;
    }

    export interface SyncConfigObjectsDatabaseView {
        /**
         * New view name. Note: This field may return null, indicating that no valid value can be obtained.
         */
        newViewName?: string;
        /**
         * View name. Note: This field may return null, indicating that no valid value can be obtained.
         */
        viewName?: string;
    }

    export interface SyncConfigObjectsOnlineDdl {
        /**
         * status.
         */
        status?: string;
    }

    export interface SyncConfigOptions {
        /**
         * Whether to add additional columns. Note: This field may return null, indicating that no valid value can be obtained.
         */
        addAdditionalColumn: boolean;
        /**
         * Detailed options for conflict handling, such as conditional rows and conditional actions in conditional overrides. Note: This field may return null, indicating that no valid value can be obtained.
         */
        conflictHandleOption?: outputs.Dts.SyncConfigOptionsConflictHandleOption;
        /**
         * Conflict handling options, ReportError (error report, the default value), Ignore (ignore), Cover (cover), ConditionCover (condition coverage). Note: This field may return null, indicating that no valid value can be obtained.
         */
        conflictHandleType: string;
        /**
         * DDL synchronization options, specifically describe which DDLs to synchronize. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ddlOptions?: outputs.Dts.SyncConfigOptionsDdlOption[];
        /**
         * The processing of the table with the same name, ReportErrorAfterCheck (pre-check and report error, default), InitializeAfterDelete (delete and re-initialize), ExecuteAfterIgnore (ignore and continue to execute). Note: This field may return null, indicating that no valid value can be obtained.
         */
        dealOfExistSameTable: string;
        /**
         * Synchronous initialization options, Data (full data initialization), Structure (structure initialization), Full (full data and structure initialization, default), None (incremental only). Note: This field may return null, indicating that no valid value can be obtained.
         */
        initType: string;
        /**
         * DML and DDL options to be synchronized, Insert (insert operation), Update (update operation), Delete (delete operation), DDL (structure synchronization), leave blank (not selected), PartialDDL (custom, work with DdlOptions). Note: This field may return null, indicating that no valid value can be obtained.
         */
        opTypes?: string[];
    }

    export interface SyncConfigOptionsConflictHandleOption {
        /**
         * Columns covered by the condition. Note: This field may return null, indicating that no valid value can be obtained.
         */
        conditionColumn?: string;
        /**
         * Conditional Override Operation. Note: This field may return null, indicating that no valid value can be obtained.
         */
        conditionOperator?: string;
        /**
         * Conditional Override Priority Processing. Note: This field may return null, indicating that no valid value can be obtained.
         */
        conditionOrderInSrcAndDst?: string;
    }

    export interface SyncConfigOptionsDdlOption {
        /**
         * Ddl type, such as Database, Table, View, Index, etc. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ddlObject?: string;
        /**
         * The specific value of ddl, the possible values for Database [Create,Drop,Alter].The possible values for Table [Create,Drop,Alter,Truncate,Rename].The possible values for View[Create,Drop].For the possible values of Index [Create, Drop]. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ddlValues?: string[];
    }

    export interface SyncConfigSrcInfo {
        /**
         * The account to which the instance belongs. This field is required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        account?: string;
        /**
         * The account to which the resource belongs is empty or self (represents resources within this account), other (represents cross-account resources). Note: This field may return null, indicating that no valid value can be obtained.
         */
        accountMode?: string;
        /**
         * The role during cross-account synchronization, only [a-zA-Z0-9-_]+ is allowed, if it is a cross-account instance, this field is required. Note: This field may return null, indicating that no valid value can be obtained.
         */
        accountRole?: string;
        /**
         * Cloud networking ID, which is required for the cloud networking access type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ccnId?: string;
        /**
         * CVM instance short ID, which is the same as the instance ID displayed on the cloud server console page. If it is a self-built instance of CVM, this field needs to be passed. Note: This field may return null, indicating that no valid value can be obtained.
         */
        cvmInstanceId?: string;
        /**
         * The network environment to which the database belongs. It is required when AccessType is Cloud Network (CCN). `UserIDC` represents the user IDC. `TencentVPC` represents Tencent Cloud VPC. Note: This field may return null, indicating that no valid value can be obtained.
         */
        databaseNetEnv?: string;
        /**
         * Database kernel type, used to distinguish different kernels in tdsql: percona, mariadb, mysql. Note: This field may return null, indicating that no valid value can be obtained.
         */
        dbKernel?: string;
        /**
         * Database name, when the database is cdwpg, it needs to be provided. Note: This field may return null, indicating that no valid value can be obtained.
         */
        dbName?: string;
        /**
         * Whether to use encrypted transmission, UnEncrypted means not to use encrypted transmission, Encrypted means to use encrypted transmission, the default is UnEncrypted. Note: This field may return null, indicating that no valid value can be obtained.
         */
        encryptConn?: string;
        /**
         * Database version, valid only when the instance is an RDS instance, ignored by other instances, the format is: 5.6 or 5.7, the default is 5.6. Note: This field may return null, indicating that no valid value can be obtained.
         */
        engineVersion?: string;
        /**
         * Database instance id. Note: This field may return null, indicating that no valid value can be obtained.
         */
        instanceId?: string;
        /**
         * The IP address of the instance, which is required when the access type is non-cdb. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ip?: string;
        /**
         * Password, required for instances that require username and password authentication for access. Note: This field may return null, indicating that no valid value can be obtained.
         */
        password: string;
        /**
         * Instance port, this item is required when the access type is non-cdb. Note: This field may return null, indicating that no valid value can be obtained.
         */
        port?: number;
        /**
         * The english name of region. Note: This field may return null, indicating that no valid value can be obtained.
         */
        region?: string;
        /**
         * The node type of tdsql mysql version, the enumeration value is proxy, set. Note: This field may return null, indicating that no valid value can be obtained.
         */
        role?: string;
        /**
         * External role id. Note: This field may return null, indicating that no valid value can be obtained.
         */
        roleExternalId?: string;
        /**
         * The subnet ID under the private network, this item is required for the private network, leased line, and VPN access methods. Note: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId?: string;
        /**
         * Cloud vendor type, when the instance is an RDS instance, fill in aliyun, in other cases fill in others, the default is others. Note: This field may return null, indicating that no valid value can be obtained.
         */
        supplier?: string;
        /**
         * Temporary key Id, required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tmpSecretId?: string;
        /**
         * Temporary key Key, required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tmpSecretKey?: string;
        /**
         * Temporary Token, required if it is a cross-account instance. Note: This field may return null, indicating that no valid value can be obtained.
         */
        tmpToken?: string;
        /**
         * Leased line gateway ID, which is required for the leased line access type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        uniqDcgId?: string;
        /**
         * VPN gateway ID, which is required for the VPN access type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        uniqVpnGwId?: string;
        /**
         * Username, required for instances that require username and password authentication for access. Note: This field may return null, indicating that no valid value can be obtained.
         */
        user?: string;
        /**
         * Private network ID, which is required for access methods of private network, leased line, and VPN. Note: This field may return null, indicating that no valid value can be obtained.
         */
        vpcId?: string;
    }

    export interface SyncJobTag {
        /**
         * tag key.
         */
        tagKey?: string;
        /**
         * tag value.
         */
        tagValue?: string;
    }

}

export namespace Eb {
    export interface EventConnectorConnectionDescription {
        /**
         * apigw parameter,Note: This field may return null, indicating that no valid value can be obtained.
         */
        apiGwParams?: outputs.Eb.EventConnectorConnectionDescriptionApiGwParams;
        /**
         * ckafka parameter, note: this field may return null, indicating that no valid value can be obtained.
         */
        ckafkaParams?: outputs.Eb.EventConnectorConnectionDescriptionCkafkaParams;
        /**
         * Resource qcs six-segment style, more reference [resource six-segment style](https://cloud.tencent.com/document/product/598/10606).
         */
        resourceDescription: string;
    }

    export interface EventConnectorConnectionDescriptionApiGwParams {
        /**
         * POST.
         */
        method: string;
        /**
         * HTTPS.
         */
        protocol: string;
    }

    export interface EventConnectorConnectionDescriptionCkafkaParams {
        /**
         * kafka offset.
         */
        offset: string;
        /**
         * ckafka  topic.
         */
        topicName: string;
    }

    export interface EventTargetTargetDescription {
        /**
         * Ckafka parameters.
         */
        ckafkaTargetParams?: outputs.Eb.EventTargetTargetDescriptionCkafkaTargetParams;
        /**
         * ElasticSearch parameters.
         */
        esTargetParams?: outputs.Eb.EventTargetTargetDescriptionEsTargetParams;
        /**
         * QCS resource six-stage format, more references [resource six-stage format](https://cloud.tencent.com/document/product/598/10606).
         */
        resourceDescription: string;
        /**
         * cloud function parameters.
         */
        scfParams?: outputs.Eb.EventTargetTargetDescriptionScfParams;
    }

    export interface EventTargetTargetDescriptionCkafkaTargetParams {
        /**
         * retry strategy.
         */
        retryPolicy: outputs.Eb.EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicy;
        /**
         * The ckafka topic to deliver to.
         */
        topicName: string;
    }

    export interface EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicy {
        /**
         * Maximum number of retries.
         */
        maxRetryAttempts: number;
        /**
         * Retry Interval Unit: Seconds.
         */
        retryInterval: number;
    }

    export interface EventTargetTargetDescriptionEsTargetParams {
        /**
         * index prefix.
         */
        indexPrefix: string;
        /**
         * DTS index configuration.
         */
        indexSuffixMode: string;
        /**
         * es template type.
         */
        indexTemplateType?: string;
        /**
         * network connection type.
         */
        netMode: string;
        /**
         * DTS event configuration.
         */
        outputMode: string;
        /**
         * es log rotation granularity.
         */
        rotationInterval: string;
    }

    export interface EventTargetTargetDescriptionScfParams {
        /**
         * Maximum number of events for batch delivery.
         */
        batchEventCount?: number;
        /**
         * Maximum waiting time for bulk delivery.
         */
        batchTimeout?: number;
        /**
         * Enable batch delivery.
         */
        enableBatchDelivery?: boolean;
    }

    export interface EventTransformTransformation {
        /**
         * Describe how to filter data.
         */
        etlFilter?: outputs.Eb.EventTransformTransformationEtlFilter;
        /**
         * Describe how to extract data.
         */
        extraction?: outputs.Eb.EventTransformTransformationExtraction;
        /**
         * Describe how to convert data.
         */
        transform?: outputs.Eb.EventTransformTransformationTransform;
    }

    export interface EventTransformTransformationEtlFilter {
        /**
         * Grammatical Rules are consistent.
         */
        filter: string;
    }

    export interface EventTransformTransformationExtraction {
        /**
         * JsonPath, if not specified, the default value $.
         */
        extractionInputPath: string;
        /**
         * Value: `TEXT`, `JSON`.
         */
        format: string;
        /**
         * Only Text needs to be passed.
         */
        textParams?: outputs.Eb.EventTransformTransformationExtractionTextParams;
    }

    export interface EventTransformTransformationExtractionTextParams {
        /**
         * Fill in the regular expression: length 128.
         */
        regex?: string;
        /**
         * `Comma`, `|`, `tab`, `space`, `newline`, `%`, `#`, the limit length is 1.
         */
        separator?: string;
    }

    export interface EventTransformTransformationTransform {
        /**
         * Describe how the data is transformed.
         */
        outputStructs: outputs.Eb.EventTransformTransformationTransformOutputStruct[];
    }

    export interface EventTransformTransformationTransformOutputStruct {
        /**
         * Corresponding to the key in the output json.
         */
        key: string;
        /**
         * You can fill in the json-path and also support constants or built-in keyword date types.
         */
        value: string;
        /**
         * The data type of value, optional values: `STRING`, `NUMBER`, `BOOLEAN`, `NULL`, `SYS_VARIABLE`, `JSONPATH`.
         */
        valueType: string;
    }

    export interface GetBusEventBus {
        /**
         * create time.
         */
        addTime: string;
        /**
         * Connector basic information, note: this field may return null, indicating that no valid value can be obtained.
         */
        connectionBriefs: outputs.Eb.GetBusEventBusConnectionBrief[];
        /**
         * Event set description, unlimited character type, description within 200 characters.
         */
        description: string;
        /**
         * event bus Id.
         */
        eventBusId: string;
        /**
         * Event set name, which can only contain letters, numbers, underscores, hyphens, starts with a letter and ends with a number or letter, 2~60 characters.
         */
        eventBusName: string;
        /**
         * update time.
         */
        modTime: string;
        /**
         * Billing mode, note: this field may return null, indicating that no valid value can be obtained.
         */
        payMode: string;
        /**
         * Target brief information, note: this field may return null, indicating that no valid value can be obtained.
         */
        targetBriefs: outputs.Eb.GetBusEventBusTargetBrief[];
        /**
         * event bus type.
         */
        type: string;
    }

    export interface GetBusEventBusConnectionBrief {
        /**
         * Connector status, note: this field may return null, indicating that no valid value can be obtained.
         */
        status: string;
        /**
         * event bus type.
         */
        type: string;
    }

    export interface GetBusEventBusTargetBrief {
        /**
         * Target ID.
         */
        targetId: string;
        /**
         * event bus type.
         */
        type: string;
    }

    export interface GetBusFilter {
        /**
         * The name of the filter key.
         */
        name: string;
        /**
         * One or more filter values.
         */
        values: string[];
    }

    export interface GetEventRulesRule {
        /**
         * create time.
         */
        addTime: string;
        /**
         * The dlq rule set by rule. It may be null. Note: this field may return null, indicating that no valid value can be obtained.
         */
        deadLetterConfigs: outputs.Eb.GetEventRulesRuleDeadLetterConfig[];
        /**
         * description.
         */
        description: string;
        /**
         * enable switch.
         */
        enable: boolean;
        /**
         * event bus Id.
         */
        eventBusId: string;
        /**
         * modify time.
         */
        modTime: string;
        /**
         * rule Id.
         */
        ruleId: string;
        /**
         * rule name.
         */
        ruleName: string;
        /**
         * Status.
         */
        status: string;
        /**
         * Target brief information, note: this field may return null, indicating that no valid value can be obtained.
         */
        targets: outputs.Eb.GetEventRulesRuleTarget[];
    }

    export interface GetEventRulesRuleDeadLetterConfig {
        /**
         * After setting the DLQ mode, this option is required. The error message will be delivered to the corresponding kafka topic Note: This field may return null, indicating that no valid value can be obtained.
         */
        ckafkaDeliveryParams: outputs.Eb.GetEventRulesRuleDeadLetterConfigCkafkaDeliveryParam[];
        /**
         * Support three modes of dlq, discarding, ignoring errors and continuing to pass, corresponding to: DLQ, DROP, IGNORE_ERROR.
         */
        disposeMethod: string;
    }

    export interface GetEventRulesRuleDeadLetterConfigCkafkaDeliveryParam {
        /**
         * ckafka resource qcs six-segment.
         */
        resourceDescription: string;
        /**
         * ckafka topic name.
         */
        topicName: string;
    }

    export interface GetEventRulesRuleTarget {
        /**
         * target Id.
         */
        targetId: string;
        /**
         * target type.
         */
        type: string;
    }

    export interface GetPlatformEventNamesEventName {
        /**
         * Event name.Note: This field may return null, indicating that no valid value can be obtained.
         */
        eventName: string;
        /**
         * Event type.Note: This field may return null, indicating that no valid value can be obtained.
         */
        eventType: string;
    }

    export interface GetPlatformEventPatternsEventPattern {
        /**
         * Platform event name.Note: This field may return null, indicating that no valid value can be obtained.
         */
        eventName: string;
        /**
         * Platform event matching rules.Note: This field may return null, indicating that no valid value can be obtained.
         */
        eventPattern: string;
    }

    export interface GetPlatformProductsPlatformProduct {
        /**
         * Platform product name.
         */
        productName: string;
        /**
         * Platform product type.
         */
        productType: string;
    }

    export interface GetSearchFilter {
        /**
         * LogFilters array.
         */
        filters?: outputs.Eb.GetSearchFilterFilter[];
        /**
         * filter field name.
         */
        key?: string;
        /**
         * operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, in range range, not in range norange.
         */
        operator?: string;
        /**
         * The logical relationship of the level filters, the value AND or OR.
         */
        type?: string;
        /**
         * Filter value, range operation needs to enter two values at the same time, separated by commas.
         */
        value?: string;
    }

    export interface GetSearchFilterFilter {
        /**
         * filter field name.
         */
        key: string;
        /**
         * operator, congruent eq, not equal neq, similar like, exclude similar not like, less than lt, less than and equal to lte, greater than gt, greater than and equal to gte, within range range, not within range norange.
         */
        operator: string;
        /**
         * Filter values, range operations need to enter two values at the same time, separated by commas.
         */
        value: string;
    }

    export interface GetSearchResult {
        /**
         * Log content details, note: this field may return null, indicating that no valid value can be obtained.
         */
        message: string;
        /**
         * Region, Note: This field may return null, indicating that no valid value can be obtained.
         */
        region: string;
        /**
         * Event matching rules, note: this field may return null, indicating that no valid value can be obtained.
         */
        ruleIds: string;
        /**
         * Event source, note: this field may return null, indicating that no valid value can be obtained.
         */
        source: string;
        /**
         * Event status, note: this field may return null, indicating that no valid value can be obtained.
         */
        status: string;
        /**
         * Instance ID, note: this field may return null, indicating that no valid value can be obtained.
         */
        subject: string;
        /**
         * The reporting time of a single log, note: this field may return null, indicating that no valid value can be obtained.
         */
        timestamp: string;
        /**
         * Event type, note: this field may return null, indicating that no valid value can be obtained.
         */
        type: string;
    }

    export interface PutEventsEventList {
        /**
         * Event data, the content is controlled by the system that created the event, the current datacontenttype only supports application/json;charset=utf-8, so this field is a json string.
         */
        data: string;
        /**
         * Event source information, new product reporting must comply with EB specifications.
         */
        source: string;
        /**
         * Detailed description of the event source, customizable, optional. The cloud service defaults to the standard qcs resource representation syntax: qcs::dts:ap-guangzhou:appid/uin:xxx.
         */
        subject: string;
        /**
         * The timestamp in milliseconds when the event occurred,time.Now().UnixNano()/1e6.
         */
        time?: number;
        /**
         * Event type, customizable, optional. The cloud service writes COS:Created:PostObject by default, use: to separate the type field.
         */
        type: string;
    }

}

export namespace Eip {
    export interface GetAddressQuotaQuotaSet {
        /**
         * Current count.
         */
        quotaCurrent: number;
        /**
         * Quota name: TOTAL_EIP_QUOTA,DAILY_EIP_APPLY,DAILY_PUBLIC_IP_ASSIGN.
         */
        quotaId: string;
        /**
         * quota count.
         */
        quotaLimit: number;
    }

}

export namespace Eips {
    export interface GetInstanceEipList {
        /**
         * Creation time of the EIP.
         */
        createTime: string;
        /**
         * ID of the EIP to be queried.
         */
        eipId: string;
        /**
         * Name of the EIP to be queried.
         */
        eipName: string;
        /**
         * Type of the EIP.
         */
        eipType: string;
        /**
         * The eni id to bind with the EIP.
         */
        eniId: string;
        /**
         * The instance id to bind with the EIP.
         */
        instanceId: string;
        /**
         * The elastic ip address.
         */
        publicIp: string;
        /**
         * The EIP current status.
         */
        status: string;
        /**
         * The tags of EIP.
         */
        tags: {[key: string]: any};
    }

}

export namespace Elasticsearch {
    export interface DiagnoseDiagnoseJobMeta {
        /**
         * Intelligent operation and maintenance diagnostic item description.
         */
        jobDescription: string;
        /**
         * English name of diagnosis item for intelligent operation and maintenance.
         */
        jobName: string;
        /**
         * Chinese name of intelligent operation and maintenance diagnosis item.
         */
        jobZhName: string;
    }

    export interface GetDescribeIndexListIndexMetaField {
        /**
         * App id.
         */
        appId: number;
        /**
         * Backing indices.
         */
        backingIndices: outputs.Elasticsearch.GetDescribeIndexListIndexMetaFieldBackingIndex[];
        /**
         * Cluster id.
         */
        clusterId: string;
        /**
         * Cluster name.
         */
        clusterName: string;
        /**
         * Cluster version.
         */
        clusterVersion: string;
        /**
         * Index create time.
         */
        indexCreateTime: string;
        /**
         * Number of indexed documents.
         */
        indexDocs: number;
        /**
         * Index meta json.
         */
        indexMetaJson: string;
        /**
         * Index name. If you fill in the blanks, get all indexes.
         */
        indexName: string;
        /**
         * Index options field.
         */
        indexOptionsFields: outputs.Elasticsearch.GetDescribeIndexListIndexMetaFieldIndexOptionsField[];
        /**
         * Index lifecycle field.
         */
        indexPolicyFields: outputs.Elasticsearch.GetDescribeIndexListIndexMetaFieldIndexPolicyField[];
        /**
         * Index settings field.
         */
        indexSettingsFields: outputs.Elasticsearch.GetDescribeIndexListIndexMetaFieldIndexSettingsField[];
        /**
         * Index status.
         */
        indexStatus: string;
        /**
         * Index storage.
         */
        indexStorage: number;
        /**
         * Index type. `auto`: Autonomous index; `normal`: General index.
         */
        indexType: string;
    }

    export interface GetDescribeIndexListIndexMetaFieldBackingIndex {
        /**
         * Index create time.
         */
        indexCreateTime: string;
        /**
         * Index name. If you fill in the blanks, get all indexes.
         */
        indexName: string;
        /**
         * Index phrase.
         */
        indexPhrase: string;
        /**
         * Index status.
         */
        indexStatus: string;
        /**
         * Index storage.
         */
        indexStorage: number;
    }

    export interface GetDescribeIndexListIndexMetaFieldIndexOptionsField {
        /**
         * Expire max age.
         */
        expireMaxAge: string;
        /**
         * Expire max size.
         */
        expireMaxSize: string;
        /**
         * Whether to turn on dynamic scrolling.
         */
        rolloverDynamic: string;
        /**
         * Rollover max age.
         */
        rolloverMaxAge: string;
        /**
         * Whether to enable dynamic slicing.
         */
        shardNumDynamic: string;
        /**
         * Time partition field.
         */
        timestampField: string;
        /**
         * Write mode.
         */
        writeMode: string;
    }

    export interface GetDescribeIndexListIndexMetaFieldIndexPolicyField {
        /**
         * Cold action.
         */
        coldAction: string;
        /**
         * Whether to enable the cold phase.
         */
        coldEnable: string;
        /**
         * Cold phase transition time.
         */
        coldMinAge: string;
        /**
         * Start frozen phase.
         */
        frozenEnable: string;
        /**
         * Frozen phase transition time.
         */
        frozenMinAge: string;
        /**
         * Whether to enable warm.
         */
        warmEnable: string;
        /**
         * Warm phase transition time.
         */
        warmMinAge: string;
    }

    export interface GetDescribeIndexListIndexMetaFieldIndexSettingsField {
        /**
         * Number of index copy fragments.
         */
        numberOfReplicas: string;
        /**
         * Number of index main fragments.
         */
        numberOfShards: string;
        /**
         * Index refresh frequency.
         */
        refreshInterval: string;
    }

    export interface GetDiagnoseDiagnoseResult {
        /**
         * Whether the diagnosis is complete or not.
         */
        completed: boolean;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Instance id.
         */
        instanceId: string;
        /**
         * Diagnostic parameters such as diagnostic time, diagnostic index, etc.
         */
        jobParams: outputs.Elasticsearch.GetDiagnoseDiagnoseResultJobParam[];
        /**
         * Diagnostic item result list.
         */
        jobResults: outputs.Elasticsearch.GetDiagnoseDiagnoseResultJobResult[];
        /**
         * Diagnosis type, 2 timing diagnosis, 3 customer manual trigger diagnosis.
         */
        jobType: number;
        /**
         * Request id.
         */
        requestId: string;
        /**
         * Total diagnostic score.
         */
        score: number;
    }

    export interface GetDiagnoseDiagnoseResultJobParam {
        /**
         * Diagnostic indices.
         */
        indices: string;
        /**
         * Historical diagnosis time.
         */
        interval: number;
        /**
         * Diagnostic item list.
         */
        jobs: string[];
    }

    export interface GetDiagnoseDiagnoseResultJobResult {
        /**
         * Configuration processing recommendations.
         */
        advise: string;
        /**
         * Diagnosis details.
         */
        detail: string;
        /**
         * Diagnostic item name.
         */
        jobName: string;
        /**
         * Diagnostic log details.
         */
        logDetails: outputs.Elasticsearch.GetDiagnoseDiagnoseResultJobResultLogDetail[];
        /**
         * Details of diagnostic metrics.
         */
        metricDetails: outputs.Elasticsearch.GetDiagnoseDiagnoseResultJobResultMetricDetail[];
        /**
         * Total diagnostic score.
         */
        score: number;
        /**
         * Diagnostic configuration detail.
         */
        settingDetails: outputs.Elasticsearch.GetDiagnoseDiagnoseResultJobResultSettingDetail[];
        /**
         * Diagnostic item status:-2 failed,-1 to be retried, 0 running, 1 successful.
         */
        status: number;
        /**
         * Diagnostic summary.
         */
        summary: string;
    }

    export interface GetDiagnoseDiagnoseResultJobResultLogDetail {
        /**
         * Configuration processing recommendations.
         */
        advise: string;
        /**
         * Number of occurrences of log exception names.
         */
        count: number;
        /**
         * Key.
         */
        key: string;
    }

    export interface GetDiagnoseDiagnoseResultJobResultMetricDetail {
        /**
         * Key.
         */
        key: string;
        /**
         * Metric detail value.
         */
        metrics: outputs.Elasticsearch.GetDiagnoseDiagnoseResultJobResultMetricDetailMetric[];
    }

    export interface GetDiagnoseDiagnoseResultJobResultMetricDetailMetric {
        /**
         * Index dimension family.
         */
        dimensions: outputs.Elasticsearch.GetDiagnoseDiagnoseResultJobResultMetricDetailMetricDimension[];
        /**
         * Value.
         */
        value: number;
    }

    export interface GetDiagnoseDiagnoseResultJobResultMetricDetailMetricDimension {
        /**
         * Key.
         */
        key: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface GetDiagnoseDiagnoseResultJobResultSettingDetail {
        /**
         * Configuration processing recommendations.
         */
        advise: string;
        /**
         * Key.
         */
        key: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface GetInstanceLogsInstanceLogList {
        /**
         * Cluster node ip.
         */
        ip: string;
        /**
         * Log level.
         */
        level: string;
        /**
         * Log message.
         */
        message: string;
        /**
         * Cluster node id.
         */
        nodeId: string;
        /**
         * Log time.
         */
        time: string;
    }

    export interface GetInstanceOperationsOperation {
        /**
         * Operation details.
         */
        details: outputs.Elasticsearch.GetInstanceOperationsOperationDetail[];
        /**
         * Id.
         */
        id: number;
        /**
         * Task progress.
         */
        progress: number;
        /**
         * Subtask result.
         */
        result: string;
        /**
         * Start time, e.g. 2019-03-07 16:30:39.
         */
        startTime: string;
        /**
         * Operator uin.
         */
        subAccountUin: string;
        /**
         * Task information.
         */
        tasks: outputs.Elasticsearch.GetInstanceOperationsOperationTask[];
        /**
         * Type.
         */
        type: string;
    }

    export interface GetInstanceOperationsOperationDetail {
        /**
         * Configuration information after instance update.
         */
        newInfos: outputs.Elasticsearch.GetInstanceOperationsOperationDetailNewInfo[];
        /**
         * Instance original configuration information.
         */
        oldInfos: outputs.Elasticsearch.GetInstanceOperationsOperationDetailOldInfo[];
    }

    export interface GetInstanceOperationsOperationDetailNewInfo {
        /**
         * Key.
         */
        key: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface GetInstanceOperationsOperationDetailOldInfo {
        /**
         * Key.
         */
        key: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface GetInstanceOperationsOperationTask {
        /**
         * Elapsed time.
         */
        elapsedTime: number;
        /**
         * Subtask end time.
         */
        finishTime: string;
        /**
         * Subtask name.
         */
        name: string;
        /**
         * Progress info.
         */
        processInfos: outputs.Elasticsearch.GetInstanceOperationsOperationTaskProcessInfo[];
        /**
         * Task progress.
         */
        progress: number;
        /**
         * Subtask.
         */
        subTasks: outputs.Elasticsearch.GetInstanceOperationsOperationTaskSubTask[];
    }

    export interface GetInstanceOperationsOperationTaskProcessInfo {
        /**
         * Completed quantity.
         */
        completed: number;
        /**
         * Remaining quantity.
         */
        remain: number;
        /**
         * Task type. 60: restart task 70: fragment migration task 80: node modification task.
         */
        taskType: number;
        /**
         * Total quantity.
         */
        total: number;
    }

    export interface GetInstanceOperationsOperationTaskSubTask {
        /**
         * Subtask error message.
         */
        errMsg: string;
        /**
         * The index name of the failed upgrade check.
         */
        failedIndices: string[];
        /**
         * Subtask end time.
         */
        finishTime: string;
        /**
         * Subtask level, 1: warning; 2: failed.
         */
        level: number;
        /**
         * Subtask name.
         */
        name: string;
        /**
         * Subtask result.
         */
        result: boolean;
        /**
         * Subtask status, 1: success; 0: processing; -1: failure.
         */
        status: number;
        /**
         * Type.
         */
        type: string;
    }

    export interface GetInstancePluginListPluginList {
        /**
         * Plugin description.
         */
        pluginDesc: string;
        /**
         * Plugin name.
         */
        pluginName: string;
        /**
         * Plugin type. Valid values: `0`: System plugin.
         */
        pluginType: number;
        /**
         * Plugin update time.
         */
        pluginUpdateTime: string;
        /**
         * Plugin version.
         */
        pluginVersion: string;
        /**
         * Whether the plug-in can be uninstalled.
         */
        removable: boolean;
        /**
         * Plugin status. Valid values:
         * - `-2` has been uninstalled
         * - `-1` has been installed in
         */
        status: number;
    }

    export interface GetInstancesInstanceList {
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * Whether to enable X-Pack security authentication in Basic Edition 6.8 and above.
         */
        basicSecurityType: number;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * Instance creation time.
         */
        createTime: string;
        /**
         * Cluster deployment mode.
         */
        deployMode: number;
        /**
         * Elasticsearch domain name.
         */
        elasticsearchDomain: string;
        /**
         * Elasticsearch port.
         */
        elasticsearchPort: number;
        /**
         * Elasticsearch VIP.
         */
        elasticsearchVip: string;
        /**
         * ID of the instance to be queried.
         */
        instanceId: string;
        /**
         * Name of the instance to be queried.
         */
        instanceName: string;
        /**
         * Kibana access URL.
         */
        kibanaUrl: string;
        /**
         * License type.
         */
        licenseType: string;
        /**
         * Details of AZs in multi-AZ deployment mode.
         */
        multiZoneInfos: outputs.Elasticsearch.GetInstancesInstanceListMultiZoneInfo[];
        /**
         * Node information list, which describe the specification information of various types of nodes in the cluster.
         */
        nodeInfoLists: outputs.Elasticsearch.GetInstancesInstanceListNodeInfoList[];
        /**
         * The ID of a VPC subnet.
         */
        subnetId: string;
        /**
         * Tag of the instance to be queried.
         */
        tags: {[key: string]: any};
        /**
         * Version of the instance.
         */
        version: string;
        /**
         * The ID of a VPC network.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceListMultiZoneInfo {
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * The ID of a VPC subnet.
         */
        subnetId: string;
    }

    export interface GetInstancesInstanceListNodeInfoList {
        /**
         * Node disk size.
         */
        diskSize: number;
        /**
         * Node disk type.
         */
        diskType: string;
        /**
         * Decides this disk encrypted or not.
         */
        encrypt: boolean;
        /**
         * Number of nodes.
         */
        nodeNum: number;
        /**
         * Node specification.
         */
        nodeType: string;
        /**
         * Node type.
         */
        type: string;
    }

    export interface GetLogstashInstanceLogsInstanceLogList {
        /**
         * Cluster node ip.
         */
        ip: string;
        /**
         * Log level.
         */
        level: string;
        /**
         * Log content.
         */
        message: string;
        /**
         * Cluster node id.
         */
        nodeId: string;
        /**
         * Log time.
         */
        time: string;
    }

    export interface GetLogstashInstanceOperationsOperation {
        /**
         * Operation details.
         */
        details: outputs.Elasticsearch.GetLogstashInstanceOperationsOperationDetail[];
        /**
         * Id.
         */
        id: number;
        /**
         * Task progress.
         */
        progress: number;
        /**
         * Subtask result.
         */
        result: string;
        /**
         * Start time, e.g. 2019-03-07 16:30:39.
         */
        startTime: string;
        /**
         * Operator uin.
         */
        subAccountUin: string;
        /**
         * Task information.
         */
        tasks: outputs.Elasticsearch.GetLogstashInstanceOperationsOperationTask[];
        /**
         * Type.
         */
        type: string;
    }

    export interface GetLogstashInstanceOperationsOperationDetail {
        /**
         * Configuration information after instance update.
         */
        newInfos: outputs.Elasticsearch.GetLogstashInstanceOperationsOperationDetailNewInfo[];
        /**
         * Instance original configuration information.
         */
        oldInfos: outputs.Elasticsearch.GetLogstashInstanceOperationsOperationDetailOldInfo[];
    }

    export interface GetLogstashInstanceOperationsOperationDetailNewInfo {
        /**
         * Key.
         */
        key: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface GetLogstashInstanceOperationsOperationDetailOldInfo {
        /**
         * Key.
         */
        key: string;
        /**
         * Value.
         */
        value: string;
    }

    export interface GetLogstashInstanceOperationsOperationTask {
        /**
         * Elapsed time.
         */
        elapsedTime: number;
        /**
         * Subtask end time.
         */
        finishTime: string;
        /**
         * Subtask name.
         */
        name: string;
        /**
         * Progress info.
         */
        processInfos: outputs.Elasticsearch.GetLogstashInstanceOperationsOperationTaskProcessInfo[];
        /**
         * Task progress.
         */
        progress: number;
        /**
         * Subtask.
         */
        subTasks: outputs.Elasticsearch.GetLogstashInstanceOperationsOperationTaskSubTask[];
    }

    export interface GetLogstashInstanceOperationsOperationTaskProcessInfo {
        /**
         * Completed quantity.
         */
        completed: number;
        /**
         * Remaining quantity.
         */
        remain: number;
        /**
         * Task type. 60: restart task 70: fragment migration task 80: node modification task.
         */
        taskType: number;
        /**
         * Total quantity.
         */
        total: number;
    }

    export interface GetLogstashInstanceOperationsOperationTaskSubTask {
        /**
         * Subtask error message.
         */
        errMsg: string;
        /**
         * The index name of the failed upgrade check.
         */
        failedIndices: string[];
        /**
         * Subtask end time.
         */
        finishTime: string;
        /**
         * Subtask level, 1: warning; 2: failed.
         */
        level: number;
        /**
         * Subtask name.
         */
        name: string;
        /**
         * Subtask result.
         */
        result: boolean;
        /**
         * Subtask status, 1: success; 0: processing; -1: failure.
         */
        status: number;
        /**
         * Type.
         */
        type: string;
    }

    export interface GetViewsClusterView {
        /**
         * Average cpu utilization.
         */
        avgCpuUsage: number;
        /**
         * Average disk utilization.
         */
        avgDiskUsage: number;
        /**
         * Average memory utilization.
         */
        avgMemUsage: number;
        /**
         * Whether or not to break.
         */
        break: number;
        /**
         * Number of data nodes.
         */
        dataNodeNum: number;
        /**
         * Bytes used on disk.
         */
        diskUsedInBytes: number;
        /**
         * Number of documents.
         */
        docNum: number;
        /**
         * Cluster health status.
         */
        health: number;
        /**
         * Index number.
         */
        indexNum: number;
        /**
         * Initializing shard number.
         */
        initializingShardNum: number;
        /**
         * Number of online nodes.
         */
        nodeNum: number;
        /**
         * Primary shard number.
         */
        primaryShardNum: number;
        /**
         * Relocating shard number.
         */
        relocatingShardNum: number;
        /**
         * Enterprise cluster can search the appid to which snapshot cos belongs.
         */
        searchableSnapshotCosAppId: string;
        /**
         * Enterprise cluster searchable bucket name stored in snapshot cos.
         */
        searchableSnapshotCosBucket: string;
        /**
         * Number of node fragments.
         */
        shardNum: number;
        /**
         * Client request node.
         */
        targetNodeTypes: string[];
        /**
         * Storage capacity of COS Enterprise Edition (in GB).
         */
        totalCosStorage: number;
        /**
         * Total storage size of cluster.
         */
        totalDiskSize: number;
        /**
         * Total number of nodes.
         */
        totalNodeNum: number;
        /**
         * Unassigned shard number.
         */
        unassignedShardNum: number;
        /**
         * Whether the node is visible.
         */
        visible: number;
    }

    export interface GetViewsKibanasView {
        /**
         * CPU number.
         */
        cpuNum: number;
        /**
         * CPU usage.
         */
        cpuUsage: number;
        /**
         * Total disk size of node.
         */
        diskSize: number;
        /**
         * Disk usage.
         */
        diskUsage: number;
        /**
         * Kibana node ip.
         */
        ip: string;
        /**
         * Node memory size (in GB).
         */
        memSize: number;
        /**
         * Memory usage.
         */
        memUsage: number;
        /**
         * Node id.
         */
        nodeId: string;
        /**
         * Zone.
         */
        zone: string;
    }

    export interface GetViewsNodesView {
        /**
         * Whether or not to break.
         */
        break: number;
        /**
         * CPU number.
         */
        cpuNum: number;
        /**
         * CPU usage.
         */
        cpuUsage: number;
        /**
         * List of disk ID on the node.
         */
        diskIds: string[];
        /**
         * Total disk size of node.
         */
        diskSize: number;
        /**
         * Disk usage.
         */
        diskUsage: number;
        /**
         * Whether it is a hidden availability zone.
         */
        hidden: boolean;
        /**
         * Whether to act as a coordinator node or not.
         */
        isCoordinationNode: boolean;
        /**
         * JVM memory usage.
         */
        jvmMemUsage: number;
        /**
         * Node memory size (in GB).
         */
        memSize: number;
        /**
         * Memory usage.
         */
        memUsage: number;
        /**
         * Node HTTP IP.
         */
        nodeHttpIp: string;
        /**
         * Node id.
         */
        nodeId: string;
        /**
         * Node ip.
         */
        nodeIp: string;
        /**
         * Node role.
         */
        nodeRole: string;
        /**
         * Number of node fragments.
         */
        shardNum: number;
        /**
         * Whether the node is visible.
         */
        visible: number;
        /**
         * Zone.
         */
        zone: string;
    }

    export interface InstanceEsAcl {
        /**
         * Blacklist of kibana access.
         */
        blackLists: string[];
        /**
         * Whitelist of kibana access.
         */
        whiteLists: string[];
    }

    export interface InstanceMultiZoneInfo {
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * The ID of a VPC subnetwork.
         */
        subnetId: string;
    }

    export interface InstanceNodeInfoList {
        /**
         * Node disk size. Unit is GB, and default value is `100`.
         */
        diskSize?: number;
        /**
         * Node disk type. Valid values are `CLOUD_SSD` and `CLOUD_PREMIUM`, `CLOUD_HSSD`. The default value is `CLOUD_SSD`.
         */
        diskType?: string;
        /**
         * Decides to encrypt this disk or not.
         */
        encrypt?: boolean;
        /**
         * Number of nodes.
         */
        nodeNum: number;
        /**
         * Node specification, and valid values refer to [document of tencentcloud](https://intl.cloud.tencent.com/document/product/845/18376).
         */
        nodeType: string;
        /**
         * Node type. Valid values are `hotData`, `warmData` and `dedicatedMaster`. The default value is 'hotData`.
         */
        type?: string;
    }

    export interface InstanceWebNodeTypeInfo {
        /**
         * Visual node number.
         */
        nodeNum: number;
        /**
         * Visual node specifications.
         */
        nodeType: string;
    }

    export interface LogstashOperationDuration {
        /**
         * day of week, from Monday to Sunday, value range: [0, 6]notes: may return null when missing.
         */
        periods: number[];
        /**
         * operation end time.
         */
        timeEnd: string;
        /**
         * operation start time.
         */
        timeStart: string;
        /**
         * time zone, for example: UTC+8.
         */
        timeZone: string;
    }

    export interface LogstashPipelinePipeline {
        /**
         * Pipeline batch processing delay.
         */
        batchDelay: number;
        /**
         * Pipe batch size.
         */
        batchSize: number;
        /**
         * Pipeline configuration content.
         */
        config: string;
        /**
         * Pipeline description information.
         */
        pipelineDesc: string;
        /**
         * Pipeline id.
         */
        pipelineId: string;
        /**
         * Number of pipeline buffer queue checkpoint writes.
         */
        queueCheckPointWrites: number;
        /**
         * Pipeline buffer queue size.
         */
        queueMaxBytes: string;
        /**
         * Pipeline buffer queue type.
         */
        queueType: string;
        /**
         * Number of Worker of pipe.
         */
        workers: number;
    }

}

export namespace Emr {
    export interface ClusterPlacementInfo {
        /**
         * Project id.
         */
        projectId: number;
        /**
         * Zone.
         */
        zone: string;
    }

    export interface ClusterResourceSpec {
        /**
         * The number of common node.
         */
        commonCount: number;
        commonResourceSpec?: outputs.Emr.ClusterResourceSpecCommonResourceSpec;
        /**
         * The number of core node.
         */
        coreCount: number;
        coreResourceSpec?: outputs.Emr.ClusterResourceSpecCoreResourceSpec;
        /**
         * The number of master node.
         */
        masterCount: number;
        masterResourceSpec?: outputs.Emr.ClusterResourceSpecMasterResourceSpec;
        /**
         * The number of core node.
         */
        taskCount: number;
        taskResourceSpec?: outputs.Emr.ClusterResourceSpecTaskResourceSpec;
    }

    export interface ClusterResourceSpecCommonResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecCoreResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecMasterResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecTaskResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface GetAutoScaleRecordsFilter {
        /**
         * Key. Note: This field may return null, indicating that no valid value can be obtained.
         */
        key: string;
        /**
         * Value. Note: This field may return null, indicating that no valid value can be obtained.
         */
        value: string;
    }

    export interface GetAutoScaleRecordsRecordList {
        /**
         * `SUCCESS`, `FAILED`, `PART_SUCCESS`, `IN_PROCESS`.
         */
        actionStatus: string;
        /**
         * Process Trigger Time.
         */
        actionTime: string;
        /**
         * Compensation Times Note: This field may return null, indicating that no valid value can be obtained.
         */
        compensateCount: number;
        /**
         * Compensation and expansion, 0 represents no start, 1 represents start. Note: This field may return null, indicating that no valid value can be obtained.
         */
        compensateFlag: number;
        /**
         * Process End Time.
         */
        endTime: string;
        /**
         * Effective only when ScaleAction is SCALE_OUT.
         */
        expectScaleNum: number;
        /**
         * `SCALE_OUT` and `SCALE_IN` respectively represent expanding and shrinking capacity.
         */
        scaleAction: string;
        /**
         * Scalability-related Description.
         */
        scaleInfo: string;
        /**
         * Specification information used when expanding capacity.
         */
        specInfo: string;
        /**
         * Rule name of expanding and shrinking capacity.
         */
        strategyName: string;
        /**
         * Strategy Type, 1 for Load scaling, 2 for Time scaling.
         */
        strategyType: number;
    }

    export interface GetCvmQuotaEksQuotaSet {
        /**
         * Cpu cores.
         */
        cpu: number;
        /**
         * Memory quantity (unit: GB).
         */
        memory: number;
        /**
         * The specifications of the marketable resource are as follows: `TASK`, `CORE`, `MASTER`, `ROUTER`.
         */
        nodeType: string;
        /**
         * Specifies the maximum number of resources that can be applied for.
         */
        number: number;
    }

    export interface GetCvmQuotaPostPaidQuotaSet {
        /**
         * Residual quota Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        remainingQuota: number;
        /**
         * Total quota Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        totalQuota: number;
        /**
         * Used quota Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        usedQuota: number;
        /**
         * Available area Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        zone: string;
    }

    export interface GetCvmQuotaSpotPaidQuotaSet {
        /**
         * Residual quota Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        remainingQuota: number;
        /**
         * Total quota Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        totalQuota: number;
        /**
         * Used quota Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        usedQuota: number;
        /**
         * Available area Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        zone: string;
    }

    export interface GetInstanceCluster {
        /**
         * Add time of instance.
         */
        addTime: string;
        /**
         * Charge type of instance.
         */
        chargeType: number;
        /**
         * Cluster id of instance.
         */
        clusterId: string;
        /**
         * Cluster name of instance.
         */
        clusterName: string;
        /**
         * Title of instance.
         */
        ftitle: string;
        /**
         * Id of instance.
         */
        id: number;
        /**
         * Master ip of instance.
         */
        masterIp: string;
        /**
         * Fetch all instances which owner same project. Default 0 meaning use default project id.
         */
        projectId: number;
        /**
         * Region id of instance.
         */
        regionId: number;
        /**
         * Status of instance.
         */
        status: number;
        /**
         * Zone of instance.
         */
        zone: string;
        /**
         * Zone id of instance.
         */
        zoneId: number;
    }

    export interface GetNodesNode {
        /**
         * User APPID.
         */
        appId: number;
        /**
         * Application time.
         */
        applyTime: string;
        /**
         * Whether it is an autoscaling node, 0 is a normal node, and 1 is an autoscaling node.
         */
        autoFlag: number;
        /**
         * Database IP.
         */
        cdbIp: string;
        /**
         * Database information.
         */
        cdbNodeInfos: outputs.Emr.GetNodesNodeCdbNodeInfo[];
        /**
         * Database port.
         */
        cdbPort: number;
        /**
         * The type of payment.
         */
        chargeType: number;
        /**
         * Number of node cores.
         */
        cpuNum: number;
        /**
         * Whether this node is destroyable, 1 can be destroyed, 0 is not destroyable.
         */
        destroyable: number;
        /**
         * Device identity.
         */
        deviceClass: string;
        /**
         * Hard disk size.
         */
        diskSize: string;
        /**
         * Floating specification value json string.
         */
        dynamicPodSpec: string;
        /**
         * Node resource ID.
         */
        emrResourceId: string;
        /**
         * Expiration time.
         */
        expireTime: string;
        /**
         * Node type. 0: common node; 1: master node; 2: core node; 3: task node.
         */
        flag: number;
        /**
         * Release time.
         */
        freeTime: string;
        /**
         * Resource type: Support all/host/pod, default is all.
         */
        hardwareResourceType: string;
        /**
         * Hard disk capacity.
         */
        hwDiskSize: number;
        /**
         * Hard disk capacity description.
         */
        hwDiskSizeDesc: string;
        /**
         * Memory capacity.
         */
        hwMemSize: number;
        /**
         * Memory capacity description.
         */
        hwMemSizeDesc: string;
        /**
         * Intranet IP.
         */
        ip: string;
        /**
         * Renewal logo.
         */
        isAutoRenew: number;
        /**
         * Floating specifications, 1 yes, 0 no.
         */
        isDynamicSpec: number;
        /**
         * Multi-cloud disk.
         */
        mcMultiDisks: outputs.Emr.GetNodesNodeMcMultiDisk[];
        /**
         * Node memory description.
         */
        memDesc: string;
        /**
         * Node memory.
         */
        memSize: number;
        /**
         * Supports variations.
         */
        mutable: number;
        /**
         * Node description.
         */
        nameTag: string;
        /**
         * Machine instance ID.
         */
        orderNo: string;
        /**
         * The node is located in the region.
         */
        regionId: number;
        /**
         * The size of the system disk.
         */
        rootSize: number;
        /**
         * Serial number.
         */
        serialNo: string;
        /**
         * Node deployment service.
         */
        services: string;
        /**
         * Node specifications.
         */
        spec: string;
        /**
         * Disk type.
         */
        storageType: number;
        /**
         * Whether to support change billing type 1 Yes and 0 No.
         */
        supportModifyPayMode: number;
        /**
         * The label of the node binding.
         */
        tags: outputs.Emr.GetNodesNodeTag[];
        /**
         * The master node is bound to the Internet IP address.
         */
        wanIp: string;
        /**
         * Zone where the node is located.
         */
        zoneId: number;
    }

    export interface GetNodesNodeCdbNodeInfo {
        /**
         * Application time.
         */
        applyTime: string;
        /**
         * Expired id.
         */
        expireFlag: boolean;
        /**
         * Expiration time.
         */
        expireTime: string;
        /**
         * DB instance.
         */
        instanceName: string;
        /**
         * Intranet IP.
         */
        ip: string;
        /**
         * Renewal logo.
         */
        isAutoRenew: number;
        /**
         * Node memory.
         */
        memSize: number;
        /**
         * The type of payment.
         */
        payType: number;
        /**
         * Database port.
         */
        port: number;
        /**
         * The node is located in the region.
         */
        regionId: number;
        /**
         * Serial number.
         */
        serialNo: string;
        /**
         * The service identity.
         */
        service: string;
        /**
         * Database status.
         */
        status: number;
        /**
         * The size of the cloud disk.
         */
        volume: number;
        /**
         * Zone where the node is located.
         */
        zoneId: number;
    }

    export interface GetNodesNodeMcMultiDisk {
        /**
         * The number of cloud disks of this type.
         */
        count: number;
        /**
         * Disk type.
         */
        type: number;
        /**
         * The size of the cloud disk.
         */
        volume: number;
    }

    export interface GetNodesNodeTag {
        /**
         * Tag key.
         */
        tagKey: string;
        /**
         * Tag value.
         */
        tagValue: string;
    }

}

export namespace Eni {
    export interface InstanceIpv4 {
        /**
         * Description of the IP, maximum length 25.
         */
        description?: string;
        /**
         * Intranet IP.
         */
        ip: string;
        /**
         * Indicates whether the IP is primary.
         */
        primary: boolean;
    }

    export interface InstanceIpv4Info {
        /**
         * Description of the IP, maximum length 25.
         */
        description: string;
        /**
         * Intranet IP.
         */
        ip: string;
        /**
         * Indicates whether the IP is primary.
         */
        primary: boolean;
    }

    export interface Ipv4AddressPrivateIpAddress {
        /**
         * EIP instance ID, such as `eip-11112222`.
         */
        addressId: string;
        /**
         * Private IP description.
         */
        description: string;
        /**
         * Whether the public IP is blocked.
         */
        isWanIpBlocked: boolean;
        /**
         * Whether it is a primary IP.
         */
        primary: boolean;
        /**
         * Private IP address.
         */
        privateIpAddress: string;
        /**
         * Public IP address.
         */
        publicIpAddress: string;
        /**
         * IP service level. Values: PT` (Gold), `AU` (Silver), `AG `(Bronze) and DEFAULT` (Default).
         */
        qosLevel: string;
        /**
         * IP status: `PENDING`: Creating, `MIGRATING`: Migrating, `DELETING`: Deleting, `AVAILABLE`: Available.
         */
        state: string;
    }

    export interface Ipv6AddressIpv6Address {
        /**
         * `IPv6` address, in the form of: `3402:4e00:20:100:0:8cd9:2a67:71f3`.
         */
        address: string;
        /**
         * `EIP` instance `ID`, such as:`eip-hxlqja90`.
         */
        addressId: string;
        /**
         * Description.
         */
        description?: string;
        /**
         * Whether the public network IP is blocked.
         */
        isWanIpBlocked: boolean;
        /**
         * Whether to master `IP`.
         */
        primary: boolean;
        /**
         * `IPv6` address status: `PENDING`: pending, `MIGRATING`: migrating, `DELETING`: deleting, `AVAILABLE`: available.
         */
        state: string;
    }

}

export namespace Enis {
    export interface GetInstanceEni {
        /**
         * Creation time of the ENI.
         */
        createTime: string;
        /**
         * Description of the ENI. Conflict with `ids`.
         */
        description: string;
        /**
         * ID of the ENI.
         */
        id: string;
        /**
         * ID of the instance which bind the ENI. Conflict with `ids`.
         */
        instanceId: string;
        /**
         * A set of intranet IPv4s.
         */
        ipv4s: outputs.Enis.GetInstanceEniIpv4[];
        /**
         * MAC address.
         */
        mac: string;
        /**
         * Name of the ENI to be queried. Conflict with `ids`.
         */
        name: string;
        /**
         * Indicates whether the IP is primary.
         */
        primary: boolean;
        /**
         * A set of security group IDs which bind the ENI.
         */
        securityGroups: string[];
        /**
         * States of the ENI.
         */
        state: string;
        /**
         * ID of the subnet within this vpc to be queried. Conflict with `ids`.
         */
        subnetId: string;
        /**
         * Tags of the ENI. Conflict with `ids`.
         */
        tags: {[key: string]: any};
        /**
         * ID of the vpc to be queried. Conflict with `ids`.
         */
        vpcId: string;
    }

    export interface GetInstanceEniIpv4 {
        /**
         * Description of the ENI. Conflict with `ids`.
         */
        description: string;
        /**
         * Intranet IP.
         */
        ip: string;
        /**
         * Indicates whether the IP is primary.
         */
        primary: boolean;
    }

}

export namespace Gaap {
    export interface CustomHeaderHeader {
        /**
         * Header name.
         */
        headerName: string;
        /**
         * Header value.
         */
        headerValue: string;
    }

    export interface GetAccessRegionsAccessRegionSet {
        /**
         * Property bitmap, where each bit represents a property, where:0, indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * The type of computer room, where dc represents the DataCenter data center and ec represents the EdgeComputing edge node.
         */
        idcType: string;
        /**
         * Region of the computer room.
         */
        regionArea: string;
        /**
         * Name of the region to which the computer room belongs.
         */
        regionAreaName: string;
        /**
         * Region id.
         */
        regionId: string;
        /**
         * English or Chinese name of the region.
         */
        regionName: string;
        /**
         * Ability to access regional supportNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        supportFeatures: outputs.Gaap.GetAccessRegionsAccessRegionSetSupportFeature[];
    }

    export interface GetAccessRegionsAccessRegionSetSupportFeature {
        /**
         * A list of network types supported by the access area, with normal indicating support for regular BGP, cn2 indicating premium BGP, triple indicating three networks, and secure_ EIP represents a custom secure EIP.
         */
        networkTypes: string[];
    }

    export interface GetAccessRegionsByDestRegionAccessRegionSet {
        /**
         * Optional bandwidth value array.
         */
        bandwidthLists: number[];
        /**
         * Optional concurrency value array.
         */
        concurrentLists: number[];
        /**
         * The type of computer room, where dc represents the DataCenter data center, ec represents the feature bitmap, and each bit represents a feature, where:0, indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained. Edge nodes.
         */
        featureBitmap: number;
        /**
         * The type of computer room, where dc represents the DataCenter data center and ec represents the EdgeComputing edge node.
         */
        idcType: string;
        /**
         * Region of the computer room.
         */
        regionArea: string;
        /**
         * Region name of the computer room.
         */
        regionAreaName: string;
        /**
         * Region id.
         */
        regionId: string;
        /**
         * Chinese or English name of the region.
         */
        regionName: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * Beginning time of the certificate.
         */
        beginTime: string;
        /**
         * Creation time of the certificate.
         */
        createTime: string;
        /**
         * Ending time of the certificate.
         */
        endTime: string;
        /**
         * ID of the certificate to be queried.
         */
        id: string;
        /**
         * Issuer name of the certificate.
         */
        issuerCn: string;
        /**
         * Name of the certificate to be queried.
         */
        name: string;
        /**
         * Subject name of the certificate.
         */
        subjectCn: string;
        /**
         * Type of the certificate to be queried. Valid values: `BASIC`, `CLIENT`, `SERVER`, `REALSERVER` and `PROXY`. `BASIC` means basic certificate; `CLIENT` means client CA certificate; `SERVER` means server SSL certificate; `REALSERVER` means realserver CA certificate; `PROXY` means proxy SSL certificate.
         */
        type: string;
    }

    export interface GetCountryAreaMappingCountryAreaMappingList {
        /**
         * Continental Code.
         */
        continentInnerCode: string;
        /**
         * The name of the continent.
         */
        continentName: string;
        /**
         * Region code.
         */
        geographicalZoneInnerCode: string;
        /**
         * Region name.
         */
        geographicalZoneName: string;
        /**
         * Country code.
         */
        nationCountryInnerCode: string;
        /**
         * Country name.
         */
        nationCountryName: string;
        /**
         * Annotation InformationNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        remark: string;
    }

    export interface GetCustomHeaderHeader {
        /**
         * Header Name.
         */
        headerName: string;
        /**
         * Header Value.
         */
        headerValue: string;
    }

    export interface GetDestRegionsDestRegionSet {
        /**
         * Property bitmap, where each bit represents a property, where:0, indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * The type of computer room, where dc represents the DataCenter data center and ec represents the EdgeComputing edge node.
         */
        idcType: string;
        /**
         * Region of the computer room.
         */
        regionArea: string;
        /**
         * Region name of the computer room.
         */
        regionAreaName: string;
        /**
         * region ID.
         */
        regionId: string;
        /**
         * region name.
         */
        regionName: string;
        /**
         * Ability to access regional supportNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        supportFeatures: outputs.Gaap.GetDestRegionsDestRegionSetSupportFeature[];
    }

    export interface GetDestRegionsDestRegionSetSupportFeature {
        /**
         * A list of network types supported by the access area, with normal indicating support for regular BGP, cn2 indicating premium BGP, triple indicating three networks, and secure_EIP represents a custom secure EIP.
         */
        networkTypes: string[];
    }

    export interface GetDomainErrorPageInfosErrorPageSet {
        /**
         * Response body set (excluding HTTP header)Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        body: string;
        /**
         * Response headers that need to be cleanedNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        clearHeaders: string[];
        /**
         * domain name.
         */
        domain: string;
        /**
         * Original error code.
         */
        errorNos: number[];
        /**
         * Configuration ID for error customization response.
         */
        errorPageId: string;
        /**
         * Listener ID.
         */
        listenerId: string;
        /**
         * New error codeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        newErrorNo: number;
        /**
         * Response header to be setNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        setHeaders: outputs.Gaap.GetDomainErrorPageInfosErrorPageSetSetHeader[];
        /**
         * Rule status, 0 indicates successNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        status: number;
    }

    export interface GetDomainErrorPageInfosErrorPageSetSetHeader {
        /**
         * HTTP header name.
         */
        headerName: string;
        /**
         * HTTP header value.
         */
        headerValue: string;
    }

    export interface GetDomainErrorPagesErrorPageInfoList {
        /**
         * New response body.
         */
        body: string;
        /**
         * Response headers to be removed.
         */
        clearHeaders: string[];
        /**
         * HTTP domain to be queried.
         */
        domain: string;
        /**
         * Original error codes.
         */
        errorCodes: number[];
        /**
         * ID of the error page info.
         */
        id: string;
        /**
         * ID of the layer7 listener to be queried.
         */
        listenerId: string;
        /**
         * New error code.
         */
        newErrorCodes: number;
        /**
         * Response headers to be set.
         */
        setHeaders: {[key: string]: any};
    }

    export interface GetGroupAndStatisticsProxyGroupSet {
        /**
         * Channel Group ID.
         */
        groupId: string;
        /**
         * Channel Group name.
         */
        groupName: string;
        /**
         * Channel list in the proxy group.
         */
        proxySets: outputs.Gaap.GetGroupAndStatisticsProxyGroupSetProxySet[];
    }

    export interface GetGroupAndStatisticsProxyGroupSetProxySet {
        /**
         * listener list.
         */
        listenerLists: outputs.Gaap.GetGroupAndStatisticsProxyGroupSetProxySetListenerList[];
        /**
         * Channel Id.
         */
        proxyId: string;
        /**
         * Channel name.
         */
        proxyName: string;
    }

    export interface GetGroupAndStatisticsProxyGroupSetProxySetListenerList {
        /**
         * listener Id.
         */
        listenerId: string;
        /**
         * listener name.
         */
        listenerName: string;
        /**
         * listened port.
         */
        port: number;
        /**
         * Listener protocol type.
         */
        protocol: string;
    }

    export interface GetHttpDomainsDomain {
        /**
         * Indicates whether basic authentication is enable.
         */
        basicAuth: boolean;
        /**
         * ID of the basic authentication.
         */
        basicAuthId: string;
        /**
         * ID of the server certificate.
         */
        certificateId: string;
        /**
         * (**Deprecated**) It has been deprecated from version 1.26.0. Use `clientCertificateIds` instead. ID of the client certificate.
         *
         * @deprecated It has been deprecated from version 1.26.0. Use `clientCertificateIds` instead.
         */
        clientCertificateId: string;
        /**
         * ID list of the client certificate.
         */
        clientCertificateIds: string[];
        /**
         * Forward domain of the layer7 listener to be queried.
         */
        domain: string;
        /**
         * Indicates whether SSL certificate authentication is enable.
         */
        gaapAuth: boolean;
        /**
         * ID of the SSL certificate.
         */
        gaapAuthId: string;
        /**
         * Indicates whether realserver authentication is enable.
         */
        realserverAuth: boolean;
        /**
         * CA certificate domain of the realserver.
         */
        realserverCertificateDomain: string;
        /**
         * (**Deprecated**) It has been deprecated from version 1.28.0. Use `realserverCertificateIds` instead. CA certificate ID of the realserver.
         *
         * @deprecated It has been deprecated from version 1.28.0. Use `realserverCertificateIds` instead.
         */
        realserverCertificateId: string;
        /**
         * CA certificate ID list of the realserver.
         */
        realserverCertificateIds: string[];
    }

    export interface GetHttpRulesRule {
        /**
         * Timeout of the health check response.
         */
        connectTimeout: number;
        /**
         * Forward domain of the layer7 listener to be queried.
         */
        domain: string;
        /**
         * Requested host which is forwarded to the realserver by the listener to be queried.
         */
        forwardHost: string;
        /**
         * Indicates whether health check is enable.
         */
        healthCheck: boolean;
        /**
         * Method of the health check.
         */
        healthCheckMethod: string;
        /**
         * Path of health check.
         */
        healthCheckPath: string;
        /**
         * Return code of confirmed normal.
         */
        healthCheckStatusCodes: number[];
        /**
         * ID of the GAAP realserver.
         */
        id: string;
        /**
         * Interval of the health check.
         */
        interval: number;
        /**
         * ID of the layer7 listener to be queried.
         */
        listenerId: string;
        /**
         * Path of the forward rule to be queried.
         */
        path: string;
        /**
         * Type of the realserver.
         */
        realserverType: string;
        /**
         * An information list of GAAP realserver. Each element contains the following attributes:
         */
        realservers: outputs.Gaap.GetHttpRulesRuleRealserver[];
        /**
         * Scheduling policy of the forward rule.
         */
        scheduler: string;
        /**
         * ServerNameIndication (SNI).
         */
        sni: string;
        /**
         * ServerNameIndication (SNI) switch.
         */
        sniSwitch: string;
    }

    export interface GetHttpRulesRuleRealserver {
        /**
         * Forward domain of the layer7 listener to be queried.
         */
        domain: string;
        /**
         * ID of the GAAP realserver.
         */
        id: string;
        /**
         * IP of the GAAP realserver.
         */
        ip: string;
        /**
         * Port of the GAAP realserver.
         */
        port: number;
        /**
         * Status of the GAAP realserver.
         */
        status: number;
        /**
         * Scheduling weight.
         */
        weight: number;
    }

    export interface GetLayer4ListenersListener {
        /**
         * Timeout of the health check response.
         */
        connectTimeout: number;
        /**
         * Creation time of the layer4 listener.
         */
        createTime: string;
        /**
         * Indicates whether health check is enable.
         */
        healthCheck: boolean;
        /**
         * ID of the layer4 listener.
         */
        id: string;
        /**
         * Interval of the health check.
         */
        interval: number;
        /**
         * Name of the layer4 listener.
         */
        name: string;
        /**
         * Port of the layer4 listener to be queried.
         */
        port: number;
        /**
         * Protocol of the layer4 listener to be queried. Valid values: `TCP` and `UDP`.
         */
        protocol: string;
        /**
         * ID of the GAAP proxy to be queried.
         */
        proxyId: string;
        /**
         * Type of the realserver.
         */
        realserverType: string;
        /**
         * Scheduling policy of the layer4 listener.
         */
        scheduler: string;
        /**
         * Status of the layer4 listener.
         */
        status: number;
    }

    export interface GetLayer7ListenersListener {
        /**
         * Authentication type of the layer7 listener. `0` is one-way authentication and `1` is mutual authentication.
         */
        authType: number;
        /**
         * Certificate ID of the layer7 listener.
         */
        certificateId: string;
        /**
         * (**Deprecated**) It has been deprecated from version 1.26.0. Use `clientCertificateIds` instead. ID of the client certificate.
         *
         * @deprecated It has been deprecated from version 1.26.0. Use `clientCertificateIds` instead.
         */
        clientCertificateId: string;
        /**
         * ID list of the client certificate.
         */
        clientCertificateIds: string[];
        /**
         * Creation time of the layer7 listener.
         */
        createTime: string;
        /**
         * Protocol type of the forwarding.
         */
        forwardProtocol: string;
        /**
         * ID of the layer7 listener.
         */
        id: string;
        /**
         * Name of the layer7 listener.
         */
        name: string;
        /**
         * Port of the layer7 listener to be queried.
         */
        port: number;
        /**
         * Protocol of the layer7 listener to be queried. Valid values: `HTTP` and `HTTPS`.
         */
        protocol: string;
        /**
         * ID of the GAAP proxy to be queried.
         */
        proxyId: string;
        /**
         * Status of the layer7 listener.
         */
        status: number;
    }

    export interface GetListenerRealServersBindRealServerSet {
        /**
         * When the real server is a domain name, the domain name is resolved to one or more IPs, and this field represents the list of abnormal IPs. When the status is abnormal, but the field is empty, it indicates that the domain name resolution is abnormal.
         */
        downIPLists: string[];
        /**
         * The primary and secondary roles of the real server, &#39;master&#39; represents primary, &#39;slave&#39; represents secondary, and this parameter must be in the active and standby mode of the real server when the listener is turned on.
         */
        realServerFailoverRole: string;
        /**
         * Real Server IP.
         */
        realServerIP: string;
        /**
         * Real Server Id.
         */
        realServerId: string;
        /**
         * The port number of the real serverNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        realServerPort: number;
        /**
         * real server health check status, where:0 indicates normal;1 indicates an exception.When the health check status is not enabled, it is always normal.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        realServerStatus: number;
        /**
         * The weight of this real server.
         */
        realServerWeight: number;
    }

    export interface GetListenerRealServersRealServerSet {
        /**
         * Is it on the banned blacklist? 0 indicates not on the blacklist, and 1 indicates on the blacklist.
         */
        inBanBlacklist: number;
        /**
         * Project Id.
         */
        projectId: number;
        /**
         * Real Server IP.
         */
        realServerIP: string;
        /**
         * Real Server Id.
         */
        realServerId: string;
        /**
         * Real Server Name.
         */
        realServerName: string;
    }

    export interface GetListenerStatisticsStatisticsData {
        /**
         * Metric Data.
         */
        metricDatas: outputs.Gaap.GetListenerStatisticsStatisticsDataMetricData[];
        /**
         * Metric Name.
         */
        metricName: string;
    }

    export interface GetListenerStatisticsStatisticsDataMetricData {
        /**
         * Statistical data valueNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        data: number;
        /**
         * Time.
         */
        time: number;
    }

    export interface GetProxiesProxy {
        /**
         * Access region of the GAAP proxy to be queried. Conflict with `ids`.
         */
        accessRegion: string;
        /**
         * Maximum bandwidth of the GAAP proxy, unit is Mbps.
         */
        bandwidth: number;
        /**
         * Maximum concurrency of the GAAP proxy, unit is 10k.
         */
        concurrent: number;
        /**
         * Creation time of the GAAP proxy.
         */
        createTime: string;
        /**
         * Access domain of the GAAP proxy.
         */
        domain: string;
        /**
         * Forwarding IP of the GAAP proxy.
         */
        forwardIp: string;
        /**
         * ID of the GAAP proxy.
         */
        id: string;
        /**
         * Access domain of the GAAP proxy.
         */
        ip: string;
        /**
         * Name of the GAAP proxy.
         */
        name: string;
        /**
         * Security policy ID of the GAAP proxy.
         */
        policyId: string;
        /**
         * Project ID of the GAAP proxy to be queried. Conflict with `ids`.
         */
        projectId: number;
        /**
         * Region of the GAAP realserver to be queried. Conflict with `ids`.
         */
        realserverRegion: string;
        /**
         * Indicates whether GAAP proxy can scalable.
         */
        scalable: boolean;
        /**
         * Status of the GAAP proxy.
         */
        status: string;
        /**
         * Supported protocols of the GAAP proxy.
         */
        supportProtocols: string[];
        /**
         * Tags of the GAAP proxy to be queried. Support up to 5, display the information as long as it matches one.
         */
        tags: {[key: string]: any};
        /**
         * Version of the GAAP proxy.
         */
        version: string;
    }

    export interface GetProxiesStatusInstanceStatusSet {
        /**
         * proxy instance ID.
         */
        instanceId: string;
        /**
         * proxy status.Among them:
         * - RUNNING indicates running;
         * - CREATING indicates being created;
         * - DESTROYING indicates being destroyed;
         * - OPENING indicates being opened;
         * - CLOSING indicates being closed;
         * - Closed indicates that it has been closed;
         * - ADJUSTING represents a configuration change in progress;
         * - ISOLATING indicates being isolated;
         * - ISOLATED indicates that it has been isolated;
         * - MOVING indicates that migration is in progress.
         */
        status: string;
    }

    export interface GetProxyAndStatisticsListenersProxySet {
        /**
         * Listener List.
         */
        listenerLists: outputs.Gaap.GetProxyAndStatisticsListenersProxySetListenerList[];
        /**
         * Proxy Id.
         */
        proxyId: string;
        /**
         * Proxy Name.
         */
        proxyName: string;
    }

    export interface GetProxyAndStatisticsListenersProxySetListenerList {
        /**
         * Listener Id.
         */
        listenerId: string;
        /**
         * Listener Name.
         */
        listenerName: string;
        /**
         * listerned port.
         */
        port: number;
        /**
         * Listener protocol type.
         */
        protocol: string;
    }

    export interface GetProxyDetailProxyDetail {
        /**
         * Access Region.
         */
        accessRegion: string;
        /**
         * Detailed information about the access region, including the region ID and domain name.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        accessRegionInfos: outputs.Gaap.GetProxyDetailProxyDetailAccessRegionInfo[];
        /**
         * Blocking and Unblocking Status: BANNED indicates that the ban has been lifted, RECOVER indicates that the ban has been lifted or not, BANNING indicates that the ban is in progress, RECOVERING indicates that the ban is being lifted, BAN_FAILED indicates that the ban has failed, RECOVER_FAILED indicates that the unblocking has failed.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        banStatus: string;
        /**
         * Band width.
         */
        bandwidth: number;
        /**
         * Billing type: 0 represents bandwidth based billing, and 1 represents traffic based billing.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        billingType: number;
        /**
         * The method of obtaining client IP through proxys, where 0 represents TOA and 1 represents Proxy ProtocolNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        clientIpMethods: number[];
        /**
         * Concurrent, in 10000 pieces/second.
         */
        concurrent: number;
        /**
         * The creation time, using a Unix timestamp, represents the number of seconds that have passed since January 1, 1970 (midnight UTC/GMT).
         */
        createTime: number;
        /**
         * Domain.
         */
        domain: string;
        /**
         * Property bitmap, where each bit represents a property, where:0 indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * proxy forwarding IP.
         */
        forwardIp: string;
        /**
         * proxy group ID, which exists when a proxy belongs to a certain proxy group.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        groupId: string;
        /**
         * Identification that supports the Http3 protocol, where:0 indicates shutdown;1 indicates enabled.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        http3Supported: number;
        /**
         * Is it on the banned blacklist? 0 indicates not on the blacklist, and 1 indicates on the blacklist.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        inBanBlacklist: number;
        /**
         * (Old parameter, please use ProxyId) Proxy instance ID.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        instanceId: string;
        /**
         * IP.
         */
        ip: string;
        /**
         * IP version: IPv4, IPv6Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        ipAddressVersion: string;
        /**
         * IP ListNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        ipLists: outputs.Gaap.GetProxyDetailProxyDetailIpList[];
        /**
         * Configuration change timeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        modifyConfigTime: number;
        /**
         * A list of network types supported by the access area, with normal indicating support for regular BGP, cn2 indicating premium BGP, triple indicating three networks, and secure_EIP represents a custom secure EIP.
         */
        networkType: string;
        /**
         * proxy package type: Thunder represents standard proxy, Accelerator represents silver acceleration proxy,CrossBorder represents a cross-border proxy.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        packageType: string;
        /**
         * Security policy ID, which exists when a security policy is set.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        policyId: string;
        /**
         * Project Id.
         */
        projectId: number;
        /**
         * Proxy Id.
         */
        proxyId: string;
        /**
         * Proxy Name.
         */
        proxyName: string;
        /**
         * proxy type, 100 represents THUNDER proxy, 103 represents Microsoft cooperation proxyNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        proxyType: number;
        /**
         * Real Server Region.
         */
        realServerRegion: string;
        /**
         * Detailed information of the real server region, including the region ID and domain name.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        realServerRegionInfos: outputs.Gaap.GetProxyDetailProxyDetailRealServerRegionInfo[];
        /**
         * List of domain names associated with resolutionNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        relatedGlobalDomains: string[];
        /**
         * 1. This proxy can be scaled and expanded; 0, this proxy cannot be scaled or expanded.
         */
        scalarable: number;
        /**
         * proxy status. Among them:RUNNING indicates running;CREATING indicates being created;DESTROYING indicates being destroyed;OPENING indicates being opened;CLOSING indicates being closed;Closed indicates that it has been closed;ADJUSTING represents a configuration change in progress;ISOLATING indicates being isolated;ISOLATED indicates that it has been isolated;CLONING indicates copying;RECOVERING indicates that the proxy is being maintained;MOVING indicates that migration is in progress.
         */
        status: string;
        /**
         * Supported protocol types.
         */
        supportProtocols: string[];
        /**
         * Does it support security group configurationNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        supportSecurity: number;
        /**
         * tag list, when there are no labels, this field is an empty list.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        tagSets: outputs.Gaap.GetProxyDetailProxyDetailTagSet[];
        /**
         * Version 1.0, 2.0, 3.0.
         */
        version: string;
    }

    export interface GetProxyDetailProxyDetailAccessRegionInfo {
        /**
         * Property bitmap, where each bit represents a property, where:0 indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * The type of computer room, where dc represents the DataCenter data center and ec represents the EdgeComputing edge node.
         */
        idcType: string;
        /**
         * Region of the computer room.
         */
        regionArea: string;
        /**
         * Region name of the computer room.
         */
        regionAreaName: string;
        /**
         * Region Id.
         */
        regionId: string;
        /**
         * Region Name.
         */
        regionName: string;
        /**
         * Ability to access regional supportNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        supportFeatures: outputs.Gaap.GetProxyDetailProxyDetailAccessRegionInfoSupportFeature[];
    }

    export interface GetProxyDetailProxyDetailAccessRegionInfoSupportFeature {
        /**
         * A list of network types supported by the access area, with normal indicating support for regular BGP, cn2 indicating premium BGP, triple indicating three networks, and secure_EIP represents a custom secure EIP.
         */
        networkTypes: string[];
    }

    export interface GetProxyDetailProxyDetailIpList {
        /**
         * Band width.
         */
        bandwidth: number;
        /**
         * IP.
         */
        ip: string;
        /**
         * Supplier, BGP represents default, CMCC represents China Mobile, CUCC represents China Unicom, and CTCC represents China Telecom.
         */
        provider: string;
    }

    export interface GetProxyDetailProxyDetailRealServerRegionInfo {
        /**
         * Property bitmap, where each bit represents a property, where:0 indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * The type of computer room, where dc represents the DataCenter data center and ec represents the EdgeComputing edge node.
         */
        idcType: string;
        /**
         * Region of the computer room.
         */
        regionArea: string;
        /**
         * Region name of the computer room.
         */
        regionAreaName: string;
        /**
         * Region Id.
         */
        regionId: string;
        /**
         * Region Name.
         */
        regionName: string;
        /**
         * Ability to access regional supportNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        supportFeatures: outputs.Gaap.GetProxyDetailProxyDetailRealServerRegionInfoSupportFeature[];
    }

    export interface GetProxyDetailProxyDetailRealServerRegionInfoSupportFeature {
        /**
         * A list of network types supported by the access area, with normal indicating support for regular BGP, cn2 indicating premium BGP, triple indicating three networks, and secure_EIP represents a custom secure EIP.
         */
        networkTypes: string[];
    }

    export interface GetProxyDetailProxyDetailTagSet {
        /**
         * Tag Key.
         */
        tagKey: string;
        /**
         * Tag Value.
         */
        tagValue: string;
    }

    export interface GetProxyGroupStatisticsStatisticsData {
        /**
         * Metric Data.
         */
        metricDatas: outputs.Gaap.GetProxyGroupStatisticsStatisticsDataMetricData[];
        /**
         * Metric Name.
         */
        metricName: string;
    }

    export interface GetProxyGroupStatisticsStatisticsDataMetricData {
        /**
         * DataNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        data: number;
        /**
         * Time.
         */
        time: number;
    }

    export interface GetProxyGroupsFilter {
        /**
         * Filter conditions.
         */
        name: string;
        /**
         * filtering value.
         */
        values: string[];
    }

    export interface GetProxyGroupsProxyGroupList {
        /**
         * Create TimeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        createTime: number;
        /**
         * proxy group domain nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        domain: string;
        /**
         * Property bitmap, where each bit represents a property, where:0, indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * proxy group Id.
         */
        groupId: string;
        /**
         * proxy Group NameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        groupName: string;
        /**
         * Supports the identification of Http3 features, where:0 indicates shutdown;1 indicates enabled.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        http3Supported: number;
        /**
         * Project ID. Value range:-1, All projects under this user0, default projectOther values, specified items.
         */
        projectId: number;
        /**
         * Does the proxy group include Microsoft proxysNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        proxyType: number;
        /**
         * Real Server Region Info.
         */
        realServerRegionInfos: outputs.Gaap.GetProxyGroupsProxyGroupListRealServerRegionInfo[];
        /**
         * proxy group status.Among them,&#39;RUNNING&#39; indicates running;&#39;CREATING&#39; indicates being created;&#39;DESTROYING&#39; indicates being destroyed;&#39;MOVING&#39; indicates that the proxy is being migrated;&#39;CHANGING&#39; indicates partial deployment.
         */
        status: string;
        /**
         * Tag list, when this field exists, pulls the resource list under the corresponding tag.Supports a maximum of 5 labels. When there are two or more labels and any one of them is met, the proxy group will be pulled out.
         */
        tagSets: outputs.Gaap.GetProxyGroupsProxyGroupListTagSet[];
        /**
         * proxy Group VersionNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        version: string;
    }

    export interface GetProxyGroupsProxyGroupListRealServerRegionInfo {
        /**
         * Property bitmap, where each bit represents a property, where:0, indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * The type of computer room, where &#39;dc&#39; represents the DataCenter data center and &#39;ec&#39; represents the EdgeComputing edge node.
         */
        idcType: string;
        /**
         * Region of the computer room.
         */
        regionArea: string;
        /**
         * Region name of the computer room.
         */
        regionAreaName: string;
        /**
         * Region Id.
         */
        regionId: string;
        /**
         * Region Name.
         */
        regionName: string;
        /**
         * Ability to access regional supportNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        supportFeatures: outputs.Gaap.GetProxyGroupsProxyGroupListRealServerRegionInfoSupportFeature[];
    }

    export interface GetProxyGroupsProxyGroupListRealServerRegionInfoSupportFeature {
        /**
         * A list of network types supported by the access area, with &#39;normal&#39; indicating support for regular BGP, &#39;cn2&#39; indicating premium BGP, &#39;triple&#39; indicating three networks, and &#39;secure_EIP&#39; represents a custom secure EIP.
         */
        networkTypes: string[];
    }

    export interface GetProxyGroupsProxyGroupListTagSet {
        /**
         * Tag Key.
         */
        tagKey: string;
        /**
         * Tag Value.
         */
        tagValue: string;
    }

    export interface GetProxyGroupsTagSet {
        /**
         * Tag Key.
         */
        tagKey: string;
        /**
         * Tag Value.
         */
        tagValue: string;
    }

    export interface GetProxyStatisticsStatisticsData {
        /**
         * Metric Data.
         */
        metricDatas: outputs.Gaap.GetProxyStatisticsStatisticsDataMetricData[];
        /**
         * Metric Name.
         */
        metricName: string;
    }

    export interface GetProxyStatisticsStatisticsDataMetricData {
        /**
         * DataNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        data: number;
        /**
         * Time.
         */
        time: number;
    }

    export interface GetRealServersStatusRealServerStatusSet {
        /**
         * Bind Status, 0 indicates unbound, 1 indicates bound by rules or listeners.
         */
        bindStatus: number;
        /**
         * Bind the group ID of this real server, which is an empty string when not bound.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        groupId: string;
        /**
         * Bind the proxy ID of this real server, which is an empty string when not bound.
         */
        proxyId: string;
        /**
         * Real Server Id.
         */
        realServerId: string;
    }

    export interface GetRealserversRealserver {
        /**
         * Domain of the GAAP realserver to be queried, conflict with `ip`.
         */
        domain: string;
        /**
         * ID of the GAAP realserver.
         */
        id: string;
        /**
         * IP of the GAAP realserver to be queried, conflict with `domain`.
         */
        ip: string;
        /**
         * Name of the GAAP realserver to be queried, the maximum length is 30.
         */
        name: string;
        /**
         * ID of the project within the GAAP realserver to be queried, default value is `-1`, no set means all projects.
         */
        projectId: number;
        /**
         * Tags of the GAAP proxy to be queried. Support up to 5, display the information as long as it matches one.
         */
        tags: {[key: string]: any};
    }

    export interface GetRegionAndPriceBandwidthUnitPrice {
        /**
         * Band width Range.
         */
        bandwidthRanges: number[];
        /**
         * Band width Unit Price, Unit:yuan/Mbps/day.
         */
        bandwidthUnitPrice: number;
        /**
         * Bandwidth discount price, unit:yuan/Mbps/day.
         */
        discountBandwidthUnitPrice: number;
    }

    export interface GetRegionAndPriceDestRegionSet {
        /**
         * Property bitmap, where each bit represents a property, where:0, indicates that the feature is not supported;1, indicates support for this feature.The meaning of the feature bitmap is as follows (from right to left):The first bit supports 4-layer acceleration;The second bit supports 7-layer acceleration;The third bit supports Http3 access;The fourth bit supports IPv6;The fifth bit supports high-quality BGP access;The 6th bit supports three network access;The 7th bit supports QoS acceleration in the access segment.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        featureBitmap: number;
        /**
         * Type of computer room, dc represents DataCenter data center, ec represents EdgeComputing edge node.
         */
        idcType: string;
        /**
         * Region of the computer room.
         */
        regionArea: string;
        /**
         * Region name of the computer room.
         */
        regionAreaName: string;
        /**
         * Region Id.
         */
        regionId: string;
        /**
         * Region Name.
         */
        regionName: string;
        /**
         * Ability to access regional supportNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        supportFeatures: outputs.Gaap.GetRegionAndPriceDestRegionSetSupportFeature[];
    }

    export interface GetRegionAndPriceDestRegionSetSupportFeature {
        /**
         * A list of network types supported by the access area, with `normal` indicating support for regular BGP, `cn2` indicating premium BGP, `triple` indicating three networks, and `secureEip` represents a custom secure EIP.
         */
        networkTypes: string[];
    }

    export interface GetResourcesByTagResourceSet {
        /**
         * Resource Id.
         */
        resourceId: string;
        /**
         * Resource type, where:Proxy represents the proxy;ProxyGroup represents a proxy group;RealServer represents the Real Server.If this field is not specified, all resources under the label will be queried.
         */
        resourceType: string;
    }

    export interface GetRuleRealServersBindRealServerSet {
        /**
         * When the real server is a domain name, the domain name is resolved to one or more IPs, and this field represents the list of abnormal IPs. When the status is abnormal, but the field is empty, it indicates that the domain name resolution is abnormal.
         */
        downIpLists: string[];
        /**
         * The primary and secondary roles of the real server:master represents primary, slave represents secondary, and this parameter must be in the active and standby mode of the real server when the listener is turned on.
         */
        realServerFailoverRole: string;
        /**
         * Real Server Id.
         */
        realServerId: string;
        /**
         * Real Server IP or domain.
         */
        realServerIp: string;
        /**
         * Real Server PortNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        realServerPort: number;
        /**
         * RealServerStatus: 0 indicates normal;1 indicates an exception.When the health check status is not enabled, it is always normal.Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        realServerStatus: number;
        /**
         * Real Server Weight.
         */
        realServerWeight: number;
    }

    export interface GetRuleRealServersRealServerSet {
        /**
         * Is it on the banned blacklist? 0 indicates not on the blacklist, and 1 indicates on the blacklist.
         */
        inBanBlacklist: number;
        /**
         * Project Id.
         */
        projectId: number;
        /**
         * Real Server Id.
         */
        realServerId: string;
        /**
         * Real Server IP or domain.
         */
        realServerIp: string;
        /**
         * Real Server Name.
         */
        realServerName: string;
    }

    export interface GetSecurityRulesRule {
        /**
         * Policy of the rule to be queried.
         */
        action: string;
        /**
         * A network address block of the request source to be queried.
         */
        cidrIp: string;
        /**
         * ID of the security policy rule.
         */
        id: string;
        /**
         * Name of the security policy rule to be queried.
         */
        name: string;
        /**
         * Port of the security policy rule to be queried.
         */
        port: string;
        /**
         * Protocol of the security policy rule to be queried.
         */
        protocol: string;
    }

    export interface HttpRuleRealserver {
        /**
         * ID of the GAAP realserver.
         */
        id: string;
        /**
         * IP of the GAAP realserver.
         */
        ip: string;
        /**
         * Port of the GAAP realserver.
         */
        port: number;
        /**
         * Scheduling weight, default value is `1`. Valid value ranges: (1~100).
         */
        weight?: number;
    }

    export interface Layer4ListenerRealserverBindSet {
        /**
         * ID of the GAAP realserver.
         */
        id: string;
        /**
         * IP of the GAAP realserver.
         */
        ip: string;
        /**
         * Port of the GAAP realserver.
         */
        port: number;
        /**
         * Scheduling weight, default value is `1`. The range of values is [1,100].
         */
        weight?: number;
    }

}

export namespace Ha {
    export interface GetVipEipAttachmentsHaVipEipAttachmentList {
        /**
         * Public IP address of EIP to be queried.
         */
        addressIp: string;
        /**
         * ID of the attached HA VIP to be queried.
         */
        havipId: string;
    }

    export interface GetVipsHaVipList {
        /**
         * EIP of the HA VIP to be queried.
         */
        addressIp: string;
        /**
         * Create time of the HA VIP.
         */
        createTime: string;
        /**
         * ID of the HA VIP to be queried.
         */
        id: string;
        /**
         * Instance id that is associated.
         */
        instanceId: string;
        /**
         * Name of the HA VIP. The length of character is limited to 1-60.
         */
        name: string;
        /**
         * Network interface id that is associated.
         */
        networkInterfaceId: string;
        /**
         * State of the HA VIP. Valid values: `AVAILABLE`, `UNBIND`.
         */
        state: string;
        /**
         * Subnet id of the HA VIP to be queried.
         */
        subnetId: string;
        /**
         * Virtual IP address, it must not be occupied and in this VPC network segment. If not set, it will be assigned after resource created automatically.
         */
        vip: string;
        /**
         * VPC id of the HA VIP to be queried.
         */
        vpcId: string;
    }

}

export namespace Image {
    export interface GetInstanceFilter {
        /**
         * Key of the filter, valid keys: `image-id`, `image-type`, `image-name`.
         */
        name: string;
        /**
         * Values of the filter.
         */
        values: string[];
    }

}

export namespace Images {
    export interface GetInstanceImage {
        /**
         * Architecture of the image.
         */
        architecture: string;
        /**
         * Created time of the image.
         */
        createdTime: string;
        /**
         * Image creator of the image.
         */
        imageCreator: string;
        /**
         * Description of the image.
         */
        imageDescription: string;
        /**
         * ID of the image to be queried.
         */
        imageId: string;
        /**
         * Name of the image.
         */
        imageName: string;
        /**
         * Size of the image.
         */
        imageSize: number;
        /**
         * Image source of the image.
         */
        imageSource: string;
        /**
         * State of the image.
         */
        imageState: string;
        /**
         * A list of the image type to be queried. Valid values: 'PUBLIC_IMAGE', 'PRIVATE_IMAGE', 'SHARED_IMAGE', 'MARKET_IMAGE'.
         */
        imageType: string;
        /**
         * A string to apply with fuzzy match to the osName attribute on the image list returned by TencentCloud, conflict with 'image_name_regex'.
         */
        osName: string;
        /**
         * Platform of the image.
         */
        platform: string;
        /**
         * List of snapshot details.
         */
        snapshots: outputs.Images.GetInstanceImageSnapshot[];
        /**
         * Whether support cloud-init.
         */
        supportCloudInit: boolean;
        /**
         * Sync percent of the image.
         */
        syncPercent: number;
    }

    export interface GetInstanceImageSnapshot {
        /**
         * Size of the cloud disk used to create the snapshot; unit: GB.
         */
        diskSize: number;
        /**
         * Type of the cloud disk used to create the snapshot.
         */
        diskUsage: string;
        /**
         * Snapshot ID.
         */
        snapshotId: string;
        /**
         * Snapshot name, the user-defined snapshot alias.
         */
        snapshotName: string;
    }

}

export namespace Instance {
    export interface GetTypesFilter {
        /**
         * The filter name. Valid values: `zone`, `instance-family` and `instance-charge-type`.
         */
        name: string;
        /**
         * The filter values.
         */
        values: string[];
    }

    export interface GetTypesInstanceType {
        /**
         * The available zone that the CVM instance locates at. This field is conflict with `filter`.
         */
        availabilityZone: string;
        /**
         * The number of CPU cores of the instance.
         */
        cpuCoreCount: number;
        /**
         * Type series of the instance.
         */
        family: string;
        /**
         * The number of GPU cores of the instance.
         */
        gpuCoreCount: number;
        /**
         * Charge type of the instance.
         */
        instanceChargeType: string;
        /**
         * Type of the instance.
         */
        instanceType: string;
        /**
         * Instance memory capacity, unit in GB.
         */
        memorySize: number;
        /**
         * Sell status of the instance.
         */
        status: string;
    }

    export interface InstanceDataDisk {
        /**
         * Data disk ID used to initialize the data disk. When data disk type is `LOCAL_BASIC` and `LOCAL_SSD`, disk id is not supported.
         */
        dataDiskId: string;
        /**
         * Size of the data disk, and unit is GB.
         */
        dataDiskSize: number;
        /**
         * Snapshot ID of the data disk. The selected data disk snapshot size must be smaller than the data disk size.
         */
        dataDiskSnapshotId?: string;
        /**
         * Data disk type. For more information about limits on different data disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: LOCAL_BASIC: local disk, LOCAL_SSD: local SSD disk, LOCAL_NVME: local NVME disk, specified in the InstanceType, LOCAL_PRO: local HDD disk, specified in the InstanceType, CLOUD_BASIC: HDD cloud disk, CLOUD_PREMIUM: Premium Cloud Storage, CLOUD_SSD: SSD, CLOUD_HSSD: Enhanced SSD, CLOUD_TSSD: Tremendous SSD, CLOUD_BSSD: Balanced SSD.
         */
        dataDiskType: string;
        /**
         * Decides whether the disk is deleted with instance(only applied to `CLOUD_BASIC`, `CLOUD_SSD` and `CLOUD_PREMIUM` disk with `POSTPAID_BY_HOUR` instance), default is true.
         */
        deleteWithInstance?: boolean;
        /**
         * Decides whether the disk is encrypted. Default is `false`.
         */
        encrypt?: boolean;
        /**
         * Add extra performance to the data disk. Only works when disk type is `CLOUD_TSSD` or `CLOUD_HSSD`.
         */
        throughputPerformance?: number;
    }

}

export namespace Instances {
    export interface GetInstanceInstanceList {
        /**
         * Indicates whether public ip is assigned.
         */
        allocatePublicIp: boolean;
        /**
         * The available zone that the CVM instance locates at.
         */
        availabilityZone: string;
        /**
         * CAM role name authorized to access.
         */
        camRoleName: string;
        /**
         * The number of CPU cores of the instance.
         */
        cpu: number;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * An information list of data disk. Each element contains the following attributes:
         */
        dataDisks: outputs.Instances.GetInstanceInstanceListDataDisk[];
        /**
         * Expired time of the instance.
         */
        expiredTime: string;
        /**
         * ID of the image.
         */
        imageId: string;
        /**
         * The charge type of the instance.
         */
        instanceChargeType: string;
        /**
         * The way that CVM instance will be renew automatically or not when it reach the end of the prepaid tenancy.
         */
        instanceChargeTypePrepaidRenewFlag: string;
        /**
         * ID of the instances to be queried.
         */
        instanceId: string;
        /**
         * Name of the instances to be queried.
         */
        instanceName: string;
        /**
         * Type of the instance.
         */
        instanceType: string;
        /**
         * The charge type of the instance.
         */
        internetChargeType: string;
        /**
         * Public network maximum output bandwidth of the instance.
         */
        internetMaxBandwidthOut: number;
        /**
         * Instance memory capacity, unit in GB.
         */
        memory: number;
        /**
         * Instance os name.
         */
        osName: string;
        /**
         * Private IP of the instance.
         */
        privateIp: string;
        /**
         * The project CVM belongs to.
         */
        projectId: number;
        /**
         * Public IP of the instance.
         */
        publicIp: string;
        /**
         * Security groups of the instance.
         */
        securityGroups: string[];
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * ID of a vpc subnetwork.
         */
        subnetId: string;
        /**
         * Image ID of the system disk.
         */
        systemDiskId: string;
        /**
         * Size of the system disk.
         */
        systemDiskSize: number;
        /**
         * Type of the system disk.
         */
        systemDiskType: string;
        /**
         * Tags of the instance.
         */
        tags: {[key: string]: any};
        /**
         * ID of the vpc to be queried.
         */
        vpcId: string;
    }

    export interface GetInstanceInstanceListDataDisk {
        /**
         * Image ID of the data disk.
         */
        dataDiskId: string;
        /**
         * Size of the data disk.
         */
        dataDiskSize: number;
        /**
         * Type of the data disk.
         */
        dataDiskType: string;
        /**
         * Indicates whether the data disk is destroyed with the instance.
         */
        deleteWithInstance: boolean;
    }

    export interface GetSetInstanceList {
        /**
         * Indicates whether public ip is assigned.
         */
        allocatePublicIp: boolean;
        /**
         * The available zone that the CVM instance locates at.
         */
        availabilityZone: string;
        /**
         * CAM role name authorized to access.
         */
        camRoleName: string;
        /**
         * The number of CPU cores of the instance.
         */
        cpu: number;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * An information list of data disk. Each element contains the following attributes:
         */
        dataDisks: outputs.Instances.GetSetInstanceListDataDisk[];
        /**
         * Expired time of the instance.
         */
        expiredTime: string;
        /**
         * ID of the image.
         */
        imageId: string;
        /**
         * The charge type of the instance.
         */
        instanceChargeType: string;
        /**
         * The way that CVM instance will be renew automatically or not when it reach the end of the prepaid tenancy.
         */
        instanceChargeTypePrepaidRenewFlag: string;
        /**
         * ID of the instances to be queried.
         */
        instanceId: string;
        /**
         * Name of the instances to be queried.
         */
        instanceName: string;
        /**
         * Type of the instance.
         */
        instanceType: string;
        /**
         * The charge type of the instance.
         */
        internetChargeType: string;
        /**
         * Public network maximum output bandwidth of the instance.
         */
        internetMaxBandwidthOut: number;
        /**
         * Instance memory capacity, unit in GB.
         */
        memory: number;
        /**
         * Private IP of the instance.
         */
        privateIp: string;
        /**
         * The project CVM belongs to.
         */
        projectId: number;
        /**
         * Public IP of the instance.
         */
        publicIp: string;
        /**
         * Security groups of the instance.
         */
        securityGroups: string[];
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * ID of a vpc subnetwork.
         */
        subnetId: string;
        /**
         * Image ID of the system disk.
         */
        systemDiskId: string;
        /**
         * Size of the system disk.
         */
        systemDiskSize: number;
        /**
         * Type of the system disk.
         */
        systemDiskType: string;
        /**
         * Tags of the instance.
         */
        tags: {[key: string]: any};
        /**
         * ID of the vpc to be queried.
         */
        vpcId: string;
    }

    export interface GetSetInstanceListDataDisk {
        /**
         * Image ID of the data disk.
         */
        dataDiskId: string;
        /**
         * Size of the data disk.
         */
        dataDiskSize: number;
        /**
         * Type of the data disk.
         */
        dataDiskType: string;
        /**
         * Indicates whether the data disk is destroyed with the instance.
         */
        deleteWithInstance: boolean;
    }

}

export namespace Key {
    export interface GetPairsKeyPairList {
        /**
         * Creation time of the key pair.
         */
        createTime: string;
        /**
         * ID of the key pair to be queried.
         */
        keyId: string;
        /**
         * Name of the key pair to be queried. Support regular expression search, only `^` and `$` are supported.
         */
        keyName: string;
        /**
         * Project ID of the key pair to be queried.
         */
        projectId: number;
        /**
         * public key of the key pair.
         */
        publicKey: string;
    }

}

export namespace Kms {
    export interface GetDescribeKeysKeyList {
        /**
         * Name of CMK.
         */
        alias: string;
        /**
         * Create time of CMK.
         */
        createTime: number;
        /**
         * Uin of CMK Creator.
         */
        creatorUin: number;
        /**
         * Delete time of CMK.
         */
        deletionDate: number;
        /**
         * Description of CMK.
         */
        description: string;
        /**
         * ID of CMK.
         */
        keyId: string;
        /**
         * Specify whether to enable key rotation.
         */
        keyRotationEnabled: boolean;
        /**
         * State of CMK.
         */
        keyState: string;
        /**
         * Usage of CMK.
         */
        keyUsage: string;
        /**
         * Next rotate time of CMK when keyRotationEnabled is true.
         */
        nextRotateTime: number;
        /**
         * Origin of CMK. `TENCENT_KMS` - CMK created by KMS, `EXTERNAL` - CMK imported by user.
         */
        origin: string;
        /**
         * Creator of CMK.
         */
        owner: string;
        /**
         * Valid when origin is `EXTERNAL`, it means the effective date of the key material.
         */
        validTo: number;
    }

    export interface GetKeysKeyList {
        /**
         * Name of CMK.
         */
        alias: string;
        /**
         * Create time of CMK.
         */
        createTime: number;
        /**
         * Uin of CMK Creator.
         */
        creatorUin: number;
        /**
         * Delete time of CMK.
         */
        deletionDate: number;
        /**
         * Description of CMK.
         */
        description: string;
        /**
         * ID of CMK.
         */
        keyId: string;
        /**
         * Specify whether to enable key rotation.
         */
        keyRotationEnabled: boolean;
        /**
         * Filter by state of CMK. `0` - all CMKs are queried, `1` - only Enabled CMKs are queried, `2` - only Disabled CMKs are queried, `3` - only PendingDelete CMKs are queried, `4` - only PendingImport CMKs are queried, `5` - only Archived CMKs are queried.
         */
        keyState: string;
        /**
         * Filter by usage of CMK. Available values include `ALL`, `ENCRYPT_DECRYPT`, `ASYMMETRIC_DECRYPT_RSA_2048`, `ASYMMETRIC_DECRYPT_SM2`, `ASYMMETRIC_SIGN_VERIFY_SM2`, `ASYMMETRIC_SIGN_VERIFY_RSA_2048`, `ASYMMETRIC_SIGN_VERIFY_ECC`. Default value is `ENCRYPT_DECRYPT`.
         */
        keyUsage: string;
        /**
         * Next rotate time of CMK when keyRotationEnabled is true.
         */
        nextRotateTime: number;
        /**
         * Filter by origin of CMK. `TENCENT_KMS` - CMK created by KMS, `EXTERNAL` - CMK imported by user, `ALL` - all CMKs. Default value is `ALL`.
         */
        origin: string;
        /**
         * Creator of CMK.
         */
        owner: string;
        /**
         * Valid when origin is `EXTERNAL`, it means the effective date of the key material.
         */
        validTo: number;
    }

    export interface GetListAlgorithmsAsymmetricAlgorithm {
        /**
         * Algorithm.
         */
        algorithm: string;
        /**
         * Key usage.
         */
        keyUsage: string;
    }

    export interface GetListAlgorithmsAsymmetricSignVerifyAlgorithm {
        /**
         * Algorithm.
         */
        algorithm: string;
        /**
         * Key usage.
         */
        keyUsage: string;
    }

    export interface GetListAlgorithmsSymmetricAlgorithm {
        /**
         * Algorithm.
         */
        algorithm: string;
        /**
         * Key usage.
         */
        keyUsage: string;
    }

    export interface GetListKeysKey {
        /**
         * ID of CMK.
         */
        keyId: string;
    }

    export interface GetWhiteBoxDeviceFingerprintsList {
        /**
         * Description.
         */
        description: string;
        /**
         * identity.
         */
        identity: string;
    }

    export interface GetWhiteBoxKeyDetailsKeyInfo {
        /**
         * The type of algorithm used by the key.
         */
        algorithm: string;
        /**
         * As an alias for a key that is easier to identify and easier to understand, it cannot be empty and is a combination of 1-60 alphanumeric characters - _. The first character must be a letter or number. It cannot be repeated.
         */
        alias: string;
        /**
         * Key creation time, Unix timestamp.
         */
        createTime: number;
        /**
         * Creator.
         */
        creatorUin: number;
        /**
         * White box decryption key, base64 encoded.
         */
        decryptKey: string;
        /**
         * Description of the key.
         */
        description: string;
        /**
         * Is there a device fingerprint bound to the current key?.
         */
        deviceFingerprintBind: boolean;
        /**
         * White box encryption key, base64 encoded.
         */
        encryptKey: string;
        /**
         * Globally unique identifier for the white box key.
         */
        keyId: string;
        /**
         * Creator.
         */
        ownerUin: number;
        /**
         * Resource ID, format: creatorUin/$creatorUin/$keyId.
         */
        resourceId: string;
        /**
         * The status of the white box key, the value is: Enabled | Disabled.
         */
        status: string;
    }

    export interface OverwriteWhiteBoxDeviceFingerprintsDeviceFingerprint {
        /**
         * Description.
         */
        description?: string;
        /**
         * identity.
         */
        identity: string;
    }

}

export namespace Kubernetes {
    export interface ClusterAttachmentWorkerConfig {
        /**
         * Configurations of data disk.
         */
        dataDisks?: outputs.Kubernetes.ClusterAttachmentWorkerConfigDataDisk[];
        /**
         * Indicate to set desired pod number in node. valid when the cluster is podCIDR.
         */
        desiredPodNum?: number;
        /**
         * Docker graph path. Default is `/var/lib/docker`.
         */
        dockerGraphPath?: string;
        /**
         * Custom parameter information related to the node. This is a white-list parameter.
         */
        extraArgs?: string[];
        /**
         * GPU driver parameters.
         */
        gpuArgs?: outputs.Kubernetes.ClusterAttachmentWorkerConfigGpuArgs;
        /**
         * Indicate to schedule the adding node or not. Default is true.
         */
        isSchedule?: boolean;
        /**
         * Mount target. Default is not mounting.
         */
        mountTarget?: string;
        /**
         * Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
         */
        preStartUserScript?: string;
        /**
         * Base64-encoded User Data text, the length limit is 16KB.
         */
        userData?: string;
    }

    export interface ClusterAttachmentWorkerConfigDataDisk {
        /**
         * Indicate whether to auto format and mount or not. Default is `false`.
         */
        autoFormatAndMount?: boolean;
        /**
         * The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
         */
        diskPartition?: string;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
         */
        diskType?: string;
        /**
         * File system, e.g. `ext3/ext4/xfs`.
         */
        fileSystem?: string;
        /**
         * Mount target.
         */
        mountTarget?: string;
    }

    export interface ClusterAttachmentWorkerConfigGpuArgs {
        /**
         * CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        cuda?: {[key: string]: any};
        /**
         * cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `docName`: Doc name of cuDNN; `devName`: Dev name of cuDNN.
         */
        cudnn?: {[key: string]: any};
        /**
         * Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
         */
        customDriver?: {[key: string]: any};
        /**
         * GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        driver?: {[key: string]: any};
        /**
         * Whether to enable MIG.
         */
        migEnable?: boolean;
    }

    export interface ClusterAttachmentWorkerConfigOverrides {
        /**
         * Configurations of data disk.
         */
        dataDisks?: outputs.Kubernetes.ClusterAttachmentWorkerConfigOverridesDataDisk[];
        /**
         * Indicate to set desired pod number in node. valid when the cluster is podCIDR.
         */
        desiredPodNum?: number;
        /**
         * Docker graph path. Default is `/var/lib/docker`.
         */
        dockerGraphPath?: string;
        /**
         * Custom parameter information related to the node. This is a white-list parameter.
         */
        extraArgs?: string[];
        /**
         * GPU driver parameters.
         */
        gpuArgs?: outputs.Kubernetes.ClusterAttachmentWorkerConfigOverridesGpuArgs;
        /**
         * Indicate to schedule the adding node or not. Default is true.
         */
        isSchedule?: boolean;
        /**
         * Mount target. Default is not mounting.
         */
        mountTarget?: string;
        /**
         * Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
         */
        preStartUserScript?: string;
        /**
         * Base64-encoded User Data text, the length limit is 16KB.
         */
        userData?: string;
    }

    export interface ClusterAttachmentWorkerConfigOverridesDataDisk {
        /**
         * Indicate whether to auto format and mount or not. Default is `false`.
         */
        autoFormatAndMount?: boolean;
        /**
         * The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
         */
        diskPartition?: string;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
         */
        diskType?: string;
        /**
         * File system, e.g. `ext3/ext4/xfs`.
         */
        fileSystem?: string;
        /**
         * Mount target.
         */
        mountTarget?: string;
    }

    export interface ClusterAttachmentWorkerConfigOverridesGpuArgs {
        /**
         * CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        cuda?: {[key: string]: any};
        /**
         * cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `docName`: Doc name of cuDNN; `devName`: Dev name of cuDNN.
         */
        cudnn?: {[key: string]: any};
        /**
         * Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
         */
        customDriver?: {[key: string]: any};
        /**
         * GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        driver?: {[key: string]: any};
        /**
         * Whether to enable MIG.
         */
        migEnable?: boolean;
    }

    export interface ClusterAuthOptions {
        /**
         * If set to `true`, the rbac rule will be created automatically which allow anonymous user to access '/.well-known/openid-configuration' and '/openid/v1/jwks'.
         */
        autoCreateDiscoveryAnonymousAuth?: boolean;
        /**
         * Specify service-account-issuer. If useTkeDefault is set to `true`, please do not set this field, it will be ignored anyway.
         */
        issuer?: string;
        /**
         * Specify service-account-jwks-uri. If useTkeDefault is set to `true`, please do not set this field, it will be ignored anyway.
         */
        jwksUri?: string;
        /**
         * If set to `true`, the issuer and jwksUri will be generated automatically by tke, please do not set issuer and jwks_uri, and they will be ignored.
         */
        useTkeDefault?: boolean;
    }

    export interface ClusterClusterAudit {
        /**
         * when you want to close the cluster audit log or delete the cluster, you can use this parameter to determine whether the audit log set and topic created by default will be deleted.
         */
        deleteAuditLogAndTopic?: boolean;
        /**
         * Specify weather the Cluster Audit enabled. NOTE: Enable Cluster Audit will also auto install Log Agent.
         */
        enabled: boolean;
        /**
         * Specify id of existing CLS log set, or auto create a new set by leave it empty.
         */
        logSetId?: string;
        /**
         * Specify id of existing CLS log topic, or auto create a new topic by leave it empty.
         */
        topicId?: string;
    }

    export interface ClusterClusterExtraArgs {
        /**
         * The customized parameters for kube-apiserver.
         */
        kubeApiservers?: string[];
        /**
         * The customized parameters for kube-controller-manager.
         */
        kubeControllerManagers?: string[];
        /**
         * The customized parameters for kube-scheduler.
         */
        kubeSchedulers?: string[];
    }

    export interface ClusterEventPersistence {
        /**
         * when you want to close the cluster event persistence or delete the cluster, you can use this parameter to determine whether the event persistence log set and topic created by default will be deleted.
         */
        deleteEventLogAndTopic?: boolean;
        /**
         * Specify weather the Event Persistence enabled.
         */
        enabled: boolean;
        /**
         * Specify id of existing CLS log set, or auto create a new set by leave it empty.
         */
        logSetId?: string;
        /**
         * Specify id of existing CLS log topic, or auto create a new topic by leave it empty.
         */
        topicId?: string;
    }

    export interface ClusterExistInstance {
        /**
         * Custom mode cluster, you can specify the number of pods for each node. corresponding to the existed_instances_para.instance_ids parameter.
         */
        desiredPodNumbers?: number[];
        /**
         * Reinstallation parameters of an existing instance.
         */
        instancesPara?: outputs.Kubernetes.ClusterExistInstanceInstancesPara;
        /**
         * Role of existed node. value:MASTER_ETCD or WORKER.
         */
        nodeRole?: string;
    }

    export interface ClusterExistInstanceInstancesPara {
        /**
         * Cluster IDs.
         */
        instanceIds: string[];
    }

    export interface ClusterExtensionAddon {
        /**
         * Add-on name.
         */
        name: string;
        /**
         * Parameter of the add-on resource object in JSON string format, please check the example at the top of page for reference.
         */
        param: string;
    }

    export interface ClusterLogAgent {
        /**
         * Whether the log agent enabled.
         */
        enabled: boolean;
        /**
         * Kubelet root directory as the literal.
         */
        kubeletRootDir?: string;
    }

    export interface ClusterMasterConfig {
        /**
         * Indicates which availability zone will be used.
         */
        availabilityZone?: string;
        /**
         * bandwidth package id. if user is standard user, then the bandwidthPackageId is needed, or default has bandwidth_package_id.
         */
        bandwidthPackageId?: string;
        /**
         * CAM role name authorized to access.
         */
        camRoleName?: string;
        /**
         * Number of cvm.
         */
        count?: number;
        /**
         * Configurations of data disk.
         */
        dataDisks?: outputs.Kubernetes.ClusterMasterConfigDataDisk[];
        /**
         * Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desiredPodNum` or none.
         */
        desiredPodNum?: number;
        /**
         * Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
         */
        disasterRecoverGroupIds?: string;
        /**
         * To specify whether to enable cloud monitor service. Default is TRUE.
         */
        enhancedMonitorService?: boolean;
        /**
         * To specify whether to enable cloud security service. Default is TRUE.
         */
        enhancedSecurityService?: boolean;
        /**
         * The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
         */
        hostname?: string;
        /**
         * Id of cvm hpc cluster.
         */
        hpcClusterId?: string;
        /**
         * The valid image id, format of img-xxx.
         */
        imgId?: string;
        /**
         * The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
         */
        instanceChargeType?: string;
        /**
         * The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instanceChargeType is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
         */
        instanceChargeTypePrepaidPeriod?: number;
        /**
         * Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instanceChargeType is set to `PREPAID`.
         */
        instanceChargeTypePrepaidRenewFlag: string;
        /**
         * Name of the CVMs.
         */
        instanceName?: string;
        /**
         * Specified types of CVM instance.
         */
        instanceType: string;
        /**
         * Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
         */
        internetChargeType?: string;
        /**
         * Max bandwidth of Internet access in Mbps. Default is 0.
         */
        internetMaxBandwidthOut?: number;
        /**
         * ID list of keys, should be set if `password` not set.
         */
        keyIds?: string;
        /**
         * Password to access, should be set if `keyIds` not set.
         */
        password?: string;
        /**
         * Specify whether to assign an Internet IP address.
         */
        publicIpAssigned?: boolean;
        /**
         * Security groups to which a CVM instance belongs.
         */
        securityGroupIds?: string[];
        /**
         * Private network ID.
         */
        subnetId: string;
        /**
         * Volume of system disk in GB. Default is `50`.
         */
        systemDiskSize?: number;
        /**
         * System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
         */
        systemDiskType?: string;
        /**
         * User data provided to instances, needs to be encoded in base64, and the maximum supported data size is 16KB.
         */
        userData?: string;
    }

    export interface ClusterMasterConfigDataDisk {
        /**
         * Indicate whether to auto format and mount or not. Default is `false`.
         */
        autoFormatAndMount?: boolean;
        /**
         * The name of the device or partition to mount.
         */
        diskPartition?: string;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
         */
        diskType?: string;
        /**
         * Indicates whether to encrypt data disk, default `false`.
         */
        encrypt?: boolean;
        /**
         * File system, e.g. `ext3/ext4/xfs`.
         */
        fileSystem?: string;
        /**
         * ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
         */
        kmsKeyId?: string;
        /**
         * Mount target.
         */
        mountTarget?: string;
        /**
         * Data disk snapshot ID.
         */
        snapshotId?: string;
    }

    export interface ClusterNodePoolGlobalConfig {
        /**
         * Indicates which scale-out method will be used when there are multiple scaling groups. Valid values: `random` - select a random scaling group, `most-pods` - select the scaling group that can schedule the most pods, `least-waste` - select the scaling group that can ensure the fewest remaining resources after Pod scheduling.
         */
        expander: string;
        /**
         * Whether to ignore DaemonSet pods by default when calculating resource usage.
         */
        ignoreDaemonSetsUtilization: boolean;
        /**
         * Indicates whether to enable scale-in.
         */
        isScaleInEnabled: boolean;
        /**
         * Max concurrent scale-in volume.
         */
        maxConcurrentScaleIn: number;
        /**
         * Number of minutes after cluster scale-out when the system starts judging whether to perform scale-in.
         */
        scaleInDelay: number;
        /**
         * Number of consecutive minutes of idleness after which the node is subject to scale-in.
         */
        scaleInUnneededTime: number;
        /**
         * Percentage of node resource usage below which the node is considered to be idle.
         */
        scaleInUtilizationThreshold: number;
        /**
         * During scale-in, ignore nodes with local storage pods.
         */
        skipNodesWithLocalStorage: boolean;
        /**
         * During scale-in, ignore nodes with pods in the kube-system namespace that are not managed by DaemonSet.
         */
        skipNodesWithSystemPods: boolean;
    }

    export interface ClusterWorkerConfig {
        /**
         * Indicates which availability zone will be used.
         */
        availabilityZone?: string;
        /**
         * bandwidth package id. if user is standard user, then the bandwidthPackageId is needed, or default has bandwidth_package_id.
         */
        bandwidthPackageId?: string;
        /**
         * CAM role name authorized to access.
         */
        camRoleName?: string;
        /**
         * Number of cvm.
         */
        count?: number;
        /**
         * Configurations of data disk.
         */
        dataDisks?: outputs.Kubernetes.ClusterWorkerConfigDataDisk[];
        /**
         * Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desiredPodNum` or none.
         */
        desiredPodNum?: number;
        /**
         * Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
         */
        disasterRecoverGroupIds?: string;
        /**
         * To specify whether to enable cloud monitor service. Default is TRUE.
         */
        enhancedMonitorService?: boolean;
        /**
         * To specify whether to enable cloud security service. Default is TRUE.
         */
        enhancedSecurityService?: boolean;
        /**
         * The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
         */
        hostname?: string;
        /**
         * Id of cvm hpc cluster.
         */
        hpcClusterId?: string;
        /**
         * The valid image id, format of img-xxx.
         */
        imgId?: string;
        /**
         * The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
         */
        instanceChargeType?: string;
        /**
         * The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instanceChargeType is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
         */
        instanceChargeTypePrepaidPeriod?: number;
        /**
         * Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instanceChargeType is set to `PREPAID`.
         */
        instanceChargeTypePrepaidRenewFlag: string;
        /**
         * Name of the CVMs.
         */
        instanceName?: string;
        /**
         * Specified types of CVM instance.
         */
        instanceType: string;
        /**
         * Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
         */
        internetChargeType?: string;
        /**
         * Max bandwidth of Internet access in Mbps. Default is 0.
         */
        internetMaxBandwidthOut?: number;
        /**
         * ID list of keys, should be set if `password` not set.
         */
        keyIds?: string;
        /**
         * Password to access, should be set if `keyIds` not set.
         */
        password?: string;
        /**
         * Specify whether to assign an Internet IP address.
         */
        publicIpAssigned?: boolean;
        /**
         * Security groups to which a CVM instance belongs.
         */
        securityGroupIds?: string[];
        /**
         * Private network ID.
         */
        subnetId: string;
        /**
         * Volume of system disk in GB. Default is `50`.
         */
        systemDiskSize?: number;
        /**
         * System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
         */
        systemDiskType?: string;
        /**
         * User data provided to instances, needs to be encoded in base64, and the maximum supported data size is 16KB.
         */
        userData?: string;
    }

    export interface ClusterWorkerConfigDataDisk {
        /**
         * Indicate whether to auto format and mount or not. Default is `false`.
         */
        autoFormatAndMount?: boolean;
        /**
         * The name of the device or partition to mount.
         */
        diskPartition?: string;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
         */
        diskType?: string;
        /**
         * Indicates whether to encrypt data disk, default `false`.
         */
        encrypt?: boolean;
        /**
         * File system, e.g. `ext3/ext4/xfs`.
         */
        fileSystem?: string;
        /**
         * ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
         */
        kmsKeyId?: string;
        /**
         * Mount target.
         */
        mountTarget?: string;
        /**
         * Data disk snapshot ID.
         */
        snapshotId?: string;
    }

    export interface ClusterWorkerInstancesList {
        /**
         * Information of the cvm when it is failed.
         */
        failedReason: string;
        /**
         * ID of the cvm.
         */
        instanceId: string;
        /**
         * Role of the cvm.
         */
        instanceRole: string;
        /**
         * State of the cvm.
         */
        instanceState: string;
        /**
         * LAN IP of the cvm.
         */
        lanIp: string;
    }

    export interface EncryptionProtectionKmsConfiguration {
        /**
         * kms id.
         */
        keyId?: string;
        /**
         * kms region.
         */
        kmsRegion?: string;
    }

    export interface GetAvailableClusterVersionsCluster {
        /**
         * Cluster Id.
         */
        clusterId: string;
        /**
         * Upgradable cluster version number. Note: This field may return null, indicating that no valid value can be obtained.
         */
        versions: string[];
    }

    export interface GetChartsChartList {
        /**
         * Label of chart.
         */
        label: {[key: string]: any};
        /**
         * Chart latest version.
         */
        latestVersion: string;
        /**
         * Name of chart.
         */
        name: string;
    }

    export interface GetClusterAuthenticationOptionsOidcConfig {
        /**
         * Creating ClientId of the identity provider. Note: This field may return `null`, indicating that no valid value can be obtained.
         */
        autoCreateClientIds: string[];
        /**
         * Creating an identity provider. Note: This field may return `null`, indicating that no valid value can be obtained.
         */
        autoCreateOidcConfig: boolean;
        /**
         * Creating the PodIdentityWebhook component. Note: This field may return `null`, indicating that no valid value can be obtained.
         */
        autoInstallPodIdentityWebhookAddon: boolean;
    }

    export interface GetClusterAuthenticationOptionsServiceAccount {
        /**
         * If it is set to `true`, a RABC rule is automatically created to allow anonymous users to access `/.well-known/openid-configuration` and `/openid/v1/jwks`. Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        autoCreateDiscoveryAnonymousAuth: boolean;
        /**
         * service-account-issuer. Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        issuer: string;
        /**
         * service-account-jwks-uri. Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        jwksUri: string;
        /**
         * Use TKE default issuer and jwksuri. Note: This field may return `null`, indicating that no valid values can be obtained.
         */
        useTkeDefault: boolean;
    }

    export interface GetClusterCommonNamesList {
        /**
         * The CommonName in the certificate of the client corresponding to the sub-account.
         */
        commonNames: string;
        /**
         * User UIN.
         */
        subaccountUin: string;
    }

    export interface GetClusterInstancesFilter {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
         */
        values: string[];
    }

    export interface GetClusterInstancesInstanceSet {
        /**
         * Auto scaling group ID.
         */
        autoscalingGroupId: string;
        /**
         * Add time.
         */
        createdTime: string;
        /**
         * Whether the instance is blocked.
         */
        drainStatus: string;
        /**
         * Reasons for instance exception (or being initialized).
         */
        failedReason: string;
        /**
         * Node configuration.
         */
        instanceAdvancedSettings: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSetting[];
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Node role, MASTER, WORKER, ETCD, MASTER_ETCD,ALL, default is WORKER.
         */
        instanceRole: string;
        /**
         * The status of the instance (running, initializing, failed).
         */
        instanceState: string;
        /**
         * Node intranet IP.
         */
        lanIp: string;
        /**
         * Resource pool ID.
         */
        nodePoolId: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSetting {
        /**
         * Multi-disk data disk mounting information.
         */
        dataDisks: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingDataDisk[];
        /**
         * When the node belongs to the podCIDR size customization mode, you can specify the upper limit of the number of pods running on the node.
         */
        desiredPodNumber: number;
        /**
         * Dockerd --graph specifies the value, the default is /var/lib/docker.
         */
        dockerGraphPath: string;
        /**
         * Node-related custom parameter information.
         */
        extraArgs: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingExtraArg[];
        /**
         * GPU driver related parameters, obtain related GPU parameters: https://cloud.tencent.com/document/api/213/15715.
         */
        gpuArgs: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArg[];
        /**
         * Node Label array.
         */
        labels: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingLabel[];
        /**
         * Data disk mount point, the data disk is not mounted by default. Formatted ext3, ext4, xfs file system data disks will be mounted directly. Other file systems or unformatted data disks will be automatically formatted as ext4 (tlinux system formatted as xfs) and mounted. Please pay attention to backing up the data. This setting does not take effect for cloud hosts that have no data disks or multiple data disks.
         */
        mountTarget: string;
        /**
         * Base64 encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
         */
        preStartUserScript: string;
        /**
         * Node taint.
         */
        taints: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingTaint[];
        /**
         * Set whether the added node participates in scheduling. The default value is 0, which means participating in scheduling; non-0 means not participating in scheduling. After the node initialization is completed, you can execute kubectl uncordon nodename to join the node in scheduling.
         */
        unschedulable: number;
        /**
         * Base64 encoded userscript.
         */
        userScript: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingDataDisk {
        /**
         * Whether to automatically format the disk and mount it.
         */
        autoFormatAndMount: boolean;
        /**
         * Mount device name or partition name, required when and only when adding an existing node.
         */
        diskPartition: string;
        /**
         * Cloud disk size (G).
         */
        diskSize: number;
        /**
         * Cloud disk type.
         */
        diskType: string;
        /**
         * File system (ext3/ext4/xfs).
         */
        fileSystem: string;
        /**
         * Data disk mount point, the data disk is not mounted by default. Formatted ext3, ext4, xfs file system data disks will be mounted directly. Other file systems or unformatted data disks will be automatically formatted as ext4 (tlinux system formatted as xfs) and mounted. Please pay attention to backing up the data. This setting does not take effect for cloud hosts that have no data disks or multiple data disks.
         */
        mountTarget: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingExtraArg {
        /**
         * Kubelet custom parameters.
         */
        kubelets: string[];
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArg {
        /**
         * CUDA version information.
         */
        cudas: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCuda[];
        /**
         * CuDNN version information.
         */
        cudnns: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudnn[];
        /**
         * Custom GPU driver information.
         */
        customDrivers: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCustomDriver[];
        /**
         * GPU driver version information.
         */
        drivers: outputs.Kubernetes.GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgDriver[];
        /**
         * Whether to enable MIG features.
         */
        migEnable: boolean;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCuda {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * GPU driver or CUDA version.
         */
        version: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCudnn {
        /**
         * Dev name of cuDNN.
         */
        devName: string;
        /**
         * Doc name of cuDNN.
         */
        docName: string;
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * GPU driver or CUDA version.
         */
        version: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgCustomDriver {
        /**
         * Custom GPU driver address link.
         */
        address: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingGpuArgDriver {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * GPU driver or CUDA version.
         */
        version: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingLabel {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * Value of taints mark.
         */
        value: string;
    }

    export interface GetClusterInstancesInstanceSetInstanceAdvancedSettingTaint {
        /**
         * Effect of taints mark.
         */
        effect: string;
        /**
         * Key of taints mark.
         */
        key: string;
        /**
         * Value of taints mark.
         */
        value: string;
    }

    export interface GetClusterLevelsList {
        /**
         * Alias used for pass to cluster level arguments.
         */
        alias: string;
        /**
         * Number of ConfigMaps.
         */
        configMapCount: number;
        /**
         * Number of CRDs.
         */
        crdCount: number;
        /**
         * Indicates whether the current level enabled.
         */
        enable: boolean;
        /**
         * Level name.
         */
        name: string;
        /**
         * Number of nodes.
         */
        nodeCount: number;
        /**
         * Number of others.
         */
        otherCount: number;
        /**
         * Number of pods.
         */
        podCount: number;
    }

    export interface GetClusterNodePoolsFilter {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.
         */
        values: string[];
    }

    export interface GetClusterNodePoolsNodePoolSet {
        /**
         * ID of autoscaling group.
         */
        autoscalingGroupId: string;
        /**
         * Status information.
         */
        autoscalingGroupStatus: string;
        /**
         * ID of the cluster.
         */
        clusterInstanceId: string;
        /**
         * Multi disk data disk mounting information.
         */
        dataDisks: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetDataDisk[];
        /**
         * Remove protection switch.
         */
        deletionProtection: boolean;
        /**
         * Expected number of nodes.
         */
        desiredNodesNum: number;
        /**
         * When the cluster belongs to the node podCIDR size customization mode, the node pool needs to have the pod number attribute.
         */
        desiredPodNum: number;
        /**
         * Dockerd --graph specified value, default to /var/lib/docker.
         */
        dockerGraphPath: string;
        /**
         * Node configuration.
         */
        extraArgs: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetExtraArg[];
        /**
         * GPU driver related parameters.
         */
        gpuArgs: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetGpuArg[];
        /**
         * ID of image.
         */
        imageId: string;
        /**
         * Labels of the node pool.
         */
        labels: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetLabel[];
        /**
         * ID of launch configuration.
         */
        launchConfigurationId: string;
        /**
         * Life cycle state of the node pool, include: creating, normal, updating, deleting, deleted.
         */
        lifeState: string;
        /**
         * Maximum number of nodes.
         */
        maxNodesNum: number;
        /**
         * Minimum number of nodes.
         */
        minNodesNum: number;
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * Node List.
         */
        nodeCountSummaries: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetNodeCountSummary[];
        /**
         * ID of the node pool.
         */
        nodePoolId: string;
        /**
         * Node Pool OS Name.
         */
        nodePoolOs: string;
        /**
         * Mirror version of container.
         */
        osCustomizeType: string;
        /**
         * User defined script, executed before User Script.
         */
        preStartUserScript: string;
        /**
         * Resource tags.
         */
        tags: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetTag[];
        /**
         * Labels of the node pool.
         */
        taints: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetTaint[];
        /**
         * Is it not schedulable.
         */
        unschedulable: number;
        /**
         * User defined scripts.
         */
        userScript: string;
    }

    export interface GetClusterNodePoolsNodePoolSetDataDisk {
        /**
         * Whether to automate the format disk and mount it.
         */
        autoFormatAndMount: boolean;
        /**
         * Mount device name or partition name.
         */
        diskPartition: string;
        /**
         * Cloud disk size(G).
         */
        diskSize: number;
        /**
         * Cloud disk type.
         */
        diskType: string;
        /**
         * File system(ext3/ext4/xfs).
         */
        fileSystem: string;
        /**
         * Mount directory.
         */
        mountTarget: string;
    }

    export interface GetClusterNodePoolsNodePoolSetExtraArg {
        /**
         * Kubelet custom parameters.
         */
        kubelets: string[];
    }

    export interface GetClusterNodePoolsNodePoolSetGpuArg {
        /**
         * CUDA version information.
         */
        cudas: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetGpuArgCuda[];
        /**
         * CuDNN version information.
         */
        cudnns: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetGpuArgCudnn[];
        /**
         * Custom GPU driver information.
         */
        customDrivers: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetGpuArgCustomDriver[];
        /**
         * GPU driver version information.
         */
        drivers: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetGpuArgDriver[];
        /**
         * Is the MIG feature enabled.
         */
        migEnable: boolean;
    }

    export interface GetClusterNodePoolsNodePoolSetGpuArgCuda {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * GPU driver or CUDA version.
         */
        version: string;
    }

    export interface GetClusterNodePoolsNodePoolSetGpuArgCudnn {
        /**
         * Dev name of cuDNN.
         */
        devName: string;
        /**
         * Doc name of cuDNN.
         */
        docName: string;
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * GPU driver or CUDA version.
         */
        version: string;
    }

    export interface GetClusterNodePoolsNodePoolSetGpuArgCustomDriver {
        /**
         * Custom GPU driver address link.
         */
        address: string;
    }

    export interface GetClusterNodePoolsNodePoolSetGpuArgDriver {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * GPU driver or CUDA version.
         */
        version: string;
    }

    export interface GetClusterNodePoolsNodePoolSetLabel {
        /**
         * The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.
         */
        name: string;
        /**
         * Value of taints mark.
         */
        value: string;
    }

    export interface GetClusterNodePoolsNodePoolSetNodeCountSummary {
        /**
         * Automatically managed nodes.
         */
        autoscalingAddeds: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetNodeCountSummaryAutoscalingAdded[];
        /**
         * Manually managed nodes.
         */
        manuallyAddeds: outputs.Kubernetes.GetClusterNodePoolsNodePoolSetNodeCountSummaryManuallyAdded[];
    }

    export interface GetClusterNodePoolsNodePoolSetNodeCountSummaryAutoscalingAdded {
        /**
         * Number of nodes in initialization.
         */
        initializing: number;
        /**
         * Number of nodes joining.
         */
        joining: number;
        /**
         * Normal number of nodes.
         */
        normal: number;
        /**
         * Total number of nodes.
         */
        total: number;
    }

    export interface GetClusterNodePoolsNodePoolSetNodeCountSummaryManuallyAdded {
        /**
         * Number of nodes in initialization.
         */
        initializing: number;
        /**
         * Number of nodes joining.
         */
        joining: number;
        /**
         * Normal number of nodes.
         */
        normal: number;
        /**
         * Total number of nodes.
         */
        total: number;
    }

    export interface GetClusterNodePoolsNodePoolSetTag {
        /**
         * Key of taints mark.
         */
        key: string;
        /**
         * Value of taints mark.
         */
        value: string;
    }

    export interface GetClusterNodePoolsNodePoolSetTaint {
        /**
         * Effect of taints mark.
         */
        effect: string;
        /**
         * Key of taints mark.
         */
        key: string;
        /**
         * Value of taints mark.
         */
        value: string;
    }

    export interface GetClustersList {
        /**
         * The certificate used for access.
         */
        certificationAuthority: string;
        /**
         * The expired seconds to recycle ENI.
         */
        claimExpiredSeconds: number;
        /**
         * Indicates whether to enable cluster node auto scaler.
         */
        clusterAsEnabled: boolean;
        /**
         * A network address block of the cluster. Different from vpc cidr and cidr of other clusters within this VPC.
         */
        clusterCidr: string;
        /**
         * Deployment type of the cluster.
         */
        clusterDeployType: string;
        /**
         * Description of the cluster.
         */
        clusterDesc: string;
        /**
         * External network address to access.
         */
        clusterExternalEndpoint: string;
        /**
         * Customized parameters for master component.
         */
        clusterExtraArgs: outputs.Kubernetes.GetClustersListClusterExtraArg[];
        /**
         * ID of the cluster. Conflict with cluster_name, can not be set at the same time.
         */
        clusterId: string;
        /**
         * Indicates whether ipvs is enabled.
         */
        clusterIpvs: boolean;
        /**
         * The maximum number of Pods per node in the cluster.
         */
        clusterMaxPodNum: number;
        /**
         * The maximum number of services in the cluster.
         */
        clusterMaxServiceNum: number;
        /**
         * Name of the cluster. Conflict with cluster_id, can not be set at the same time.
         */
        clusterName: string;
        /**
         * Number of nodes in the cluster.
         */
        clusterNodeNum: number;
        /**
         * Operating system of the cluster.
         */
        clusterOs: string;
        /**
         * Version of the cluster.
         */
        clusterVersion: string;
        /**
         * (**Deprecated**) It has been deprecated from version 1.18.1. Container runtime of the cluster.
         *
         * @deprecated It has been deprecated from version 1.18.1.
         */
        containerRuntime: string;
        /**
         * Indicates whether cluster deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * Domain name for access.
         */
        domain: string;
        /**
         * Subnet IDs for cluster with VPC-CNI network mode.
         */
        eniSubnetIds: string[];
        /**
         * Indicates whether to ignore the cluster cidr conflict error.
         */
        ignoreClusterCidrConflict: boolean;
        /**
         * Indicates whether non-static ip mode is enabled.
         */
        isNonStaticIpMode: boolean;
        /**
         * Kubernetes config.
         */
        kubeConfig: string;
        /**
         * Kubernetes config of private network.
         */
        kubeConfigIntranet: string;
        /**
         * Cluster kube-proxy mode.
         */
        kubeProxyMode: string;
        /**
         * Cluster network type.
         */
        networkType: string;
        /**
         * Node name type of cluster.
         */
        nodeNameType: string;
        /**
         * Password of account.
         */
        password: string;
        /**
         * The Intranet address used for access.
         */
        pgwEndpoint: string;
        /**
         * Project ID of the cluster.
         */
        projectId: number;
        /**
         * Access policy.
         */
        securityPolicies: string[];
        /**
         * The network address block of the cluster.
         */
        serviceCidr: string;
        /**
         * Tags of the cluster.
         */
        tags: {[key: string]: any};
        /**
         * User name of account.
         */
        userName: string;
        /**
         * Distinguish between shared network card multi-IP mode and independent network card mode.
         */
        vpcCniType: string;
        /**
         * Vpc ID of the cluster.
         */
        vpcId: string;
        /**
         * An information list of cvm within the WORKER clusters. Each element contains the following attributes.
         */
        workerInstancesLists: outputs.Kubernetes.GetClustersListWorkerInstancesList[];
    }

    export interface GetClustersListClusterExtraArg {
        /**
         * The customized parameters for kube-apiserver.
         */
        kubeApiservers: string[];
        /**
         * The customized parameters for kube-controller-manager.
         */
        kubeControllerManagers: string[];
        /**
         * The customized parameters for kube-scheduler.
         */
        kubeSchedulers: string[];
    }

    export interface GetClustersListWorkerInstancesList {
        /**
         * Information of the cvm when it is failed.
         */
        failedReason: string;
        /**
         * ID of the cvm.
         */
        instanceId: string;
        /**
         * Role of the cvm.
         */
        instanceRole: string;
        /**
         * State of the cvm.
         */
        instanceState: string;
        /**
         * LAN IP of the cvm.
         */
        lanIp: string;
    }

    export interface NodePoolAutoScalingConfig {
        /**
         * Backup CVM instance types if specified instance type sold out or mismatch.
         */
        backupInstanceTypes?: string[];
        /**
         * bandwidth package id. if user is standard user, then the bandwidthPackageId is needed, or default has bandwidth_package_id.
         */
        bandwidthPackageId?: string;
        /**
         * Name of cam role.
         */
        camRoleName?: string;
        /**
         * Configurations of data disk.
         */
        dataDisks?: outputs.Kubernetes.NodePoolAutoScalingConfigDataDisk[];
        /**
         * To specify whether to enable cloud monitor service. Default is TRUE.
         */
        enhancedMonitorService?: boolean;
        /**
         * To specify whether to enable cloud security service. Default is TRUE.
         */
        enhancedSecurityService?: boolean;
        /**
         * The hostname of the cloud server, dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows instances are not supported. Examples of other types (Linux, etc.): The character length is [2, 40], multiple periods are allowed, and there is a paragraph between the dots, and each paragraph is allowed to consist of letters (unlimited case), numbers and dashes (-). Pure numbers are not allowed. For usage, refer to `HostNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
         */
        hostName: string;
        /**
         * The style of the host name of the cloud server, the value range includes ORIGINAL and UNIQUE, and the default is ORIGINAL. For usage, refer to `HostNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
         */
        hostNameStyle: string;
        /**
         * Charge type of instance. Valid values are `PREPAID`, `POSTPAID_BY_HOUR`, `SPOTPAID`. The default is `POSTPAID_BY_HOUR`. NOTE: `SPOTPAID` instance must set `spotInstanceType` and `spotMaxPrice` at the same time.
         */
        instanceChargeType: string;
        /**
         * The tenancy (in month) of the prepaid instance, NOTE: it only works when instanceChargeType is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
         */
        instanceChargeTypePrepaidPeriod?: number;
        /**
         * Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instanceChargeType is set to `PREPAID`.
         */
        instanceChargeTypePrepaidRenewFlag: string;
        /**
         * Instance name, no more than 60 characters. For usage, refer to `InstanceNameSettings` in https://www.tencentcloud.com/document/product/377/31001.
         */
        instanceName: string;
        /**
         * Specified types of CVM instance.
         */
        instanceType: string;
        /**
         * Charge types for network traffic. Valid value: `BANDWIDTH_PREPAID`, `TRAFFIC_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`.
         */
        internetChargeType?: string;
        /**
         * Max bandwidth of Internet access in Mbps. Default is `0`.
         */
        internetMaxBandwidthOut?: number;
        /**
         * ID list of keys.
         */
        keyIds?: string[];
        /**
         * Ordered security groups to which a CVM instance belongs.
         */
        orderlySecurityGroupIds: string[];
        /**
         * Password to access.
         */
        password?: string;
        /**
         * Specify whether to assign an Internet IP address.
         */
        publicIpAssigned?: boolean;
        /**
         * The order of elements in this field cannot be guaranteed. Use `orderlySecurityGroupIds` instead. Security groups to which a CVM instance belongs.
         *
         * @deprecated The order of elements in this field cannot be guaranteed. Use `orderlySecurityGroupIds` instead.
         */
        securityGroupIds: string[];
        /**
         * Type of spot instance, only support `one-time` now. Note: it only works when instanceChargeType is set to `SPOTPAID`.
         */
        spotInstanceType?: string;
        /**
         * Max price of a spot instance, is the format of decimal string, for example "0.50". Note: it only works when instanceChargeType is set to `SPOTPAID`.
         */
        spotMaxPrice?: string;
        /**
         * Volume of system disk in GB. Default is `50`.
         */
        systemDiskSize?: number;
        /**
         * Type of a CVM disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`. Default is `CLOUD_PREMIUM`.
         */
        systemDiskType?: string;
    }

    export interface NodePoolAutoScalingConfigDataDisk {
        /**
         * Indicates whether the disk remove after instance terminated. Default is `false`.
         */
        deleteWithInstance?: boolean;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
         */
        diskType?: string;
        /**
         * Specify whether to encrypt data disk, default: false. NOTE: Make sure the instance type is offering and the cam role `QcloudKMSAccessForCVMRole` was provided.
         */
        encrypt?: boolean;
        /**
         * Data disk snapshot ID.
         */
        snapshotId?: string;
        /**
         * Add extra performance to the data disk. Only works when disk type is `CLOUD_TSSD` or `CLOUD_HSSD` and `dataSize` > 460GB.
         */
        throughputPerformance?: number;
    }

    export interface NodePoolNodeConfig {
        /**
         * Configurations of data disk.
         */
        dataDisks?: outputs.Kubernetes.NodePoolNodeConfigDataDisk[];
        /**
         * Indicate to set desired pod number in node. valid when the cluster is podCIDR.
         */
        desiredPodNum?: number;
        /**
         * Docker graph path. Default is `/var/lib/docker`.
         */
        dockerGraphPath?: string;
        /**
         * Custom parameter information related to the node. This is a white-list parameter.
         */
        extraArgs?: string[];
        /**
         * GPU driver parameters.
         */
        gpuArgs?: outputs.Kubernetes.NodePoolNodeConfigGpuArgs;
        /**
         * Indicate to schedule the adding node or not. Default is true.
         */
        isSchedule?: boolean;
        /**
         * Mount target. Default is not mounting.
         */
        mountTarget?: string;
        /**
         * Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
         */
        preStartUserScript?: string;
        /**
         * Base64-encoded User Data text, the length limit is 16KB.
         */
        userData?: string;
    }

    export interface NodePoolNodeConfigDataDisk {
        /**
         * Indicate whether to auto format and mount or not. Default is `false`.
         */
        autoFormatAndMount?: boolean;
        /**
         * The name of the device or partition to mount. NOTE: this argument doesn't support setting in node pool, or will leads to mount error.
         */
        diskPartition?: string;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk. Valid value: `LOCAL_BASIC`, `LOCAL_SSD`, `CLOUD_BASIC`, `CLOUD_PREMIUM`, `CLOUD_SSD`, `CLOUD_HSSD`, `CLOUD_TSSD` and `CLOUD_BSSD`.
         */
        diskType?: string;
        /**
         * File system, e.g. `ext3/ext4/xfs`.
         */
        fileSystem?: string;
        /**
         * Mount target.
         */
        mountTarget?: string;
    }

    export interface NodePoolNodeConfigGpuArgs {
        /**
         * CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        cuda?: {[key: string]: any};
        /**
         * cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `docName`: Doc name of cuDNN; `devName`: Dev name of cuDNN.
         */
        cudnn?: {[key: string]: any};
        /**
         * Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
         */
        customDriver?: {[key: string]: any};
        /**
         * GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        driver?: {[key: string]: any};
        /**
         * Whether to enable MIG.
         */
        migEnable?: boolean;
    }

    export interface NodePoolTaint {
        /**
         * Effect of the taint. Valid values are: `NoSchedule`, `PreferNoSchedule`, `NoExecute`.
         */
        effect: string;
        /**
         * Key of the taint. The taint key name does not exceed 63 characters, only supports English, numbers,'/','-', and does not allow beginning with ('/').
         */
        key: string;
        /**
         * Value of the taint.
         */
        value: string;
    }

    export interface ScaleWorkerDataDisk {
        /**
         * Indicate whether to auto format and mount or not. Default is `false`.
         */
        autoFormatAndMount?: boolean;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
         */
        diskType?: string;
        /**
         * File system, e.g. `ext3/ext4/xfs`.
         */
        fileSystem?: string;
        /**
         * Mount target.
         */
        mountTarget?: string;
    }

    export interface ScaleWorkerGpuArgs {
        /**
         * CUDA  version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        cuda?: {[key: string]: any};
        /**
         * cuDNN version. Format like: `{ version: String, name: String, doc_name: String, dev_name: String }`. `version`: cuDNN version; `name`: cuDNN name; `docName`: Doc name of cuDNN; `devName`: Dev name of cuDNN.
         */
        cudnn?: {[key: string]: any};
        /**
         * Custom GPU driver. Format like: `{address: String}`. `address`: URL of custom GPU driver address.
         */
        customDriver?: {[key: string]: any};
        /**
         * GPU driver version. Format like: `{ version: String, name: String }`. `version`: Version of GPU driver or CUDA; `name`: Name of GPU driver or CUDA.
         */
        driver?: {[key: string]: any};
        /**
         * Whether to enable MIG.
         */
        migEnable?: boolean;
    }

    export interface ScaleWorkerWorkerConfig {
        /**
         * Indicates which availability zone will be used.
         */
        availabilityZone?: string;
        /**
         * bandwidth package id. if user is standard user, then the bandwidthPackageId is needed, or default has bandwidth_package_id.
         */
        bandwidthPackageId?: string;
        /**
         * CAM role name authorized to access.
         */
        camRoleName?: string;
        /**
         * Number of cvm.
         */
        count?: number;
        /**
         * Configurations of data disk.
         */
        dataDisks?: outputs.Kubernetes.ScaleWorkerWorkerConfigDataDisk[];
        /**
         * Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it override `[globe_]desired_pod_num` for current node. Either all the fields `desiredPodNum` or none.
         */
        desiredPodNum?: number;
        /**
         * Disaster recover groups to which a CVM instance belongs. Only support maximum 1.
         */
        disasterRecoverGroupIds?: string;
        /**
         * To specify whether to enable cloud monitor service. Default is TRUE.
         */
        enhancedMonitorService?: boolean;
        /**
         * To specify whether to enable cloud security service. Default is TRUE.
         */
        enhancedSecurityService?: boolean;
        /**
         * The host name of the attached instance. Dot (.) and dash (-) cannot be used as the first and last characters of HostName and cannot be used consecutively. Windows example: The length of the name character is [2, 15], letters (capitalization is not restricted), numbers and dashes (-) are allowed, dots (.) are not supported, and not all numbers are allowed. Examples of other types (Linux, etc.): The character length is [2, 60], and multiple dots are allowed. There is a segment between the dots. Each segment allows letters (with no limitation on capitalization), numbers and dashes (-).
         */
        hostname?: string;
        /**
         * Id of cvm hpc cluster.
         */
        hpcClusterId?: string;
        /**
         * The valid image id, format of img-xxx.
         */
        imgId?: string;
        /**
         * The charge type of instance. Valid values are `PREPAID` and `POSTPAID_BY_HOUR`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR`, `PREPAID` instance will not terminated after cluster deleted, and may not allow to delete before expired.
         */
        instanceChargeType?: string;
        /**
         * The tenancy (time unit is month) of the prepaid instance. NOTE: it only works when instanceChargeType is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.
         */
        instanceChargeTypePrepaidPeriod?: number;
        /**
         * Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instanceChargeType is set to `PREPAID`.
         */
        instanceChargeTypePrepaidRenewFlag: string;
        /**
         * Name of the CVMs.
         */
        instanceName?: string;
        /**
         * Specified types of CVM instance.
         */
        instanceType: string;
        /**
         * Charge types for network traffic. Available values include `TRAFFIC_POSTPAID_BY_HOUR`.
         */
        internetChargeType?: string;
        /**
         * Max bandwidth of Internet access in Mbps. Default is 0.
         */
        internetMaxBandwidthOut?: number;
        /**
         * ID list of keys, should be set if `password` not set.
         */
        keyIds?: string;
        /**
         * Password to access, should be set if `keyIds` not set.
         */
        password?: string;
        /**
         * Specify whether to assign an Internet IP address.
         */
        publicIpAssigned?: boolean;
        /**
         * Security groups to which a CVM instance belongs.
         */
        securityGroupIds?: string[];
        /**
         * Private network ID.
         */
        subnetId: string;
        /**
         * Volume of system disk in GB. Default is `50`.
         */
        systemDiskSize?: number;
        /**
         * System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_SSD`: SSD, `CLOUD_PREMIUM`: Premium Cloud Storage. NOTE: `CLOUD_BASIC`, `LOCAL_BASIC` and `LOCAL_SSD` are deprecated.
         */
        systemDiskType?: string;
        /**
         * User data provided to instances, needs to be encoded in base64, and the maximum supported data size is 16KB.
         */
        userData?: string;
    }

    export interface ScaleWorkerWorkerConfigDataDisk {
        /**
         * Indicate whether to auto format and mount or not. Default is `false`.
         */
        autoFormatAndMount?: boolean;
        /**
         * The name of the device or partition to mount.
         */
        diskPartition?: string;
        /**
         * Volume of disk in GB. Default is `0`.
         */
        diskSize?: number;
        /**
         * Types of disk, available values: `CLOUD_PREMIUM` and `CLOUD_SSD` and `CLOUD_HSSD` and `CLOUD_TSSD`.
         */
        diskType?: string;
        /**
         * Indicates whether to encrypt data disk, default `false`.
         */
        encrypt?: boolean;
        /**
         * File system, e.g. `ext3/ext4/xfs`.
         */
        fileSystem?: string;
        /**
         * ID of the custom CMK in the format of UUID or `kms-abcd1234`. This parameter is used to encrypt cloud disks.
         */
        kmsKeyId?: string;
        /**
         * Mount target.
         */
        mountTarget?: string;
        /**
         * Data disk snapshot ID.
         */
        snapshotId?: string;
    }

    export interface ScaleWorkerWorkerInstancesList {
        /**
         * Information of the cvm when it is failed.
         */
        failedReason: string;
        /**
         * ID of the cvm.
         */
        instanceId: string;
        /**
         * Role of the cvm.
         */
        instanceRole: string;
        /**
         * State of the cvm.
         */
        instanceState: string;
        /**
         * LAN IP of the cvm.
         */
        lanIp: string;
    }

    export interface ServerlessNodePoolServerlessNode {
        /**
         * display name of serverless node.
         */
        displayName?: string;
        /**
         * subnet id of serverless node.
         */
        subnetId: string;
    }

    export interface ServerlessNodePoolTaint {
        /**
         * Effect of the taint. Valid values are: `NoSchedule`, `PreferNoSchedule`, `NoExecute`.
         */
        effect: string;
        /**
         * Key of the taint. The taint key name does not exceed 63 characters, only supports English, numbers,'/','-', and does not allow beginning with ('/').
         */
        key: string;
        /**
         * Value of the taint.
         */
        value: string;
    }

}

export namespace Lighthouse {
    export interface DiskAutoMountConfiguration {
        /**
         * The file system type. Value: ext4, xfs. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it defaults to ext4.
         */
        fileSystemType?: string;
        /**
         * Instance ID to be mounted. The specified instance must be in the Running state.
         */
        instanceId: string;
        /**
         * The mount point within the instance. Only instances of the Linux operating system can pass in this parameter, and if it is not passed, it will be mounted under the /data/disk path by default.
         */
        mountPoint?: string;
    }

    export interface DiskDiskChargePrepaid {
        /**
         * new purchase cycle.
         */
        period: number;
        /**
         * Automatic renewal flag. Value: `NOTIFY_AND_AUTO_RENEW`: Notice expires and auto-renews. `NOTIFY_AND_MANUAL_RENEW`: Notification expires without automatic renewal, users need to manually renew. `DISABLE_NOTIFY_AND_AUTO_RENEW`: No automatic renewal and no notification. Default: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the disk will be automatically renewed monthly when the account balance is sufficient.
         */
        renewFlag?: string;
        /**
         * newly purchased unit. Default: m.
         */
        timeUnit?: string;
    }

    export interface FirewallRuleFirewallRule {
        /**
         * Valid values are ACCEPT, DROP. Default value is ACCEPT.
         */
        action?: string;
        /**
         * IP range or IP (mutually exclusive). Default value is 0.0.0.0/0, which indicates all sources.
         */
        cidrBlock?: string;
        /**
         * Firewall rule description.
         */
        firewallRuleDescription?: string;
        /**
         * Port. Valid values are ALL, one single port, multiple ports separated by commas, or port range indicated by a minus sign.
         */
        port?: string;
        /**
         * Protocol. Valid values are TCP, UDP, ICMP, ALL.
         */
        protocol: string;
    }

    export interface FirewallTemplateTemplateRule {
        /**
         * Action. Values: ACCEPT, DROP. The default is `ACCEPT`.
         */
        action?: string;
        /**
         * Network segment or IP (mutually exclusive). The default is `0.0.0.0`, indicating all sources.
         */
        cidrBlock?: string;
        /**
         * Firewall rule description.
         */
        firewallRuleDescription?: string;
        /**
         * Port. Values: ALL, Separate ports, comma-separated discrete ports, minus sign-separated port ranges.
         */
        port?: string;
        /**
         * Protocol. Values: TCP, UDP, ICMP, ALL.
         */
        protocol: string;
    }

    export interface GetAllSceneSceneSet {
        /**
         * Use scene description.
         */
        description: string;
        /**
         * Use the scene presentation name.
         */
        displayName: string;
        /**
         * Use scene Id.
         */
        sceneId: string;
    }

    export interface GetBundleBundleSet {
        /**
         * Package tag.Valid values:ACTIVITY: promotional packageNORMAL: regular packageCAREFREE: carefree package.
         */
        bundleDisplayLabel: string;
        /**
         * Package ID.
         */
        bundleId: string;
        /**
         * Package sale status. Valid values are AVAILABLE, SOLD_OUT.
         */
        bundleSalesState: string;
        /**
         * Package type.Valid values:GENERAL_BUNDLE: generalSTORAGE_BUNDLE: Storage.
         */
        bundleType: string;
        /**
         * CPU.
         */
        cpu: number;
        /**
         * Network billing mode.
         */
        internetChargeType: string;
        /**
         * Peak bandwidth in Mbps.
         */
        internetMaxBandwidthOut: number;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Monthly network traffic in Gb.
         */
        monthlyTraffic: number;
        /**
         * Current package unit price information.
         */
        prices: outputs.Lighthouse.GetBundleBundleSetPrice[];
        /**
         * Whether Linux/Unix is supported.
         */
        supportLinuxUnixPlatform: boolean;
        /**
         * Whether Windows is supported.
         */
        supportWindowsPlatform: boolean;
        /**
         * System disk size.
         */
        systemDiskSize: number;
        /**
         * System disk type.
         */
        systemDiskType: string;
    }

    export interface GetBundleBundleSetPrice {
        /**
         * Instance price.
         */
        instancePrices: outputs.Lighthouse.GetBundleBundleSetPriceInstancePrice[];
    }

    export interface GetBundleBundleSetPriceInstancePrice {
        /**
         * Currency unit. Valid values: CNY and USD.
         */
        currency: string;
        /**
         * Discount.
         */
        discount: number;
        /**
         * Discounted price.
         */
        discountPrice: number;
        /**
         * Original package unit price.
         */
        originalBundlePrice: number;
        /**
         * Original price.
         */
        originalPrice: number;
    }

    export interface GetBundleFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter value of field.
         */
        values: string[];
    }

    export interface GetDiskConfigDiskConfigSet {
        /**
         * Cloud disk sale status.
         */
        diskSalesState: string;
        /**
         * Cloud disk increment.
         */
        diskStepSize: number;
        /**
         * Cloud disk type.
         */
        diskType: string;
        /**
         * Maximum cloud disk size.
         */
        maxDiskSize: number;
        /**
         * Minimum cloud disk size.
         */
        minDiskSize: number;
        /**
         * Availability zone.
         */
        zone: string;
    }

    export interface GetDiskConfigFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter value of field.
         */
        values: string[];
    }

    export interface GetDisksDiskList {
        /**
         * Disk attach state.
         */
        attached: boolean;
        /**
         * Created time. Expressed according to the ISO8601 standard, and using UTC time. The format is `YYYY-MM-DDThh:mm:ssZ`.
         */
        createdTime: string;
        /**
         * Whether to release with the instance.
         */
        deleteWithInstance: boolean;
        /**
         * Number of existing backup points of cloud disk.
         */
        diskBackupCount: number;
        /**
         * Number of backup points quota for cloud disk.
         */
        diskBackupQuota: number;
        /**
         * Disk charge type.
         */
        diskChargeType: string;
        /**
         * Disk id.
         */
        diskId: string;
        /**
         * Disk name.
         */
        diskName: string;
        /**
         * Disk size.
         */
        diskSize: number;
        /**
         * Disk state. Valid values:`PENDING`, `UNATTACHED`, `ATTACHING`, `ATTACHED`, `DETACHING`, `SHUTDOWN`, `CREATED_FAILED`, `TERMINATING`, `DELETING`, `FREEZING`.
         */
        diskState: string;
        /**
         * Disk type.
         */
        diskType: string;
        /**
         * Disk usage.
         */
        diskUsage: string;
        /**
         * Expired time. Expressed according to the ISO8601 standard, and using UTC time. The format is `YYYY-MM-DDThh:mm:ssZ`.
         */
        expiredTime: string;
        /**
         * Instance id.
         */
        instanceId: string;
        /**
         * Isolated time. Expressed according to the ISO8601 standard, and using UTC time. The format is `YYYY-MM-DDThh:mm:ssZ`.
         */
        isolatedTime: string;
        /**
         * Latest operation.
         */
        latestOperation: string;
        /**
         * Latest operation request id.
         */
        latestOperationRequestId: string;
        /**
         * Latest operation state.
         */
        latestOperationState: string;
        /**
         * Renew flag.
         */
        renewFlag: string;
        /**
         * Availability zone.
         */
        zone: string;
    }

    export interface GetDisksFilter {
        /**
         * Fields to be filtered. Valid names: `disk-id`: Filters by disk id; `instance-id`: Filter by instance id; `disk-name`: Filter by disk name; `zone`: Filter by zone; `disk-usage`: Filter by disk usage(Values: `SYSTEM_DISK` or `DATA_DISK`); `disk-state`: Filter by disk state.
         */
        name: string;
        /**
         * Value of the field.
         */
        values: string[];
    }

    export interface GetFirewallRulesTemplateFirewallRuleSet {
        /**
         * Valid values are (ACCEPT, DROP). Default value is ACCEPT.
         */
        action: string;
        /**
         * Application type. Valid values are custom, HTTP (80), HTTPS (443), Linux login (22), Windows login (3389), MySQL (3306), SQL Server (1433), all TCP ports, all UDP ports, Ping-ICMP, ALL.
         */
        appType: string;
        /**
         * IP range or IP (mutually exclusive). Default value is 0.0.0.0/0, which indicates all sources.
         */
        cidrBlock: string;
        /**
         * Firewall rule description.
         */
        firewallRuleDescription: string;
        /**
         * Port. Valid values are ALL, one single port, multiple ports separated by commas, or port range indicated by a minus sign.
         */
        port: string;
        /**
         * Protocol. Valid values are TCP, UDP, ICMP, ALL.
         */
        protocol: string;
    }

    export interface GetInstanceBlueprintBlueprintInstanceSet {
        /**
         * Blueprint instance information.
         */
        blueprints: outputs.Lighthouse.GetInstanceBlueprintBlueprintInstanceSetBlueprint[];
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Software list.
         */
        softwareSets: outputs.Lighthouse.GetInstanceBlueprintBlueprintInstanceSetSoftwareSet[];
    }

    export interface GetInstanceBlueprintBlueprintInstanceSetBlueprint {
        /**
         * Blueprint ID, which is the unique identifier of Blueprint.
         */
        blueprintId: string;
        /**
         * Blueprint name.
         */
        blueprintName: string;
        /**
         * Blueprint status.
         */
        blueprintState: string;
        /**
         * Blueprint type, such as APP_OS, PURE_OS, and PRIVATE.
         */
        blueprintType: string;
        /**
         * URL of official website of the open-source project.
         */
        communityUrl: string;
        /**
         * Creation time according to ISO 8601 standard. UTC time is used. Format is YYYY-MM-DDThh:mm:ssZ.
         */
        createdTime: string;
        /**
         * Image description information.
         */
        description: string;
        /**
         * Blueprint title to be displayed.
         */
        displayTitle: string;
        /**
         * Blueprint version to be displayed.
         */
        displayVersion: string;
        /**
         * Docker version.Note: This field may return null, indicating that no valid values can be obtained.
         */
        dockerVersion: string;
        /**
         * Guide documentation URL.
         */
        guideUrl: string;
        /**
         * ID of the Lighthouse blueprint shared from a CVM imageNote: this field may return null, indicating that no valid values can be obtained.
         */
        imageId: string;
        /**
         * Software picture URL.
         */
        imageUrl: string;
        /**
         * OS name.
         */
        osName: string;
        /**
         * OS type.
         */
        platform: string;
        /**
         * OS type, such as LINUX_UNIX and WINDOWS.
         */
        platformType: string;
        /**
         * Memory size required by blueprint in GB.
         */
        requiredMemorySize: number;
        /**
         * System disk size required by blueprint in GB.
         */
        requiredSystemDiskSize: number;
        /**
         * Array of IDs of scenes associated with a blueprintNote: This field may return null, indicating that no valid values can be obtained.
         */
        sceneIdSets: string[];
        /**
         * Whether the blueprint supports automation tools.
         */
        supportAutomationTools: boolean;
    }

    export interface GetInstanceBlueprintBlueprintInstanceSetSoftwareSet {
        /**
         * List of software details.
         */
        detailSets: outputs.Lighthouse.GetInstanceBlueprintBlueprintInstanceSetSoftwareSetDetailSet[];
        /**
         * Software picture URL.
         */
        imageUrl: string;
        /**
         * Software installation directory.
         */
        installDir: string;
        /**
         * Software name.
         */
        name: string;
        /**
         * Software version.
         */
        version: string;
    }

    export interface GetInstanceBlueprintBlueprintInstanceSetSoftwareSetDetailSet {
        /**
         * Unique detail key.
         */
        key: string;
        /**
         * Detail title.
         */
        title: string;
        /**
         * Detail value.
         */
        value: string;
    }

    export interface GetInstanceDiskNumAttachDetailSet {
        /**
         * Number of elastic cloud disks mounted to the instance.
         */
        attachedDiskCount: number;
        /**
         * Instance Id.
         */
        instanceId: string;
        /**
         * Number of elastic cloud disks that can be mounted.
         */
        maxAttachCount: number;
    }

    export interface GetInstanceTrafficPackageInstanceTrafficPackageSet {
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * List of traffic package details.
         */
        trafficPackageSets: outputs.Lighthouse.GetInstanceTrafficPackageInstanceTrafficPackageSetTrafficPackageSet[];
    }

    export interface GetInstanceTrafficPackageInstanceTrafficPackageSetTrafficPackageSet {
        /**
         * The expiration time of the traffic package. Expressed according to the ISO8601 standard, and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ..
         */
        deadline: string;
        /**
         * The end time of the effective period of the traffic packet. Expressed according to the ISO8601 standard, and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ.
         */
        endTime: string;
        /**
         * The start time of the effective cycle of the traffic packet. Expressed according to the ISO8601 standard, and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ.
         */
        startTime: string;
        /**
         * Traffic packet status:- `NETWORK_NORMAL`: normal.- `OVERDUE_NETWORK_DISABLED`: network disconnection due to arrears.
         */
        status: string;
        /**
         * The amount of traffic that exceeds the quota of the traffic packet during the effective period of the traffic packet, in bytes.
         */
        trafficOverflow: number;
        /**
         * Traffic packet ID.
         */
        trafficPackageId: string;
        /**
         * The remaining traffic during the effective period of the traffic packet, in bytes.
         */
        trafficPackageRemaining: number;
        /**
         * The total traffic in bytes during the effective period of the traffic packet.
         */
        trafficPackageTotal: number;
        /**
         * Traffic has been used during the effective period of the traffic packet, in bytes.
         */
        trafficUsed: number;
    }

    export interface GetModifyInstanceBundleFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter value of field.
         */
        values: string[];
    }

    export interface GetModifyInstanceBundleModifyBundleSet {
        /**
         * Package information.
         */
        bundles: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetBundle[];
        /**
         * Change the status of the package. Value:
         * - SOLD_OUT: the package is sold out;
         * - AVAILABLE: support package changes;
         * - UNAVAILABLE: package changes are not supported for the time being.
         */
        modifyBundleState: string;
        /**
         * Change the price difference to be made up after the instance package.
         */
        modifyPrices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetModifyPrice[];
        /**
         * Package change reason information is not supported. When the package status is changed to `AVAILABLE`, the information is empty.
         */
        notSupportModifyMessage: string;
    }

    export interface GetModifyInstanceBundleModifyBundleSetBundle {
        /**
         * Package tag.Valid values:ACTIVITY: promotional packageNORMAL: regular packageCAREFREE: carefree package.
         */
        bundleDisplayLabel: string;
        /**
         * Package ID.
         */
        bundleId: string;
        /**
         * Package sale status. Valid values are AVAILABLE, SOLD_OUT.
         */
        bundleSalesState: string;
        /**
         * Package type.Valid values:GENERAL_BUNDLE: generalSTORAGE_BUNDLE: Storage.
         */
        bundleType: string;
        /**
         * Package type description information.
         */
        bundleTypeDescription: string;
        /**
         * CPU.
         */
        cpu: number;
        /**
         * Network billing mode.
         */
        internetChargeType: string;
        /**
         * Peak bandwidth in Mbps.
         */
        internetMaxBandwidthOut: number;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Monthly network traffic in Gb.
         */
        monthlyTraffic: number;
        /**
         * Current package unit price information.
         */
        prices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetBundlePrice[];
        /**
         * Whether Linux/Unix is supported.
         */
        supportLinuxUnixPlatform: boolean;
        /**
         * Whether Windows is supported.
         */
        supportWindowsPlatform: boolean;
        /**
         * System disk size.
         */
        systemDiskSize: number;
        /**
         * System disk type.
         */
        systemDiskType: string;
    }

    export interface GetModifyInstanceBundleModifyBundleSetBundlePrice {
        /**
         * Instance price.
         */
        instancePrices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetBundlePriceInstancePrice[];
    }

    export interface GetModifyInstanceBundleModifyBundleSetBundlePriceInstancePrice {
        /**
         * A monetary unit of price. Value range CNY: RMB. USD: us dollar.
         */
        currency: string;
        /**
         * Discount.
         */
        discount: number;
        /**
         * Discounted price.
         */
        discountPrice: number;
        /**
         * Original unit price of the package.
         */
        originalBundlePrice: number;
        /**
         * Original price.
         */
        originalPrice: number;
    }

    export interface GetModifyInstanceBundleModifyBundleSetModifyPrice {
        /**
         * Instance price.
         */
        instancePrices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetModifyPriceInstancePrice[];
    }

    export interface GetModifyInstanceBundleModifyBundleSetModifyPriceInstancePrice {
        /**
         * A monetary unit of price. Value range CNY: RMB. USD: us dollar.
         */
        currency: string;
        /**
         * Discount.
         */
        discount: number;
        /**
         * Discounted price.
         */
        discountPrice: number;
        /**
         * Original unit price of the package.
         */
        originalBundlePrice: number;
        /**
         * Original price.
         */
        originalPrice: number;
    }

    export interface GetRegionRegionSet {
        /**
         * Whether the region is in the Chinese mainland.
         */
        isChinaMainland: boolean;
        /**
         * Region name.
         */
        region: string;
        /**
         * Region description.
         */
        regionName: string;
        /**
         * Region availability status.
         */
        regionState: string;
    }

    export interface GetResetInstanceBlueprintFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter value of field.
         */
        values: string[];
    }

    export interface GetResetInstanceBlueprintResetInstanceBlueprintSet {
        /**
         * Mirror details.
         */
        blueprintInfos: outputs.Lighthouse.GetResetInstanceBlueprintResetInstanceBlueprintSetBlueprintInfo[];
        /**
         * Whether the instance image can be reset to the target image.
         */
        isResettable: boolean;
        /**
         * The information cannot be reset. when the mirror can be reset ''.
         */
        nonResettableMessage: string;
    }

    export interface GetResetInstanceBlueprintResetInstanceBlueprintSetBlueprintInfo {
        /**
         * Image ID, which is the unique identity of Blueprint.
         */
        blueprintId: string;
        /**
         * Mirror name.
         */
        blueprintName: string;
        /**
         * Mirror status.
         */
        blueprintState: string;
        /**
         * Image type, such as APP_OS, PURE_OS, PRIVATE.
         */
        blueprintType: string;
        /**
         * The official website Url.
         */
        communityUrl: string;
        /**
         * Creation time. Expressed according to the ISO8601 standard, and using UTC time. The format is YYYY-MM-DDThh:mm:ssZ.
         */
        createdTime: string;
        /**
         * Mirror description information.
         */
        description: string;
        /**
         * The mirror image shows the title to the public.
         */
        displayTitle: string;
        /**
         * The image shows the version to the public.
         */
        displayVersion: string;
        /**
         * Docker version number.
         */
        dockerVersion: string;
        /**
         * Guide article Url.
         */
        guideUrl: string;
        /**
         * CVM image ID after sharing the CVM image to the lightweight application server.
         */
        imageId: string;
        /**
         * Mirror image URL.
         */
        imageUrl: string;
        /**
         * Operating system name.
         */
        osName: string;
        /**
         * Operating system platform.
         */
        platform: string;
        /**
         * Operating system platform type, such as LINUX_UNIX, WINDOWS.
         */
        platformType: string;
        /**
         * Memory required for mirroring (in GB).
         */
        requiredMemorySize: number;
        /**
         * The size of the system disk required for image (in GB).
         */
        requiredSystemDiskSize: number;
        /**
         * The mirror association uses the scene Id list.
         */
        sceneIdSets: string[];
        /**
         * Whether the image supports automation helper.
         */
        supportAutomationTools: boolean;
    }

    export interface GetSceneSceneSet {
        /**
         * Use scene description.
         */
        description: string;
        /**
         * Use the scene presentation name.
         */
        displayName: string;
        /**
         * Use scene Id.
         */
        sceneId: string;
    }

    export interface GetZoneZoneInfoSet {
        /**
         * Instance purchase page availability zone display label.
         */
        instanceDisplayLabel: string;
        /**
         * Availability zone.
         */
        zone: string;
        /**
         * Chinese name of availability zone.
         */
        zoneName: string;
    }

    export interface InstanceContainer {
        /**
         * The command to run.
         */
        command?: string;
        /**
         * Container image address.
         */
        containerImage?: string;
        /**
         * Container name.
         */
        containerName?: string;
        /**
         * List of environment variables.
         */
        envs?: outputs.Lighthouse.InstanceContainerEnv[];
        /**
         * List of mappings of container ports and host ports.
         */
        publishPorts?: outputs.Lighthouse.InstanceContainerPublishPort[];
        /**
         * List of container mount volumes.
         */
        volumes?: outputs.Lighthouse.InstanceContainerVolume[];
    }

    export interface InstanceContainerEnv {
        /**
         * Environment variable key.
         */
        key: string;
        /**
         * Environment variable value.
         */
        value: string;
    }

    export interface InstanceContainerPublishPort {
        /**
         * Container port.
         */
        containerPort: number;
        /**
         * Host port.
         */
        hostPort: number;
        /**
         * External IP. It defaults to 0.0.0.0.
         */
        ip?: string;
        /**
         * The protocol defaults to tcp. Valid values: tcp, udp and sctp.
         */
        protocol?: string;
    }

    export interface InstanceContainerVolume {
        /**
         * Container path.
         */
        containerPath: string;
        /**
         * Host path.
         */
        hostPath: string;
    }

    export interface InstanceLoginConfiguration {
        /**
         * whether auto generate password. if false, need set password.
         */
        autoGeneratePassword: string;
        /**
         * Login password.
         */
        password?: string;
    }

    export interface RenewDiskRenewDiskChargePrepaid {
        /**
         * Current instance expiration time. Such as 2018-01-01 00:00:00. Specifying this parameter can align the expiration time of the instance attached to the disk. One of this parameter and Period must be specified, and cannot be specified at the same time.
         */
        curInstanceDeadline?: string;
        /**
         * Renewal period.
         */
        period?: number;
        /**
         * Automatic renewal falg. Value:NOTIFY_AND_AUTO_RENEW: Notice expires and auto-renews.NOTIFY_AND_MANUAL_RENEW: Notification expires without automatic renewal, users need to manually renew.DISABLE_NOTIFY_AND_AUTO_RENEW: No automatic renewal and no notification.Default: NOTIFY_AND_MANUAL_RENEW. If this parameter is specified as NOTIFY_AND_AUTO_RENEW, the disk will be automatically renewed monthly when the account balance is sufficient.
         */
        renewFlag?: string;
        /**
         * newly purchased unit. Default: m.
         */
        timeUnit?: string;
    }

    export interface RenewInstanceInstanceChargePrepaid {
        /**
         * The duration of purchasing an instance. Unit is month. Valid values are (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60).
         */
        period: number;
        /**
         * Automatic renewal logo. Values:
         */
        renewFlag?: string;
    }

}

export namespace Mariadb {
    export interface AccountPrivilegesAccounts {
        /**
         * user host.
         */
        host: string;
        /**
         * user name.
         */
        user: string;
    }

    export interface AccountPrivilegesColumnPrivilege {
        /**
         * Column name.
         */
        column: string;
        /**
         * Database name.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
        /**
         * Table name.
         */
        table: string;
    }

    export interface AccountPrivilegesDatabasePrivilege {
        /**
         * Database name.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
    }

    export interface AccountPrivilegesFunctionPrivilege {
        /**
         * Database name.
         */
        database: string;
        /**
         * Function name.
         */
        functionName: string;
        /**
         * Permission information.
         */
        privileges: string[];
    }

    export interface AccountPrivilegesProcedurePrivilege {
        /**
         * Database name.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
        /**
         * Procedure name.
         */
        procedure: string;
    }

    export interface AccountPrivilegesTablePrivilege {
        /**
         * Database name.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
        /**
         * Table name.
         */
        table: string;
    }

    export interface AccountPrivilegesViewPrivilege {
        /**
         * Database name.
         */
        database: string;
        /**
         * Permission information.
         */
        privileges: string[];
        /**
         * View name.
         */
        view: string;
    }

    export interface GetAccountsList {
        /**
         * creation time.
         */
        createTime: string;
        /**
         * This field is meaningful for read-only accounts, indicating that the standby machine with the active-standby delay less than this value is selected.
         */
        delayThresh: number;
        /**
         * User remarks.
         */
        description: string;
        /**
         * The host from which the user can log in (corresponding to the host field of MySQL users, UserName + Host uniquely identifies a user, in the form of IP, and the IP segment ends with %; supports filling in %; if it is empty, it defaults to %).
         */
        host: string;
        /**
         * Read-only flag, `0`: No, `1`: The SQL request of this account is preferentially executed on the standby machine, and the host machine is selected for execution when the standby machine is unavailable, `2`: The standby machine is preferentially selected for execution, and the operation fails when the standby machine is unavailable.
         */
        readOnly: number;
        /**
         * For read-only accounts, set whether the policy is to fix the standby machine, `0`: The standby machine is not fixed, that is, the standby machine does not meet the conditions and will not disconnect from the client, and the Proxy selects other available standby machines, `1`: The standby machine does not meet the conditions Disconnect, make sure one connection secures the standby.
         */
        slaveConst: number;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * username.
         */
        userName: string;
    }

    export interface GetDatabaseObjectsFunc {
        /**
         * func name.
         */
        func: string;
    }

    export interface GetDatabaseObjectsProc {
        /**
         * proc name.
         */
        proc: string;
    }

    export interface GetDatabaseObjectsTable {
        /**
         * table name.
         */
        table: string;
    }

    export interface GetDatabaseObjectsView {
        /**
         * view name.
         */
        view: string;
    }

    export interface GetDatabaseTableCol {
        /**
         * column name.
         */
        col: string;
        /**
         * column type.
         */
        type: string;
    }

    export interface GetDatabasesDatabase {
        /**
         * Database name.
         */
        dbName: string;
    }

    export interface GetDbInstancesInstance {
        /**
         * db version id.
         */
        dbVersionId: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * instance name.
         */
        instanceName: string;
        /**
         * Public network access domain name.
         */
        internetDomain: string;
        /**
         * Public IP address.
         */
        internetIp: string;
        /**
         * Public network port.
         */
        internetPort: number;
        /**
         * meory of instance.
         */
        memory: number;
        /**
         * project id.
         */
        projectId: number;
        /**
         * region.
         */
        region: string;
        /**
         * resource tags.
         */
        resourceTags: outputs.Mariadb.GetDbInstancesInstanceResourceTag[];
        /**
         * storage of instance.
         */
        storage: number;
        /**
         * subnet id.
         */
        subnetId: string;
        /**
         * Intranet IP address.
         */
        vip: string;
        /**
         * vpc id.
         */
        vpcId: string;
        /**
         * Intranet port.
         */
        vport: number;
        /**
         * available zone.
         */
        zone: string;
    }

    export interface GetDbInstancesInstanceResourceTag {
        /**
         * tag key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

    export interface GetDcnDetailDcnDetail {
        /**
         * Number of CPU cores of the instance.
         */
        cpu: number;
        /**
         * Creation time of the instance in the format of 2006-01-02 15:04:05.
         */
        createTime: string;
        /**
         * DCN flag. Valid values: `1` (primary), `2` (disaster recovery).
         */
        dcnFlag: number;
        /**
         * DCN status. Valid values: `0` (none), `1` (creating), `2` (syncing), `3` (disconnected).
         */
        dcnStatus: number;
        /**
         * Whether KMS is enabled.
         */
        encryptStatus: number;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Instance type. Valid values: `1` (dedicated primary instance), `2` (non-dedicated primary instance), `3` (non-dedicated disaster recovery instance), `4` (dedicated disaster recovery instance).
         */
        instanceType: number;
        /**
         * Instance memory capacity in GB.
         */
        memory: number;
        /**
         * Billing mode.
         */
        payMode: number;
        /**
         * Expiration time of the instance in the format of 2006-01-02 15:04:05.
         */
        periodEndTime: string;
        /**
         * Region where the instance resides.
         */
        region: string;
        /**
         * Configuration information of DCN replication. This field is null for a primary instance.Note: This field may return null, indicating that no valid values can be obtained.
         */
        replicaConfigs: outputs.Mariadb.GetDcnDetailDcnDetailReplicaConfig[];
        /**
         * DCN replication status. This field is null for the primary instance.Note: This field may return null, indicating that no valid values can be obtained.
         */
        replicaStatuses: outputs.Mariadb.GetDcnDetailDcnDetailReplicaStatus[];
        /**
         * Instance status.
         */
        status: number;
        /**
         * Instance status description.
         */
        statusDesc: string;
        /**
         * Instance storage capacity in GB.
         */
        storage: number;
        /**
         * Instance IP address.
         */
        vip: string;
        /**
         * Instance IPv6 address.
         */
        vipv6: string;
        /**
         * Instance port.
         */
        vport: number;
        /**
         * Availability zone where the instance resides.
         */
        zone: string;
    }

    export interface GetDcnDetailDcnDetailReplicaConfig {
        /**
         * Delayed replication type. Valid values: `DEFAULT` (no delay), `DUE_TIME` (specified replication time)Note: This field may return null, indicating that no valid values can be obtained.
         */
        delayReplicationType: string;
        /**
         * Specified time for delayed replicationNote: This field may return null, indicating that no valid values can be obtained.
         */
        dueTime: string;
        /**
         * The number of seconds to delay the replicationNote: This field may return null, indicating that no valid values can be obtained.
         */
        replicationDelay: number;
        /**
         * DCN running status. Valid values: `START` (running), `STOP` (pause)Note: This field may return null, indicating that no valid values can be obtained.
         */
        roReplicationMode: string;
    }

    export interface GetDcnDetailDcnDetailReplicaStatus {
        /**
         * The current delay, which takes the delay value of the replica instance.
         */
        delay: number;
        /**
         * Instance status.
         */
        status: string;
    }

    export interface GetInstanceNodeInfoNodesInfo {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node role. Valid values: `master`, `slave`.
         */
        role: string;
    }

    export interface GetInstanceSpecsSpec {
        /**
         * machine type.
         */
        machine: string;
        /**
         * list of machine specifications.
         */
        specInfos: outputs.Mariadb.GetInstanceSpecsSpecSpecInfo[];
    }

    export interface GetInstanceSpecsSpecSpecInfo {
        /**
         * CPU cores.
         */
        cpu: number;
        /**
         * machine type.
         */
        machine: string;
        /**
         * maximum storage size, in GB.
         */
        maxStorage: number;
        /**
         * memory, in GB.
         */
        memory: number;
        /**
         * minimum storage size, in GB.
         */
        minStorage: number;
        /**
         * node count.
         */
        nodeCount: number;
        /**
         * product price id.
         */
        pid: number;
        /**
         * maximum QPS.
         */
        qps: number;
        /**
         * recommended usage scenarios.
         */
        suitInfo: string;
    }

    export interface GetLogFilesFile {
        /**
         * Filename.
         */
        fileName: string;
        /**
         * File length.
         */
        length: number;
        /**
         * Last modified time of log.
         */
        mtime: number;
        /**
         * Uniform resource identifier (URI) used during log download.
         */
        uri: string;
    }

    export interface GetOrdersDeal {
        /**
         * Number of items.
         */
        count: number;
        /**
         * List of long order numbers to be queried, which are returned for the APIs for creating, renewing, or scaling instances.
         */
        dealName: string;
        /**
         * ID of the associated process, which can be used to query the process execution status.
         */
        flowId: number;
        /**
         * The ID of the created instance, which is required only for the order that creates an instance.Note: This field may return null, indicating that no valid values can be obtained.
         */
        instanceIds: string[];
        /**
         * Account.
         */
        ownerUin: string;
        /**
         * Payment mode. Valid values: 0 (postpaid), 1 (prepaid).
         */
        payMode: number;
    }

    export interface GetProjectSecurityGroupsGroup {
        /**
         * Creation time in the format of yyyy-mm-dd hh:mm:ss.
         */
        createTime: string;
        /**
         * Inbound rule.
         */
        inbounds: outputs.Mariadb.GetProjectSecurityGroupsGroupInbound[];
        /**
         * Outbound rule.
         */
        outbounds: outputs.Mariadb.GetProjectSecurityGroupsGroupOutbound[];
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * Security group name.
         */
        securityGroupName: string;
        /**
         * Security group remarks.
         */
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsGroupInbound {
        /**
         * Policy, which can be `ACCEPT` or `DROP`.
         */
        action: string;
        /**
         * Source IP or source IP range, such as 192.168.0.0/16.
         */
        cidrIp: string;
        /**
         * Network protocol. UDP and TCP are supported.
         */
        ipProtocol: string;
        /**
         * Port.
         */
        portRange: string;
    }

    export interface GetProjectSecurityGroupsGroupOutbound {
        /**
         * Policy, which can be `ACCEPT` or `DROP`.
         */
        action: string;
        /**
         * Source IP or source IP range, such as 192.168.0.0/16.
         */
        cidrIp: string;
        /**
         * Network protocol. UDP and TCP are supported.
         */
        ipProtocol: string;
        /**
         * Port.
         */
        portRange: string;
    }

    export interface GetSaleInfoRegionList {
        /**
         * available zone choice.
         */
        availableChoices: outputs.Mariadb.GetSaleInfoRegionListAvailableChoice[];
        /**
         * region name(en).
         */
        region: string;
        /**
         * region id.
         */
        regionId: number;
        /**
         * region name(zh).
         */
        regionName: string;
        /**
         * list of az zone.
         */
        zoneLists: outputs.Mariadb.GetSaleInfoRegionListZoneList[];
    }

    export interface GetSaleInfoRegionListAvailableChoice {
        /**
         * master zone.
         */
        masterZones: outputs.Mariadb.GetSaleInfoRegionListAvailableChoiceMasterZone[];
        /**
         * slave zones.
         */
        slaveZones: outputs.Mariadb.GetSaleInfoRegionListAvailableChoiceSlaveZone[];
    }

    export interface GetSaleInfoRegionListAvailableChoiceMasterZone {
        /**
         * is zone on sale.
         */
        onSale: boolean;
        /**
         * zone name(en).
         */
        zone: string;
        /**
         * zone id.
         */
        zoneId: number;
        /**
         * zone name(zh).
         */
        zoneName: string;
    }

    export interface GetSaleInfoRegionListAvailableChoiceSlaveZone {
        /**
         * is zone on sale.
         */
        onSale: boolean;
        /**
         * zone name(en).
         */
        zone: string;
        /**
         * zone id.
         */
        zoneId: number;
        /**
         * zone name(zh).
         */
        zoneName: string;
    }

    export interface GetSaleInfoRegionListZoneList {
        /**
         * is zone on sale.
         */
        onSale: boolean;
        /**
         * zone name(en).
         */
        zone: string;
        /**
         * zone id.
         */
        zoneId: number;
        /**
         * zone name(zh).
         */
        zoneName: string;
    }

    export interface GetSecurityGroupsList {
        /**
         * Creation time, time format: `yyyy-mm-dd hh:mm:ss`.
         */
        createTime: string;
        /**
         * Inbound rules.
         */
        inbounds: outputs.Mariadb.GetSecurityGroupsListInbound[];
        /**
         * Outbound Rules.
         */
        outbounds: outputs.Mariadb.GetSecurityGroupsListOutbound[];
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * security group name.
         */
        securityGroupName: string;
        /**
         * Security Group Notes.
         */
        securityGroupRemark: string;
    }

    export interface GetSecurityGroupsListInbound {
        /**
         * Policy, ACCEPT or DROP.
         */
        action: string;
        /**
         * Source IP or IP range, such as 192.168.0.0/16.
         */
        cidrIp: string;
        /**
         * Network protocols, support `UDP`, `TCP`, etc.
         */
        ipProtocol: string;
        /**
         * port.
         */
        portRange: string;
    }

    export interface GetSecurityGroupsListOutbound {
        /**
         * Policy, ACCEPT or DROP.
         */
        action: string;
        /**
         * Source IP or IP range, such as 192.168.0.0/16.
         */
        cidrIp: string;
        /**
         * Network protocols, support `UDP`, `TCP`, etc.
         */
        ipProtocol: string;
        /**
         * port.
         */
        portRange: string;
    }

    export interface GetSlowLogsData {
        /**
         * Statement checksum for querying details.
         */
        checkSum: string;
        /**
         * Specific name of the database to be queried.
         */
        db: string;
        /**
         * Sample SQLNote: This field may return null, indicating that no valid values can be obtained.
         */
        exampleSql: string;
        /**
         * Abstracted SQL statement.
         */
        fingerPrint: string;
        /**
         * Host address of account.
         */
        host: string;
        /**
         * Average lock time.
         */
        lockTimeAvg: string;
        /**
         * Maximum lock time.
         */
        lockTimeMax: string;
        /**
         * Minimum lock time.
         */
        lockTimeMin: string;
        /**
         * Total statement lock time.
         */
        lockTimeSum: string;
        /**
         * Total number of statement queries.
         */
        queryCount: string;
        /**
         * Average query time.
         */
        queryTimeAvg: string;
        /**
         * Maximum query time.
         */
        queryTimeMax: string;
        /**
         * Minimum query time.
         */
        queryTimeMin: string;
        /**
         * Total statement query time.
         */
        queryTimeSum: string;
        /**
         * Number of scanned rows.
         */
        rowsExaminedSum: string;
        /**
         * Number of sent rows.
         */
        rowsSentSum: string;
        /**
         * Last execution time.
         */
        tsMax: string;
        /**
         * First execution time.
         */
        tsMin: string;
        /**
         * Account.
         */
        user: string;
    }

    export interface InstanceInitParam {
        /**
         * parameter name.
         */
        param: string;
        /**
         * parameter value.
         */
        value: string;
    }

    export interface ParametersParam {
        /**
         * parameter name.
         */
        param: string;
        /**
         * parameter value.
         */
        value: string;
    }

}

export namespace Mdl {
    export interface StreamLiveInputInputSetting {
        /**
         * Application name, which is valid if `Type` is `RTMP_PUSH` and can contain 1-32 letters and digitsNote: This field may return `null`, indicating that no valid value was found.
         */
        appName?: string;
        /**
         * Delayed time (ms) for playback, which is valid if `Type` is `RTMP_PUSH`Value range: 0 (default) or 10000-600000The value must be a multiple of 1,000.Note: This field may return `null`, indicating that no valid value was found.
         */
        delayTime?: number;
        /**
         * RTP/UDP input address, which does not need to be entered for the input parameter.Note: this field may return null, indicating that no valid values can be obtained.
         */
        inputAddress?: string;
        /**
         * The domain of an SRT_PUSH address. If this is a request parameter, you do not need to specify it.Note: This field may return `null`, indicating that no valid value was found.
         */
        inputDomain?: string;
        /**
         * The password, which is used for authentication.Note: This field may return `null`, indicating that no valid value was found.
         */
        password?: string;
        /**
         * Source type for stream pulling and relaying. To pull content from private-read COS buckets under the current account, set this parameter to `TencentCOS`; otherwise, leave it empty.Note: this field may return `null`, indicating that no valid value was found.
         */
        sourceType?: string;
        /**
         * Source URL, which is valid if `Type` is `RTMP_PULL`, `HLS_PULL`, or `MP4_PULL` and can contain 1-512 charactersNote: This field may return `null`, indicating that no valid value was found.
         */
        sourceUrl?: string;
        /**
         * Stream name, which is valid if `Type` is `RTMP_PUSH` and can contain 1-32 letters and digitsNote: This field may return `null`, indicating that no valid value was found.
         */
        streamName?: string;
        /**
         * The username, which is used for authentication.Note: This field may return `null`, indicating that no valid value was found.
         */
        userName?: string;
    }

}

export namespace Mongodb {
    export interface GetInstanceBackupsBackupList {
        /**
         * Remark of backup.
         */
        backupDesc: string;
        /**
         * Backup mode, currently supported: 0-logic backup, 1-physical backup, 2-all backups.The default is logical backup.
         */
        backupMethod: number;
        /**
         * Backup mode name.
         */
        backupName: string;
        /**
         * Size of backup(KN).
         */
        backupSize: number;
        /**
         * Backup mode type.
         */
        backupType: number;
        /**
         * end time of backup.
         */
        endTime: string;
        /**
         * Instance ID, the format is: cmgo-9d0p6umb.Same as the instance ID displayed in the cloud database console page.
         */
        instanceId: string;
        /**
         * start time of backup.
         */
        startTime: string;
        /**
         * Backup status.
         */
        status: number;
    }

    export interface GetInstanceConnectionsClient {
        /**
         * client connection count.
         */
        count: number;
        /**
         * is internal.
         */
        internalService: boolean;
        /**
         * client connection ip.
         */
        ip: string;
    }

    export interface GetInstanceCurrentOpCurrentOp {
        /**
         * running time(ms).
         */
        microsecsRunning: number;
        /**
         * Node name.
         */
        nodeName: string;
        /**
         * Filter condition, the namespace namespace to which the operation belongs, in the format of db.collection.
         */
        ns: string;
        /**
         * Filter condition, operation type, possible values: none, update, insert, query, command, getmore,remove and killcursors.
         */
        op: string;
        /**
         * operation id.
         */
        opId: number;
        /**
         * operation info.
         */
        operation: string;
        /**
         * operation query.
         */
        query: string;
        /**
         * filter condition, shard name.
         */
        replicaSetName: string;
        /**
         * Filter condition, node status, possible value: primary, secondary.
         */
        state: string;
    }

    export interface GetInstanceParamsInstanceEnumParam {
        /**
         * current value.
         */
        currentValue: string;
        /**
         * default value.
         */
        defaultValue: string;
        /**
         * enum value.
         */
        enumValues: string[];
        /**
         * if need restart.
         */
        needRestart: string;
        /**
         * name of parameter.
         */
        paramName: string;
        /**
         * if is running.
         */
        status: number;
        /**
         * descripition of parameter.
         */
        tips: string[];
        /**
         * value type.
         */
        valueType: string;
    }

    export interface GetInstanceParamsInstanceIntegerParam {
        /**
         * current value.
         */
        currentValue: string;
        /**
         * default value.
         */
        defaultValue: string;
        /**
         * max value.
         */
        max: string;
        /**
         * min value.
         */
        min: string;
        /**
         * if need restart.
         */
        needRestart: string;
        /**
         * name of parameter.
         */
        paramName: string;
        /**
         * if is running.
         */
        status: number;
        /**
         * descripition of parameter.
         */
        tips: string[];
        /**
         * value type.
         */
        valueType: string;
    }

    export interface GetInstanceParamsInstanceMultiParam {
        /**
         * current value.
         */
        currentValue: string;
        /**
         * default value.
         */
        defaultValue: string;
        /**
         * enum value.
         */
        enumValues: string[];
        /**
         * if need restart.
         */
        needRestart: string;
        /**
         * name of parameter.
         */
        paramName: string;
        /**
         * if is running.
         */
        status: number;
        /**
         * descripition of parameter.
         */
        tips: string[];
        /**
         * value type.
         */
        valueType: string;
    }

    export interface GetInstanceParamsInstanceTextParam {
        /**
         * current value.
         */
        currentValue: string;
        /**
         * default value.
         */
        defaultValue: string;
        /**
         * if need restart.
         */
        needRestart: string;
        /**
         * name of parameter.
         */
        paramName: string;
        /**
         * if is running.
         */
        status: string;
        /**
         * text value.
         */
        textValue: string;
        /**
         * descripition of parameter.
         */
        tips: string[];
        /**
         * value type.
         */
        valueType: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * Auto renew flag.
         */
        autoRenewFlag: number;
        /**
         * The available zone of the Mongodb.
         */
        availableZone: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * Type of Mongodb cluster, and available values include replica set cluster(expressed with `REPLSET`), sharding cluster(expressed with `SHARD`).
         */
        clusterType: string;
        /**
         * Number of cpu's core.
         */
        cpu: number;
        /**
         * Creation time of the Mongodb instance.
         */
        createTime: string;
        /**
         * Version of the Mongodb engine.
         */
        engineVersion: string;
        /**
         * ID of the Mongodb instance to be queried.
         */
        instanceId: string;
        /**
         * Name of the Mongodb instance.
         */
        instanceName: string;
        /**
         * Type of Mongodb instance.
         */
        machineType: string;
        /**
         * Memory size.
         */
        memory: number;
        /**
         * ID of the project which the instance belongs.
         */
        projectId: number;
        /**
         * Number of sharding.
         */
        shardQuantity: number;
        /**
         * Status of the Mongodb, and available values include pending initialization(expressed with 0),  processing(expressed with 1), running(expressed with 2) and expired(expressed with -2).
         */
        status: number;
        /**
         * ID of the subnet.
         */
        subnetId: string;
        /**
         * Tags of the Mongodb instance to be queried.
         */
        tags: {[key: string]: any};
        /**
         * IP of the Mongodb instance.
         */
        vip: string;
        /**
         * Disk size.
         */
        volume: number;
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * IP port of the Mongodb instance.
         */
        vport: number;
    }

    export interface GetZoneConfigList {
        /**
         * The available zone of the Mongodb.
         */
        availableZone: string;
        /**
         * Type of Mongodb cluster.
         */
        clusterType: string;
        /**
         * Number of cpu's core.
         */
        cpu: number;
        /**
         * Default disk size.
         */
        defaultStorage: number;
        /**
         * Version of the Mongodb version.
         */
        engineVersion: string;
        /**
         * Type of Mongodb instance.
         */
        machineType: string;
        /**
         * Maximum replicate set num for sharding cluster.
         */
        maxReplicateSetNum: number;
        /**
         * Maximum size of the disk.
         */
        maxStorage: number;
        /**
         * Memory size.
         */
        memory: number;
        /**
         * Minimum replicate set num for sharding cluster.
         */
        minReplicateSetNum: number;
        /**
         * Minimum sie of the disk.
         */
        minStorage: number;
    }

    export interface InstanceAccountAuthRole {
        /**
         * Permission information of the current account. 0: No permission. 1: read-only. 2: Write only. 3: Read and write.
         */
        mask: number;
        /**
         * Refers to the name of the database with the current account permissions.*: Indicates all databases. db.name: Indicates the database of a specific name.
         */
        namespace: string;
    }

    export interface InstanceAddNodeList {
        /**
         * The node role that needs to be added.
         * - SECONDARY: Mongod node;
         * - READONLY: read-only node;
         * - MONGOS: Mongos node.
         */
        role: string;
        /**
         * The availability zone corresponding to the node.
         * - single availability zone, where all nodes are in the same availability zone;
         * - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
         */
        zone: string;
    }

    export interface InstanceBackupDownloadTaskBackupSet {
        /**
         * Replication Id.
         */
        replicaSetId: string;
    }

    export interface InstanceRemoveNodeList {
        /**
         * The node ID to delete. The shard cluster must specify the name of the node to be deleted by a group of shards, and the rest of the shards should be grouped and aligned.
         */
        nodeName: string;
        /**
         * The node role that needs to be deleted.
         * - SECONDARY: Mongod node;
         * - READONLY: read-only node;
         * - MONGOS: Mongos node.
         */
        role: string;
        /**
         * The availability zone corresponding to the node.
         * - single availability zone, where all nodes are in the same availability zone;
         * - multiple availability zones: the current standard specification is the distribution of three availability zones, and the master and slave nodes are not in the same availability zone. You should pay attention to configuring the availability zone corresponding to the new node, and the rule that the number of nodes in any two availability zones is greater than the third availability zone must be met after the addition.
         */
        zone: string;
    }

    export interface InstanceStandbyInstanceList {
        /**
         * Indicates the ID of standby instance.
         */
        standbyInstanceId: string;
        /**
         * Indicates the region of standby instance.
         */
        standbyInstanceRegion: string;
    }

}

export namespace Monitor {
    export interface AlarmNoticeClsNotice {
        /**
         * Start-stop status, can not be transmitted, default enabled. 0= Disabled, 1= enabled.
         */
        enable?: number;
        /**
         * Log collection Id.
         */
        logSetId: string;
        /**
         * Regional.
         */
        region: string;
        /**
         * Theme Id.
         */
        topicId: string;
    }

    export interface AlarmNoticeUrlNotice {
        /**
         * Notification End Time Seconds at the start of a day.
         */
        endTime?: number;
        /**
         * If passed verification `0` is no, `1` is yes. Default `0`.
         */
        isValid: number;
        /**
         * Notification Start Time Number of seconds at the start of a day.
         */
        startTime?: number;
        /**
         * Callback URL (limited to 256 characters).
         */
        url: string;
        /**
         * Verification code.
         */
        validationCode?: string;
        /**
         * Notification period 1-7 indicates Monday to Sunday.
         */
        weekdays?: number[];
    }

    export interface AlarmNoticeUserNotice {
        /**
         * The number of seconds since the notification end time 00:00:00 (value range 0-86399).
         */
        endTime: number;
        /**
         * User group ID list.
         */
        groupIds?: number[];
        /**
         * Contact notification required 0= No 1= Yes.
         */
        needPhoneArriveNotice?: number;
        /**
         * Notification Channel List EMAIL=Mail SMS=SMS CALL=Telephone WECHAT=WeChat RTX=Enterprise WeChat.
         */
        noticeWays: string[];
        /**
         * Call type SYNC= Simultaneous call CIRCLE= Round call If this parameter is not specified, the default value is round call.
         */
        phoneCallType?: string;
        /**
         * Number of seconds between polls (value range: 60-900).
         */
        phoneCircleInterval?: number;
        /**
         * Number of telephone polls (value range: 1-5).
         */
        phoneCircleTimes?: number;
        /**
         * Number of seconds between calls in a polling session (value range: 60-900).
         */
        phoneInnerInterval?: number;
        /**
         * Telephone polling list.
         */
        phoneOrders?: number[];
        /**
         * Recipient Type USER=User GROUP=User Group.
         */
        receiverType: string;
        /**
         * The number of seconds since the notification start time 00:00:00 (value range 0-86399).
         */
        startTime: number;
        /**
         * User UID List.
         */
        userIds?: number[];
        /**
         * Notification period 1-7 indicates Monday to Sunday.
         */
        weekdays?: number[];
    }

    export interface AlarmPolicyConditions {
        /**
         * The and or relation of indicator alarm rule.
         */
        isUnionRule?: number;
        /**
         * A list of metric trigger condition.
         */
        rules?: outputs.Monitor.AlarmPolicyConditionsRule[];
    }

    export interface AlarmPolicyConditionsRule {
        /**
         * Number of periods.
         */
        continuePeriod: number;
        /**
         * Metric display name, which is used in the output parameter.
         */
        description: string;
        /**
         * Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
         */
        filter?: outputs.Monitor.AlarmPolicyConditionsRuleFilter;
        /**
         * Whether the alarm frequency increases exponentially.
         */
        isPowerNotice: number;
        /**
         * Metric name or event name.
         */
        metricName?: string;
        /**
         * Alarm interval in seconds.
         */
        noticeFrequency: number;
        /**
         * Operator.
         */
        operator?: string;
        /**
         * Statistical period in seconds.
         */
        period?: number;
        /**
         * Trigger condition type.
         */
        ruleType: string;
        /**
         * Unit, which is used in the output parameter.
         */
        unit: string;
        /**
         * Threshold.
         */
        value?: string;
    }

    export interface AlarmPolicyConditionsRuleFilter {
        /**
         * JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
         */
        dimensions?: string;
        /**
         * Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
         */
        type?: string;
    }

    export interface AlarmPolicyEventCondition {
        /**
         * Number of periods.
         */
        continuePeriod: number;
        /**
         * Metric display name, which is used in the output parameter.
         */
        description: string;
        /**
         * Filter condition for one single trigger rule. Must set it when create tke-xxx rules.
         */
        filter?: outputs.Monitor.AlarmPolicyEventConditionFilter;
        /**
         * Whether the alarm frequency increases exponentially.
         */
        isPowerNotice: number;
        /**
         * Metric name or event name.
         */
        metricName?: string;
        /**
         * Alarm interval in seconds.
         */
        noticeFrequency: number;
        /**
         * Operator.
         */
        operator?: string;
        /**
         * Statistical period in seconds.
         */
        period?: number;
        /**
         * Trigger condition type.
         */
        ruleType: string;
        /**
         * Unit, which is used in the output parameter.
         */
        unit: string;
        /**
         * Threshold.
         */
        value?: string;
    }

    export interface AlarmPolicyEventConditionFilter {
        /**
         * JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
         */
        dimensions?: string;
        /**
         * Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
         */
        type?: string;
    }

    export interface AlarmPolicyFilter {
        /**
         * JSON string generated by serializing the AlarmPolicyDimension two-dimensional array.
         */
        dimensions?: string;
        /**
         * Filter condition type. Valid values: DIMENSION (uses dimensions for filtering).
         */
        type: string;
    }

    export interface AlarmPolicyPolicyTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface AlarmPolicyTriggerTask {
        /**
         * Configuration information in JSON format.
         */
        taskConfig: string;
        /**
         * Triggered task type.
         */
        type: string;
    }

    export interface BindingReceiverReceivers {
        /**
         * End of alarm period. Meaning with `startTime`.
         */
        endTime?: number;
        /**
         * Method of warning notification.Optional `CALL`,`EMAIL`,`SITE`,`SMS`,`WECHAT`.
         */
        notifyWays: string[];
        /**
         * Alert sending language. Optional `en-US`,`zh-CN`.
         */
        receiveLanguage?: string;
        /**
         * Alarm receive group ID list.
         */
        receiverGroupLists?: number[];
        /**
         * Receive type. Optional `group`,`user`.
         */
        receiverType: string;
        /**
         * Alarm receiver ID list.
         */
        receiverUserLists?: number[];
        /**
         * Alarm period start time. Valid value ranges: (0~86399). which removes the date after it is converted to Beijing time as a Unix timestamp, for example 7200 means '10:0:0'.
         */
        startTime?: number;
    }

    export interface GetAlarmAllNamespacesCommonNamespace {
        /**
         * Dimension Information.
         */
        dimensions: outputs.Monitor.GetAlarmAllNamespacesCommonNamespaceDimension[];
        /**
         * Namespace labeling.
         */
        id: string;
        /**
         * Monitoring type.
         */
        monitorType: string;
        /**
         * Namespace name.
         */
        name: string;
    }

    export interface GetAlarmAllNamespacesCommonNamespaceDimension {
        /**
         * Can it be used to filter alarm history.
         */
        canFilterHistory: boolean;
        /**
         * Can it be used to filter the policy list.
         */
        canFilterPolicy: boolean;
        /**
         * Can it be used as an aggregation dimension.
         */
        canGroupBy: boolean;
        /**
         * Do you support multiple selections.
         */
        isMultiple: boolean;
        /**
         * Can I modify it after creation.
         */
        isMutable: boolean;
        /**
         * Required or not.
         */
        isRequired: boolean;
        /**
         * Whether to display to users.
         */
        isVisible: boolean;
        /**
         * Dimension key identifier, backend English name.
         */
        key: string;
        /**
         * Must it be used as an aggregation dimension.
         */
        mustGroupBy: boolean;
        /**
         * Namespace name.
         */
        name: string;
        /**
         * List of supported operators.
         */
        operators: outputs.Monitor.GetAlarmAllNamespacesCommonNamespaceDimensionOperator[];
        /**
         * Key to replace in front-end translation.
         */
        showValueReplace: string;
    }

    export interface GetAlarmAllNamespacesCommonNamespaceDimensionOperator {
        /**
         * Namespace labeling.
         */
        id: string;
        /**
         * Namespace name.
         */
        name: string;
    }

    export interface GetAlarmAllNamespacesCustomNamespacesNews {
        /**
         * List of supported regions.
         */
        availableRegions: string[];
        /**
         * Configuration information.
         */
        config: string;
        /**
         * Unique representation in dashboard.
         */
        dashboardId: string;
        /**
         * Namespace labeling.
         */
        id: string;
        /**
         * Namespace name.
         */
        name: string;
        /**
         * Product Name.
         */
        productName: string;
        /**
         * Sort Id.
         */
        sortId: number;
        /**
         * Namespace value.
         */
        value: string;
    }

    export interface GetAlarmAllNamespacesQceNamespacesNews {
        /**
         * List of supported regions.
         */
        availableRegions: string[];
        /**
         * Configuration information.
         */
        config: string;
        /**
         * Unique representation in dashboard.
         */
        dashboardId: string;
        /**
         * Namespace labeling.
         */
        id: string;
        /**
         * Namespace name.
         */
        name: string;
        /**
         * Product Name.
         */
        productName: string;
        /**
         * Sort Id.
         */
        sortId: number;
        /**
         * Namespace value.
         */
        value: string;
    }

    export interface GetAlarmBasicAlarmsAlarm {
        /**
         * Filter based on alarm status.
         */
        alarmStatus: string;
        /**
         * Alarm type, 0 represents indicator alarm, 2 represents product event alarm, and 3 represents platform event alarm.
         */
        alarmType: number;
        /**
         * Alarm content.
         */
        content: string;
        /**
         * Alarm object dimension information.
         */
        dimensions: string;
        /**
         * Duration in seconds.
         */
        duration: number;
        /**
         * Time of occurrence.
         */
        firstOccurTime: string;
        /**
         * Policy Group ID.
         */
        groupId: number;
        /**
         * Policy Group Name.
         */
        groupName: string;
        /**
         * The ID of this alarm.
         */
        id: number;
        /**
         * Instance Group Information.
         */
        instanceGroups: outputs.Monitor.GetAlarmBasicAlarmsAlarmInstanceGroup[];
        /**
         * End time.
         */
        lastOccurTime: string;
        /**
         * Indicator ID.
         */
        metricId: number;
        /**
         * Indicator Name.
         */
        metricName: string;
        /**
         * Notification method.
         */
        notifyWays: string[];
        /**
         * Alarm object ID.
         */
        objId: string;
        /**
         * Alarm Object.
         */
        objName: string;
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Entry name.
         */
        projectName: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Alarm status ID, 0 indicates not recovered; 1 indicates that it has been restored; 2,3,5 indicates insufficient data; 4 indicates it has expired.
         */
        status: number;
        /**
         * Policy Type.
         */
        viewName: string;
        /**
         * VPC, only CVM has.
         */
        vpc: string;
    }

    export interface GetAlarmBasicAlarmsAlarmInstanceGroup {
        /**
         * Instance Group ID.
         */
        instanceGroupId: number;
        /**
         * Instance Group Name.
         */
        instanceGroupName: string;
    }

    export interface GetAlarmBasicMetricMetricSet {
        /**
         * Optional parameters, filtered by dimension.
         */
        dimensions: outputs.Monitor.GetAlarmBasicMetricMetricSetDimension[];
        /**
         * Explanation of the meaning of statistical indicators.
         */
        meanings: outputs.Monitor.GetAlarmBasicMetricMetricSetMeaning[];
        /**
         * Indicator Chinese Name.
         */
        metricCName: string;
        /**
         * Indicator English name.
         */
        metricEName: string;
        /**
         * Indicator names are different for each cloud product. To obtain indicator names, please go to the monitoring indicator documents of each product, such as the indicator names of cloud servers, which can be found in Cloud Server Monitoring Indicators.
         */
        metricName: string;
        /**
         * The business namespace is different for each cloud product. To obtain the business namespace, please go to the product monitoring indicator documents, such as the namespace of the cloud server, which can be found in [Cloud Server Monitoring Indicators](https://cloud.tencent.com/document/product/248/6843 ).
         */
        namespace: string;
        /**
         * Cycle.
         */
        period: number[];
        /**
         * Indicator method within the statistical cycle.
         */
        periods: outputs.Monitor.GetAlarmBasicMetricMetricSetPeriod[];
        /**
         * Units used for indicators.
         */
        unit: string;
        /**
         * Units used for indicators.
         */
        unitCname: string;
    }

    export interface GetAlarmBasicMetricMetricSetDimension {
        /**
         * Optional parameters, filtered by dimension.
         */
        dimensions: string[];
    }

    export interface GetAlarmBasicMetricMetricSetMeaning {
        /**
         * Explanation of indicators in English.
         */
        en: string;
        /**
         * Chinese interpretation of indicators.
         */
        zh: string;
    }

    export interface GetAlarmBasicMetricMetricSetPeriod {
        /**
         * Cycle.
         */
        period: string;
        /**
         * Statistical methods.
         */
        statTypes: string[];
    }

    export interface GetAlarmConditionsTemplateTemplateGroupList {
        /**
         * Indicator alarm rules.
         */
        conditions: outputs.Monitor.GetAlarmConditionsTemplateTemplateGroupListCondition[];
        /**
         * Event alarm rules.
         */
        eventConditions: outputs.Monitor.GetAlarmConditionsTemplateTemplateGroupListEventCondition[];
        /**
         * Filter queries based on trigger condition template ID.
         */
        groupId: number;
        /**
         * Filter queries based on trigger condition template names.
         */
        groupName: string;
        /**
         * Creation time.
         */
        insertTime: number;
        /**
         * Is it a relationship rule with.
         */
        isUnionRule: number;
        /**
         * Last modified by UIN.
         */
        lastEditUin: number;
        /**
         * Associate Alert Policy Group.
         */
        policyGroups: outputs.Monitor.GetAlarmConditionsTemplateTemplateGroupListPolicyGroup[];
        /**
         * Remarks.
         */
        remark: string;
        /**
         * Update time.
         */
        updateTime: number;
        /**
         * View name, composed of DescribeAllNamespacesObtain. For cloud product monitoring, retrieve the QceNamespacesNew. N.ID parameter from the interface, such as cvm_ Device.
         */
        viewName: string;
    }

    export interface GetAlarmConditionsTemplateTemplateGroupListCondition {
        /**
         * Alarm notification frequency.
         */
        alarmNotifyPeriod: number;
        /**
         * Predefined repeated notification strategy (0- alarm only once, 1- exponential alarm, 2- connection alarm).
         */
        alarmNotifyType: number;
        /**
         * Detection method.
         */
        calcType: string;
        /**
         * Detection value.
         */
        calcValue: string;
        /**
         * Duration in seconds.
         */
        continueTime: string;
        /**
         * Whether it is an advanced indicator, 0: No; 1: Yes.
         */
        isAdvanced: number;
        /**
         * Whether to activate advanced indicators, 0: No; 1: Yes.
         */
        isOpen: number;
        /**
         * Indicator display name (external).
         */
        metricDisplayName: string;
        /**
         * Indicator ID.
         */
        metricId: number;
        /**
         * Cycle.
         */
        period: number;
        /**
         * Product ID.
         */
        productId: string;
        /**
         * Rule ID.
         */
        ruleId: number;
        /**
         * Indicator unit.
         */
        unit: string;
    }

    export interface GetAlarmConditionsTemplateTemplateGroupListEventCondition {
        /**
         * Alarm notification frequency.
         */
        alarmNotifyPeriod: string;
        /**
         * Predefined repeated notification strategy (0- alarm only once, 1- exponential alarm, 2- connection alarm).
         */
        alarmNotifyType: string;
        /**
         * Event Display Name (External).
         */
        eventDisplayName: string;
        /**
         * Event ID.
         */
        eventId: string;
        /**
         * Rule ID.
         */
        ruleId: string;
    }

    export interface GetAlarmConditionsTemplateTemplateGroupListPolicyGroup {
        /**
         * Can it be set as the default alarm strategy.
         */
        canSetDefault: boolean;
        /**
         * Alarm Policy Enable Status.
         */
        enable: boolean;
        /**
         * Filter queries based on trigger condition template ID.
         */
        groupId: number;
        /**
         * Filter queries based on trigger condition template names.
         */
        groupName: string;
        /**
         * Creation time.
         */
        insertTime: number;
        /**
         * Is it the default alarm policy.
         */
        isDefault: number;
        /**
         * Is it a relationship rule with.
         */
        isUnionRule: number;
        /**
         * Last modified by UIN.
         */
        lastEditUin: number;
        /**
         * Number of unshielded instances.
         */
        noShieldedInstanceCount: number;
        /**
         * Parent Policy Group ID.
         */
        parentGroupId: number;
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Alarm receiving object information.
         */
        receiverInfos: outputs.Monitor.GetAlarmConditionsTemplateTemplateGroupListPolicyGroupReceiverInfo[];
        /**
         * Remarks.
         */
        remark: string;
        /**
         * Total number of bound instances.
         */
        totalInstanceCount: number;
        /**
         * Update time.
         */
        updateTime: number;
        /**
         * View name, composed of DescribeAllNamespacesObtain. For cloud product monitoring, retrieve the QceNamespacesNew. N.ID parameter from the interface, such as cvm_ Device.
         */
        viewName: string;
    }

    export interface GetAlarmConditionsTemplateTemplateGroupListPolicyGroupReceiverInfo {
        /**
         * Effective period end time.
         */
        endTime: number;
        /**
         * Do you need to send a notification.
         */
        needSendNotice: number;
        /**
         * Alarm reception channel.
         */
        notifyWays: string[];
        /**
         * Telephone alarm to personal interval (seconds).
         */
        personInterval: number;
        /**
         * Message receiving group list.
         */
        receiverGroupLists: number[];
        /**
         * Receiver type.
         */
        receiverType: string;
        /**
         * Recipient list. List of recipient IDs queried through the platform interface.
         */
        receiverUserLists: number[];
        /**
         * Alarm recovery notification method.
         */
        recoverNotifies: string[];
        /**
         * Telephone alarm interval per round (seconds).
         */
        roundInterval: number;
        /**
         * Number of phone alarm rounds.
         */
        roundNumber: number;
        /**
         * Timing of telephone alarm notification. Optional OCCUR (notification during alarm), RECOVER (notification during recovery).
         */
        sendFors: string[];
        /**
         * Effective period start time.
         */
        startTime: number;
        /**
         * Telephone alarm receiver uid.
         */
        uidLists: number[];
    }

    export interface GetAlarmHistoryHistory {
        /**
         * Alarm record ID.
         */
        alarmId: string;
        /**
         * Alarm level.Note: this field may return null, indicating that no valid values can be obtained.
         */
        alarmLevel: string;
        /**
         * Filter by alarm object. Fuzzy search with string is supported.
         */
        alarmObject: string;
        /**
         * Filter by alarm status. Valid values: ALARM (not resolved), OK (resolved), NO_CONF (expired), NO_DATA (insufficient data). If this parameter is left empty, all will be queried by default.
         */
        alarmStatus: string;
        /**
         * Alarm type.
         */
        alarmType: string;
        /**
         * Fuzzy search by alarm content.
         */
        content: string;
        /**
         * Dimension information of an instance that triggered alarms.Note: this field may return null, indicating that no valid values can be obtained.
         */
        dimensions: string;
        /**
         * Event ID.
         */
        eventId: number;
        /**
         * Timestamp of the first occurrence.
         */
        firstOccurTime: number;
        /**
         * Instance group of alarm object.
         */
        instanceGroups: outputs.Monitor.GetAlarmHistoryHistoryInstanceGroup[];
        /**
         * Timestamp of the last occurrence.
         */
        lastOccurTime: number;
        /**
         * Metric informationNote: this field may return null, indicating that no valid values can be obtained.
         */
        metricsInfos: outputs.Monitor.GetAlarmHistoryHistoryMetricsInfo[];
        /**
         * Monitor type.
         */
        monitorType: string;
        /**
         * Policy type.
         */
        namespace: string;
        /**
         * Alarm channel list. Valid values: SMS (SMS), EMAIL (email), CALL (phone), WECHAT (WeChat).
         */
        noticeWays: string[];
        /**
         * Alarm policy ID, which can be used when you call APIs (BindingPolicyObject, UnBindingAllPolicyObject, UnBindingPolicyObject) to bind/unbind instances or instance groups to/from an alarm policy.
         */
        originId: string;
        /**
         * Whether the policy exists. Valid values: 0 (no), 1 (yes).
         */
        policyExists: number;
        /**
         * Alarm policy ID.
         */
        policyId: string;
        /**
         * Fuzzy search by policy name.
         */
        policyName: string;
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Project name.
         */
        projectName: string;
        /**
         * Search by recipient group.
         */
        receiverGroups: number[];
        /**
         * Search by recipient.
         */
        receiverUids: number[];
        /**
         * Region.
         */
        region: string;
        /**
         * VPC of alarm object for basic product alarm.
         */
        vpc: string;
    }

    export interface GetAlarmHistoryHistoryInstanceGroup {
        /**
         * Instance group ID.
         */
        id: number;
        /**
         * Instance group name.
         */
        name: string;
    }

    export interface GetAlarmHistoryHistoryMetricsInfo {
        /**
         * Metric display name.
         */
        description: string;
        /**
         * Metric name.
         */
        metricName: string;
        /**
         * Statistical period.
         */
        period: number;
        /**
         * Namespace used to query data by Tencent Cloud service monitoring type.
         */
        qceNamespace: string;
        /**
         * Value triggering alarm.
         */
        value: string;
    }

    export interface GetAlarmHistoryNamespace {
        /**
         * Monitor type.
         */
        monitorType: string;
        /**
         * Policy type.
         */
        namespace: string;
    }

    export interface GetAlarmMetricMetric {
        /**
         * Indicator display name.
         */
        description: string;
        /**
         * Dimension List.
         */
        dimensions: string[];
        /**
         * Is it a high-level indicator. 1 Yes 0 No.
         */
        isAdvanced: number;
        /**
         * Is the advanced indicator activated. 1 Yes 0 No.
         */
        isOpen: number;
        /**
         * Maximum value.
         */
        max: number;
        /**
         * Indicator configuration.
         */
        metricConfigs: outputs.Monitor.GetAlarmMetricMetricMetricConfig[];
        /**
         * Indicator Name.
         */
        metricName: string;
        /**
         * Minimum value.
         */
        min: number;
        /**
         * Alarm policy type, obtained from DescribeAllNamespaces, such as cvm_device.
         */
        namespace: string;
        /**
         * Matching operator.
         */
        operators: outputs.Monitor.GetAlarmMetricMetricOperator[];
        /**
         * Indicator trigger.
         */
        periods: number[];
        /**
         * Integration Center Product ID.
         */
        productId: number;
        /**
         * Unit.
         */
        unit: string;
    }

    export interface GetAlarmMetricMetricMetricConfig {
        /**
         * Number of allowed duration cycles for configuration.
         */
        continuePeriods: number[];
        /**
         * Allowed Operators.
         */
        operators: string[];
        /**
         * The data period allowed for configuration, in seconds.
         */
        periods: number[];
    }

    export interface GetAlarmMetricMetricOperator {
        /**
         * Operator identification.
         */
        id: string;
        /**
         * Operator Display Name.
         */
        name: string;
    }

    export interface GetAlarmMonitorTypeMonitorTypeInfo {
        /**
         * Monitoring type ID.
         */
        id: string;
        /**
         * Monitoring type.
         */
        name: string;
        /**
         * Sort order.
         */
        sortId: number;
    }

    export interface GetAlarmNoticeCallbacksUrlNotice {
        /**
         * The number of seconds from the end of the notification day.
         */
        endTime: number;
        /**
         * Verified 0=No 1=Yes.
         */
        isValid: number;
        /**
         * The number of seconds starting from the day of notification start time.
         */
        startTime: number;
        /**
         * Callback URL (limited to 256 characters).
         */
        url: string;
        /**
         * Verification code.
         */
        validationCode: string;
        /**
         * Notification period 1-7 represents Monday to Sunday.
         */
        weekdays: number[];
    }

    export interface GetAlarmNoticesAlarmNotice {
        /**
         * AMP consumer ID.
         */
        ampConsumerId: string;
        /**
         * A maximum of one alarm notification can be pushed to the CLS service.
         */
        clsNotices: outputs.Monitor.GetAlarmNoticesAlarmNoticeClsNotice[];
        /**
         * Alarm notification template ID.
         */
        id: string;
        /**
         * Whether it is the system default notification template 0=No 1=Yes.
         */
        isPreset: number;
        /**
         * Alarm notification template name Used for fuzzy search.
         */
        name: string;
        /**
         * Notification language zh-CN=Chinese en-US=English.
         */
        noticeLanguage: string;
        /**
         * Alarm notification type ALARM=Notification not restored OK=Notification restored ALL.
         */
        noticeType: string;
        /**
         * List of alarm policy IDs bound to the alarm notification template.
         */
        policyIds: string[];
        /**
         * Last modified time.
         */
        updatedAt: string;
        /**
         * Last Modified By.
         */
        updatedBy: string;
        /**
         * The maximum number of callback notifications is 3.
         */
        urlNotices: outputs.Monitor.GetAlarmNoticesAlarmNoticeUrlNotice[];
        /**
         * Alarm notification template list.(At most five).
         */
        userNotices: outputs.Monitor.GetAlarmNoticesAlarmNoticeUserNotice[];
    }

    export interface GetAlarmNoticesAlarmNoticeClsNotice {
        /**
         * Start-stop status, can not be transmitted, default enabled. 0= Disabled, 1= enabled.
         */
        enable: number;
        /**
         * Log collection Id.
         */
        logSetId: string;
        /**
         * Regional.
         */
        region: string;
        /**
         * Theme Id.
         */
        topicId: string;
    }

    export interface GetAlarmNoticesAlarmNoticeUrlNotice {
        /**
         * The number of seconds since the notification end time 00:00:00 (value range 0-86399).
         */
        endTime: number;
        /**
         * The number of seconds since the notification start time 00:00:00 (value range 0-86399).
         */
        startTime: number;
        /**
         * Callback URL (limited to 256 characters).
         */
        url: string;
        /**
         * Notification period 1-7 indicates Monday to Sunday.
         */
        weekdays: number[];
    }

    export interface GetAlarmNoticesAlarmNoticeUserNotice {
        /**
         * The number of seconds since the notification end time 00:00:00 (value range 0-86399).
         */
        endTime: number;
        /**
         * Receive group list.
         */
        groupIds: number[];
        /**
         * Contact notification required 0= No 1= Yes.
         */
        needPhoneArriveNotice: number;
        /**
         * Notification Channel List EMAIL=Mail SMS=SMS CALL=Telephone WECHAT=WeChat RTX=Enterprise WeChat.
         */
        noticeWays: string[];
        /**
         * Call type SYNC= Simultaneous call CIRCLE= Round call If this parameter is not specified, the default value is round call.
         */
        phoneCallType: string;
        /**
         * Number of seconds between polls (value range: 60-900).
         */
        phoneCircleInterval: number;
        /**
         * Number of telephone polls (value range: 1-5).
         */
        phoneCircleTimes: number;
        /**
         * Number of seconds between calls in a polling session (value range: 60-900).
         */
        phoneInnerInterval: number;
        /**
         * Telephone polling list.
         */
        phoneOrders: number[];
        /**
         * To filter alarm notification templates according to recipients, you need to select the notification user type. USER=user GROUP=user group Leave blank = not filter by recipient.
         */
        receiverType: string;
        /**
         * The number of seconds since the notification start time 00:00:00 (value range 0-86399).
         */
        startTime: number;
        /**
         * List of recipients.
         */
        userIds: number[];
        /**
         * Notification period 1-7 indicates Monday to Sunday.
         */
        weekdays: number[];
    }

    export interface GetAlarmPolicyPolicy {
        /**
         * The number of advanced metrics.Note: This field may return null, indicating that no valid values can be obtained.
         */
        advancedMetricNumber: number;
        /**
         * Whether the default policy can be set. Valid values: 1 (yes), 0 (no)Note: this field may return null, indicating that no valid values can be obtained.
         */
        canSetDefault: number;
        /**
         * Trigger condition template IDNote: this field may return null, indicating that no valid values can be obtained.
         */
        conditionTemplateId: string;
        /**
         * Metric trigger conditionNote: this field may return null, indicating that no valid values can be obtained.
         */
        conditions: outputs.Monitor.GetAlarmPolicyPolicyCondition[];
        /**
         * Template policy groupNote: this field may return null, indicating that no valid values can be obtained.
         */
        conditionsTemps: outputs.Monitor.GetAlarmPolicyPolicyConditionsTemp[];
        /**
         * Filter by alarm status. Valid values: [1]: enabled; [0]: disabled; [0, 1]: all.
         */
        enable: number;
        /**
         * Event trigger conditioNote: this field may return null, indicating that no valid values can be obtained.
         */
        eventConditions: outputs.Monitor.GetAlarmPolicyPolicyEventCondition[];
        /**
         * Information on the filter dimension associated with a policy.Note: This field may return null, indicating that no valid values can be obtained.
         */
        filterDimensionsParam: string;
        /**
         * Creation timeNote: this field may return null, indicating that no valid values can be obtained.
         */
        insertTime: number;
        /**
         * Instance group ID.
         */
        instanceGroupId: number;
        /**
         * Instance group nameNote: this field may return null, indicating that no valid values can be obtained.
         */
        instanceGroupName: string;
        /**
         * Number of instancesNote: This field may return null, indicating that no valid values can be obtained.
         */
        instanceSum: number;
        /**
         * Whether the policy is associated with all objectsNote: This field may return null, indicating that no valid values can be obtained.
         */
        isBindAll: number;
        /**
         * Whether it is the default policy. Valid values: 1 (yes), 0 (no)Note: this field may return null, indicating that no valid values can be obtained.
         */
        isDefault: number;
        /**
         * Whether it is a quick alarm policy.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isOneClick: number;
        /**
         * Uin of the last modifying userNote: this field may return null, indicating that no valid values can be obtained.
         */
        lastEditUin: string;
        /**
         * Monitor type. Valid values: MT_QCE (Tencent Cloud service monitoring)Note: this field may return null, indicating that no valid values can be obtained.
         */
        monitorType: string;
        /**
         * Alarm policy typeNote: this field may return null, indicating that no valid values can be obtained.
         */
        namespace: string;
        /**
         * Namespace display nameNote: this field may return null, indicating that no valid values can be obtained.
         */
        namespaceShowName: string;
        /**
         * List of the notification template IDs, which can be obtained by querying the notification template list.It can be queried with the API [DescribeAlarmNotices](https://www.tencentcloud.com/document/product/248/39300).
         */
        noticeIds: string[];
        /**
         * Notification rule listNote: this field may return null, indicating that no valid values can be obtained.
         */
        notices: outputs.Monitor.GetAlarmPolicyPolicyNotice[];
        /**
         * Whether the quick alarm policy is enabled.Note: This field may return null, indicating that no valid values can be obtained.
         */
        oneClickStatus: number;
        /**
         * Policy ID for instance/instance group binding and unbinding APIs (BindingPolicyObject, UnBindingAllPolicyObject, UnBindingPolicyObject)Note: this field may return null, indicating that no valid values can be obtained.
         */
        originId: string;
        /**
         * Alarm policy IDNote: this field may return null, indicating that no valid values can be obtained.
         */
        policyId: string;
        /**
         * Fuzzy search by policy name.
         */
        policyName: string;
        /**
         * Project ID. Valid values: -1 (no project), 0 (default project)Note: this field may return null, indicating that no valid values can be obtained.
         */
        projectId: number;
        /**
         * Project nameNote: this field may return null, indicating that no valid values can be obtained.
         */
        projectName: string;
        /**
         * RegionNote: this field may return null, indicating that no valid values can be obtained.
         */
        regions: string[];
        /**
         * RemarksNote: this field may return null, indicating that no valid values can be obtained.
         */
        remark: string;
        /**
         * Trigger condition type. Valid values: STATIC (static threshold), DYNAMIC (dynamic)Note: this field may return null, indicating that no valid values can be obtained.
         */
        ruleType: string;
        /**
         * TagNote: This field may return null, indicating that no valid values can be obtained.
         */
        tagInstances: outputs.Monitor.GetAlarmPolicyPolicyTagInstance[];
        /**
         * Policy tagNote: This field may return null, indicating that no valid values can be obtained.
         */
        tags: outputs.Monitor.GetAlarmPolicyPolicyTag[];
        /**
         * Filter alarm policy by triggered task (such as auto scaling task). Up to 10 tasks can be specified.
         */
        triggerTasks: outputs.Monitor.GetAlarmPolicyPolicyTriggerTask[];
        /**
         * Update timeNote: this field may return null, indicating that no valid values can be obtained.
         */
        updateTime: number;
        /**
         * Number of instances bound to policy groupNote: this field may return null, indicating that no valid values can be obtained.
         */
        useSum: number;
    }

    export interface GetAlarmPolicyPolicyCondition {
        /**
         * The judgment expression of composite alarm trigger conditions, which is valid when the value of IsUnionRule is 2. This parameter is used to determine that an alarm condition is met only when the expression values are True for multiple trigger conditions.Note: This field may return null, indicating that no valid values can be obtained.
         */
        complexExpression: string;
        /**
         * Judgment condition of an alarm trigger condition (0: Any; 1: All; 2: Composite). When the value is set to 2 (i.e., composite trigger conditions), this parameter should be used together with ComplexExpression.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isUnionRule: number;
        /**
         * Alarm trigger condition lisNote: this field may return null, indicating that no valid values can be obtained.
         */
        rules: outputs.Monitor.GetAlarmPolicyPolicyConditionRule[];
    }

    export interface GetAlarmPolicyPolicyConditionRule {
        /**
         * Number of periods. 1: continue for one period; 2: continue for two periods; and so on. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        continuePeriod: number;
        /**
         * Metric display name, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * Filter condition for one single trigger ruleNote: this field may return null, indicating that no valid values can be obtained.
         */
        filters: outputs.Monitor.GetAlarmPolicyPolicyConditionRuleFilter[];
        /**
         * The configuration of alarm level thresholdNote: This field may return null, indicating that no valid values can be obtained.
         */
        hierarchicalValues: outputs.Monitor.GetAlarmPolicyPolicyConditionRuleHierarchicalValue[];
        /**
         * Whether it is an advanced metric. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isAdvanced: number;
        /**
         * Whether the advanced metric feature is enabled. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isOpen: number;
        /**
         * Whether the alarm frequency increases exponentially. Valid values: 0 (no), 1 (yes)Note: this field may return null, indicating that no valid values can be obtained.
         */
        isPowerNotice: number;
        /**
         * Metric name or event name. The supported metrics can be queried via DescribeAlarmMetrics and the supported events via DescribeAlarmEventsNote: this field may return null, indicating that no valid value is obtained.
         */
        metricName: string;
        /**
         * Alarm interval in seconds. Valid values: 0 (do not repeat), 300 (alarm once every 5 minutes), 600 (alarm once every 10 minutes), 900 (alarm once every 15 minutes), 1800 (alarm once every 30 minutes), 3600 (alarm once every hour), 7200 (alarm once every 2 hours), 10800 (alarm once every 3 hours), 21600 (alarm once every 6 hours), 43200 (alarm once every 12 hours), 86400 (alarm once every day)Note: this field may return null, indicating that no valid values can be obtained.
         */
        noticeFrequency: number;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.Operator	String	No	Operatorintelligent = intelligent detection without thresholdeq = equal toge = greater than or equal togt = greater thanle = less than or equal tolt = less thanne = not equal todayIncrease = day-on-day increasedayDecrease = day-on-day decreasedayWave = day-on-day fluctuationweekIncrease = week-on-week increaseweekDecrease = week-on-week decreaseweekWave = week-on-week fluctuationcycleIncrease = cyclical increasecycleDecrease = cyclical decreasecycleWave = cyclical fluctuationre = regex matchThe valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        operator: string;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetricsNote: this field may return null, indicating that no valid value is obtained.
         */
        period: number;
        /**
         * Integration center product ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        productId: string;
        /**
         * Trigger condition type. Valid values: STATIC (static threshold), DYNAMIC (dynamic)Note: this field may return null, indicating that no valid values can be obtained.
         */
        ruleType: string;
        /**
         * Unit, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        unit: string;
        /**
         * Tag value.
         */
        value: string;
        /**
         * Maximum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMax: number;
        /**
         * Minimum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMin: number;
    }

    export interface GetAlarmPolicyPolicyConditionRuleFilter {
        /**
         * The alarm object list, which is a JSON string. The outer array corresponds to multiple instances, and the inner array is the dimension of an object.For example, 'CVM - Basic Monitor' can be written as: [ {Dimensions: {unInstanceId: ins-qr8d555g}}, {Dimensions: {unInstanceId: ins-qr8d555h}} ]You can also refer to the 'Example 2' below.For more information on the parameter samples of different Tencent Cloud services, see [Product Policy Type and Dimension Information](https://www.tencentcloud.com/document/product/248/39565?has_map=1).Note: If 1 is passed in for NeedCorrespondence, the relationship between a policy and an instance needs to be returned. You can pass in up to 20 alarm object dimensions to avoid request timeout.
         */
        dimensions: string;
        /**
         * Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface GetAlarmPolicyPolicyConditionRuleHierarchicalValue {
        /**
         * Threshold for the Remind levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        remind: string;
        /**
         * Threshold for the Serious levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        serious: string;
        /**
         * Threshold for the Warn levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        warn: string;
    }

    export interface GetAlarmPolicyPolicyConditionsTemp {
        /**
         * Metric trigger conditionNote: this field may return null, indicating that no valid values can be obtained.
         */
        conditions: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempCondition[];
        /**
         * Event trigger conditioNote: this field may return null, indicating that no valid values can be obtained.
         */
        eventConditions: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempEventCondition[];
        /**
         * Template nameNote: u200dThis field may return null, indicating that no valid values can be obtained.
         */
        templateName: string;
    }

    export interface GetAlarmPolicyPolicyConditionsTempCondition {
        /**
         * The judgment expression of composite alarm trigger conditions, which is valid when the value of IsUnionRule is 2. This parameter is used to determine that an alarm condition is met only when the expression values are True for multiple trigger conditions.Note: This field may return null, indicating that no valid values can be obtained.
         */
        complexExpression: string;
        /**
         * Judgment condition of an alarm trigger condition (0: Any; 1: All; 2: Composite). When the value is set to 2 (i.e., composite trigger conditions), this parameter should be used together with ComplexExpression.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isUnionRule: number;
        /**
         * Alarm trigger condition lisNote: this field may return null, indicating that no valid values can be obtained.
         */
        rules: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempConditionRule[];
    }

    export interface GetAlarmPolicyPolicyConditionsTempConditionRule {
        /**
         * Number of periods. 1: continue for one period; 2: continue for two periods; and so on. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        continuePeriod: number;
        /**
         * Metric display name, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * Filter condition for one single trigger ruleNote: this field may return null, indicating that no valid values can be obtained.
         */
        filters: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempConditionRuleFilter[];
        /**
         * The configuration of alarm level thresholdNote: This field may return null, indicating that no valid values can be obtained.
         */
        hierarchicalValues: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempConditionRuleHierarchicalValue[];
        /**
         * Whether it is an advanced metric. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isAdvanced: number;
        /**
         * Whether the advanced metric feature is enabled. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isOpen: number;
        /**
         * Whether the alarm frequency increases exponentially. Valid values: 0 (no), 1 (yes)Note: this field may return null, indicating that no valid values can be obtained.
         */
        isPowerNotice: number;
        /**
         * Metric name or event name. The supported metrics can be queried via DescribeAlarmMetrics and the supported events via DescribeAlarmEventsNote: this field may return null, indicating that no valid value is obtained.
         */
        metricName: string;
        /**
         * Alarm interval in seconds. Valid values: 0 (do not repeat), 300 (alarm once every 5 minutes), 600 (alarm once every 10 minutes), 900 (alarm once every 15 minutes), 1800 (alarm once every 30 minutes), 3600 (alarm once every hour), 7200 (alarm once every 2 hours), 10800 (alarm once every 3 hours), 21600 (alarm once every 6 hours), 43200 (alarm once every 12 hours), 86400 (alarm once every day)Note: this field may return null, indicating that no valid values can be obtained.
         */
        noticeFrequency: number;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.Operator	String	No	Operatorintelligent = intelligent detection without thresholdeq = equal toge = greater than or equal togt = greater thanle = less than or equal tolt = less thanne = not equal todayIncrease = day-on-day increasedayDecrease = day-on-day decreasedayWave = day-on-day fluctuationweekIncrease = week-on-week increaseweekDecrease = week-on-week decreaseweekWave = week-on-week fluctuationcycleIncrease = cyclical increasecycleDecrease = cyclical decreasecycleWave = cyclical fluctuationre = regex matchThe valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        operator: string;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetricsNote: this field may return null, indicating that no valid value is obtained.
         */
        period: number;
        /**
         * Integration center product ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        productId: string;
        /**
         * Trigger condition type. Valid values: STATIC (static threshold), DYNAMIC (dynamic)Note: this field may return null, indicating that no valid values can be obtained.
         */
        ruleType: string;
        /**
         * Unit, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        unit: string;
        /**
         * Tag value.
         */
        value: string;
        /**
         * Maximum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMax: number;
        /**
         * Minimum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMin: number;
    }

    export interface GetAlarmPolicyPolicyConditionsTempConditionRuleFilter {
        /**
         * The alarm object list, which is a JSON string. The outer array corresponds to multiple instances, and the inner array is the dimension of an object.For example, 'CVM - Basic Monitor' can be written as: [ {Dimensions: {unInstanceId: ins-qr8d555g}}, {Dimensions: {unInstanceId: ins-qr8d555h}} ]You can also refer to the 'Example 2' below.For more information on the parameter samples of different Tencent Cloud services, see [Product Policy Type and Dimension Information](https://www.tencentcloud.com/document/product/248/39565?has_map=1).Note: If 1 is passed in for NeedCorrespondence, the relationship between a policy and an instance needs to be returned. You can pass in up to 20 alarm object dimensions to avoid request timeout.
         */
        dimensions: string;
        /**
         * Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface GetAlarmPolicyPolicyConditionsTempConditionRuleHierarchicalValue {
        /**
         * Threshold for the Remind levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        remind: string;
        /**
         * Threshold for the Serious levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        serious: string;
        /**
         * Threshold for the Warn levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        warn: string;
    }

    export interface GetAlarmPolicyPolicyConditionsTempEventCondition {
        /**
         * Alarm trigger condition lisNote: this field may return null, indicating that no valid values can be obtained.
         */
        rules: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempEventConditionRule[];
    }

    export interface GetAlarmPolicyPolicyConditionsTempEventConditionRule {
        /**
         * Number of periods. 1: continue for one period; 2: continue for two periods; and so on. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        continuePeriod: number;
        /**
         * Metric display name, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * Filter condition for one single trigger ruleNote: this field may return null, indicating that no valid values can be obtained.
         */
        filters: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempEventConditionRuleFilter[];
        /**
         * The configuration of alarm level thresholdNote: This field may return null, indicating that no valid values can be obtained.
         */
        hierarchicalValues: outputs.Monitor.GetAlarmPolicyPolicyConditionsTempEventConditionRuleHierarchicalValue[];
        /**
         * Whether it is an advanced metric. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isAdvanced: number;
        /**
         * Whether the advanced metric feature is enabled. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isOpen: number;
        /**
         * Whether the alarm frequency increases exponentially. Valid values: 0 (no), 1 (yes)Note: this field may return null, indicating that no valid values can be obtained.
         */
        isPowerNotice: number;
        /**
         * Metric name or event name. The supported metrics can be queried via DescribeAlarmMetrics and the supported events via DescribeAlarmEventsNote: this field may return null, indicating that no valid value is obtained.
         */
        metricName: string;
        /**
         * Alarm interval in seconds. Valid values: 0 (do not repeat), 300 (alarm once every 5 minutes), 600 (alarm once every 10 minutes), 900 (alarm once every 15 minutes), 1800 (alarm once every 30 minutes), 3600 (alarm once every hour), 7200 (alarm once every 2 hours), 10800 (alarm once every 3 hours), 21600 (alarm once every 6 hours), 43200 (alarm once every 12 hours), 86400 (alarm once every day)Note: this field may return null, indicating that no valid values can be obtained.
         */
        noticeFrequency: number;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.Operator	String	No	Operatorintelligent = intelligent detection without thresholdeq = equal toge = greater than or equal togt = greater thanle = less than or equal tolt = less thanne = not equal todayIncrease = day-on-day increasedayDecrease = day-on-day decreasedayWave = day-on-day fluctuationweekIncrease = week-on-week increaseweekDecrease = week-on-week decreaseweekWave = week-on-week fluctuationcycleIncrease = cyclical increasecycleDecrease = cyclical decreasecycleWave = cyclical fluctuationre = regex matchThe valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        operator: string;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetricsNote: this field may return null, indicating that no valid value is obtained.
         */
        period: number;
        /**
         * Integration center product ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        productId: string;
        /**
         * Trigger condition type. Valid values: STATIC (static threshold), DYNAMIC (dynamic)Note: this field may return null, indicating that no valid values can be obtained.
         */
        ruleType: string;
        /**
         * Unit, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        unit: string;
        /**
         * Tag value.
         */
        value: string;
        /**
         * Maximum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMax: number;
        /**
         * Minimum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMin: number;
    }

    export interface GetAlarmPolicyPolicyConditionsTempEventConditionRuleFilter {
        /**
         * The alarm object list, which is a JSON string. The outer array corresponds to multiple instances, and the inner array is the dimension of an object.For example, 'CVM - Basic Monitor' can be written as: [ {Dimensions: {unInstanceId: ins-qr8d555g}}, {Dimensions: {unInstanceId: ins-qr8d555h}} ]You can also refer to the 'Example 2' below.For more information on the parameter samples of different Tencent Cloud services, see [Product Policy Type and Dimension Information](https://www.tencentcloud.com/document/product/248/39565?has_map=1).Note: If 1 is passed in for NeedCorrespondence, the relationship between a policy and an instance needs to be returned. You can pass in up to 20 alarm object dimensions to avoid request timeout.
         */
        dimensions: string;
        /**
         * Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface GetAlarmPolicyPolicyConditionsTempEventConditionRuleHierarchicalValue {
        /**
         * Threshold for the Remind levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        remind: string;
        /**
         * Threshold for the Serious levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        serious: string;
        /**
         * Threshold for the Warn levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        warn: string;
    }

    export interface GetAlarmPolicyPolicyEventCondition {
        /**
         * Alarm trigger condition lisNote: this field may return null, indicating that no valid values can be obtained.
         */
        rules: outputs.Monitor.GetAlarmPolicyPolicyEventConditionRule[];
    }

    export interface GetAlarmPolicyPolicyEventConditionRule {
        /**
         * Number of periods. 1: continue for one period; 2: continue for two periods; and so on. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        continuePeriod: number;
        /**
         * Metric display name, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * Filter condition for one single trigger ruleNote: this field may return null, indicating that no valid values can be obtained.
         */
        filters: outputs.Monitor.GetAlarmPolicyPolicyEventConditionRuleFilter[];
        /**
         * The configuration of alarm level thresholdNote: This field may return null, indicating that no valid values can be obtained.
         */
        hierarchicalValues: outputs.Monitor.GetAlarmPolicyPolicyEventConditionRuleHierarchicalValue[];
        /**
         * Whether it is an advanced metric. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isAdvanced: number;
        /**
         * Whether the advanced metric feature is enabled. 0: No; 1: Yes.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isOpen: number;
        /**
         * Whether the alarm frequency increases exponentially. Valid values: 0 (no), 1 (yes)Note: this field may return null, indicating that no valid values can be obtained.
         */
        isPowerNotice: number;
        /**
         * Metric name or event name. The supported metrics can be queried via DescribeAlarmMetrics and the supported events via DescribeAlarmEventsNote: this field may return null, indicating that no valid value is obtained.
         */
        metricName: string;
        /**
         * Alarm interval in seconds. Valid values: 0 (do not repeat), 300 (alarm once every 5 minutes), 600 (alarm once every 10 minutes), 900 (alarm once every 15 minutes), 1800 (alarm once every 30 minutes), 3600 (alarm once every hour), 7200 (alarm once every 2 hours), 10800 (alarm once every 3 hours), 21600 (alarm once every 6 hours), 43200 (alarm once every 12 hours), 86400 (alarm once every day)Note: this field may return null, indicating that no valid values can be obtained.
         */
        noticeFrequency: number;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.Operator	String	No	Operatorintelligent = intelligent detection without thresholdeq = equal toge = greater than or equal togt = greater thanle = less than or equal tolt = less thanne = not equal todayIncrease = day-on-day increasedayDecrease = day-on-day decreasedayWave = day-on-day fluctuationweekIncrease = week-on-week increaseweekDecrease = week-on-week decreaseweekWave = week-on-week fluctuationcycleIncrease = cyclical increasecycleDecrease = cyclical decreasecycleWave = cyclical fluctuationre = regex matchThe valid values can be queried via DescribeAlarmMetrics.Note: this field may return null, indicating that no valid value is obtained.
         */
        operator: string;
        /**
         * Statistical period in seconds. The valid values can be queried via DescribeAlarmMetricsNote: this field may return null, indicating that no valid value is obtained.
         */
        period: number;
        /**
         * Integration center product ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        productId: string;
        /**
         * Trigger condition type. Valid values: STATIC (static threshold), DYNAMIC (dynamic)Note: this field may return null, indicating that no valid values can be obtained.
         */
        ruleType: string;
        /**
         * Unit, which is used in the output parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        unit: string;
        /**
         * Tag value.
         */
        value: string;
        /**
         * Maximum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMax: number;
        /**
         * Minimum valueNote: This field may return null, indicating that no valid values can be obtained.
         */
        valueMin: number;
    }

    export interface GetAlarmPolicyPolicyEventConditionRuleFilter {
        /**
         * The alarm object list, which is a JSON string. The outer array corresponds to multiple instances, and the inner array is the dimension of an object.For example, 'CVM - Basic Monitor' can be written as: [ {Dimensions: {unInstanceId: ins-qr8d555g}}, {Dimensions: {unInstanceId: ins-qr8d555h}} ]You can also refer to the 'Example 2' below.For more information on the parameter samples of different Tencent Cloud services, see [Product Policy Type and Dimension Information](https://www.tencentcloud.com/document/product/248/39565?has_map=1).Note: If 1 is passed in for NeedCorrespondence, the relationship between a policy and an instance needs to be returned. You can pass in up to 20 alarm object dimensions to avoid request timeout.
         */
        dimensions: string;
        /**
         * Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface GetAlarmPolicyPolicyEventConditionRuleHierarchicalValue {
        /**
         * Threshold for the Remind levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        remind: string;
        /**
         * Threshold for the Serious levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        serious: string;
        /**
         * Threshold for the Warn levelNote: This field may return null, indicating that no valid values can be obtained.
         */
        warn: string;
    }

    export interface GetAlarmPolicyPolicyNotice {
        /**
         * Backend AMP consumer ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        ampConsumerId: string;
        /**
         * Channel to push alarm notifications to CLS.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clsNotices: outputs.Monitor.GetAlarmPolicyPolicyNoticeClsNotice[];
        /**
         * Alarm notification template IDNote: this field may return null, indicating that no valid values can be obtained.
         */
        id: string;
        /**
         * Whether it is the system default notification template. Valid values: 0 (no), 1 (yes)Note: this field may return null, indicating that no valid values can be obtained.
         */
        isPreset: number;
        /**
         * Alarm notification template nameNote: this field may return null, indicating that no valid values can be obtained.
         */
        name: string;
        /**
         * Notification language. Valid values: zh-CN (Chinese), en-US (English)Note: this field may return null, indicating that no valid values can be obtained.
         */
        noticeLanguage: string;
        /**
         * Alarm notification type. Valid values: ALARM (for unresolved alarms), OK (for resolved alarms), ALL (for all alarms)Note: this field may return null, indicating that no valid values can be obtained.
         */
        noticeType: string;
        /**
         * List of IDs of the alarm policies bound to alarm notification templateNote: this field may return null, indicating that no valid values can be obtained.
         */
        policyIds: string[];
        /**
         * Policy tagNote: This field may return null, indicating that no valid values can be obtained.
         */
        tags: outputs.Monitor.GetAlarmPolicyPolicyNoticeTag[];
        /**
         * Last modified timeNote: this field may return null, indicating that no valid values can be obtained.
         */
        updatedAt: string;
        /**
         * Last modified byNote: this field may return null, indicating that no valid values can be obtained.
         */
        updatedBy: string;
        /**
         * Callback notification listNote: this field may return null, indicating that no valid values can be obtained.
         */
        urlNotices: outputs.Monitor.GetAlarmPolicyPolicyNoticeUrlNotice[];
        /**
         * User notification listNote: this field may return null, indicating that no valid values can be obtained.
         */
        userNotices: outputs.Monitor.GetAlarmPolicyPolicyNoticeUserNotice[];
    }

    export interface GetAlarmPolicyPolicyNoticeClsNotice {
        /**
         * Filter by alarm status. Valid values: [1]: enabled; [0]: disabled; [0, 1]: all.
         */
        enable: number;
        /**
         * Logset ID.
         */
        logSetId: string;
        /**
         * RegionNote: this field may return null, indicating that no valid values can be obtained.
         */
        region: string;
        /**
         * Topic ID.
         */
        topicId: string;
    }

    export interface GetAlarmPolicyPolicyNoticeTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface GetAlarmPolicyPolicyNoticeUrlNotice {
        /**
         * Notification end time, which is expressed by the number of seconds since 00:00:00. Value range: 0-86399Note: this field may return null, indicating that no valid values can be obtained.
         */
        endTime: number;
        /**
         * Whether verification is passed. Valid values: 0 (no), 1 (yes)Note: this field may return null, indicating that no valid values can be obtained.
         */
        isValid: number;
        /**
         * Notification start time, which is expressed by the number of seconds since 00:00:00. Value range: 0-86399Note: this field may return null, indicating that no valid values can be obtained.
         */
        startTime: number;
        /**
         * Callback URL, which can contain up to 256 charactersNote: this field may return null, indicating that no valid values can be obtained.
         */
        url: string;
        /**
         * Verification codeNote: this field may return null, indicating that no valid values can be obtained.
         */
        validationCode: string;
        /**
         * Notification cycle. The values 1-7 indicate Monday to Sunday.Note: This field may return null, indicating that no valid values can be obtained.
         */
        weekdays: number[];
    }

    export interface GetAlarmPolicyPolicyNoticeUserNotice {
        /**
         * Notification end time, which is expressed by the number of seconds since 00:00:00. Value range: 0-86399Note: this field may return null, indicating that no valid values can be obtained.
         */
        endTime: number;
        /**
         * User group ID listNote: this field may return null, indicating that no valid values can be obtained.
         */
        groupIds: number[];
        /**
         * Whether receipt notification is required. Valid values: 0 (no), 1 (yes)Note: this field may return null, indicating that no valid values can be obtained.
         */
        needPhoneArriveNotice: number;
        /**
         * Notification channel list. Valid values: EMAIL (email), SMS (SMS), CALL (phone), WECHAT (WeChat), RTX (WeCom)Note: This field may return null, indicating that no valid values can be obtained.
         */
        noticeWays: string[];
        /**
         * List of schedule IDsNote: u200dThis field may return null, indicating that no valid values can be obtained.
         */
        onCallFormIds: string[];
        /**
         * Dial type. SYNC (simultaneous dial), CIRCLE (polled dial). Default value: CIRCLE.Note: This field may return null, indicating that no valid values can be obtained.
         */
        phoneCallType: string;
        /**
         * Polling interval in seconds. Value range: 60-900Note: this field may return null, indicating that no valid values can be obtained.
         */
        phoneCircleInterval: number;
        /**
         * Number of phone pollings. Value range: 1-5Note: this field may return null, indicating that no valid values can be obtained.
         */
        phoneCircleTimes: number;
        /**
         * Call interval in seconds within one polling. Value range: 60-900Note: this field may return null, indicating that no valid values can be obtained.
         */
        phoneInnerInterval: number;
        /**
         * Phone polling listNote: this field may return null, indicating that no valid values can be obtained.
         */
        phoneOrders: number[];
        /**
         * Recipient type. Valid values: USER (user), GROUP (user group)Note: this field may return null, indicating that no valid values can be obtained.
         */
        receiverType: string;
        /**
         * Notification start time, which is expressed by the number of seconds since 00:00:00. Value range: 0-86399Note: this field may return null, indicating that no valid values can be obtained.
         */
        startTime: number;
        /**
         * User uid listNote: this field may return null, indicating that no valid values can be obtained.
         */
        userIds: number[];
        /**
         * Notification cycle. The values 1-7 indicate Monday to Sunday.Note: This field may return null, indicating that no valid values can be obtained.
         */
        weekdays: number[];
    }

    export interface GetAlarmPolicyPolicyTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface GetAlarmPolicyPolicyTagInstance {
        /**
         * Binding status. 2: bound; 1: bindingNote: This field may return null, indicating that no valid values can be obtained.
         */
        bindingStatus: number;
        /**
         * Number of instancesNote: This field may return null, indicating that no valid values can be obtained.
         */
        instanceSum: number;
        /**
         * Tag key.
         */
        key: string;
        /**
         * Region IDNote: This field may return null, indicating that no valid values can be obtained.
         */
        regionId: number;
        /**
         * Service type, for example, CVMNote: This field may return null, indicating that no valid values can be obtained.
         */
        serviceType: string;
        /**
         * Tag status. 2: existent; 1: nonexistentNote: This field may return null, indicating that no valid values can be obtained.
         */
        tagStatus: number;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface GetAlarmPolicyPolicyTriggerTask {
        /**
         * Configuration information in JSON format, such as {Key1:Value1,Key2:Value2}Note: this field may return null, indicating that no valid values can be obtained.
         */
        taskConfig: string;
        /**
         * Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface GetAlarmPolicyTriggerTask {
        /**
         * Configuration information in JSON format, such as {Key1:Value1,Key2:Value2}Note: this field may return null, indicating that no valid values can be obtained.
         */
        taskConfig: string;
        /**
         * Triggered task type. Valid value: AS (auto scaling)Note: this field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface GetBindingObjectsList {
        /**
         * Represents a collection of dimensions of an object instance, json format.
         */
        dimensionsJson: string;
        /**
         * Whether the object is shielded or not, `0` means unshielded and `1` means shielded.
         */
        isShielded: number;
        /**
         * The region where the object is located.
         */
        region: string;
        /**
         * Object unique ID.
         */
        uniqueId: string;
    }

    export interface GetDataDimension {
        /**
         * Instance dimension name, eg: `InstanceId` for cvm.
         */
        name: string;
        /**
         * Instance dimension value, eg: `ins-j0hk02zo` for cvm.
         */
        value: string;
    }

    export interface GetDataList {
        /**
         * Statistical timestamp.
         */
        timestamp: number;
        /**
         * Instance dimension value, eg: `ins-j0hk02zo` for cvm.
         */
        value: number;
    }

    export interface GetGrafanaPluginOverviewsPluginSet {
        /**
         * Grafana plugin ID.
         */
        pluginId: string;
        /**
         * Grafana plugin version.
         */
        version: string;
    }

    export interface GetPolicyConditionsList {
        /**
         * A list of event condition metrics. Each element contains the following attributes:
         */
        eventMetrics: outputs.Monitor.GetPolicyConditionsListEventMetric[];
        /**
         * Whether to support multi region.
         */
        isSupportMultiRegion: boolean;
        /**
         * A list of event condition metrics. Each element contains the following attributes:
         */
        metrics: outputs.Monitor.GetPolicyConditionsListMetric[];
        /**
         * Name of the policy name, support partial matching, eg:`Cloud Virtual Machine`,`Virtual`,`Cloud Load Banlancer-Private CLB Listener`.
         */
        name: string;
        /**
         * Policy view name, eg:`cvmDevice`,`BANDWIDTHPACKAGE`, refer to `data.tencentcloud_monitor_policy_conditions(policy_view_name)`.
         */
        policyViewName: string;
        /**
         * Support regions of this policy view.
         */
        supportRegions: string[];
    }

    export interface GetPolicyConditionsListEventMetric {
        /**
         * The ID of this event metric.
         */
        eventId: number;
        /**
         * The name of this event metric.
         */
        eventShowName: string;
        /**
         * Whether to recover.
         */
        needRecovered: boolean;
    }

    export interface GetPolicyConditionsListMetric {
        /**
         * Calculate type of this metric.
         */
        calcTypeKeys: number[];
        /**
         * Whether `calcType` required in the configuration.
         */
        calcTypeNeed: boolean;
        /**
         * The default calculate value of this metric.
         */
        calcValueDefault: string;
        /**
         * The fixed calculate value of this metric.
         */
        calcValueFixed: string;
        /**
         * The max calculate value of this metric.
         */
        calcValueMax: string;
        /**
         * The min calculate value of this metric.
         */
        calcValueMin: string;
        /**
         * Whether `calcValue` required in the configuration.
         */
        calcValueNeed: boolean;
        /**
         * The default continue time(seconds) config for this metric.
         */
        continueTimeDefault: number;
        /**
         * The continue time(seconds) keys for this metric.
         */
        continueTimeKeys: number[];
        /**
         * Whether `continueTime` required in the configuration.
         */
        continueTimeNeed: boolean;
        /**
         * The ID of this metric.
         */
        metricId: number;
        /**
         * The name of this metric.
         */
        metricShowName: string;
        /**
         * The unit of this metric.
         */
        metricUnit: string;
        /**
         * The default data time(seconds) config for this metric.
         */
        periodDefault: number;
        /**
         * The data time(seconds) keys for this metric.
         */
        periodKeys: number[];
        /**
         * Whether `period` required in the configuration.
         */
        periodNeed: boolean;
        /**
         * The default period number config for this metric.
         */
        periodNumDefault: number;
        /**
         * The period number keys for this metric.
         */
        periodNumKeys: number[];
        /**
         * Whether `periodNum` required in the configuration.
         */
        periodNumNeed: boolean;
        /**
         * Data aggregation mode, cycle of 10 seconds.
         */
        statTypeP10: string;
        /**
         * Data aggregation mode, cycle of 1800 seconds.
         */
        statTypeP1800: string;
        /**
         * Data aggregation mode, cycle of 300 seconds.
         */
        statTypeP300: string;
        /**
         * Data aggregation mode, cycle of 3600 seconds.
         */
        statTypeP3600: string;
        /**
         * Data aggregation mode, cycle of 5 seconds.
         */
        statTypeP5: string;
        /**
         * Data aggregation mode, cycle of 60 seconds.
         */
        statTypeP60: string;
        /**
         * Data aggregation mode, cycle of 600 seconds.
         */
        statTypeP600: string;
        /**
         * Data aggregation mode, cycle of 86400 seconds.
         */
        statTypeP86400: string;
    }

    export interface GetPolicyGroupsList {
        /**
         * Whether it can be set as the default policy.
         */
        canSetDefault: boolean;
        /**
         * A list of threshold rules. Each element contains the following attributes:
         */
        conditions: outputs.Monitor.GetPolicyGroupsListCondition[];
        /**
         * A list of event rules. Each element contains the following attributes:
         */
        eventConditions: outputs.Monitor.GetPolicyGroupsListEventCondition[];
        /**
         * The policy group id.
         */
        groupId: number;
        /**
         * The policy group name.
         */
        groupName: string;
        /**
         * The policy group create timestamp.
         */
        insertTime: number;
        /**
         * If is default policy group or not, `0` represents the non-default policy, and `1` represents the default policy.
         */
        isDefault: number;
        /**
         * Whether open or not.
         */
        isOpen: boolean;
        /**
         * Recently edited user uin.
         */
        lastEditUin: string;
        /**
         * Number of unmasked instances of policy group bindings.
         */
        noShieldedSum: number;
        /**
         * Parent policy group ID.
         */
        parentGroupId: number;
        /**
         * The policy group view name.
         */
        policyViewName: string;
        /**
         * The project ID to which the policy group belongs.
         */
        projectId: number;
        /**
         * A list of receivers. Each element contains the following attributes:
         */
        receivers: outputs.Monitor.GetPolicyGroupsListReceiver[];
        /**
         * Policy group remarks.
         */
        remark: string;
        /**
         * The policy group update timestamp.
         */
        updateTime: number;
        /**
         * Number of instances of policy group bindings.
         */
        useSum: number;
    }

    export interface GetPolicyGroupsListCondition {
        /**
         * Alarm sending cycle per second. `<0` does not fire, `0` only fires once, and `>0` fires every triggerTime second.
         */
        alarmNotifyPeriod: number;
        /**
         * Alarm sending convergence type. `0` continuous alarm, `1` index alarm.
         */
        alarmNotifyType: number;
        /**
         * Compare type, `1` means more than, `2`  means greater than or equal, `3` means less than, `4` means less than or equal to, `5` means equal, `6` means not equal, `7` means days rose, `8` means days fell, `9` means weeks rose, `10` means weeks fell, `11` means period rise, `12` means period fell.
         */
        calcType: number;
        /**
         * Threshold value.
         */
        calcValue: string;
        /**
         * How long does the triggering rule last (per second).
         */
        continueTime: number;
        /**
         * The ID of this metric.
         */
        metricId: number;
        /**
         * The name of this metric.
         */
        metricShowName: string;
        /**
         * The unit of this metric.
         */
        metricUnit: string;
        /**
         * Data aggregation cycle (unit second).
         */
        period: number;
        /**
         * Threshold rule ID.
         */
        ruleId: number;
    }

    export interface GetPolicyGroupsListEventCondition {
        /**
         * Alarm sending cycle per second. `<0` does not fire, `0` only fires once, and `>0` fires every triggerTime second.
         */
        alarmNotifyPeriod: number;
        /**
         * Alarm sending convergence type. `0` continuous alarm, `1` index alarm.
         */
        alarmNotifyType: number;
        /**
         * The ID of this event metric.
         */
        eventId: number;
        /**
         * The name of this event metric.
         */
        eventShowName: string;
        /**
         * Threshold rule ID.
         */
        ruleId: number;
    }

    export interface GetPolicyGroupsListReceiver {
        /**
         * End of alarm period. Meaning with `startTime`.
         */
        endTime: number;
        /**
         * Do need a telephone alarm contact prompt.You don't need 0, you need 1.
         */
        needSendNotice: number;
        /**
         * Method of warning notification.Optional `CALL`,`EMAIL`,`SITE`,`SMS`,`WECHAT`.
         */
        notifyWays: string[];
        /**
         * Telephone warning to individual interval (seconds).
         */
        personInterval: number;
        /**
         * Alert sending language.
         */
        receiveLanguage: string;
        /**
         * Alarm receive group ID list.
         */
        receiverGroupLists: number[];
        /**
         * Receive type. Optional 'group' or 'user'.
         */
        receiverType: string;
        /**
         * Alarm receiver ID list.
         */
        receiverUserLists: number[];
        /**
         * Restore notification mode. Optional "SMS".
         */
        recoverNotifies: string[];
        /**
         * Telephone alarm interval per round (seconds).
         */
        roundInterval: number;
        /**
         * Telephone alarm number.
         */
        roundNumber: number;
        /**
         * Telephone warning time.Option "OCCUR", "RECOVER".
         */
        sendFors: string[];
        /**
         * Alarm period start time.Range [0,86399], which removes the date after it is converted to Beijing time as a Unix timestamp, for example 7200 means '10:0:0'.
         */
        startTime: number;
        /**
         * The phone alerts the receiver uid.
         */
        uidLists: number[];
    }

    export interface GetProductEventDimension {
        /**
         * Instance dimension name, eg: `deviceWanIp` for internet ip.
         */
        name?: string;
        /**
         * Instance dimension value, eg: `119.119.119.119` for internet ip.
         */
        value?: string;
    }

    export interface GetProductEventList {
        /**
         * A list of addition message. Each element contains the following attributes:
         */
        additionMsgs: outputs.Monitor.GetProductEventListAdditionMsg[];
        /**
         * Dimensional composition of instance objects.
         */
        dimensions: outputs.Monitor.GetProductEventListDimension[];
        /**
         * Event chinese name.
         */
        eventCname: string;
        /**
         * Event english name.
         */
        eventEname: string;
        /**
         * Event ID.
         */
        eventId: number;
        /**
         * Event name filtering, such as `guestReboot` indicates that the machine restart.
         */
        eventName: string;
        /**
         * A list of group info. Each element contains the following attributes:
         */
        groupInfos: outputs.Monitor.GetProductEventListGroupInfo[];
        /**
         * Affect objects, such as `ins-19708ino`.
         */
        instanceId: string;
        /**
         * The name of this instance.
         */
        instanceName: string;
        /**
         * Alarm status configuration filter, 1means configured, 0(default) means not configured.
         */
        isAlarmConfig: number;
        /**
         * Product chinese name.
         */
        productCname: string;
        /**
         * Product english name.
         */
        productEname: string;
        /**
         * Product type filtering, such as `cvm` for cloud server.
         */
        productName: string;
        /**
         * Project ID filter.
         */
        projectId: string;
        /**
         * The region of this instance.
         */
        region: string;
        /**
         * Start timestamp for this query, eg:`1588230000`. Default start time is `now-3600`.
         */
        startTime: number;
        /**
         * Event status filter, value range `-`,`alarm`,`recover`, indicating recovered, unrecovered and stateless.
         */
        status: string;
        /**
         * Whether to support alarm.
         */
        supportAlarm: number;
        /**
         * Event type filtering, with value range `abnormal`,`statusChange`, indicating state change and abnormal events.
         */
        type: string;
        /**
         * The update timestamp of this event.
         */
        updateTime: number;
    }

    export interface GetProductEventListAdditionMsg {
        /**
         * The key of this dimension.
         */
        key: string;
        /**
         * Instance dimension name, eg: `deviceWanIp` for internet ip.
         */
        name: string;
        /**
         * Instance dimension value, eg: `119.119.119.119` for internet ip.
         */
        value: string;
    }

    export interface GetProductEventListDimension {
        /**
         * The key of this dimension.
         */
        key: string;
        /**
         * Instance dimension name, eg: `deviceWanIp` for internet ip.
         */
        name: string;
        /**
         * Instance dimension value, eg: `119.119.119.119` for internet ip.
         */
        value: string;
    }

    export interface GetProductEventListGroupInfo {
        /**
         * Policy group ID.
         */
        groupId: string;
        /**
         * Policy group name.
         */
        groupName: string;
    }

    export interface GetProductNamespaceList {
        /**
         * Namespace of each cloud product in monitor system.
         */
        namespace: string;
        /**
         * Chinese name of this product.
         */
        productChineseName: string;
        /**
         * English name of this product.
         */
        productName: string;
    }

    export interface GetStatisticDataCondition {
        /**
         * Dimension.
         */
        key: string;
        /**
         * Operator. Valid values: eq (equal to), ne (not equal to), in.
         */
        operator: string;
        /**
         * Dimension value. If Operator is eq or ne, only the first element will be used.
         */
        values: string[];
    }

    export interface GetStatisticDataData {
        /**
         * Metric name.
         */
        metricName: string;
        /**
         * Monitoring data point.
         */
        points: outputs.Monitor.GetStatisticDataDataPoint[];
    }

    export interface GetStatisticDataDataPoint {
        /**
         * Combination of instance object dimensions.
         */
        dimensions: outputs.Monitor.GetStatisticDataDataPointDimension[];
        /**
         * Data point list.
         */
        values: outputs.Monitor.GetStatisticDataDataPointValue[];
    }

    export interface GetStatisticDataDataPointDimension {
        /**
         * Instance dimension name.
         */
        name: string;
        /**
         * Instance dimension value.
         */
        value: string;
    }

    export interface GetStatisticDataDataPointValue {
        /**
         * Time point when this monitoring data point is generated.
         */
        timestamp: number;
        /**
         * Monitoring data point valueNote: this field may return null, indicating that no valid values can be obtained.
         */
        value: number;
    }

    export interface GetTmpRegionsRegionSet {
        /**
         * Region area.
         */
        area: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Region ID.
         */
        regionId: number;
        /**
         * Region name.
         */
        regionName: string;
        /**
         * Region pay mode.
         */
        regionPayMode: number;
        /**
         * Region short name.
         */
        regionShortName: string;
        /**
         * Region status (0-unavailable; 1-available).
         */
        regionState: number;
    }

    export interface GrafanaSsoAccountRole {
        /**
         * Grafana organization id string.
         */
        organization: string;
        /**
         * Grafana role, one of {Admin,Editor,Viewer}.
         */
        role: string;
    }

    export interface PolicyBindingObjectDimension {
        /**
         * Represents a collection of dimensions of an object instance, json format.eg:'{"unInstanceId":"ins-ot3cq4bi"}'.
         */
        dimensionsJson: string;
        /**
         * Object unique ID.
         */
        uniqueId: string;
    }

    export interface TmpAlertGroupCustomReceiver {
        /**
         * Time ranges which allow alert message send.
         */
        allowedTimeRanges?: outputs.Monitor.TmpAlertGroupCustomReceiverAllowedTimeRange[];
        /**
         * Only effect when alertmanager in user cluster, this cluster id.
         */
        clusterId?: string;
        /**
         * Only effect when alertmanager in user cluster, this cluster type (tke|eks|tdcc).
         */
        clusterType?: string;
        /**
         * Custom receiver type, webhook|alertmanager.
         */
        type?: string;
        /**
         * Custom receiver address, can be accessed by process in prometheus instance subnet.
         */
        url?: string;
    }

    export interface TmpAlertGroupCustomReceiverAllowedTimeRange {
        /**
         * Time range end, seconds since 0 o'clock.
         */
        end?: string;
        /**
         * Time range start, seconds since 0 o'clock.
         */
        start?: string;
    }

    export interface TmpAlertGroupRule {
        /**
         * Annotation of alert rule. `summary`, `description` is special annotation in prometheus, mapping `Alarm Object`, `Alarm Information` in alarm message.
         */
        annotations?: {[key: string]: any};
        /**
         * Rule alarm duration.
         */
        duration?: string;
        /**
         * Prometheus alert expression.
         */
        expr?: string;
        /**
         * Labels of alert rule.
         */
        labels?: {[key: string]: any};
        /**
         * Alert rule name.
         */
        ruleName?: string;
        /**
         * Rule state. `2`-enable, `3`-disable, default `2`.
         */
        state?: number;
    }

    export interface TmpAlertRuleAnnotation {
        /**
         * key.
         */
        key: string;
        /**
         * value.
         */
        value: string;
    }

    export interface TmpAlertRuleLabel {
        /**
         * key.
         */
        key: string;
        /**
         * value.
         */
        value: string;
    }

    export interface TmpTkeAlertPolicyAlertRule {
        /**
         * If the alarm policy is derived from the CRD resource definition of the user cluster, the ClusterId is the cluster ID to which it belongs.
         */
        clusterId?: string;
        /**
         * Alarm policy ID. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        id?: string;
        /**
         * Policy name.
         */
        name: string;
        /**
         * Alarm channels, which may be returned using null in the template.
         */
        notification?: outputs.Monitor.TmpTkeAlertPolicyAlertRuleNotification;
        /**
         * A list of rules.
         */
        rules: outputs.Monitor.TmpTkeAlertPolicyAlertRuleRule[];
        /**
         * If the alarm is sent from a template, the TemplateId is the template id.
         */
        templateId?: string;
        /**
         * Last modified time.
         */
        updatedAt?: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleNotification {
        /**
         * If Type is alertmanager, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved..
         */
        alertManager?: outputs.Monitor.TmpTkeAlertPolicyAlertRuleNotificationAlertManager;
        /**
         * Whether it is enabled.
         */
        enabled: boolean;
        /**
         * Alarm notification method. At present, there are SMS, EMAIL, CALL, WECHAT methods.
         */
        notifyWays?: string[];
        /**
         * Telephone alerts reach notifications.
         */
        phoneArriveNotice?: boolean;
        /**
         * Effective end timeTelephone alarm wheel interval. Units: Seconds.
         */
        phoneCircleInterval?: number;
        /**
         * PhoneCircleTimes.
         */
        phoneCircleTimes?: number;
        /**
         * Telephone alarm wheel intervals. Units: Seconds.
         */
        phoneInnerInterval?: number;
        /**
         * Telephone alarm sequence.
         */
        phoneNotifyOrders?: number[];
        /**
         * Alert Receiving Group (User Group).
         */
        receiverGroups?: string[];
        /**
         * Convergence time.
         */
        repeatInterval?: string;
        /**
         * Effective end time.
         */
        timeRangeEnd?: string;
        /**
         * The time from which it takes effect.
         */
        timeRangeStart?: string;
        /**
         * The channel type, which defaults to amp, supports the following `amp`, `webhook`, `alertmanager`.
         */
        type: string;
        /**
         * If Type is webhook, the field is required. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        webHook?: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleNotificationAlertManager {
        /**
         * The ID of the cluster where the alertmanager is deployed. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        clusterId?: string;
        /**
         * Alertmanager is deployed in the cluster type. Note: This field may return null, indicating that a valid value could not be retrieved.
         */
        clusterType?: string;
        /**
         * Alertmanager url.
         */
        url: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleRule {
        /**
         * Refer to annotations in prometheus rule.
         */
        annotations?: outputs.Monitor.TmpTkeAlertPolicyAlertRuleRuleAnnotation[];
        /**
         * A description of the rule.
         */
        describe?: string;
        /**
         * Time of duration.
         */
        for: string;
        /**
         * Extra labels.
         */
        labels: outputs.Monitor.TmpTkeAlertPolicyAlertRuleRuleLabel[];
        /**
         * Rule name.
         */
        name: string;
        /**
         * Prometheus statement.
         */
        rule: string;
        /**
         * Alarm rule status.
         */
        ruleState?: number;
        /**
         * Alert sending template.
         */
        template: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleRuleAnnotation {
        /**
         * Name of map.
         */
        name: string;
        /**
         * Value of map.
         */
        value: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleRuleLabel {
        /**
         * Name of map.
         */
        name: string;
        /**
         * Value of map.
         */
        value: string;
    }

    export interface TmpTkeClusterAgentAgents {
        /**
         * An id identify the cluster, like `cls-xxxxxx`.
         */
        clusterId: string;
        /**
         * the name of the cluster.
         */
        clusterName: string;
        /**
         * Type of cluster.
         */
        clusterType: string;
        /**
         * Whether to enable the public network CLB.
         */
        enableExternal: boolean;
        /**
         * All metrics collected by the cluster will carry these labels.
         */
        externalLabels?: outputs.Monitor.TmpTkeClusterAgentAgentsExternalLabel[];
        /**
         * Pod configuration for components deployed in the cluster.
         */
        inClusterPodConfig?: outputs.Monitor.TmpTkeClusterAgentAgentsInClusterPodConfig;
        /**
         * Whether to install the default collection configuration.
         */
        notInstallBasicScrape?: boolean;
        /**
         * Whether to collect indicators, true means drop all indicators, false means collect default indicators.
         */
        notScrape?: boolean;
        /**
         * Limitation of region.
         */
        region: string;
        /**
         * agent state, `normal`, `abnormal`.
         */
        status: string;
    }

    export interface TmpTkeClusterAgentAgentsExternalLabel {
        /**
         * Indicator name.
         */
        name: string;
        /**
         * Index value.
         */
        value?: string;
    }

    export interface TmpTkeClusterAgentAgentsInClusterPodConfig {
        /**
         * Whether to use HostNetWork.
         */
        hostNet: boolean;
        /**
         * Specify the pod to run the node.
         */
        nodeSelectors?: outputs.Monitor.TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelector[];
        /**
         * Tolerate Stain.
         */
        tolerations?: outputs.Monitor.TmpTkeClusterAgentAgentsInClusterPodConfigToleration[];
    }

    export interface TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelector {
        /**
         * The pod configuration name of the component deployed in the cluster.
         */
        name?: string;
        /**
         * Pod configuration values for components deployed in the cluster.
         */
        value?: string;
    }

    export interface TmpTkeClusterAgentAgentsInClusterPodConfigToleration {
        /**
         * blemish effect to match.
         */
        effect?: string;
        /**
         * The taint key to which the tolerance applies.
         */
        key?: string;
        /**
         * key-value relationship.
         */
        operator?: string;
    }

    export interface TmpTkeConfigPodMonitor {
        /**
         * Config.
         */
        config: string;
        /**
         * Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
         */
        name: string;
        /**
         * Used for output parameters, if the configuration comes from a template, it is the template id.
         */
        templateId?: string;
    }

    export interface TmpTkeConfigRawJob {
        /**
         * Config.
         */
        config: string;
        /**
         * Name.
         */
        name: string;
        /**
         * Used for output parameters, if the configuration comes from a template, it is the template id.
         */
        templateId?: string;
    }

    export interface TmpTkeConfigServiceMonitor {
        /**
         * Config.
         */
        config: string;
        /**
         * Name. The naming rule is: namespace/name. If you don't have any namespace, use the default namespace: kube-system, otherwise use the specified one.
         */
        name: string;
        /**
         * Used for output parameters, if the configuration comes from a template, it is the template id.
         */
        templateId?: string;
    }

    export interface TmpTkeGlobalNotificationNotification {
        /**
         * Alert manager, if Type is `alertmanager`, this field is required.
         */
        alertManagers?: outputs.Monitor.TmpTkeGlobalNotificationNotificationAlertManager[];
        /**
         * Alarm notification switch.
         */
        enabled: boolean;
        /**
         * Alarm notification method, Valid values: `SMS`, `EMAIL`, `CALL`, `WECHAT`.
         */
        notifyWays?: string[];
        /**
         * Phone Alarm Reach Notification, NotifyWay is `CALL`, and this parameter is used.
         */
        phoneArriveNotice?: boolean;
        /**
         * Telephone alarm off-wheel interval, NotifyWay is `CALL`, and this parameter is used.
         */
        phoneCircleInterval?: number;
        /**
         * Number of phone alerts (user group), NotifyWay is `CALL`, and this parameter is used.
         */
        phoneCircleTimes?: number;
        /**
         * Interval between telephone alarm rounds, NotifyWay is `CALL`, and this parameter is used.
         */
        phoneInnerInterval?: number;
        /**
         * Phone alert sequence, NotifyWay is `CALL`, and this parameter is used.
         */
        phoneNotifyOrders?: number[];
        /**
         * Alarm receiving group(user group).
         */
        receiverGroups?: string[];
        /**
         * Convergence time.
         */
        repeatInterval?: string;
        /**
         * Effective end time.
         */
        timeRangeEnd?: string;
        /**
         * Effective start time.
         */
        timeRangeStart?: string;
        /**
         * Alarm notification type, Valid values: `amp`, `webhook`, `alertmanager`.
         */
        type: string;
        /**
         * Web hook, if Type is `webhook`, this field is required.
         */
        webHook?: string;
    }

    export interface TmpTkeGlobalNotificationNotificationAlertManager {
        /**
         * Cluster id.
         */
        clusterId?: string;
        /**
         * Cluster type.
         */
        clusterType?: string;
        /**
         * Alert manager url.
         */
        url: string;
    }

    export interface TmpTkeTemplateAttachmentTargets {
        /**
         * ID of the cluster.
         */
        clusterId?: string;
        /**
         * Name the cluster.
         */
        clusterName?: string;
        /**
         * Cluster type.
         */
        clusterType?: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * Name of the prometheus instance.
         */
        instanceName?: string;
        /**
         * target area.
         */
        region: string;
        /**
         * Last sync template time.
         */
        syncTime?: string;
        /**
         * Template version currently in use.
         */
        version?: string;
    }

    export interface TmpTkeTemplateTemplate {
        /**
         * Template description.
         */
        describe: string;
        /**
         * Whether the system-supplied default template is used for outgoing references.
         */
        isDefault?: boolean;
        /**
         * Template dimensions, the following types are supported `instance` instance level, `cluster` cluster level.
         */
        level: string;
        /**
         * Template name.
         */
        name: string;
        /**
         * Effective when Level is a cluster, A list of PodMonitors rules in the template.
         */
        podMonitors: outputs.Monitor.TmpTkeTemplateTemplatePodMonitor[];
        /**
         * Effective when Level is a cluster, A list of RawJobs rules in the template.
         */
        rawJobs: outputs.Monitor.TmpTkeTemplateTemplateRawJob[];
        /**
         * Effective when Level is instance, A list of aggregation rules in the template.
         */
        recordRules: outputs.Monitor.TmpTkeTemplateTemplateRecordRule[];
        /**
         * Effective when Level is a cluster, A list of ServiceMonitor rules in the template.
         */
        serviceMonitors: outputs.Monitor.TmpTkeTemplateTemplateServiceMonitor[];
        /**
         * The ID of the template, which is used for the outgoing reference.
         */
        templateId?: string;
        /**
         * Last updated, for outgoing references.
         */
        updateTime?: string;
        /**
         * Whether the system-supplied default template is used for outgoing references.
         */
        version?: string;
    }

    export interface TmpTkeTemplateTemplatePodMonitor {
        /**
         * Config.
         */
        config: string;
        /**
         * Name.
         */
        name: string;
        /**
         * Used for the argument, if the configuration comes to the template, the template id.
         */
        templateId?: string;
    }

    export interface TmpTkeTemplateTemplateRawJob {
        /**
         * Config.
         */
        config: string;
        /**
         * Name.
         */
        name: string;
        /**
         * Used for the argument, if the configuration comes to the template, the template id.
         */
        templateId?: string;
    }

    export interface TmpTkeTemplateTemplateRecordRule {
        /**
         * Config.
         */
        config: string;
        /**
         * Name.
         */
        name: string;
        /**
         * Used for the argument, if the configuration comes to the template, the template id.
         */
        templateId?: string;
    }

    export interface TmpTkeTemplateTemplateServiceMonitor {
        /**
         * Config.
         */
        config: string;
        /**
         * Name.
         */
        name: string;
        /**
         * Used for the argument, if the configuration comes to the template, the template id.
         */
        templateId?: string;
    }

}

export namespace Mps {
    export interface AdaptiveDynamicStreamingTemplateStreamInfo {
        /**
         * Audio parameter information.
         */
        audio: outputs.Mps.AdaptiveDynamicStreamingTemplateStreamInfoAudio;
        /**
         * Whether to remove audio stream, value:0: reserved.1: remove.
         */
        removeAudio?: number;
        /**
         * Whether to remove video stream, value:0: reserved.1: remove.
         */
        removeVideo?: number;
        /**
         * Video parameter information.
         */
        video: outputs.Mps.AdaptiveDynamicStreamingTemplateStreamInfoVideo;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoAudio {
        /**
         * Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
         */
        audioChannel?: number;
        /**
         * Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
         */
        bitrate: number;
        /**
         * Encoding format of audio stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
         */
        codec: string;
        /**
         * Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
         */
        sampleRate: number;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoVideo {
        /**
         * Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
         */
        bitrate: number;
        /**
         * Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
         */
        codec: string;
        /**
         * Filling type, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling type:stretch: Stretching, stretching each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the video aspect ratio unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and use Gaussian blur for the rest of the edge.Default value: black.Note: Adaptive stream only supports stretch, black.
         */
        fillType?: string;
        /**
         * Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
         */
        fps: number;
        /**
         * The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
         */
        gop?: number;
        /**
         * The maximum value of the height (or short side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
         */
        height?: number;
        /**
         * Adaptive resolution, optional value:open: At this time, Width represents the long side of the video, Height represents the short side of the video.close: At this point, Width represents the width of the video, and Height represents the height of the video.Default value: open.Note: In adaptive mode, Width cannot be smaller than Height.
         */
        resolutionAdaptive?: string;
        /**
         * Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
         */
        vcrf?: number;
        /**
         * The maximum value of the width (or long side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
         */
        width?: number;
    }

    export interface AiAnalysisTemplateClassificationConfigure {
        /**
         * Ai classification task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface AiAnalysisTemplateCoverConfigure {
        /**
         * Ai cover task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface AiAnalysisTemplateFrameTagConfigure {
        /**
         * Ai frame tag task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface AiAnalysisTemplateTagConfigure {
        /**
         * Ai tag task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface AiRecognitionTemplateAsrFullTextConfigure {
        /**
         * Generated subtitle file format, if left blank or blank string means no subtitle file will be generated, optional value:vtt: Generate WebVTT subtitle files.
         */
        subtitleFormat?: string;
        /**
         * Asr full text recognition task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface AiRecognitionTemplateAsrWordsConfigure {
        /**
         * Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
         */
        labelSets?: string[];
        /**
         * Asr word recognition task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface AiRecognitionTemplateFaceConfigure {
        /**
         * Default face filter tag, specify the tag of the default face that needs to be returned. If not filled or empty, all default face results will be returned. Label optional value:entertainment, sport, politician.
         */
        defaultLibraryLabelSets?: string[];
        /**
         * Face library selection, optional value:Default, UserDefine, AllDefault value: All, use the system default face library and user-defined face library.
         */
        faceLibrary?: string;
        /**
         * Face recognition filter score, when the recognition result reaches the score above, the recognition result will be returned. The default is 95 points. Value range: 0 - 100.
         */
        score?: number;
        /**
         * Ai face recognition task switch, optional value:ON/OFF.
         */
        switch: string;
        /**
         * User-defined face filter tag, specify the tag of the user-defined face that needs to be returned. If not filled or empty, all custom face results will be returned.The maximum number of tags is 100, and the length of each tag is up to 16 characters.
         */
        userDefineLibraryLabelSets?: string[];
    }

    export interface AiRecognitionTemplateOcrFullTextConfigure {
        /**
         * Ocr full text recognition task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface AiRecognitionTemplateOcrWordsConfigure {
        /**
         * Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
         */
        labelSets?: string[];
        /**
         * Ocr words recognition task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplatePoliticalConfigure {
        /**
         * Political asr control parameters.
         */
        asrReviewInfo?: outputs.Mps.ContentReviewTemplatePoliticalConfigureAsrReviewInfo;
        /**
         * Political image control parameters.
         */
        imgReviewInfo?: outputs.Mps.ContentReviewTemplatePoliticalConfigureImgReviewInfo;
        /**
         * Political ocr control parameters.
         */
        ocrReviewInfo?: outputs.Mps.ContentReviewTemplatePoliticalConfigureOcrReviewInfo;
    }

    export interface ContentReviewTemplatePoliticalConfigureAsrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined asr review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplatePoliticalConfigureImgReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 90 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * Terrorism image filter tag, if the review result contains the selected tag, the result will be returned, if the filter tag is empty, all the review results will be returned, the optional value is:guns, crowd, bloody, police, banners, militant, explosion, terrorists, scenario.
         */
        labelSets?: string[];
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 80 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * Terrorism image task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplatePoliticalConfigureOcrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined ocr text review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplatePornConfigure {
        /**
         * Voice pornography control parameters.
         */
        asrReviewInfo?: outputs.Mps.ContentReviewTemplatePornConfigureAsrReviewInfo;
        /**
         * Porn image Identification Control Parameters.
         */
        imgReviewInfo?: outputs.Mps.ContentReviewTemplatePornConfigureImgReviewInfo;
        /**
         * Ocr pornography control parameters.
         */
        ocrReviewInfo?: outputs.Mps.ContentReviewTemplatePornConfigureOcrReviewInfo;
    }

    export interface ContentReviewTemplatePornConfigureAsrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined asr review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplatePornConfigureImgReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 90 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * Terrorism image filter tag, if the review result contains the selected tag, the result will be returned, if the filter tag is empty, all the review results will be returned, the optional value is:guns, crowd, bloody, police, banners, militant, explosion, terrorists, scenario.
         */
        labelSets?: string[];
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 80 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * Terrorism image task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplatePornConfigureOcrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined ocr text review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplateProhibitedConfigure {
        /**
         * Voice Prohibition Control Parameters.Note: This field may return null, indicating that no valid value can be obtained.
         */
        asrReviewInfo?: outputs.Mps.ContentReviewTemplateProhibitedConfigureAsrReviewInfo;
        /**
         * Ocr Prohibition Control Parameters.Note: This field may return null, indicating that no valid value can be obtained.
         */
        ocrReviewInfo?: outputs.Mps.ContentReviewTemplateProhibitedConfigureOcrReviewInfo;
    }

    export interface ContentReviewTemplateProhibitedConfigureAsrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined asr review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplateProhibitedConfigureOcrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined ocr text review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplateTerrorismConfigure {
        /**
         * Terrorism image task control parameters.
         */
        imgReviewInfo?: outputs.Mps.ContentReviewTemplateTerrorismConfigureImgReviewInfo;
        /**
         * Ocr terrorism task Control Parameters.
         */
        ocrReviewInfo: outputs.Mps.ContentReviewTemplateTerrorismConfigureOcrReviewInfo;
    }

    export interface ContentReviewTemplateTerrorismConfigureImgReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 90 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * Terrorism image filter tag, if the review result contains the selected tag, the result will be returned, if the filter tag is empty, all the review results will be returned, the optional value is:guns, crowd, bloody, police, banners, militant, explosion, terrorists, scenario.
         */
        labelSets?: string[];
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 80 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * Terrorism image task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplateTerrorismConfigureOcrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined ocr text review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplateUserDefineConfigure {
        /**
         * User-defined asr text review control parameters.
         */
        asrReviewInfo?: outputs.Mps.ContentReviewTemplateUserDefineConfigureAsrReviewInfo;
        /**
         * User-defined face review control parameters.
         */
        faceReviewInfo?: outputs.Mps.ContentReviewTemplateUserDefineConfigureFaceReviewInfo;
        /**
         * User-defined ocr text review control parameters.
         */
        ocrReviewInfo?: outputs.Mps.ContentReviewTemplateUserDefineConfigureOcrReviewInfo;
    }

    export interface ContentReviewTemplateUserDefineConfigureAsrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * User-defined asr tags, the review result contains the selected tag and returns the result, if the filter tag is empty, all review results are returned. If you want to use the tag filtering function, when adding a asr library, you need to add the corresponding character tag.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
         */
        labelSets?: string[];
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined asr review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplateUserDefineConfigureFaceReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * User-defined face review tags, the review result contains the selected tag and returns the result, if the filter tag is empty, all review results are returned. If you want to use the tag filtering function, when adding a face library, you need to add the corresponding character tag.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
         */
        labelSets?: string[];
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined face review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface ContentReviewTemplateUserDefineConfigureOcrReviewInfo {
        /**
         * The score threshold for judging suspected violations. When the smart review reaches the score above, it is considered suspected violations. If it is not filled, the default is 100 points. Value range: 0~100.
         */
        blockConfidence?: number;
        /**
         * User-defined ocr tags, the review result contains the selected tag and returns the result, if the filter tag is empty, all review results are returned. If you want to use the tag filtering function, when adding a ocr library, you need to add the corresponding character tag.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
         */
        labelSets?: string[];
        /**
         * The score threshold for judging whether manual review is required for violations. When the intelligent review reaches the score above, it is considered that manual review is required. If it is not filled, the default is 75 points. Value range: 0~100.
         */
        reviewConfidence?: number;
        /**
         * User-defined ocr text review task switch, optional value:ON/OFF.
         */
        switch: string;
    }

    export interface EditMediaOperationFileInfo {
        /**
         * End time offset of video clipping in seconds.
         */
        endTimeOffset?: number;
        /**
         * Video input information.
         */
        inputInfo: outputs.Mps.EditMediaOperationFileInfoInputInfo;
        /**
         * Start time offset of video clipping in seconds.
         */
        startTimeOffset?: number;
    }

    export interface EditMediaOperationFileInfoInputInfo {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.EditMediaOperationFileInfoInputInfoCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.EditMediaOperationFileInfoInputInfoS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.EditMediaOperationFileInfoInputInfoUrlInputInfo;
    }

    export interface EditMediaOperationFileInfoInputInfoCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface EditMediaOperationFileInfoInputInfoS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
    }

    export interface EditMediaOperationFileInfoInputInfoUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface EditMediaOperationOutputConfig {
        /**
         * Format. Valid values: `mp4` (default), `hls`, `mov`, `flv`, `avi`.
         */
        container?: string;
        /**
         * The editing mode. Valid values are `normal` and `fast`. The default is `normal`, which indicates precise editing.
         */
        type?: string;
    }

    export interface EditMediaOperationOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.EditMediaOperationOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.EditMediaOperationOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS. `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface EditMediaOperationOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface EditMediaOperationOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
    }

    export interface EditMediaOperationTaskNotifyConfig {
        /**
         * The AWS SQS queue. This parameter is required if `NotifyType` is `AWS-SQS`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsSqs?: outputs.Mps.EditMediaOperationTaskNotifyConfigAwsSqs;
        /**
         * The CMQ or TDMQ-CMQ model. Valid values: Queue, Topic.
         */
        cmqModel?: string;
        /**
         * The CMQ or TDMQ-CMQ region, such as `sh` (Shanghai) or `bj` (Beijing).
         */
        cmqRegion?: string;
        /**
         * Workflow notification method. Valid values: Finish, Change. If this parameter is left empty, `Finish` will be used.
         */
        notifyMode?: string;
        /**
         * The notification type. Valid values: `CMQ`: This value is no longer used. Please use `TDMQ-CMQ` instead. `TDMQ-CMQ`: Message queue. `URL`: If `NotifyType` is set to `URL`, HTTP callbacks are sent to the URL specified by `NotifyUrl`. HTTP and JSON are used for the callbacks. The packet contains the response parameters of the `ParseNotification` API. `SCF`: This notification type is not recommended. You need to configure it in the SCF console. `AWS-SQS`: AWS queue. This type is only supported for AWS tasks, and the queue must be in the same region as the AWS bucket. If you do not pass this parameter or pass in an empty string, `CMQ` will be used. To use a different notification type, specify this parameter accordingly.
         */
        notifyType?: string;
        /**
         * HTTP callback URL, required if `NotifyType` is set to `URL`.
         */
        notifyUrl?: string;
        /**
         * The CMQ or TDMQ-CMQ queue to receive notifications. This parameter is valid when `CmqModel` is `Queue`.
         */
        queueName?: string;
        /**
         * The CMQ or TDMQ-CMQ topic to receive notifications. This parameter is valid when `CmqModel` is `Topic`.
         */
        topicName?: string;
    }

    export interface EditMediaOperationTaskNotifyConfigAwsSqs {
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
        /**
         * The name of the SQS queue.
         */
        sqsQueueName: string;
        /**
         * The region of the SQS queue.
         */
        sqsRegion: string;
    }

    export interface FlowInputGroup {
        /**
         * The input IP whitelist, the format is CIDR.
         */
        allowIpLists?: string[];
        /**
         * Input description with a length of [0, 255].
         */
        description?: string;
        /**
         * The active/standby switch of the input, [OPEN|CLOSE] is optional, and the default is CLOSE.
         */
        failOver: string;
        /**
         * Input HLS_PULL configuration information.
         */
        hlsPullSettings: outputs.Mps.FlowInputGroupHlsPullSettings;
        /**
         * Input name, you can fill in uppercase and lowercase letters, numbers and underscores, and the length is [1, 32].
         */
        inputName: string;
        /**
         * Input protocol, optional [SRT|RTP|RTMP|RTMP_PULL].
         */
        protocol: string;
        /**
         * Delay broadcast smooth streaming configuration information.
         */
        resilientStream?: outputs.Mps.FlowInputGroupResilientStream;
        /**
         * Input RTMP_PULL configuration information.
         */
        rtmpPullSettings: outputs.Mps.FlowInputGroupRtmpPullSettings;
        /**
         * RTP configuration information.
         */
        rtpSettings: outputs.Mps.FlowInputGroupRtpSettings;
        /**
         * Input RTSP_PULL configuration information.
         */
        rtspPullSettings: outputs.Mps.FlowInputGroupRtspPullSettings;
        /**
         * The input SRT configuration information.
         */
        srtSettings: outputs.Mps.FlowInputGroupSrtSettings;
    }

    export interface FlowInputGroupHlsPullSettings {
        /**
         * There is only one origin address of the HLS origin station.
         */
        sourceAddresses: outputs.Mps.FlowInputGroupHlsPullSettingsSourceAddress[];
    }

    export interface FlowInputGroupHlsPullSettingsSourceAddress {
        /**
         * The URL address of the RTSP source site.
         */
        url: string;
    }

    export interface FlowInputGroupResilientStream {
        /**
         * Delay time, in seconds, currently supports a range of 10 to 300 seconds. Note: This field may return null, indicating that no valid value can be obtained.
         */
        bufferTime?: number;
        /**
         * Whether to enable the delayed broadcast smooth spit stream, true is enabled, false is not enabled, and the default is not enabled. Note: This field may return null, indicating that no valid value can be obtained.
         */
        enable?: boolean;
    }

    export interface FlowInputGroupRtmpPullSettings {
        /**
         * The source site address of the RTMP source site, there can only be one.
         */
        sourceAddresses: outputs.Mps.FlowInputGroupRtmpPullSettingsSourceAddress[];
    }

    export interface FlowInputGroupRtmpPullSettingsSourceAddress {
        /**
         * StreamKey information of the RTMP source site.
         */
        streamKey: string;
        /**
         * TcUrl address of the RTMP source server.
         */
        tcUrl: string;
    }

    export interface FlowInputGroupRtpSettings {
        /**
         * Defaults to none, optional values[none].
         */
        fec: string;
        /**
         * Idle timeout, the default is 5000, the unit is ms, and the range is [1000, 10000].
         */
        idleTimeout: number;
    }

    export interface FlowInputGroupRtspPullSettings {
        /**
         * The source site address of the RTSP source site, there can only be one.
         */
        sourceAddresses: outputs.Mps.FlowInputGroupRtspPullSettingsSourceAddress[];
    }

    export interface FlowInputGroupRtspPullSettingsSourceAddress {
        /**
         * The URL address of the RTSP source site.
         */
        url: string;
    }

    export interface FlowInputGroupSrtSettings {
        /**
         * Delay, default 0, unit ms, range [0, 3000].
         */
        latency: number;
        /**
         * SRT mode, optional [LISTENER|CALLER], default is LISTENER.
         */
        mode: string;
        /**
         * The decryption key, which is empty by default, means no encryption. Only ascii code values can be filled in, and the length is [10, 79].
         */
        passphrase: string;
        /**
         * Key length, default is 0, optional [0|16|24|32].
         */
        pbKeyLen: number;
        /**
         * Peer timeout, default is 5000, unit ms, range is [1000, 10000].
         */
        peerIdleTimeout: number;
        /**
         * Peer delay, the default is 0, the unit is ms, and the range is [0, 3000].
         */
        peerLatency: number;
        /**
         * Receiving delay, default is 120, unit ms, range is [0, 3000].
         */
        recvLatency: number;
        /**
         * SRT peer address, required when Mode is CALLER, and only 1 set can be filled in.
         */
        sourceAddresses?: outputs.Mps.FlowInputGroupSrtSettingsSourceAddress[];
        /**
         * Stream ID, optional uppercase and lowercase letters, numbers and special characters (.#!:&amp;,=_-), length 0~512. For specific format, please refer to:https://github.com/Haivision/srt/blob/master/docs/features/access-control.md#standard-keys.
         */
        streamId: string;
    }

    export interface FlowInputGroupSrtSettingsSourceAddress {
        /**
         * Peer IP.
         */
        ip: string;
        /**
         * Peer port.
         */
        port: number;
    }

    export interface GetMediaMetaDataInputInfo {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.GetMediaMetaDataInputInfoCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.GetMediaMetaDataInputInfoS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address.`URL`: A URL.`AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.GetMediaMetaDataInputInfoUrlInputInfo;
    }

    export interface GetMediaMetaDataInputInfoCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface GetMediaMetaDataInputInfoS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface GetMediaMetaDataInputInfoUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetMediaMetaDataMetaData {
        /**
         * Audio duration in seconds.Note: This field may return null, indicating that no valid values can be obtained.
         */
        audioDuration: number;
        /**
         * Audio stream information.Note: This field may return null, indicating that no valid values can be obtained.
         */
        audioStreamSets: outputs.Mps.GetMediaMetaDataMetaDataAudioStreamSet[];
        /**
         * Bitrate of a video stream in bps.Note: This field may return null, indicating that no valid values can be obtained.
         */
        bitrate: number;
        /**
         * Container, such as m4a and mp4.Note: This field may return null, indicating that no valid values can be obtained.
         */
        container: string;
        /**
         * Video duration in seconds.Note: This field may return null, indicating that no valid values can be obtained.
         */
        duration: number;
        /**
         * Height of a video stream in px.Note: This field may return null, indicating that no valid values can be obtained.
         */
        height: number;
        /**
         * Selected angle during video recording in degrees.Note: This field may return null, indicating that no valid values can be obtained.
         */
        rotate: number;
        /**
         * Size of an uploaded media file in bytes (which is the sum of size of m3u8 and ts files if the video is in HLS format).Note: This field may return null, indicating that no valid values can be obtained.
         */
        size: number;
        /**
         * Video duration in seconds.Note: This field may return null, indicating that no valid values can be obtained.
         */
        videoDuration: number;
        /**
         * Video stream information.Note: This field may return null, indicating that no valid values can be obtained.
         */
        videoStreamSets: outputs.Mps.GetMediaMetaDataMetaDataVideoStreamSet[];
        /**
         * Maximum value of the width of a video stream in px.Note: This field may return null, indicating that no valid values can be obtained.
         */
        width: number;
    }

    export interface GetMediaMetaDataMetaDataAudioStreamSet {
        /**
         * Bitrate of a video stream in bps.Note: This field may return null, indicating that no valid values can be obtained.
         */
        bitrate: number;
        /**
         * Number of sound channels, e.g., 2Note: this field may return `null`, indicating that no valid value was found.
         */
        channel: number;
        /**
         * Video stream codec, such as h264.Note: This field may return null, indicating that no valid values can be obtained.
         */
        codec: string;
        /**
         * Sample rate of an audio stream in Hz.Note: This field may return null, indicating that no valid values can be obtained.
         */
        samplingRate: number;
    }

    export interface GetMediaMetaDataMetaDataVideoStreamSet {
        /**
         * Bitrate of a video stream in bps.Note: This field may return null, indicating that no valid values can be obtained.
         */
        bitrate: number;
        /**
         * Video stream codec, such as h264.Note: This field may return null, indicating that no valid values can be obtained.
         */
        codec: string;
        /**
         * Color primariesNote: this field may return `null`, indicating that no valid value was found.
         */
        colorPrimaries: string;
        /**
         * Color spaceNote: this field may return `null`, indicating that no valid value was found.
         */
        colorSpace: string;
        /**
         * Color transferNote: this field may return `null`, indicating that no valid value was found.
         */
        colorTransfer: string;
        /**
         * Frame rate in Hz.Note: This field may return null, indicating that no valid values can be obtained.
         */
        fps: number;
        /**
         * HDR typeNote: This field may return `null`, indicating that no valid value was found.
         */
        hdrType: string;
        /**
         * Height of a video stream in px.Note: This field may return null, indicating that no valid values can be obtained.
         */
        height: number;
        /**
         * Maximum value of the width of a video stream in px.Note: This field may return null, indicating that no valid values can be obtained.
         */
        width: number;
    }

    export interface GetSchedulesScheduleInfoSet {
        /**
         * The subtasks of the scheme.Note: This field may return null, indicating that no valid values can be obtained.
         */
        activities: outputs.Mps.GetSchedulesScheduleInfoSetActivity[];
        /**
         * The creation time in [ISO date format](https://intl.cloud.tencent.com/document/product/862/37710?from_cn_redirect=1#52).Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * The directory to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputDir: string;
        /**
         * The bucket to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorages: outputs.Mps.GetSchedulesScheduleInfoSetOutputStorage[];
        /**
         * The resource ID. If there is no associated resource ID, fill it with the account's main resource ID.
         */
        resourceId: string;
        /**
         * The scheme ID.
         */
        scheduleId: number;
        /**
         * The scheme name.Note: This field may return null, indicating that no valid values can be obtained.
         */
        scheduleName: string;
        /**
         * The scheme status. Valid values:`Enabled`, `Disabled`. If you do not specify this parameter, all schemes will be returned regardless of the status.
         */
        status: string;
        /**
         * The notification configuration.Note: This field may return null, indicating that no valid values can be obtained.
         */
        taskNotifyConfigs: outputs.Mps.GetSchedulesScheduleInfoSetTaskNotifyConfig[];
        /**
         * The trigger of the scheme.Note: This field may return null, indicating that no valid values can be obtained.
         */
        triggers: outputs.Mps.GetSchedulesScheduleInfoSetTrigger[];
        /**
         * The last updated time in [ISO date format](https://intl.cloud.tencent.com/document/product/862/37710?from_cn_redirect=1#52).Note: This field may return null, indicating that no valid values can be obtained.
         */
        updateTime: string;
    }

    export interface GetSchedulesScheduleInfoSetActivity {
        /**
         * The parameters of a subtask.Note: This field may return null, indicating that no valid values can be obtained.
         */
        activityParas: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityPara[];
        /**
         * The subtask type.`input`: The start.`output`: The end.`action-trans`: Transcoding.`action-samplesnapshot`: Sampled screencapturing.`action-AIAnalysis`: Content analysis.`action-AIRecognition`: Content recognition.`action-aiReview`: Content moderation.`action-animated-graphics`: Animated screenshot generation.`action-image-sprite`: Image sprite generation.`action-snapshotByTimeOffset`: Time point screencapturing.`action-adaptive-substream`: Adaptive bitrate streaming.Note: This field may return null, indicating that no valid values can be obtained.
         */
        activityType: string;
        /**
         * The indexes of the subsequent actions.Note: This field may return null, indicating that no valid values can be obtained.
         */
        reardriveIndices: number[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityPara {
        /**
         * An adaptive bitrate streaming task.
         */
        adaptiveDynamicStreamingTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTask[];
        /**
         * A content analysis task.
         */
        aiAnalysisTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAiAnalysisTask[];
        /**
         * A content moderation task.
         */
        aiContentReviewTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAiContentReviewTask[];
        /**
         * A content recognition task.
         */
        aiRecognitionTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAiRecognitionTask[];
        /**
         * An animated screenshot generation task.
         */
        animatedGraphicTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTask[];
        /**
         * An image sprite generation task.
         */
        imageSpriteTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTask[];
        /**
         * A sampled screencapturing task.
         */
        sampleSnapshotTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTask[];
        /**
         * A time point screencapturing task.
         */
        snapshotByTimeOffsetTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTask[];
        /**
         * A transcoding task.
         */
        transcodeTasks: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTask[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTask {
        /**
         * The subtitle file to add.Note: This field may return null, indicating that no valid values can be obtained.
         */
        addOnSubtitles: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitle[];
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath: string;
        /**
         * The bucket to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorage[];
        /**
         * Path to an output file part (the path to ts during transcoding to HLS), which can only be a relative path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}_{number}.{format}`.
         */
        segmentObjectName: string;
        /**
         * The relative output path of the substream file after being transcoded to adaptive bitrate streaming. If this parameter is left empty, a relative path in the following format will be used by default: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
         */
        subStreamObjectName: string;
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSet[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitle {
        /**
         * The subtitle file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        subtitles: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitle[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitle {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageCosOutputStorage[];
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageS3OutputStorage[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageCosOutputStorage {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameters: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameter[];
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplate[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContents: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContent[];
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAiAnalysisTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * An extended parameter, whose value is a stringfied JSON.Note: This parameter is for customers with special requirements. It needs to be customized offline.Note: This field may return null, indicating that no valid values can be obtained.
         */
        extendedParameter: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAiContentReviewTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAiRecognitionTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath: string;
        /**
         * The bucket to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTaskOutputStorage[];
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset: number;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTaskOutputStorageCosOutputStorage[];
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTaskOutputStorageS3OutputStorage[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTaskOutputStorageCosOutputStorage {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaAnimatedGraphicTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * Rule of the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormats: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskObjectNumberFormat[];
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath: string;
        /**
         * The bucket to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskOutputStorage[];
        /**
         * Output path to the WebVTT file after an image sprite is generated, which can only be a relative path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_imageSprite_{definition}.{format}`.
         */
        webVttObjectName: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskOutputStorageCosOutputStorage[];
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskOutputStorageS3OutputStorage[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskOutputStorageCosOutputStorage {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaImageSpriteTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * Rule of the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormats: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskObjectNumberFormat[];
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath: string;
        /**
         * The bucket to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskOutputStorage[];
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSet[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskOutputStorageCosOutputStorage[];
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskOutputStorageS3OutputStorage[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskOutputStorageCosOutputStorage {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameters: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameter[];
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplate[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContents: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContent[];
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * List of screenshot time points in the format of `s` or `%`:If the string ends in `s`, it means that the time point is in seconds; for example, `3.5s` means that the time point is the 3.5th second;If the string ends in `%`, it means that the time point is the specified percentage of the video duration; for example, `10%` means that the time point is 10% of the video duration.
         */
        extTimeOffsetSets: string[];
        /**
         * Rule of the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormats: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskObjectNumberFormat[];
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath: string;
        /**
         * The bucket to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskOutputStorage[];
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSet[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageCosOutputStorage[];
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageS3OutputStorage[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageCosOutputStorage {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameters: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameter[];
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplate[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContents: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContent[];
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTask {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Opening and closing credits parametersNote: this field may return `null`, indicating that no valid value was found.
         */
        headTailParameters: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameter[];
        /**
         * List of blurs. Up to 10 ones can be supported.
         */
        mosaicSets: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskMosaicSet[];
        /**
         * Rule of the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormats: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskObjectNumberFormat[];
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath: string;
        /**
         * The bucket to save the output file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOutputStorage[];
        /**
         * Video transcoding custom parameter, which is valid when `Definition` is not 0.When any parameters in this structure are entered, they will be used to override corresponding parameters in templates.This parameter is used in highly customized scenarios. We recommend you only use `Definition` to specify the transcoding parameter.Note: this field may return `null`, indicating that no valid value was found.
         */
        overrideParameters: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameter[];
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameters: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameter[];
        /**
         * Path to an output file part (the path to ts during transcoding to HLS), which can only be a relative path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}_{number}.{format}`.
         */
        segmentObjectName: string;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSet[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameter {
        /**
         * Opening credits list.
         */
        headSets: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSet[];
        /**
         * Closing credits list.
         */
        tailSets: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSet[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSet {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSetCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSetS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSetUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSetCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSetS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterHeadSetUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSet {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSetCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSetS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSetUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSetCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSetS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskHeadTailParameterTailSetUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskMosaicSet {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin: string;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: string;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOutputStorageCosOutputStorage[];
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOutputStorageS3OutputStorage[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOutputStorageCosOutputStorage {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameter {
        /**
         * The subtitle file to add.Note: This field may return null, indicating that no valid values can be obtained.
         */
        addOnSubtitles: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitle[];
        /**
         * The information of the external audio track to add.Note: This field may return null, indicating that no valid values can be obtained.
         */
        addonAudioStreams: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStream[];
        /**
         * Audio stream configuration parameter. This field is required when `RemoveAudio` is 0.
         */
        audioTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAudioTemplate[];
        /**
         * Container. Valid values: mp4; flv; hls; mp3; flac; ogg; m4a. Among them, mp3, flac, ogg, and m4a are for audio files.
         */
        container: string;
        /**
         * Whether to remove audio data. Valid values:0: retain;1: remove.Default value: 0.
         */
        removeAudio: number;
        /**
         * Whether to remove video data. Valid values:0: retain;1: remove.Default value: 0.
         */
        removeVideo: number;
        /**
         * An extended field for transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        stdExtInfo: string;
        /**
         * The subtitle settings.Note: This field may return null, indicating that no valid values can be obtained.
         */
        subtitleTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterSubtitleTemplate[];
        /**
         * TESHD transcoding parameter.
         */
        tehdConfigs: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterTehdConfig[];
        /**
         * Video stream configuration parameter. This field is required when `RemoveVideo` is 0.
         */
        videoTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterVideoTemplate[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitle {
        /**
         * The subtitle file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        subtitles: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitle[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitle {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStream {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterAudioTemplate {
        /**
         * Audio channel system. Valid values:1: Mono2: Dual6: StereoWhen the media is packaged in audio format (FLAC, OGG, MP3, M4A), the sound channel cannot be set to stereo.Default value: 2.
         */
        audioChannel: number;
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values:`libx264`: H.264`libx265`: H.265`av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec: string;
        /**
         * Audio stream sample rate. Valid values:32,00044,10048,000In Hz.
         */
        sampleRate: number;
        /**
         * The audio tracks to retain. All audio tracks are retained by default.
         */
        streamSelects: number[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterSubtitleTemplate {
        /**
         * The text transparency. Value range: 0-1.`0`: Fully transparent.`1`: Fully opaque.Default value: 1.Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontAlpha: number;
        /**
         * The font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontColor: string;
        /**
         * The font size (pixels). If this is not specified, the font size in the subtitle file will be used.Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontSize: string;
        /**
         * The font. Valid values:`hei.ttf`: Heiti.`song.ttf`: Songti.`simkai.ttf`: Kaiti.`arial.ttf`: Arial.The default is `hei.ttf`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontType: string;
        /**
         * The URL of the subtitles to add to the video.Note: This field may return null, indicating that no valid values can be obtained.
         */
        path: string;
        /**
         * The subtitle track to add to the video. If both `Path` and `StreamIndex` are specified, `Path` will be used. You need to specify at least one of the two parameters.Note: This field may return null, indicating that no valid values can be obtained.
         */
        streamIndex: number;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterTehdConfig {
        /**
         * Maximum bitrate, which is valid when `Type` is `TESHD`. If this parameter is left empty or 0 is entered, there will be no upper limit for bitrate.
         */
        maxVideoBitrate: number;
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskOverrideParameterVideoTemplate {
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values:`libx264`: H.264`libx265`: H.265`av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec: string;
        /**
         * Whether to enable adaptive encoding. Valid values:0: Disable1: EnableDefault value: 0. If this parameter is set to `1`, multiple streams with different resolutions and bitrates will be generated automatically. The highest resolution, bitrate, and quality of the streams are determined by the values of `width` and `height`, `Bitrate`, and `Vcrf` in `VideoTemplate` respectively. If these parameters are not set in `VideoTemplate`, the highest resolution generated will be the same as that of the source video, and the highest video quality will be close to VMAF 95. To use this parameter or learn about the billing details of adaptive encoding, please contact your sales rep.
         */
        contentAdaptStream: number;
        /**
         * The fill mode, which indicates how a video is resized when the video&#39;s original aspect ratio is different from the target aspect ratio. Valid values:stretch: Stretch the image frame by frame to fill the entire screen. The video image may become squashed or stretched after transcoding.black: Keep the image&#39;s original aspect ratio and fill the blank space with black bars.white: Keep the image&#39;s original aspect ratio and fill the blank space with white bars.gauss: Keep the image&#39;s original aspect ratio and apply Gaussian blur to the blank space.Default value: black.Note: Only `stretch` and `black` are supported for adaptive bitrate streaming.
         */
        fillType: string;
        /**
         * The video frame rate (Hz). Value range: [0, 100].If the value is 0, the frame rate will be the same as that of the source video.Note: For adaptive bitrate streaming, the value range of this parameter is [0, 60].
         */
        fps: number;
        /**
         * Frame interval between I keyframes. Value range: 0 and [1,100000].If this parameter is 0 or left empty, the system will automatically set the GOP length.
         */
        gop: number;
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: number;
        /**
         * Resolution adaption. Valid values:open: Enabled. When resolution adaption is enabled, `Width` indicates the long side of a video, while `Height` indicates the short side.close: Disabled. When resolution adaption is disabled, `Width` indicates the width of a video, while `Height` indicates the height.Default value: open.Note: When resolution adaption is enabled, `Width` cannot be smaller than `Height`.
         */
        resolutionAdaptive: string;
        /**
         * The control factor of video constant bitrate. Value range: [1, 51]If this parameter is specified, CRF (a bitrate control method) will be used for transcoding. (Video bitrate will no longer take effect.)It is not recommended to specify this parameter if there are no special requirements.
         */
        vcrf: number;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width: number;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameter {
        /**
         * Audio stream configuration parameter. This field is required when `RemoveAudio` is 0.
         */
        audioTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameterAudioTemplate[];
        /**
         * Container. Valid values: mp4; flv; hls; mp3; flac; ogg; m4a. Among them, mp3, flac, ogg, and m4a are for audio files.
         */
        container: string;
        /**
         * Whether to remove audio data. Valid values:0: retain;1: remove.Default value: 0.
         */
        removeAudio: number;
        /**
         * Whether to remove video data. Valid values:0: retain;1: remove.Default value: 0.
         */
        removeVideo: number;
        /**
         * TESHD transcoding parameter.
         */
        tehdConfigs: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameterTehdConfig[];
        /**
         * Video stream configuration parameter. This field is required when `RemoveVideo` is 0.
         */
        videoTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameterVideoTemplate[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameterAudioTemplate {
        /**
         * Audio channel system. Valid values:1: Mono2: Dual6: StereoWhen the media is packaged in audio format (FLAC, OGG, MP3, M4A), the sound channel cannot be set to stereo.Default value: 2.
         */
        audioChannel: number;
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values:`libx264`: H.264`libx265`: H.265`av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec: string;
        /**
         * Audio stream sample rate. Valid values:32,00044,10048,000In Hz.
         */
        sampleRate: number;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameterTehdConfig {
        /**
         * Maximum bitrate, which is valid when `Type` is `TESHD`. If this parameter is left empty or 0 is entered, there will be no upper limit for bitrate.
         */
        maxVideoBitrate: number;
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskRawParameterVideoTemplate {
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values:`libx264`: H.264`libx265`: H.265`av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec: string;
        /**
         * The fill mode, which indicates how a video is resized when the video&#39;s original aspect ratio is different from the target aspect ratio. Valid values:stretch: Stretch the image frame by frame to fill the entire screen. The video image may become squashed or stretched after transcoding.black: Keep the image&#39;s original aspect ratio and fill the blank space with black bars.white: Keep the image&#39;s original aspect ratio and fill the blank space with white bars.gauss: Keep the image&#39;s original aspect ratio and apply Gaussian blur to the blank space.Default value: black.Note: Only `stretch` and `black` are supported for adaptive bitrate streaming.
         */
        fillType: string;
        /**
         * The video frame rate (Hz). Value range: [0, 100].If the value is 0, the frame rate will be the same as that of the source video.Note: For adaptive bitrate streaming, the value range of this parameter is [0, 60].
         */
        fps: number;
        /**
         * Frame interval between I keyframes. Value range: 0 and [1,100000].If this parameter is 0 or left empty, the system will automatically set the GOP length.
         */
        gop: number;
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: number;
        /**
         * Resolution adaption. Valid values:open: Enabled. When resolution adaption is enabled, `Width` indicates the long side of a video, while `Height` indicates the short side.close: Disabled. When resolution adaption is disabled, `Width` indicates the width of a video, while `Height` indicates the height.Default value: open.Note: When resolution adaption is enabled, `Width` cannot be smaller than `Height`.
         */
        resolutionAdaptive: string;
        /**
         * The control factor of video constant bitrate. Value range: [1, 51]If this parameter is specified, CRF (a bitrate control method) will be used for transcoding. (Video bitrate will no longer take effect.)It is not recommended to specify this parameter if there are no special requirements.
         */
        vcrf: number;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width: number;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameters: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameter[];
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplates: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplate[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContents: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContent[];
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo[];
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfos: outputs.Mps.GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo[];
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface GetSchedulesScheduleInfoSetOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetOutputStorageCosOutputStorage[];
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorages: outputs.Mps.GetSchedulesScheduleInfoSetOutputStorageS3OutputStorage[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetOutputStorageCosOutputStorage {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetSchedulesScheduleInfoSetOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetTaskNotifyConfig {
        /**
         * The SQS queue of the AWS S3 bucket.Note: The queue must be in the same region as the bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsSqs: outputs.Mps.GetSchedulesScheduleInfoSetTaskNotifyConfigAwsSq[];
        /**
         * The CMQ or TDMQ-CMQ model. Valid values: Queue, Topic.
         */
        cmqModel: string;
        /**
         * The CMQ or TDMQ-CMQ region, such as `sh` (Shanghai) or `bj` (Beijing).
         */
        cmqRegion: string;
        /**
         * Workflow notification method. Valid values: Finish, Change. If this parameter is left empty, `Finish` will be used.
         */
        notifyMode: string;
        /**
         * The notification type. Valid values:`CMQ`: This value is no longer used. Please use `TDMQ-CMQ` instead.`TDMQ-CMQ`: Message queue`URL`: If `NotifyType` is set to `URL`, HTTP callbacks are sent to the URL specified by `NotifyUrl`. HTTP and JSON are used for the callbacks. The packet contains the response parameters of the `ParseNotification` API.`SCF`: This notification type is not recommended. You need to configure it in the SCF console.`AWS-SQS`: AWS queue. This type is only supported for AWS tasks, and the queue must be in the same region as the AWS bucket.Note: If you do not pass this parameter or pass in an empty string, `CMQ` will be used. To use a different notification type, specify this parameter accordingly.
         */
        notifyType: string;
        /**
         * HTTP callback URL, required if `NotifyType` is set to `URL`.
         */
        notifyUrl: string;
        /**
         * The CMQ or TDMQ-CMQ queue to receive notifications. This parameter is valid when `CmqModel` is `Queue`.
         */
        queueName: string;
        /**
         * The CMQ or TDMQ-CMQ topic to receive notifications. This parameter is valid when `CmqModel` is `Topic`.
         */
        topicName: string;
    }

    export interface GetSchedulesScheduleInfoSetTaskNotifyConfigAwsSq {
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
        /**
         * The name of the SQS queue.
         */
        sqsQueueName: string;
        /**
         * The region of the SQS queue.
         */
        sqsRegion: string;
    }

    export interface GetSchedulesScheduleInfoSetTrigger {
        /**
         * The AWS S3 trigger. This parameter is valid and required if `Type` is `AwsS3FileUpload`.Note: Currently, the key for the AWS S3 bucket, the trigger SQS queue, and the callback SQS queue must be the same.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsS3FileUploadTriggers: outputs.Mps.GetSchedulesScheduleInfoSetTriggerAwsS3FileUploadTrigger[];
        /**
         * This parameter is required and valid when `Type` is `CosFileUpload`, indicating the COS trigger rule.Note: This field may return null, indicating that no valid values can be obtained.
         */
        cosFileUploadTriggers: outputs.Mps.GetSchedulesScheduleInfoSetTriggerCosFileUploadTrigger[];
        /**
         * The trigger type. Valid values:`CosFileUpload`: Tencent Cloud COS trigger.`AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface GetSchedulesScheduleInfoSetTriggerAwsS3FileUploadTrigger {
        /**
         * The SQS queue of the AWS S3 bucket.Note: The queue must be in the same region as the bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsSqs: outputs.Mps.GetSchedulesScheduleInfoSetTriggerAwsS3FileUploadTriggerAwsSq[];
        /**
         * Input path directory bound to a workflow, such as `/movie/201907/`. If this parameter is left empty, the `/` root directory will be used.
         */
        dir: string;
        /**
         * Format list of files that can trigger a workflow, such as [mp4, flv, mov]. If this parameter is left empty, files in all formats can trigger the workflow.
         */
        formats: string[];
        /**
         * The AWS S3 bucket bound to the scheme.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
    }

    export interface GetSchedulesScheduleInfoSetTriggerAwsS3FileUploadTriggerAwsSq {
        /**
         * The key ID of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretId: string;
        /**
         * The key of the AWS S3 bucket.Note: This field may return null, indicating that no valid values can be obtained.
         */
        s3SecretKey: string;
        /**
         * The name of the SQS queue.
         */
        sqsQueueName: string;
        /**
         * The region of the SQS queue.
         */
        sqsRegion: string;
    }

    export interface GetSchedulesScheduleInfoSetTriggerCosFileUploadTrigger {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Input path directory bound to a workflow, such as `/movie/201907/`. If this parameter is left empty, the `/` root directory will be used.
         */
        dir: string;
        /**
         * Format list of files that can trigger a workflow, such as [mp4, flv, mov]. If this parameter is left empty, files in all formats can trigger the workflow.
         */
        formats: string[];
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface GetTasksTaskSet {
        /**
         * Begin process time, in ISO date format. Refer to https://cloud.tencent.com/document/product/862/37710#52. If the task has not started yet, this field is: 0000-00-00T00:00:00Z.
         */
        beginProcessTime: string;
        /**
         * Creation time, in ISO date format. Refer to https://cloud.tencent.com/document/product/862/37710#52.
         */
        createTime: string;
        /**
         * Task finish time, in ISO date format. Refer to https://cloud.tencent.com/document/product/862/37710#52. If the task has not been completed, this field is: 0000-00-00T00:00:00Z.
         */
        finishTime: string;
        /**
         * Sub task types.
         */
        subTaskTypes: string[];
        /**
         * Task ID.
         */
        taskId: string;
        /**
         * Task type, including:WorkflowTask, EditMediaTask, LiveProcessTask.
         */
        taskType: string;
    }

    export interface InputInputGroup {
        /**
         * The input IP whitelist, the format is CIDR.
         */
        allowIpLists: string[];
        /**
         * The input description with a length of [0, 255].
         */
        description?: string;
        /**
         * The active/standby switch of the input, [OPEN|CLOSE] is optional, and the default is CLOSE.
         */
        failOver: string;
        /**
         * Input HLS_PULL configuration information.
         */
        hlsPullSettings: outputs.Mps.InputInputGroupHlsPullSettings;
        /**
         * The input name, you can fill in uppercase and lowercase letters, numbers and underscores, and the length is [1, 32].
         */
        inputName: string;
        /**
         * Input protocol, optional [SRT|RTP|RTMP|RTMP_PULL].
         */
        protocol: string;
        /**
         * Delay broadcast smooth streaming configuration information.
         */
        resilientStream?: outputs.Mps.InputInputGroupResilientStream;
        /**
         * Input RTMP_PULL configuration information.
         */
        rtmpPullSettings: outputs.Mps.InputInputGroupRtmpPullSettings;
        /**
         * Input RTP configuration information.
         */
        rtpSettings: outputs.Mps.InputInputGroupRtpSettings;
        /**
         * Input RTSP_PULL configuration information.
         */
        rtspPullSettings: outputs.Mps.InputInputGroupRtspPullSettings;
        /**
         * The input SRT configuration information.
         */
        srtSettings: outputs.Mps.InputInputGroupSrtSettings;
    }

    export interface InputInputGroupHlsPullSettings {
        /**
         * There is only one origin address of the HLS origin station.
         */
        sourceAddresses: outputs.Mps.InputInputGroupHlsPullSettingsSourceAddress[];
    }

    export interface InputInputGroupHlsPullSettingsSourceAddress {
        /**
         * The URL address of the RTSP source site.
         */
        url: string;
    }

    export interface InputInputGroupResilientStream {
        /**
         * Delay time, in seconds, currently supports a range of 10 to 300 seconds. Note: This field may return null, indicating that no valid value can be obtained.
         */
        bufferTime?: number;
        /**
         * Whether to enable the delayed broadcast smooth spit stream, true is enabled, false is not enabled, and the default is not enabled. Note: This field may return null, indicating that no valid value can be obtained.
         */
        enable?: boolean;
    }

    export interface InputInputGroupRtmpPullSettings {
        /**
         * The source site address of the RTMP source site, there can only be one.
         */
        sourceAddresses: outputs.Mps.InputInputGroupRtmpPullSettingsSourceAddress[];
    }

    export interface InputInputGroupRtmpPullSettingsSourceAddress {
        /**
         * StreamKey information of the RTMP source site.
         */
        streamKey: string;
        /**
         * TcUrl address of the RTMP source server.
         */
        tcUrl: string;
    }

    export interface InputInputGroupRtpSettings {
        /**
         * Defaults to &#39;none&#39;, optional values[&#39;none&#39;].
         */
        fec: string;
        /**
         * Idle timeout, the default is 5000, the unit is ms, and the range is [1000, 10000].
         */
        idleTimeout: number;
    }

    export interface InputInputGroupRtspPullSettings {
        /**
         * The source site address of the RTSP source site, there can only be one.
         */
        sourceAddresses: outputs.Mps.InputInputGroupRtspPullSettingsSourceAddress[];
    }

    export interface InputInputGroupRtspPullSettingsSourceAddress {
        /**
         * The URL address of the RTSP source site.
         */
        url: string;
    }

    export interface InputInputGroupSrtSettings {
        /**
         * Delay, default 0, unit ms, range [0, 3000].
         */
        latency: number;
        /**
         * SRT mode, optional [LISTENER|CALLER], default is LISTENER.
         */
        mode: string;
        /**
         * The decryption key, which is empty by default, means no encryption. Only ascii code values can be filled in, and the length is [10, 79].
         */
        passphrase: string;
        /**
         * Key length, default is 0, optional [0|16|24|32].
         */
        pbKeyLen: number;
        /**
         * Peer timeout, default is 5000, unit ms, range is [1000, 10000].
         */
        peerIdleTimeout: number;
        /**
         * Peer delay, the default is 0, the unit is ms, and the range is [0, 3000].
         */
        peerLatency: number;
        /**
         * Receiving delay, default is 120, unit ms, range is [0, 3000].
         */
        recvLatency: number;
        /**
         * SRT peer address, required when Mode is CALLER, and only 1 set can be filled in.
         */
        sourceAddresses?: outputs.Mps.InputInputGroupSrtSettingsSourceAddress[];
        /**
         * Stream ID, optional uppercase and lowercase letters, numbers and special characters (.#!:&amp;,=_-), length 0~512. Specific format can refer to:https://github.com/Haivision/srt/blob/master/docs/features/access-control.md#standard-keys.
         */
        streamId: string;
    }

    export interface InputInputGroupSrtSettingsSourceAddress {
        /**
         * Peer IP.
         */
        ip: string;
        /**
         * Peer port.
         */
        port: number;
    }

    export interface OutputOutput {
        /**
         * IP whitelist list, the format is CIDR, such as 0.0.0.0/0. When the Protocol is RTMP_PULL, it is valid, and if it is empty, it means that the client IP is not limited.
         */
        allowIpLists: string[];
        /**
         * Output description.
         */
        description: string;
        /**
         * The maximum number of concurrent pull streams, the maximum is 4, and the default is 4. Only SRT or RTMP_PULL can set this parameter.
         */
        maxConcurrent?: number;
        /**
         * The name of the output.
         */
        outputName: string;
        /**
         * Output region.
         */
        outputRegion: string;
        /**
         * Output protocol, optional [SRT|RTP|RTMP|RTMP_PULL].
         */
        protocol: string;
        /**
         * Output RTMP configuration.
         */
        rtmpSettings: outputs.Mps.OutputOutputRtmpSettings;
        /**
         * Output RTP configuration.
         */
        rtpSettings?: outputs.Mps.OutputOutputRtpSettings;
        /**
         * configuration of the output SRT.
         */
        srtSettings: outputs.Mps.OutputOutputSrtSettings;
    }

    export interface OutputOutputRtmpSettings {
        /**
         * RTMP Chunk size, range is [4096, 40960].
         */
        chunkSize?: number;
        /**
         * The target address of the relay can be filled in 1~2.
         */
        destinations: outputs.Mps.OutputOutputRtmpSettingsDestination[];
    }

    export interface OutputOutputRtmpSettingsDestination {
        /**
         * relayed StreamKey, in the format: stream?key=value.
         */
        streamKey: string;
        /**
         * relayed URL, the format is: rtmp://domain/live.
         */
        url: string;
    }

    export interface OutputOutputRtpSettings {
        /**
         * The target address of the relay can be filled in 1~2.
         */
        destinations: outputs.Mps.OutputOutputRtpSettingsDestination[];
        /**
         * You can only fill in none.
         */
        fec: string;
        /**
         * Idle timeout, unit ms.
         */
        idleTimeout: number;
    }

    export interface OutputOutputRtpSettingsDestination {
        /**
         * Output IP.
         */
        ip: string;
        /**
         * output port.
         */
        port: number;
    }

    export interface OutputOutputSrtSettings {
        /**
         * The target address of the relay is required when Mode is CALLER, and only one group can be filled in.
         */
        destinations: outputs.Mps.OutputOutputSrtSettingsDestination[];
        /**
         * The total delay of relaying SRT, the default is 0, the unit is ms, and the range is [0, 3000].
         */
        latency: number;
        /**
         * SRT mode, optional [LISTENER|CALLER], default is CALLER.
         */
        mode: string;
        /**
         * The encryption key for relaying SRT, which is empty by default, indicating no encryption. Only ascii code values can be filled in, and the length is [10, 79].
         */
        passphrase: string;
        /**
         * The key length of relay SRT, the default is 0, optional [0|16|24|32].
         */
        pbKeyLen: number;
        /**
         * The peer idle timeout for relaying SRT, the default is 5000, the unit is ms, and the range is [1000, 10000].
         */
        peerIdleTimeout: number;
        /**
         * The peer delay of relaying SRT, the default is 0, the unit is ms, and the range is [0, 3000].
         */
        peerLatency: number;
        /**
         * The reception delay of relay SRT, the default is 120, the unit is ms, the range is [0, 3000].
         */
        recvLatency: number;
        /**
         * relay the stream ID of SRT. You can choose uppercase and lowercase letters, numbers and special characters (.#!:&amp;,=_-). The length is 0~512.
         */
        streamId?: string;
    }

    export interface OutputOutputSrtSettingsDestination {
        /**
         * Output IP.
         */
        ip: string;
        /**
         * output port.
         */
        port: number;
    }

    export interface ProcessLiveStreamOperationAiAnalysisTask {
        /**
         * Video content analysis template ID.
         */
        definition: number;
        /**
         * An extended parameter, whose value is a stringfied JSON.Note: This parameter is for customers with special requirements. It needs to be customized offline.Note: This field may return null, indicating that no valid values can be obtained.
         */
        extendedParameter?: string;
    }

    export interface ProcessLiveStreamOperationAiContentReviewTask {
        /**
         * Video content audit template ID.
         */
        definition: number;
    }

    export interface ProcessLiveStreamOperationAiQualityControlTask {
        /**
         * The channel extension parameter, which is a serialized JSON string.Note: This field may return null, indicating that no valid values can be obtained.
         */
        channelExtPara?: string;
        /**
         * The ID of the quality control template.Note: This field may return null, indicating that no valid values can be obtained.
         */
        definition?: number;
    }

    export interface ProcessLiveStreamOperationAiRecognitionTask {
        /**
         * Intelligent video recognition template ID.
         */
        definition: number;
    }

    export interface ProcessLiveStreamOperationOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessLiveStreamOperationOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessLiveStreamOperationOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS.`AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessLiveStreamOperationOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessLiveStreamOperationOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to upload files to the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to upload files to the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessLiveStreamOperationTaskNotifyConfig {
        /**
         * CMQ model. There are two types: `Queue` and `Topic`. Currently, only `Queue` is supported.
         */
        cmqModel?: string;
        /**
         * CMQ region, such as `sh` and `bj`.
         */
        cmqRegion?: string;
        /**
         * The notification type, `CMQ` by default. If this parameter is set to `URL`, HTTP callbacks are sent to the URL specified by `NotifyUrl`.Note: If you do not pass this parameter or pass in an empty string, `CMQ` will be used. To use a different notification type, specify this parameter accordingly.
         */
        notifyType?: string;
        /**
         * HTTP callback URL, required if `NotifyType` is set to `URL`.
         */
        notifyUrl?: string;
        /**
         * This parameter is valid when the model is `Queue`, indicating the name of the CMQ queue for receiving event notifications.
         */
        queueName?: string;
        /**
         * This parameter is valid when the model is `Topic`, indicating the name of the CMQ topic for receiving event notifications.
         */
        topicName?: string;
    }

    export interface ProcessMediaOperationAiAnalysisTask {
        /**
         * Video content analysis template ID.
         */
        definition: number;
        /**
         * An extended parameter, whose value is a stringfied JSON.Note: This parameter is for customers with special requirements. It needs to be customized offline.Note: This field may return null, indicating that no valid values can be obtained.
         */
        extendedParameter?: string;
    }

    export interface ProcessMediaOperationAiContentReviewTask {
        /**
         * Video content audit template ID.
         */
        definition: number;
    }

    export interface ProcessMediaOperationAiQualityControlTask {
        /**
         * The channel extension parameter, which is a serialized JSON string.Note: This field may return null, indicating that no valid values can be obtained.
         */
        channelExtPara?: string;
        /**
         * The ID of the quality control template.Note: This field may return null, indicating that no valid values can be obtained.
         */
        definition?: number;
    }

    export interface ProcessMediaOperationAiRecognitionTask {
        /**
         * Intelligent video recognition template ID.
         */
        definition: number;
    }

    export interface ProcessMediaOperationInputInfo {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationInputInfoCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationInputInfoS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationInputInfoUrlInputInfo;
    }

    export interface ProcessMediaOperationInputInfoCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationInputInfoS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationInputInfoUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTask {
        /**
         * List of adaptive bitrate streaming tasks.
         */
        adaptiveDynamicStreamingTaskSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSet[];
        /**
         * List of animated image generating tasks.
         */
        animatedGraphicTaskSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSet[];
        /**
         * List of image sprite generating tasks.
         */
        imageSpriteTaskSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskImageSpriteTaskSet[];
        /**
         * List of sampled screencapturing tasks.
         */
        sampleSnapshotTaskSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSet[];
        /**
         * List of time point screencapturing tasks.
         */
        snapshotByTimeOffsetTaskSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSet[];
        /**
         * List of transcoding tasks.
         */
        transcodeTaskSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSet[];
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSet {
        /**
         * The subtitle file to add.Note: This field may return null, indicating that no valid values can be obtained.
         */
        addOnSubtitles?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitle[];
        /**
         * Adaptive bitrate streaming template ID.
         */
        definition: number;
        /**
         * The relative or absolute output path of the manifest file after being transcoded to adaptive bitrate streaming. If this parameter is left empty, a relative path in the following format will be used by default: `{inputName}_adaptiveDynamicStreaming_{definition}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of an output file after being transcoded to adaptive bitrate streaming. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: this field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage;
        /**
         * The relative output path of the segment file after being transcoded to adaptive bitrate streaming (in HLS format only). If this parameter is left empty, a relative path in the following format will be used by default: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}_{segmentNumber}.{format}`.
         */
        segmentObjectName?: string;
        /**
         * The relative output path of the substream file after being transcoded to adaptive bitrate streaming. If this parameter is left empty, a relative path in the following format will be used by default: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
         */
        subStreamObjectName?: string;
        /**
         * List of up to 10 image or text watermarks.
         */
        watermarkSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet[];
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitle {
        /**
         * The subtitle file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        subtitle?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitle;
        /**
         * The mode. Valid values:`subtitle-stream`: Add a subtitle track.`close-caption-708`: Embed CEA-708 subtitles in SEI frames.`close-caption-608`: Embed CEA-608 subtitles in SEI frames.Note: This field may return null, indicating that no valid values can be obtained.
         */
        type?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitle {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitleCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitleS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitleUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitleCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitleS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetAddOnSubtitleSubtitleUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS`&gt;AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSet {
        /**
         * Animated image generating template ID.
         */
        definition: number;
        /**
         * End time of an animated image in a video in seconds.
         */
        endTimeOffset: number;
        /**
         * Output path to a generated animated image file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_animatedGraphic_{definition}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a generated animated image file. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSetOutputStorage;
        /**
         * Start time of an animated image in a video in seconds.
         */
        startTimeOffset: number;
    }

    export interface ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSetOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSetOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS`&gt;AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskAnimatedGraphicTaskSetOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskImageSpriteTaskSet {
        /**
         * ID of an image sprite generating template.
         */
        definition: number;
        /**
         * Rule of the `{number}` variable in the image sprite output path.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetObjectNumberFormat;
        /**
         * Output path to a generated image sprite file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_imageSprite_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a generated image sprite. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetOutputStorage;
        /**
         * Output path to the WebVTT file after an image sprite is generated, which can only be a relative path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_imageSprite_{definition}.{format}`.
         */
        webVttObjectName?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS`&gt;AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskImageSpriteTaskSetOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSet {
        /**
         * Sampled screencapturing template ID.
         */
        definition: number;
        /**
         * Rule of the `{number}` variable in the sampled screenshot output path.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat;
        /**
         * Output path to a generated sampled screenshot, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_sampleSnapshot_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a sampled screenshot. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetOutputStorage;
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSet[];
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS`&gt;AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSet {
        /**
         * ID of a time point screencapturing template.
         */
        definition: number;
        /**
         * List of screenshot time points in the format of `s` or `%`:If the string ends in `s`, it means that the time point is in seconds; for example, `3.5s` means that the time point is the 3.5th second;If the string ends in `%`, it means that the time point is the specified percentage of the video duration; for example, `10%` means that the time point is 10% of the video duration.
         */
        extTimeOffsetSets?: string[];
        /**
         * Rule of the `{number}` variable in the time point screenshot output path.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat;
        /**
         * Output path to a generated time point screenshot, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_snapshotByTimeOffset_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a generated time point screenshot file. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage;
        /**
         * List of time points of screenshots in &lt;font color=red&gt;seconds&lt;/font&gt;.
         */
        timeOffsetSets?: number[];
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet[];
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS`&gt;AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSet {
        /**
         * ID of a video transcoding template.
         */
        definition: number;
        /**
         * End time offset of a transcoded video, in seconds.If this parameter is left empty or set to 0, the transcoded video will end at the same time as the original video.If this parameter is set to a positive number (n for example), the transcoded video will end at the nth second of the original video.If this parameter is set to a negative number (-n for example), the transcoded video will end at the nth second before the end of the original video.
         */
        endTimeOffset?: number;
        /**
         * Opening and closing credits parametersNote: this field may return `null`, indicating that no valid value was found.
         */
        headTailParameter?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameter;
        /**
         * List of blurs. Up to 10 ones can be supported.
         */
        mosaicSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetMosaicSet[];
        /**
         * Rule of the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetObjectNumberFormat;
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of an output file. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOutputStorage;
        /**
         * Video transcoding custom parameter, which is valid when `Definition` is not 0.When any parameters in this structure are entered, they will be used to override corresponding parameters in templates.This parameter is used in highly customized scenarios. We recommend you only use `Definition` to specify the transcoding parameter.Note: this field may return `null`, indicating that no valid value was found.
         */
        overrideParameter?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameter;
        /**
         * Custom video transcoding parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the transcoding parameter preferably.
         */
        rawParameter?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameter;
        /**
         * Path to an output file part (the path to ts during transcoding to HLS), which can only be a relative path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}_{number}.{format}`.
         */
        segmentObjectName?: string;
        /**
         * Start time offset of a transcoded video, in seconds.If this parameter is left empty or set to 0, the transcoded video will start at the same time as the original video.If this parameter is set to a positive number (n for example), the transcoded video will start at the nth second of the original video.If this parameter is set to a negative number (-n for example), the transcoded video will start at the nth second before the end of the original video.
         */
        startTimeOffset?: number;
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSet[];
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameter {
        /**
         * Opening credits list.
         */
        headSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet[];
        /**
         * Closing credits list.
         */
        tailSets?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet[];
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetMosaicSet {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * End time offset of blur in seconds.If this parameter is left empty or 0 is entered, the blur will exist till the last video frame;If this value is greater than 0 (e.g., n), the blur will exist till second n;If this value is smaller than 0 (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Blur height. % and px formats are supported:If the string ends in %, the `Height` of the blur will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the blur will be in px; for example, `100px` means that `Height` is 100 px.Default value: 10%.
         */
        height?: string;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or 0 is entered, the blur will appear upon the first video frame.If this parameter is left empty or 0 is entered, the blur will appear upon the first video frame;If this value is greater than 0 (e.g., n), the blur will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * Blur width. % and px formats are supported:If the string ends in %, the `Width` of the blur will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the blur will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
        /**
         * The horizontal position of the origin of the blur relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the blur will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the blur will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * Vertical position of the origin of blur relative to the origin of coordinates of video. % and px formats are supported:If the string ends in %, the `YPos` of the blur will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the blur will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS`&gt;AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameter {
        /**
         * The subtitle file to add.Note: This field may return null, indicating that no valid values can be obtained.
         */
        addOnSubtitles?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitle[];
        /**
         * The information of the external audio track to add.Note: This field may return null, indicating that no valid values can be obtained.
         */
        addonAudioStreams?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStream[];
        /**
         * Audio stream configuration parameter.
         */
        audioTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate;
        /**
         * Container format. Valid values: mp4, flv, hls, mp3, flac, ogg, and m4a; mp3, flac, ogg, and m4a are formats of audio files.
         */
        container?: string;
        /**
         * Whether to remove audio data. Valid values:0: retain1: remove.
         */
        removeAudio?: number;
        /**
         * Whether to remove video data. Valid values:0: retain1: remove.
         */
        removeVideo?: number;
        /**
         * An extended field for transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        stdExtInfo?: string;
        /**
         * The subtitle settings.Note: This field may return null, indicating that no valid values can be obtained.
         */
        subtitleTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate;
        /**
         * The TSC transcoding parameters.Note: This field may return null, indicating that no valid values can be obtained.
         */
        tehdConfig?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig;
        /**
         * Video stream configuration parameter.
         */
        videoTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitle {
        /**
         * The subtitle file.Note: This field may return null, indicating that no valid values can be obtained.
         */
        subtitle?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitle;
        /**
         * The mode. Valid values:`subtitle-stream`: Add a subtitle track.`close-caption-708`: Embed CEA-708 subtitles in SEI frames.`close-caption-608`: Embed CEA-608 subtitles in SEI frames.Note: This field may return null, indicating that no valid values can be obtained.
         */
        type?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitle {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitleCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitleS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitleUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitleCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitleS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddOnSubtitleSubtitleUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStream {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStreamCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStreamS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStreamUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStreamCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStreamS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAddonAudioStreamUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate {
        /**
         * Audio channel system. Valid values:1: Mono2: Dual6: StereoWhen the media is packaged in audio format (FLAC, OGG, MP3, M4A), the sound channel cannot be set to stereo.Default value: 2.
         */
        audioChannel?: number;
        /**
         * Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
         */
        bitrate?: number;
        /**
         * Audio stream codec.When the outer `Container` parameter is `mp3`, the valid value is:libmp3lame.When the outer `Container` parameter is `ogg` or `flac`, the valid value is:flac.When the outer `Container` parameter is `m4a`, the valid values include:libfdk_aac;libmp3lame;ac3.When the outer `Container` parameter is `mp4` or `flv`, the valid values include:libfdk_aac: more suitable for mp4;libmp3lame: more suitable for flv.When the outer `Container` parameter is `hls`, the valid values include:libfdk_aac;libmp3lame.
         */
        codec?: string;
        /**
         * Audio stream sample rate. Valid values:32,00044,10048,000In Hz.
         */
        sampleRate?: number;
        /**
         * The audio tracks to retain. All audio tracks are retained by default.
         */
        streamSelects?: number[];
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate {
        /**
         * The text transparency. Value range: 0-1.`0`: Fully transparent.`1`: Fully opaque.Default value: 1.Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontAlpha?: number;
        /**
         * The font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontColor?: string;
        /**
         * The font size (pixels). If this is not specified, the font size in the subtitle file will be used.Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontSize?: string;
        /**
         * The font. Valid values:`hei.ttf`: Heiti.`song.ttf`: Songti.`simkai.ttf`: Kaiti.`arial.ttf`: Arial.The default is `hei.ttf`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        fontType?: string;
        /**
         * The URL of the subtitles to add to the video.Note: This field may return null, indicating that no valid values can be obtained.
         */
        path?: string;
        /**
         * The subtitle track to add to the video. If both `Path` and `StreamIndex` are specified, `Path` will be used. You need to specify at least one of the two parameters.Note: This field may return null, indicating that no valid values can be obtained.
         */
        streamIndex?: number;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig {
        /**
         * Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left empty or 0 is entered, there will be no upper limit for bitrate.
         */
        maxVideoBitrate?: number;
        /**
         * TESHD type. Valid values:TEHD-100: TESHD-100.If this parameter is left empty, TESHD will not be enabled.
         */
        type?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate {
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate?: number;
        /**
         * The video codec. Valid values:`libx264`: H.264`libx265`: H.265`av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec?: string;
        /**
         * Whether to enable adaptive encoding. Valid values:0: Disable1: EnableDefault value: 0. If this parameter is set to `1`, multiple streams with different resolutions and bitrates will be generated automatically. The highest resolution, bitrate, and quality of the streams are determined by the values of `width` and `height`, `Bitrate`, and `Vcrf` in `VideoTemplate` respectively. If these parameters are not set in `VideoTemplate`, the highest resolution generated will be the same as that of the source video, and the highest video quality will be close to VMAF 95. To use this parameter or learn about the billing details of adaptive encoding, please contact your sales rep.
         */
        contentAdaptStream?: number;
        /**
         * The fill mode, which indicates how a video is resized when the video's original aspect ratio is different from the target aspect ratio. Valid values:stretch: Stretch the image frame by frame to fill the entire screen. The video image may become squashed or stretched after transcoding.black: Keep the image&#39;s original aspect ratio and fill the blank space with black bars.white: Keep the image's original aspect ratio and fill the blank space with white bars.gauss: Keep the image's original aspect ratio and apply Gaussian blur to the blank space.Default value: black.Note: Only `stretch` and `black` are supported for adaptive bitrate streaming.
         */
        fillType?: string;
        /**
         * The video frame rate (Hz). Value range: [0, 100].If the value is 0, the frame rate will be the same as that of the source video.Note: For adaptive bitrate streaming, the value range of this parameter is [0, 60].
         */
        fps?: number;
        /**
         * Frame interval between I keyframes. Value range: 0 and [1,100000].If this parameter is 0 or left empty, the system will automatically set the GOP length.
         */
        gop?: number;
        /**
         * Maximum value of the height (or short side) of a video stream in px. Value range: 0 and [128, 4,096].If both `Width` and `Height` are 0, the resolution will be the same as that of the source video;If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled;If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled;If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        height?: number;
        /**
         * Resolution adaption. Valid values:open: Enabled. When resolution adaption is enabled, `Width` indicates the long side of a video, while `Height` indicates the short side.close: Disabled. When resolution adaption is disabled, `Width` indicates the width of a video, while `Height` indicates the height.Default value: open.Note: When resolution adaption is enabled, `Width` cannot be smaller than `Height`.
         */
        resolutionAdaptive?: string;
        /**
         * The control factor of video constant bitrate. Value range: [1, 51]If this parameter is specified, CRF (a bitrate control method) will be used for transcoding. (Video bitrate will no longer take effect.)It is not recommended to specify this parameter if there are no special requirements.
         */
        vcrf?: number;
        /**
         * Maximum value of the width (or long side) of a video stream in px. Value range: 0 and [128, 4,096].If both `Width` and `Height` are 0, the resolution will be the same as that of the source video;If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled;If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled;If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        width?: number;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameter {
        /**
         * Audio stream configuration parameter. This field is required when `RemoveAudio` is 0.
         */
        audioTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate;
        /**
         * Container. Valid values: mp4; flv; hls; mp3; flac; ogg; m4a. Among them, mp3, flac, ogg, and m4a are for audio files.
         */
        container: string;
        /**
         * Whether to remove audio data. Valid values:0: retain;1: remove.Default value: 0.
         */
        removeAudio?: number;
        /**
         * Whether to remove video data. Valid values:0: retain;1: remove.Default value: 0.
         */
        removeVideo?: number;
        /**
         * TESHD transcoding parameter.
         */
        tehdConfig?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig;
        /**
         * Video stream configuration parameter. This field is required when `RemoveVideo` is 0.
         */
        videoTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate {
        /**
         * Audio channel system. Valid values:1: Mono2: Dual6: StereoWhen the media is packaged in audio format (FLAC, OGG, MP3, M4A), the sound channel cannot be set to stereo.Default value: 2.
         */
        audioChannel?: number;
        /**
         * Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
         */
        bitrate: number;
        /**
         * Audio stream codec.When the outer `Container` parameter is `mp3`, the valid value is:libmp3lame.When the outer `Container` parameter is `ogg` or `flac`, the valid value is:flac.When the outer `Container` parameter is `m4a`, the valid values include:libfdk_aac;libmp3lame;ac3.When the outer `Container` parameter is `mp4` or `flv`, the valid values include:libfdk_aac: more suitable for mp4;libmp3lame: more suitable for flv.When the outer `Container` parameter is `hls`, the valid values include:libfdk_aac;libmp3lame.
         */
        codec: string;
        /**
         * Audio stream sample rate. Valid values:32,00044,10048,000In Hz.
         */
        sampleRate: number;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig {
        /**
         * Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left empty or 0 is entered, there will be no upper limit for bitrate.
         */
        maxVideoBitrate?: number;
        /**
         * TESHD type. Valid values:TEHD-100: TESHD-100.If this parameter is left empty, TESHD will not be enabled.
         */
        type: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate {
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values:`libx264`: H.264`libx265`: H.265`av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec: string;
        /**
         * The fill mode, which indicates how a video is resized when the video's original aspect ratio is different from the target aspect ratio. Valid values:stretch: Stretch the image frame by frame to fill the entire screen. The video image may become squashed or stretched after transcoding.black: Keep the image&#39;s original aspect ratio and fill the blank space with black bars.white: Keep the image's original aspect ratio and fill the blank space with white bars.gauss: Keep the image's original aspect ratio and apply Gaussian blur to the blank space.Default value: black.Note: Only `stretch` and `black` are supported for adaptive bitrate streaming.
         */
        fillType?: string;
        /**
         * The video frame rate (Hz). Value range: [0, 100].If the value is 0, the frame rate will be the same as that of the source video.Note: For adaptive bitrate streaming, the value range of this parameter is [0, 60].
         */
        fps: number;
        /**
         * Frame interval between I keyframes. Value range: 0 and [1,100000].If this parameter is 0 or left empty, the system will automatically set the GOP length.
         */
        gop?: number;
        /**
         * Maximum value of the height (or short side) of a video stream in px. Value range: 0 and [128, 4,096].If both `Width` and `Height` are 0, the resolution will be the same as that of the source video;If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled;If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled;If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        height?: number;
        /**
         * Resolution adaption. Valid values:open: Enabled. When resolution adaption is enabled, `Width` indicates the long side of a video, while `Height` indicates the short side.close: Disabled. When resolution adaption is disabled, `Width` indicates the width of a video, while `Height` indicates the height.Default value: open.Note: When resolution adaption is enabled, `Width` cannot be smaller than `Height`.
         */
        resolutionAdaptive?: string;
        /**
         * The control factor of video constant bitrate. Value range: [1, 51]If this parameter is specified, CRF (a bitrate control method) will be used for transcoding. (Video bitrate will no longer take effect.)It is not recommended to specify this parameter if there are no special requirements.
         */
        vcrf?: number;
        /**
         * Maximum value of the width (or long side) of a video stream in px. Value range: 0 and [128, 4,096].If both `Width` and `Height` are 0, the resolution will be the same as that of the source video;If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled;If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled;If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        width?: number;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds.If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame;If this value is greater than 0 (e.g., n), the watermark will exist till second n;If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame.If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame;If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame;If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be:TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width;If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported:If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height;If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported:If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values:`once`: no longer appears after watermark playback ends.`repeatLastFrame`: stays on the last frame after watermark playback ends.`repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported:If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width;If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values:`COS`: A COS bucket address. `URL`: A URL. `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ProcessMediaOperationOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ProcessMediaOperationOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ProcessMediaOperationOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values:`COS`: Tencent Cloud COS`&gt;AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ProcessMediaOperationOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ProcessMediaOperationOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ProcessMediaOperationTaskNotifyConfig {
        /**
         * The AWS SQS queue. This parameter is required if `NotifyType` is `AWS-SQS`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsSqa?: outputs.Mps.ProcessMediaOperationTaskNotifyConfigAwsSqa;
        /**
         * The CMQ or TDMQ-CMQ model. Valid values: Queue, Topic.
         */
        cmqModel?: string;
        /**
         * The CMQ or TDMQ-CMQ region, such as `sh` (Shanghai) or `bj` (Beijing).
         */
        cmqRegion?: string;
        /**
         * Workflow notification method. Valid values: Finish, Change. If this parameter is left empty, `Finish` will be used.
         */
        notifyMode?: string;
        /**
         * The notification type. Valid values:`CMQ`: This value is no longer used. Please use `TDMQ-CMQ` instead.`TDMQ-CMQ`: Message queue`URL`: If `NotifyType` is set to `URL`, HTTP callbacks are sent to the URL specified by `NotifyUrl`. HTTP and JSON are used for the callbacks. The packet contains the response parameters of the `ParseNotification` API.`SCF`: This notification type is not recommended. You need to configure it in the SCF console.`AWS-SQS`: AWS queue. This type is only supported for AWS tasks, and the queue must be in the same region as the AWS bucket.&lt;font color=red&gt;Note: If you do not pass this parameter or pass in an empty string, `CMQ` will be used. To use a different notification type, specify this parameter accordingly.&lt;/font&gt;.
         */
        notifyType?: string;
        /**
         * HTTP callback URL, required if `NotifyType` is set to `URL`.
         */
        notifyUrl?: string;
        /**
         * The CMQ or TDMQ-CMQ queue to receive notifications. This parameter is valid when `CmqModel` is `Queue`.
         */
        queueName?: string;
        /**
         * The CMQ or TDMQ-CMQ topic to receive notifications. This parameter is valid when `CmqModel` is `Topic`.
         */
        topicName?: string;
    }

    export interface ProcessMediaOperationTaskNotifyConfigAwsSqa {
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
        /**
         * The name of the SQS queue.
         */
        sqaQueueName: string;
        /**
         * The region of the SQS queue.
         */
        sqaRegion: string;
    }

    export interface ScheduleActivity {
        /**
         * The parameters of a subtask.Note: This field may return null, indicating that no valid values can be obtained.
         */
        activityPara: outputs.Mps.ScheduleActivityActivityPara;
        /**
         * The subtask type. `input`: The start. `output`: The end. `action-trans`: Transcoding. `action-samplesnapshot`: Sampled screencapturing. `action-AIAnalysis`: Content analysis. `action-AIRecognition`: Content recognition. `action-aiReview`: Content moderation. `action-animated-graphics`: Animated screenshot generation. `action-image-sprite`: Image sprite generation. `action-snapshotByTimeOffset`: Time point screencapturing. `action-adaptive-substream`: Adaptive bitrate streaming.Note: This field may return null, indicating that no valid values can be obtained.
         */
        activityType: string;
        /**
         * The indexes of the subsequent actions. Note: This field may return null, indicating that no valid values can be obtained.
         */
        reardriveIndices: number[];
    }

    export interface ScheduleActivityActivityPara {
        /**
         * An adaptive bitrate streaming task.
         */
        adaptiveDynamicStreamingTask?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTask;
        /**
         * A content analysis task.
         */
        aiAnalysisTask?: outputs.Mps.ScheduleActivityActivityParaAiAnalysisTask;
        /**
         * A content moderation task.
         */
        aiContentReviewTask?: outputs.Mps.ScheduleActivityActivityParaAiContentReviewTask;
        /**
         * A content recognition task.
         */
        aiRecognitionTask?: outputs.Mps.ScheduleActivityActivityParaAiRecognitionTask;
        /**
         * An animated screenshot generation task.
         */
        animatedGraphicTask?: outputs.Mps.ScheduleActivityActivityParaAnimatedGraphicTask;
        /**
         * An image sprite generation task.
         */
        imageSpriteTask?: outputs.Mps.ScheduleActivityActivityParaImageSpriteTask;
        /**
         * A sampled screencapturing task.
         */
        sampleSnapshotTask?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTask;
        /**
         * A time point screencapturing task.
         */
        snapshotByTimeOffsetTask?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTask;
        /**
         * A transcoding task.
         */
        transcodeTask?: outputs.Mps.ScheduleActivityActivityParaTranscodeTask;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTask {
        /**
         * Subtitle files to insert.Note: This field may return null, indicating that no valid value can be obtained.
         */
        addOnSubtitles?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitle[];
        /**
         * Adaptive bitrate streaming template ID.
         */
        definition: number;
        /**
         * The relative or absolute output path of the manifest file after being transcoded to adaptive bitrate streaming. If this parameter is left empty, a relative path in the following format will be used by default: `{inputName}_adaptiveDynamicStreaming_{definition}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of an output file after being transcoded to adaptive bitrate streaming. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: this field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorage;
        /**
         * The relative output path of the segment file after being transcoded to adaptive bitrate streaming (in HLS format only). If this parameter is left empty, a relative path in the following format will be used by default: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}_{segmentNumber}.{format}`.
         */
        segmentObjectName?: string;
        /**
         * The relative output path of the substream file after being transcoded to adaptive bitrate streaming. If this parameter is left empty, a relative path in the following format will be used by default: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
         */
        subStreamObjectName?: string;
        /**
         * List of up to 10 image or text watermarks.
         */
        watermarkSets?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSet[];
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitle {
        /**
         * Subtitle file.Note: This field may return null, indicating that no valid value can be obtained.
         */
        subtitle?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitle;
        /**
         * The inserting type. Valid values: `subtitle-stream`:Insert title track. `close-caption-708`:CEA-708 subtitle encode to SEI frame. `close-caption-608`:CEA-608 subtitle encode to SEI frame. Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitle {
        /**
         * The information of the COS object to process. This parameter is valid and required when Type is COS.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if Type is AWS-S3.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleS3InputInfo;
        /**
         * The input type. Valid values:  `COS`:A COS bucket address. `URL`:A URL. `AWS-S3`:An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when Type is URL.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskAddOnSubtitleSubtitleUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame; If this value is greater than 0 (e.g., n), the watermark will exist till second n; If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame; If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be: TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values: image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width; If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height; If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height; If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values: `once`: no longer appears after watermark playback ends. `repeatLastFrame`: stays on the last frame after watermark playback ends. `repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width; If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaAdaptiveDynamicStreamingTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaAiAnalysisTask {
        /**
         * Video content analysis template ID.
         */
        definition: number;
        /**
         * An extended parameter, whose value is a stringfied JSON.Note: This parameter is for customers with special requirements. It needs to be customized offline.Note: This field may return null, indicating that no valid values can be obtained.
         */
        extendedParameter?: string;
    }

    export interface ScheduleActivityActivityParaAiContentReviewTask {
        /**
         * Video content audit template ID.
         */
        definition: number;
    }

    export interface ScheduleActivityActivityParaAiRecognitionTask {
        /**
         * Intelligent video recognition template ID.
         */
        definition: number;
    }

    export interface ScheduleActivityActivityParaAnimatedGraphicTask {
        /**
         * Animated image generating template ID.
         */
        definition: number;
        /**
         * End time of an animated image in a video in seconds.
         */
        endTimeOffset: number;
        /**
         * Output path to a generated animated image file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_animatedGraphic_{definition}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a generated animated image file. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ScheduleActivityActivityParaAnimatedGraphicTaskOutputStorage;
        /**
         * Start time of an animated image in a video in seconds.
         */
        startTimeOffset: number;
    }

    export interface ScheduleActivityActivityParaAnimatedGraphicTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ScheduleActivityActivityParaAnimatedGraphicTaskOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ScheduleActivityActivityParaAnimatedGraphicTaskOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ScheduleActivityActivityParaAnimatedGraphicTaskOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ScheduleActivityActivityParaAnimatedGraphicTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaImageSpriteTask {
        /**
         * ID of an image sprite generating template.
         */
        definition: number;
        /**
         * Rule of the `{number}` variable in the image sprite output path.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ScheduleActivityActivityParaImageSpriteTaskObjectNumberFormat;
        /**
         * Output path to a generated image sprite file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_imageSprite_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a generated image sprite. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ScheduleActivityActivityParaImageSpriteTaskOutputStorage;
        /**
         * Output path to the WebVTT file after an image sprite is generated, which can only be a relative path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_imageSprite_{definition}.{format}`.
         */
        webVttObjectName?: string;
    }

    export interface ScheduleActivityActivityParaImageSpriteTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ScheduleActivityActivityParaImageSpriteTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ScheduleActivityActivityParaImageSpriteTaskOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ScheduleActivityActivityParaImageSpriteTaskOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ScheduleActivityActivityParaImageSpriteTaskOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ScheduleActivityActivityParaImageSpriteTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTask {
        /**
         * Sampled screencapturing template ID.
         */
        definition: number;
        /**
         * Rule of the `{number}` variable in the sampled screenshot output path.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskObjectNumberFormat;
        /**
         * Output path to a generated sampled screenshot, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_sampleSnapshot_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a sampled screenshot. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskOutputStorage;
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSet[];
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame; If this value is greater than 0 (e.g., n), the watermark will exist till second n; If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame; If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be: TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values: image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width; If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height; If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height; If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values: `once`: no longer appears after watermark playback ends. `repeatLastFrame`: stays on the last frame after watermark playback ends. `repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width; If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaSampleSnapshotTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTask {
        /**
         * ID of a time point screencapturing template.
         */
        definition: number;
        /**
         * List of screenshot time points in the format of `s` or `%`: If the string ends in `s`, it means that the time point is in seconds; for example, `3.5s` means that the time point is the 3.5th second; If the string ends in `%`, it means that the time point is the specified percentage of the video duration; for example, `10%` means that the time point is 10% of the video duration.
         */
        extTimeOffsetSets?: string[];
        /**
         * Rule of the `{number}` variable in the time point screenshot output path.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskObjectNumberFormat;
        /**
         * Output path to a generated time point screenshot, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_snapshotByTimeOffset_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of a generated time point screenshot file. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskOutputStorage;
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSet[];
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame; If this value is greater than 0 (e.g., n), the watermark will exist till second n; If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame; If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be: TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values: image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width; If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height; If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height; If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values: `once`: no longer appears after watermark playback ends. `repeatLastFrame`: stays on the last frame after watermark playback ends. `repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width; If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaSnapshotByTimeOffsetTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTask {
        /**
         * ID of a video transcoding template.
         */
        definition: number;
        /**
         * End time offset of a transcoded video, in seconds. If this parameter is left empty or set to 0, the transcoded video will end at the same time as the original video. If this parameter is set to a positive number (n for example), the transcoded video will end at the nth second of the original video. If this parameter is set to a negative number (-n for example), the transcoded video will end at the nth second before the end of the original video.
         */
        endTimeOffset?: number;
        /**
         * Opening and closing credits parametersNote: this field may return `null`, indicating that no valid value was found.
         */
        headTailParameter?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameter;
        /**
         * List of blurs. Up to 10 ones can be supported.
         */
        mosaicSets?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskMosaicSet[];
        /**
         * Rule of the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid values can be obtained.
         */
        objectNumberFormat?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskObjectNumberFormat;
        /**
         * Path to a primary output file, which can be a relative path or an absolute path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * Target bucket of an output file. If this parameter is left empty, the `OutputStorage` value of the upper folder will be inherited.Note: This field may return null, indicating that no valid values can be obtained.
         */
        outputStorage?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOutputStorage;
        /**
         * Video transcoding custom parameter, which is valid when `Definition` is not 0.When any parameters in this structure are entered, they will be used to override corresponding parameters in templates.This parameter is used in highly customized scenarios. We recommend you only use `Definition` to specify the transcoding parameter.Note: this field may return `null`, indicating that no valid value was found.
         */
        overrideParameter?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameter;
        /**
         * Custom video transcoding parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the transcoding parameter preferably.
         */
        rawParameter: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskRawParameter;
        /**
         * Path to an output file part (the path to ts during transcoding to HLS), which can only be a relative path. If this parameter is left empty, the following relative path will be used by default: `{inputName}_transcode_{definition}_{number}.{format}`.
         */
        segmentObjectName?: string;
        /**
         * Start time offset of a transcoded video, in seconds. If this parameter is left empty or set to 0, the transcoded video will start at the same time as the original video. If this parameter is set to a positive number (n for example), the transcoded video will start at the nth second of the original video. If this parameter is set to a negative number (-n for example), the transcoded video will start at the nth second before the end of the original video.
         */
        startTimeOffset?: number;
        /**
         * List of up to 10 image or text watermarks.Note: This field may return null, indicating that no valid values can be obtained.
         */
        watermarkSets?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskWatermarkSet[];
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameter {
        /**
         * Opening credits list.
         */
        headSets?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSet[];
        /**
         * Closing credits list.
         */
        tailSets?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSet[];
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSet {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSetCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSetS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSetUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSetCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSetS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterHeadSetUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSet {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSetCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSetS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSetUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSetCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSetS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskHeadTailParameterTailSetUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskMosaicSet {
        /**
         * Origin position, which currently can only be: TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or 0 is entered, the blur will exist till the last video frame; If this value is greater than 0 (e.g., n), the blur will exist till second n; If this value is smaller than 0 (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Blur height. % and px formats are supported: If the string ends in %, the `Height` of the blur will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height; If the string ends in px, the `Height` of the blur will be in px; for example, `100px` means that `Height` is 100 px.Default value: 10%.
         */
        height?: string;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or 0 is entered, the blur will appear upon the first video frame. If this parameter is left empty or 0 is entered, the blur will appear upon the first video frame; If this value is greater than 0 (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than 0 (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * Blur width. % and px formats are supported: If the string ends in %, the `Width` of the blur will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width; If the string ends in px, the `Width` of the blur will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
        /**
         * The horizontal position of the origin of the blur relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `XPos` of the blur will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width; If the string ends in px, the `XPos` of the blur will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * Vertical position of the origin of blur relative to the origin of coordinates of video. % and px formats are supported: If the string ends in %, the `YPos` of the blur will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height; If the string ends in px, the `YPos` of the blur will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskObjectNumberFormat {
        /**
         * Increment of the `{number}` variable. Default value: 1.
         */
        increment?: number;
        /**
         * Start value of the `{number}` variable. Default value: 0.
         */
        initialValue?: number;
        /**
         * Minimum length of the `{number}` variable. A placeholder will be used if the variable length is below the minimum requirement. Default value: 1.
         */
        minLength?: number;
        /**
         * Placeholder used when the `{number}` variable length is below the minimum requirement. Default value: 0.
         */
        placeHolder?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameter {
        /**
         * Subtitle files to insert.Note: This field may return null, indicating that no valid value can be obtained.
         */
        addOnSubtitles?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitle[];
        /**
         * The information of the external audio track to add.Note: This field may return null, indicating that no valid values can be obtained.
         */
        addonAudioStreams?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStream[];
        /**
         * Audio stream configuration parameter.
         */
        audioTemplate: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAudioTemplate;
        /**
         * Container format. Valid values: mp4, flv, hls, mp3, flac, ogg, and m4a; mp3, flac, ogg, and m4a are formats of audio files.
         */
        container?: string;
        /**
         * Whether to remove audio data. Valid values: 0: retain 1: remove.
         */
        removeAudio: number;
        /**
         * Whether to remove video data. Valid values: 0: retain 1: remove.
         */
        removeVideo: number;
        /**
         * Transcoding extension field.Note: This field may return null, indicating that no valid value can be obtained.
         */
        stdExtInfo?: string;
        /**
         * The subtitle settings.
         */
        subtitleTemplate?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterSubtitleTemplate;
        /**
         * TESHD transcoding parameter.
         */
        tehdConfig: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterTehdConfig;
        /**
         * Video stream configuration parameter.
         */
        videoTemplate: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterVideoTemplate;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitle {
        /**
         * Subtitle file.Note: This field may return null, indicating that no valid value can be obtained.
         */
        subtitle?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitle;
        /**
         * The inserting type. Valid values: `subtitle-stream`:Insert title track. `close-caption-708`:CEA-708 subtitle encode to SEI frame. `close-caption-608`:CEA-608 subtitle encode to SEI frame. Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitle {
        /**
         * The information of the COS object to process. This parameter is valid and required when Type is COS.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if Type is AWS-S3.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleS3InputInfo;
        /**
         * The input type. Valid values:  `COS`:A COS bucket address. `URL`:A URL. `AWS-S3`:An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when Type is URL.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddOnSubtitleSubtitleUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStream {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAddonAudioStreamUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterAudioTemplate {
        /**
         * Audio channel system. Valid values: 1: Mono 2: Dual 6: StereoWhen the media is packaged in audio format (FLAC, OGG, MP3, M4A), the sound channel cannot be set to stereo.Default value: 2.
         */
        audioChannel: number;
        /**
         * Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
         */
        bitrate: number;
        /**
         * Audio stream codec.When the outer `Container` parameter is `mp3`, the valid value is: libmp3lame.When the outer `Container` parameter is `ogg` or `flac`, the valid value is: flac.When the outer `Container` parameter is `m4a`, the valid values include: libfdk_aac; libmp3lame; ac3.When the outer `Container` parameter is `mp4` or `flv`, the valid values include: libfdk_aac: more suitable for mp4; libmp3lame: more suitable for flv.When the outer `Container` parameter is `hls`, the valid values include: libfdk_aac; libmp3lame.
         */
        codec?: string;
        /**
         * Audio stream sample rate. Valid values: 32,000 44,100 48,000In Hz.
         */
        sampleRate: number;
        /**
         * The audio tracks to retain. All audio tracks are retained by default.
         */
        streamSelects?: number[];
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterSubtitleTemplate {
        /**
         * The text transparency. Value range: 0-1. 0: Completely transparent 1: Completely opaqueDefault value: 1.
         */
        fontAlpha?: number;
        /**
         * The font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).
         */
        fontColor?: string;
        /**
         * The font size (pixels). If this is not specified, the font size in the subtitle file will be used.
         */
        fontSize?: string;
        /**
         * The font type. Valid values: `hei.ttf` `song.ttf` `simkai.ttf` `arial.ttf` (for English only). The default is `hei.ttf`.
         */
        fontType?: string;
        /**
         * The URL of the subtitles to add to the video.
         */
        path?: string;
        /**
         * The subtitle track to add to the video. If both `Path` and `StreamIndex` are specified, `Path` will be used. You need to specify at least one of the two parameters.
         */
        streamIndex?: number;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterTehdConfig {
        /**
         * Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left empty or 0 is entered, there will be no upper limit for bitrate.
         */
        maxVideoBitrate: number;
        /**
         * TESHD type. Valid values: TEHD-100: TESHD-100.If this parameter is left empty, TESHD will not be enabled.
         */
        type?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskOverrideParameterVideoTemplate {
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values: `libx264`: H.264 `libx265`: H.265 `av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec?: string;
        /**
         * Whether to enable adaptive encoding. Valid values: 0: Disable 1: EnableDefault value: 0. If this parameter is set to `1`, multiple streams with different resolutions and bitrates will be generated automatically. The highest resolution, bitrate, and quality of the streams are determined by the values of `width` and `height`, `Bitrate`, and `Vcrf` in `VideoTemplate` respectively. If these parameters are not set in `VideoTemplate`, the highest resolution generated will be the same as that of the source video, and the highest video quality will be close to VMAF 95. To use this parameter or learn about the billing details of adaptive encoding, please contact your sales rep.
         */
        contentAdaptStream?: number;
        /**
         * The fill mode, which indicates how a video is resized when the video's original aspect ratio is different from the target aspect ratio. Valid values: stretch: Stretch the image frame by frame to fill the entire screen. The video image may become squashed or stretched after transcoding. black: Keep the image&#39;s original aspect ratio and fill the blank space with black bars. white: Keep the image's original aspect ratio and fill the blank space with white bars. gauss: Keep the image's original aspect ratio and apply Gaussian blur to the blank space.Default value: black.Note: Only `stretch` and `black` are supported for adaptive bitrate streaming.
         */
        fillType?: string;
        /**
         * The video frame rate (Hz). Value range: [0, 100].If the value is 0, the frame rate will be the same as that of the source video.Note: For adaptive bitrate streaming, the value range of this parameter is [0, 60].
         */
        fps: number;
        /**
         * Frame interval between I keyframes. Value range: 0 and [1,100000].If this parameter is 0 or left empty, the system will automatically set the GOP length.
         */
        gop: number;
        /**
         * Maximum value of the height (or short side) of a video stream in px. Value range: 0 and [128, 4,096]. If both `Width` and `Height` are 0, the resolution will be the same as that of the source video; If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled; If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled; If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        height: number;
        /**
         * Resolution adaption. Valid values: open: Enabled. When resolution adaption is enabled, `Width` indicates the long side of a video, while `Height` indicates the short side. close: Disabled. When resolution adaption is disabled, `Width` indicates the width of a video, while `Height` indicates the height.Default value: open.Note: When resolution adaption is enabled, `Width` cannot be smaller than `Height`.
         */
        resolutionAdaptive?: string;
        /**
         * The control factor of video constant bitrate. Value range: [1, 51]If this parameter is specified, CRF (a bitrate control method) will be used for transcoding. (Video bitrate will no longer take effect.)It is not recommended to specify this parameter if there are no special requirements.
         */
        vcrf: number;
        /**
         * Maximum value of the width (or long side) of a video stream in px. Value range: 0 and [128, 4,096]. If both `Width` and `Height` are 0, the resolution will be the same as that of the source video; If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled; If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled; If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        width: number;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskRawParameter {
        /**
         * Audio stream configuration parameter. This field is required when `RemoveAudio` is 0.
         */
        audioTemplate: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskRawParameterAudioTemplate;
        /**
         * Container. Valid values: mp4; flv; hls; mp3; flac; ogg; m4a. Among them, mp3, flac, ogg, and m4a are for audio files.
         */
        container: string;
        /**
         * Whether to remove audio data. Valid values: 0: retain; 1: remove.Default value: 0.
         */
        removeAudio?: number;
        /**
         * Whether to remove video data. Valid values: 0: retain; 1: remove.Default value: 0.
         */
        removeVideo?: number;
        /**
         * TESHD transcoding parameter.
         */
        tehdConfig: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskRawParameterTehdConfig;
        /**
         * Video stream configuration parameter. This field is required when `RemoveVideo` is 0.
         */
        videoTemplate: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskRawParameterVideoTemplate;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskRawParameterAudioTemplate {
        /**
         * Audio channel system. Valid values: 1: Mono 2: Dual 6: StereoWhen the media is packaged in audio format (FLAC, OGG, MP3, M4A), the sound channel cannot be set to stereo.Default value: 2.
         */
        audioChannel?: number;
        /**
         * Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
         */
        bitrate: number;
        /**
         * Audio stream codec.When the outer `Container` parameter is `mp3`, the valid value is: libmp3lame.When the outer `Container` parameter is `ogg` or `flac`, the valid value is: flac.When the outer `Container` parameter is `m4a`, the valid values include: libfdk_aac; libmp3lame; ac3.When the outer `Container` parameter is `mp4` or `flv`, the valid values include: libfdk_aac: more suitable for mp4; libmp3lame: more suitable for flv.When the outer `Container` parameter is `hls`, the valid values include: libfdk_aac; libmp3lame.
         */
        codec: string;
        /**
         * Audio stream sample rate. Valid values: 32,000 44,100 48,000In Hz.
         */
        sampleRate: number;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskRawParameterTehdConfig {
        /**
         * Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left empty or 0 is entered, there will be no upper limit for bitrate.
         */
        maxVideoBitrate?: number;
        /**
         * TESHD type. Valid values: TEHD-100: TESHD-100.If this parameter is left empty, TESHD will not be enabled.
         */
        type: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskRawParameterVideoTemplate {
        /**
         * The video bitrate (Kbps). Value range: 0 and [128, 35000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values: `libx264`: H.264 `libx265`: H.265 `av1`: AOMedia Video 1Note: You must specify a resolution (not higher than 640 x 480) if the H.265 codec is used.Note: You can only use the AOMedia Video 1 codec for MP4 files.
         */
        codec: string;
        /**
         * The fill mode, which indicates how a video is resized when the video's original aspect ratio is different from the target aspect ratio. Valid values: stretch: Stretch the image frame by frame to fill the entire screen. The video image may become squashed or stretched after transcoding. black: Keep the image&#39;s original aspect ratio and fill the blank space with black bars. white: Keep the image's original aspect ratio and fill the blank space with white bars. gauss: Keep the image's original aspect ratio and apply Gaussian blur to the blank space.Default value: black.Note: Only `stretch` and `black` are supported for adaptive bitrate streaming.
         */
        fillType?: string;
        /**
         * The video frame rate (Hz). Value range: [0, 100].If the value is 0, the frame rate will be the same as that of the source video.Note: For adaptive bitrate streaming, the value range of this parameter is [0, 60].
         */
        fps: number;
        /**
         * Frame interval between I keyframes. Value range: 0 and [1,100000].If this parameter is 0 or left empty, the system will automatically set the GOP length.
         */
        gop?: number;
        /**
         * Maximum value of the height (or short side) of a video stream in px. Value range: 0 and [128, 4,096]. If both `Width` and `Height` are 0, the resolution will be the same as that of the source video; If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled; If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled; If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        height?: number;
        /**
         * Resolution adaption. Valid values: open: Enabled. When resolution adaption is enabled, `Width` indicates the long side of a video, while `Height` indicates the short side. close: Disabled. When resolution adaption is disabled, `Width` indicates the width of a video, while `Height` indicates the height.Default value: open.Note: When resolution adaption is enabled, `Width` cannot be smaller than `Height`.
         */
        resolutionAdaptive?: string;
        /**
         * The control factor of video constant bitrate. Value range: [1, 51]If this parameter is specified, CRF (a bitrate control method) will be used for transcoding. (Video bitrate will no longer take effect.)It is not recommended to specify this parameter if there are no special requirements.
         */
        vcrf?: number;
        /**
         * Maximum value of the width (or long side) of a video stream in px. Value range: 0 and [128, 4,096]. If both `Width` and `Height` are 0, the resolution will be the same as that of the source video; If `Width` is 0, but `Height` is not 0, `Width` will be proportionally scaled; If `Width` is not 0, but `Height` is 0, `Height` will be proportionally scaled; If both `Width` and `Height` are not 0, the custom resolution will be used.Default value: 0.
         */
        width?: number;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskWatermarkSet {
        /**
         * ID of a watermarking template.
         */
        definition: number;
        /**
         * End time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will exist till the last video frame; If this value is greater than 0 (e.g., n), the watermark will exist till second n; If this value is smaller than 0 (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Custom watermark parameter, which is valid if `Definition` is 0.This parameter is used in highly customized scenarios. We recommend you use `Definition` to specify the watermark parameter preferably.Custom watermark parameter is not available for screenshot.
         */
        rawParameter: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameter;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame. If this parameter is left empty or 0 is entered, the watermark will appear upon the first video frame; If this value is greater than 0 (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than 0 (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to 2,000,000 characters. This field is required only when the watermark type is `SVG`.SVG watermark is not available for screenshot.
         */
        svgContent?: string;
        /**
         * Text content of up to 100 characters. This field is required only when the watermark type is text.Text watermark is not available for screenshot.
         */
        textContent?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameter {
        /**
         * Origin position, which currently can only be: TopLeft: the origin of coordinates is in the top-left corner of the video, and the origin of the watermark is in the top-left corner of the image or text.Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template. This field is required when `Type` is `image` and is invalid when `Type` is `text`.
         */
        imageTemplate?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type. Valid values: image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `XPos` of the watermark will be the specified percentage of the video width; for example, `10%` means that `XPos` is 10% of the video width; If the string ends in px, the `XPos` of the watermark will be the specified px; for example, `100px` means that `XPos` is 100 px.Default value: 0 px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark relative to the origin of coordinates of the video. % and px formats are supported: If the string ends in %, the `YPos` of the watermark will be the specified percentage of the video height; for example, `10%` means that `YPos` is 10% of the video height; If the string ends in px, the `YPos` of the watermark will be the specified px; for example, `100px` means that `YPos` is 100 px.Default value: 0 px.
         */
        yPos?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplate {
        /**
         * Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height; If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px.Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Input content of watermark image. JPEG and PNG images are supported.
         */
        imageContent: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Repeat type of an animated watermark. Valid values: `once`: no longer appears after watermark playback ends. `repeatLastFrame`: stays on the last frame after watermark playback ends. `repeat` (default): repeats the playback until the video ends.
         */
        repeatType?: string;
        /**
         * Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width; for example, `10%` means that `Width` is 10% of the video width; If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px.Default value: 10%.
         */
        width?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks.
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleActivityActivityParaTranscodeTaskWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface ScheduleOutputStorage {
        /**
         * The location to save the output object in COS. This parameter is valid and required when `Type` is COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.ScheduleOutputStorageCosOutputStorage;
        /**
         * The AWS S3 bucket to save the output file. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3OutputStorage?: outputs.Mps.ScheduleOutputStorageS3OutputStorage;
        /**
         * The storage type for a media processing output file. Valid values: `COS`: Tencent Cloud COS `AWS-S3`: AWS S3. This type is only supported for AWS tasks, and the output bucket must be in the same region as the bucket of the source file.
         */
        type: string;
    }

    export interface ScheduleOutputStorageCosOutputStorage {
        /**
         * The bucket to which the output file of media processing is saved, such as `TopRankVideo-125xxx88`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        bucket?: string;
        /**
         * The region of the output bucket, such as `ap-chongqing`. If this parameter is left empty, the value of the upper layer will be inherited.
         */
        region?: string;
    }

    export interface ScheduleOutputStorageS3OutputStorage {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleTaskNotifyConfig {
        /**
         * The AWS SQS queue. This parameter is required if `NotifyType` is `AWS-SQS`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsSqs?: outputs.Mps.ScheduleTaskNotifyConfigAwsSqs;
        /**
         * The CMQ or TDMQ-CMQ model. Valid values: Queue, Topic.
         */
        cmqModel?: string;
        /**
         * The CMQ or TDMQ-CMQ region, such as `sh` (Shanghai) or `bj` (Beijing).
         */
        cmqRegion?: string;
        /**
         * Workflow notification method. Valid values: Finish, Change. If this parameter is left empty, `Finish` will be used.
         */
        notifyMode: string;
        /**
         * The notification type. Valid values: `CMQ`: This value is no longer used. Please use `TDMQ-CMQ` instead. `TDMQ-CMQ`: Message queue `URL`: If `NotifyType` is set to `URL`, HTTP callbacks are sent to the URL specified by `NotifyUrl`. HTTP and JSON are used for the callbacks. The packet contains the response parameters of the `ParseNotification` API. `SCF`: This notification type is not recommended. You need to configure it in the SCF console. `AWS-SQS`: AWS queue. This type is only supported for AWS tasks, and the queue must be in the same region as the AWS bucket.Note: If you do not pass this parameter or pass in an empty string, `CMQ` will be used. To use a different notification type, specify this parameter accordingly.
         */
        notifyType: string;
        /**
         * HTTP callback URL, required if `NotifyType` is set to `URL`.
         */
        notifyUrl?: string;
        /**
         * The CMQ or TDMQ-CMQ queue to receive notifications. This parameter is valid when `CmqModel` is `Queue`.
         */
        queueName?: string;
        /**
         * The CMQ or TDMQ-CMQ topic to receive notifications. This parameter is valid when `CmqModel` is `Topic`.
         */
        topicName?: string;
    }

    export interface ScheduleTaskNotifyConfigAwsSqs {
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
        /**
         * The name of the SQS queue.
         */
        sqsQueueName: string;
        /**
         * The region of the SQS queue.
         */
        sqsRegion: string;
    }

    export interface ScheduleTrigger {
        /**
         * The AWS S3 trigger. This parameter is valid and required if `Type` is `AwsS3FileUpload`.Note: Currently, the key for the AWS S3 bucket, the trigger SQS queue, and the callback SQS queue must be the same.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsS3FileUploadTrigger?: outputs.Mps.ScheduleTriggerAwsS3FileUploadTrigger;
        /**
         * This parameter is required and valid when `Type` is `CosFileUpload`, indicating the COS trigger rule.Note: This field may return null, indicating that no valid values can be obtained.
         */
        cosFileUploadTrigger?: outputs.Mps.ScheduleTriggerCosFileUploadTrigger;
        /**
         * The trigger type. Valid values: `CosFileUpload`: Tencent Cloud COS trigger. `AwsS3FileUpload`: AWS S3 trigger. Currently, this type is only supported for transcoding tasks and schemes (not supported for workflows).
         */
        type: string;
    }

    export interface ScheduleTriggerAwsS3FileUploadTrigger {
        /**
         * The AWS SQS queue. This parameter is required if `NotifyType` is `AWS-SQS`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsSqs?: outputs.Mps.ScheduleTriggerAwsS3FileUploadTriggerAwsSqs;
        /**
         * Input path directory bound to a workflow, such as `/movie/201907/`. If this parameter is left empty, the `/` root directory will be used.
         */
        dir?: string;
        /**
         * Format list of files that can trigger a workflow, such as [mp4, flv, mov]. If this parameter is left empty, files in all formats can trigger the workflow.
         */
        formats?: string[];
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to access the AWS S3 object.
         */
        s3SecretId?: string;
        /**
         * The key required to access the AWS S3 object.
         */
        s3SecretKey?: string;
    }

    export interface ScheduleTriggerAwsS3FileUploadTriggerAwsSqs {
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
        /**
         * The name of the SQS queue.
         */
        sqsQueueName: string;
        /**
         * The region of the SQS queue.
         */
        sqsRegion: string;
    }

    export interface ScheduleTriggerCosFileUploadTrigger {
        /**
         * Name of the COS bucket bound to a workflow, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * Input path directory bound to a workflow, such as `/movie/201907/`. If this parameter is left empty, the `/` root directory will be used.
         */
        dir?: string;
        /**
         * Format list of files that can trigger a workflow, such as [mp4, flv, mov]. If this parameter is left empty, files in all formats can trigger the workflow.
         */
        formats?: string[];
        /**
         * Region of the COS bucket bound to a workflow, such as `ap-chongiqng`.
         */
        region: string;
    }

    export interface TranscodeTemplateAudioTemplate {
        /**
         * Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
         */
        audioChannel?: number;
        /**
         * Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
         */
        bitrate: number;
        /**
         * Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
         */
        codec: string;
        /**
         * Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
         */
        sampleRate: number;
    }

    export interface TranscodeTemplateEnhanceConfig {
        /**
         * Video Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        videoEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhance;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhance {
        /**
         * De-artifact (glitch) configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        artifactRepair?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair;
        /**
         * Color Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        colorEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance;
        /**
         * Video Noise Reduction Configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        denoise?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceDenoise;
        /**
         * Face Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        faceEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance;
        /**
         * Interpolation frame rate configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        frameRate?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate;
        /**
         * HDR configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        hdr?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceHdr;
        /**
         * Comprehensive Enhanced Configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        imageQualityEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance;
        /**
         * Low Light Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        lowLightEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance;
        /**
         * De-scratch configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        scratchRepair?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair;
        /**
         * Detail Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        sharpEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance;
        /**
         * Super resolution configuration.Note: This field may return null, indicating that no valid value can be obtained.
         */
        superResolution?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair {
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
        /**
         * Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance {
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
        /**
         * Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceDenoise {
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
        /**
         * Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance {
        /**
         * Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
         */
        intensity?: number;
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate {
        /**
         * Frame rate, value range: [0, 100], unit: Hz.Default value: 0.Note: For transcoding, this parameter will override the Fps inside the VideoTemplate.Note: This field may return null, indicating that no valid value can be obtained.
         */
        fps?: number;
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceHdr {
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
        /**
         * Type, optional value: HDR10/HLG.Default value: HDR10.Note: The encoding method of video needs to be libx265.Note: Video encoding bit depth is 10.Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance {
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
        /**
         * Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance {
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
        /**
         * Type, optional value: normal.Default value: normal.Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair {
        /**
         * Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
         */
        intensity?: number;
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance {
        /**
         * Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
         */
        intensity?: number;
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution {
        /**
         * Super resolution multiple, optional value:2: currently only supports 2x super resolution.Default value: 2.Note: This field may return null, indicating that no valid value can be obtained.
         */
        size?: number;
        /**
         * Capability configuration switch, optional value: ON/OFF.Default value: ON.
         */
        switch?: string;
        /**
         * Type, optional value:lq: super-resolution for low-definition video with more noise.hq: super resolution for high-definition video.Default value: lq.Note: This field may return null, indicating that no valid value can be obtained.
         */
        type?: string;
    }

    export interface TranscodeTemplateTehdConfig {
        /**
         * The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
         */
        maxVideoBitrate?: number;
        /**
         * Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
         */
        type: string;
    }

    export interface TranscodeTemplateVideoTemplate {
        /**
         * Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
         */
        bitrate: number;
        /**
         * Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
         */
        codec: string;
        /**
         * Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
         */
        fillType?: string;
        /**
         * Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
         */
        fps: number;
        /**
         * The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
         */
        gop?: number;
        /**
         * The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
         */
        height?: number;
        /**
         * Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
         */
        resolutionAdaptive?: string;
        /**
         * Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
         */
        vcrf?: number;
        /**
         * The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
         */
        width?: number;
    }

    export interface WatermarkTemplateImageTemplate {
        /**
         * The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels. The value range is 0 or [8, 4096].Default value: 0px. Indicates that Height is scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * Watermark image[Base64](https://tools.ietf.org/html/rfc4648) encoded string. Support jpeg, png image format.
         */
        imageContent: string;
        /**
         * Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges:once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
         */
        repeatType?: string;
        /**
         * The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixel, such as 100px means that the Width is 100 pixels. The value range is [8, 4096].Default value: 10%.
         */
        width?: string;
    }

    export interface WatermarkTemplateSvgTemplate {
        /**
         * The height of the watermark, supports px, W%, H%, S%, L% six formats:When the string ends with px, it means that the watermark Height unit is pixels, such as 100px means that the Height is 100 pixels; when filling 0px and Width is not 0px, it means that the height of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the height of the watermark takes the height of the original SVG image.When the string ends with W%, it means that the watermark Height is a percentage of the video width, such as 10W% means that the Height is 10% of the video width.When the string ends with H%, it means that the watermark Height is the percentage size of the video height, such as 10H% means that the Height is 10% of the video height.When the string ends with S%, it means that the watermark Height is the percentage size of the short side of the video, such as 10S% means that the Height is 10% of the short side of the video.When the string ends with L%, it means that the watermark Height is the percentage size of the long side of the video, such as 10L% means that the Height is 10% of the long side of the video.When the string ends with %, the meaning is the same as H%.Default value: 0px.
         */
        height?: string;
        /**
         * The width of the watermark, supports px, %, W%, H%, S%, L% six formats.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels; when filling 0px and the Height is not 0px, it means that the width of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the width of the watermark takes the width of the original SVG image.When the string ends with W%, it means that the watermark Width is a percentage of the video width, such as 10W% means that the Width is 10% of the video width.When the string ends with H%, it means that the watermark Width is a percentage of the video height, such as 10H% means that the Width is 10% of the video height.When the string ends with S%, it means that the watermark Width is the percentage size of the short side of the video, such as 10S% means that the Width is 10% of the short side of the video.When the string ends with L%, it means that the watermark Width is the percentage size of the long side of the video, such as 10L% means that the Width is 10% of the long side of the video.When the string ends with %, it has the same meaning as W%.Default value: 10W%.
         */
        width?: string;
    }

    export interface WatermarkTemplateTextTemplate {
        /**
         * Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default value: 1.
         */
        fontAlpha: number;
        /**
         * Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
         */
        fontColor: string;
        /**
         * Font size, format: Npx, N is a number.
         */
        fontSize: string;
        /**
         * Font type, currently supports two:simkai.ttf: can support Chinese and English.arial.ttf: English only.
         */
        fontType: string;
    }

    export interface WithdrawsWatermarkOperationInputInfo {
        /**
         * The information of the COS object to process. This parameter is valid and required when `Type` is `COS`.
         */
        cosInputInfo?: outputs.Mps.WithdrawsWatermarkOperationInputInfoCosInputInfo;
        /**
         * The information of the AWS S3 object processed. This parameter is required if `Type` is `AWS-S3`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        s3InputInfo?: outputs.Mps.WithdrawsWatermarkOperationInputInfoS3InputInfo;
        /**
         * The input type. Valid values: `COS`: A COS bucket address.  `URL`: A URL.  `AWS-S3`: An AWS S3 bucket address. Currently, this type is only supported for transcoding tasks..
         */
        type: string;
        /**
         * The URL of the object to process. This parameter is valid and required when `Type` is `URL`.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.WithdrawsWatermarkOperationInputInfoUrlInputInfo;
    }

    export interface WithdrawsWatermarkOperationInputInfoCosInputInfo {
        /**
         * The COS bucket of the object to process, such as `TopRankVideo-125xxx88`.
         */
        bucket: string;
        /**
         * The path of the object to process, such as `/movie/201907/WildAnimal.mov`.
         */
        object: string;
        /**
         * The region of the COS bucket, such as `ap-chongqing`.
         */
        region: string;
    }

    export interface WithdrawsWatermarkOperationInputInfoS3InputInfo {
        /**
         * The AWS S3 bucket.
         */
        s3Bucket: string;
        /**
         * The path of the AWS S3 object.
         */
        s3Object: string;
        /**
         * The region of the AWS S3 bucket.
         */
        s3Region: string;
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
    }

    export interface WithdrawsWatermarkOperationInputInfoUrlInputInfo {
        /**
         * URL of a video.
         */
        url: string;
    }

    export interface WithdrawsWatermarkOperationTaskNotifyConfig {
        /**
         * The AWS SQS queue. This parameter is required if `NotifyType` is `AWS-SQS`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        awsSqs?: outputs.Mps.WithdrawsWatermarkOperationTaskNotifyConfigAwsSqs;
        /**
         * The CMQ or TDMQ-CMQ model. Valid values: Queue, Topic.
         */
        cmqModel?: string;
        /**
         * The CMQ or TDMQ-CMQ region, such as `sh` (Shanghai) or `bj` (Beijing).
         */
        cmqRegion?: string;
        /**
         * Workflow notification method. Valid values: Finish, Change. If this parameter is left empty, `Finish` will be used.
         */
        notifyMode?: string;
        /**
         * The notification type. Valid values:  `CMQ`: This value is no longer used. Please use `TDMQ-CMQ` instead.  `TDMQ-CMQ`: Message queue  `URL`: If `NotifyType` is set to `URL`, HTTP callbacks are sent to the URL specified by `NotifyUrl`. HTTP and JSON are used for the callbacks. The packet contains the response parameters of the `ParseNotification` API.  `SCF`: This notification type is not recommended. You need to configure it in the SCF console.  `AWS-SQS`: AWS queue. This type is only supported for AWS tasks, and the queue must be in the same region as the AWS bucket. Note: If you do not pass this parameter or pass in an empty string, `CMQ` will be used. To use a different notification type, specify this parameter accordingly.
         */
        notifyType?: string;
        /**
         * HTTP callback URL, required if `NotifyType` is set to `URL`.
         */
        notifyUrl?: string;
        /**
         * The CMQ or TDMQ-CMQ queue to receive notifications. This parameter is valid when `CmqModel` is `Queue`.
         */
        queueName?: string;
        /**
         * The CMQ or TDMQ-CMQ topic to receive notifications. This parameter is valid when `CmqModel` is `Topic`.
         */
        topicName?: string;
    }

    export interface WithdrawsWatermarkOperationTaskNotifyConfigAwsSqs {
        /**
         * The key ID required to read from/write to the SQS queue.
         */
        s3SecretId?: string;
        /**
         * The key required to read from/write to the SQS queue.
         */
        s3SecretKey?: string;
        /**
         * The name of the SQS queue.
         */
        sqsQueueName: string;
        /**
         * The region of the SQS queue.
         */
        sqsRegion: string;
    }

    export interface WorkflowAiAnalysisTask {
        /**
         * Video Content Analysis Template ID.
         */
        definition: number;
        /**
         * Extension parameter whose value is a serialized json string.Note: This parameter is a customized demand parameter, which requires offline docking.Note: This field may return null, indicating that no valid value can be obtained.
         */
        extendedParameter?: string;
    }

    export interface WorkflowAiContentReviewTask {
        /**
         * Video Content Review Template ID.
         */
        definition: number;
    }

    export interface WorkflowAiRecognitionTask {
        /**
         * Video Intelligent Recognition Template ID.
         */
        definition: number;
    }

    export interface WorkflowMediaProcessTask {
        /**
         * Transfer Adaptive Code Stream Task List.
         */
        adaptiveDynamicStreamingTaskSets?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet[];
        /**
         * Video Rotation Map Task List.
         */
        animatedGraphicTaskSets?: outputs.Mps.WorkflowMediaProcessTaskAnimatedGraphicTaskSet[];
        /**
         * Sprite image capture task list for video.
         */
        imageSpriteTaskSets?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSet[];
        /**
         * Screenshot task list for video sampling.
         */
        sampleSnapshotTaskSets?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSet[];
        /**
         * Screenshot the task list of the video according to the time point.
         */
        snapshotByTimeOffsetTaskSets?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet[];
        /**
         * Video Transcoding Task List.
         */
        transcodeTaskSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSet[];
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet {
        /**
         * Transfer Adaptive Code Stream Template ID.
         */
        definition: number;
        /**
         * After converting to an adaptive stream, the output path of the manifest file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * The target storage of the file after converting to the adaptive code stream, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage;
        /**
         * After converting to an adaptive stream (only HLS), the output path of the fragmented file can only be a relative path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}_{segmentNumber}.{format}`.
         */
        segmentObjectName?: string;
        /**
         * After converting to an adaptive stream, the output path of the sub-stream file can only be a relative path. If not filled, the default is a relative path: {inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
         */
        subStreamObjectName?: string;
        /**
         * Watermark list, support multiple pictures or text watermarks, up to 10.
         */
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage {
        /**
         * Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage;
        /**
         * The type of media processing output object storage location, now only supports COS.
         */
        type: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage {
        /**
         * The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
         */
        bucket?: string;
        /**
         * The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
         */
        region?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet {
        /**
         * Watermark Template ID.
         */
        definition: number;
        /**
         * End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
         */
        endTimeOffset?: number;
        /**
         * Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
         */
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter;
        /**
         * The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
         */
        startTimeOffset?: number;
        /**
         * SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
         */
        svgContent?: string;
        /**
         * Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
         */
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
         */
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type, optional value:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
         */
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * The input content of the watermark image. Support jpeg, png image format.
         */
        imageContent: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
         */
        repeatType?: string;
        /**
         * The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
         */
        width?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * Valid when Type is COS, this item is required, indicating media processing COS object information.
         */
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * Enter the type of source object, which supports COS and URL.
         */
        type: string;
        /**
         * Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The name of the COS Bucket where the media processing object file is located.
         */
        bucket: string;
        /**
         * Input path for media processing object files.
         */
        object: string;
        /**
         * The park to which the COS Bucket where the media processing target file resides belongs.
         */
        region: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * Video URL.
         */
        url: string;
    }

    export interface WorkflowMediaProcessTaskAnimatedGraphicTaskSet {
        /**
         * Video turntable template id.
         */
        definition: number;
        /**
         * The end time of the animation in the video, in seconds.
         */
        endTimeOffset: number;
        /**
         * The output path of the file after rotating the image, which can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_animatedGraphic_{definition}.{format}.
         */
        outputObjectPath?: string;
        /**
         * The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage;
        /**
         * The start time of the animation in the video, in seconds.
         */
        startTimeOffset: number;
    }

    export interface WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage {
        /**
         * Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage;
        /**
         * The type of media processing output object storage location, now only supports COS.
         */
        type: string;
    }

    export interface WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage {
        /**
         * The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
         */
        bucket?: string;
        /**
         * The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
         */
        region?: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSet {
        /**
         * Sprite Illustration Template ID.
         */
        definition: number;
        /**
         * Rules for the `{number}` variable in the output path after intercepting the Sprite image.Note: This field may return null, indicating that no valid value can be obtained.
         */
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat;
        /**
         * After capturing the sprite image, the output path of the sprite image file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * The target storage of the file after the sprite image is intercepted, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage;
        /**
         * After capturing the sprite image, the output path of the Web VTT file can only be a relative path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}.{format}`.
         */
        webVttObjectName?: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat {
        /**
         * The growth step of the `{number}` variable, the default is 1.
         */
        increment?: number;
        /**
         * The starting value of `{number}` variable, the default is 0.
         */
        initialValue?: number;
        /**
         * The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
         */
        minLength?: number;
        /**
         * When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
         */
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage {
        /**
         * Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage;
        /**
         * The type of media processing output object storage location, now only supports COS.
         */
        type: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage {
        /**
         * The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
         */
        bucket?: string;
        /**
         * The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
         */
        region?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSet {
        /**
         * Sample screenshot template ID.
         */
        definition: number;
        /**
         * Rules for the `{number}` variable in the output path after sampling the screenshot.Note: This field may return null, indicating that no valid value can be obtained.
         */
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat;
        /**
         * The output path of the image file after sampling the screenshot, which can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_sampleSnapshot_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage;
        /**
         * Watermark list, support multiple pictures or text watermarks, up to 10.
         */
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat {
        /**
         * The growth step of the `{number}` variable, the default is 1.
         */
        increment?: number;
        /**
         * The starting value of `{number}` variable, the default is 0.
         */
        initialValue?: number;
        /**
         * The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
         */
        minLength?: number;
        /**
         * When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
         */
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage {
        /**
         * Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage;
        /**
         * The type of media processing output object storage location, now only supports COS.
         */
        type: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage {
        /**
         * The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
         */
        bucket?: string;
        /**
         * The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
         */
        region?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet {
        /**
         * Watermark Template ID.
         */
        definition: number;
        /**
         * End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
         */
        endTimeOffset?: number;
        /**
         * Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
         */
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter;
        /**
         * The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
         */
        startTimeOffset?: number;
        /**
         * SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
         */
        svgContent?: string;
        /**
         * Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
         */
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
         */
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type, optional value:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
         */
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * The input content of the watermark image. Support jpeg, png image format.
         */
        imageContent: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
         */
        repeatType?: string;
        /**
         * The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
         */
        width?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * Valid when Type is COS, this item is required, indicating media processing COS object information.
         */
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * Enter the type of source object, which supports COS and URL.
         */
        type: string;
        /**
         * Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The name of the COS Bucket where the media processing object file is located.
         */
        bucket: string;
        /**
         * Input path for media processing object files.
         */
        object: string;
        /**
         * The park to which the COS Bucket where the media processing target file resides belongs.
         */
        region: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * Video URL.
         */
        url: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet {
        /**
         * Specified time point screenshot template ID.
         */
        definition: number;
        /**
         * Screenshot time point list, the time point supports two formats: s and %:;When the string ends with s, it means that the time point is in seconds, such as 3.5s means that the time point is the 3.5th second.When the string ends with %, it means that the time point is the percentage of the video duration, such as 10% means that the time point is the first 10% of the time in the video.
         */
        extTimeOffsetSets?: string[];
        /**
         * Rules for the `{number}` variable in the output path after the screenshot at the time point.Note: This field may return null, indicating that no valid value can be obtained.
         */
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat;
        /**
         * The output path of the picture file after the snapshot at the time point can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_snapshotByTimeOffset_{definition}_{number}.{format}`.
         */
        outputObjectPath?: string;
        /**
         * The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage;
        /**
         * Screenshot time point list, the unit is &lt;font color=red&gt;seconds&lt;/font&gt;. This parameter is no longer recommended, it is recommended that you use the ExtTimeOffsetSet parameter.
         */
        timeOffsetSets?: number[];
        /**
         * Watermark list, support multiple pictures or text watermarks, up to 10.
         */
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat {
        /**
         * The growth step of the `{number}` variable, the default is 1.
         */
        increment?: number;
        /**
         * The starting value of `{number}` variable, the default is 0.
         */
        initialValue?: number;
        /**
         * The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
         */
        minLength?: number;
        /**
         * When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
         */
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage {
        /**
         * Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage;
        /**
         * The type of media processing output object storage location, now only supports COS.
         */
        type: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage {
        /**
         * The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
         */
        bucket?: string;
        /**
         * The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
         */
        region?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet {
        /**
         * Watermark Template ID.
         */
        definition: number;
        /**
         * End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
         */
        endTimeOffset?: number;
        /**
         * Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
         */
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter;
        /**
         * The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
         */
        startTimeOffset?: number;
        /**
         * SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
         */
        svgContent?: string;
        /**
         * Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
         */
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
         */
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type, optional value:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
         */
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * The input content of the watermark image. Support jpeg, png image format.
         */
        imageContent: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
         */
        repeatType?: string;
        /**
         * The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
         */
        width?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * Valid when Type is COS, this item is required, indicating media processing COS object information.
         */
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * Enter the type of source object, which supports COS and URL.
         */
        type: string;
        /**
         * Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The name of the COS Bucket where the media processing object file is located.
         */
        bucket: string;
        /**
         * Input path for media processing object files.
         */
        object: string;
        /**
         * The park to which the COS Bucket where the media processing target file resides belongs.
         */
        region: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * Video URL.
         */
        url: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSet {
        /**
         * Video Transcoding Template ID.
         */
        definition: number;
        /**
         * End time offset of video after transcoding, unit: second.Do not fill in or fill in 0, indicating that the transcoded video continues until the end of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video lasts until the nth second of the original video and terminates.When the value is less than 0 (assumed to be -n), it means that the transcoded video lasts until n seconds before the end of the original video.
         */
        endTimeOffset?: number;
        /**
         * Opening and ending parameters.Note: This field may return null, indicating that no valid value can be obtained.
         */
        headTailParameter?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter;
        /**
         * Mosaic list, up to 10 sheets can be supported.
         */
        mosaicSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet[];
        /**
         * Rules for the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid value can be obtained.
         */
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat;
        /**
         * The output path of the main file after transcoding can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_transcode_{definition}.{format}.
         */
        outputObjectPath?: string;
        /**
         * The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
         */
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage;
        /**
         * Video transcoding custom parameters, valid when Definition is not filled with 0.When some transcoding parameters in this structure are filled in, the parameters in the transcoding template will be overwritten with the filled parameters.This parameter is used in highly customized scenarios, it is recommended that you only use Definition to specify transcoding parameters.Note: This field may return null, indicating that no valid value can be obtained.
         */
        overrideParameter?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter;
        /**
         * Video transcoding custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios. It is recommended that you use Definition to specify transcoding parameters first.Note: This field may return null, indicating that no valid value can be obtained.
         */
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameter;
        /**
         * The output path of the transcoded fragment file (the path of ts when transcoding HLS), can only be a relative path. If not filled, the default is: `{inputName}_transcode_{definition}_{number}.{format}.
         */
        segmentObjectName?: string;
        /**
         * The start time offset of the transcoded video, unit: second.Do not fill in or fill in 0, indicating that the transcoded video starts from the beginning of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video starts from the nth second position of the original video.When the value is less than 0 (assumed to be -n), it means that the transcoded video starts from the position n seconds before the end of the original video.
         */
        startTimeOffset?: number;
        /**
         * Watermark list, support multiple pictures or text watermarks, up to 10.Note: This field may return null, indicating that no valid value can be obtained.
         */
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter {
        /**
         * Title list.
         */
        headSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet[];
        /**
         * Ending List.
         */
        tailSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet[];
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet {
        /**
         * Valid when Type is COS, this item is required, indicating media processing COS object information.
         */
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo;
        /**
         * Enter the type of source object, which supports COS and URL.
         */
        type: string;
        /**
         * Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo {
        /**
         * The name of the COS Bucket where the media processing object file is located.
         */
        bucket: string;
        /**
         * Input path for media processing object files.
         */
        object: string;
        /**
         * The park to which the COS Bucket where the media processing target file resides belongs.
         */
        region: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo {
        /**
         * Video URL.
         */
        url: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet {
        /**
         * Valid when Type is COS, this item is required, indicating media processing COS object information.
         */
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo;
        /**
         * Enter the type of source object, which supports COS and URL.
         */
        type: string;
        /**
         * Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo {
        /**
         * The name of the COS Bucket where the media processing object file is located.
         */
        bucket: string;
        /**
         * Input path for media processing object files.
         */
        object: string;
        /**
         * The park to which the COS Bucket where the media processing target file resides belongs.
         */
        region: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo {
        /**
         * Video URL.
         */
        url: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet {
        /**
         * Origin position, currently only supports:TopLeft: Indicates that the coordinate origin is located in the upper left corner of the video image, and the origin of the mosaic is the upper left corner of the picture or textDefault: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * The end time offset of the mosaic, unit: second.Fill in or fill in 0, indicating that the mosaic continues until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the mosaic lasts until it disappears n seconds before the end of the screen.
         */
        endTimeOffset?: number;
        /**
         * The height of the mosaic. Support %, px two formats.When the string ends with %, it means that the mosaic Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the mosaic Height unit is pixel, such as 100px means that the Height is 100 pixels.Default: 10%.
         */
        height?: string;
        /**
         * The start time offset of the mosaic, unit: second. Do not fill or fill in 0, which means that the mosaic will start to appear when the screen appears.Fill in or fill in 0, which means that the mosaic will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the mosaic starts to appear n seconds before the end of the screen.
         */
        startTimeOffset?: number;
        /**
         * The width of the mosaic. Support %, px two formats:When the string ends with %, it means that the mosaic Width is the percentage size of the video width, such as 10% means that the Width is 10% of the video width.The string ends with px, indicating that the mosaic Width unit is pixels, such as 100px indicates that the Width is 100 pixels.Default: 10%.
         */
        width?: string;
        /**
         * The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
         */
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat {
        /**
         * The growth step of the `{number}` variable, the default is 1.
         */
        increment?: number;
        /**
         * The starting value of `{number}` variable, the default is 0.
         */
        initialValue?: number;
        /**
         * The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
         */
        minLength?: number;
        /**
         * When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
         */
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage {
        /**
         * Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage;
        /**
         * The type of media processing output object storage location, now only supports COS.
         */
        type: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage {
        /**
         * The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
         */
        bucket?: string;
        /**
         * The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
         */
        region?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter {
        /**
         * Audio stream configuration parameters.
         */
        audioTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate;
        /**
         * Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
         */
        container?: string;
        /**
         * Whether to remove audio data, value:0: reserved.1: remove.
         */
        removeAudio?: number;
        /**
         * Whether to remove video data, value:0: reserved.1: remove.
         */
        removeVideo?: number;
        /**
         * Subtitle Stream Configuration Parameters.
         */
        subtitleTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate;
        /**
         * Ultra-fast HD transcoding parameters.
         */
        tehdConfig?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig;
        /**
         * Video streaming configuration parameters.
         */
        videoTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate {
        /**
         * Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
         */
        audioChannel?: number;
        /**
         * Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
         */
        bitrate?: number;
        /**
         * Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
         */
        codec?: string;
        /**
         * Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
         */
        sampleRate?: number;
        /**
         * Specifies the audio track to preserve for the output. The default is to keep all sources.
         */
        streamSelects?: number[];
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate {
        /**
         * Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default: 1.
         */
        fontAlpha?: number;
        /**
         * Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
         */
        fontColor?: string;
        /**
         * Font size, format: Npx, N is a value, if not specified, the subtitle file shall prevail.
         */
        fontSize?: string;
        /**
         * Font type.hei.ttf, song.ttf, simkai.ttf, arial.ttf.Default: hei.ttf.
         */
        fontType?: string;
        /**
         * The address of the subtitle file to be compressed into the video.
         */
        path?: string;
        /**
         * Specifies the subtitle track to be compressed into the video. If there is a specified Path, the Path has a higher priority. Path and StreamIndex specify at least one.
         */
        streamIndex?: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig {
        /**
         * The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
         */
        maxVideoBitrate?: number;
        /**
         * Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
         */
        type?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate {
        /**
         * Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
         */
        bitrate?: number;
        /**
         * Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
         */
        codec?: string;
        /**
         * Content Adaptive Encoding. optional value:0: not open.1: open.Default: 0.When this parameter is turned on, multiple code streams with different resolutions and different bit rates will be adaptively generated. The width and height of the VideoTemplate are the maximum resolutions among the multiple code streams, and the bit rates in the VideoTemplate are multiple code rates. The highest bit rate in the stream, the vcrf in VideoTemplate is the highest quality among multiple bit streams. When the resolution, bit rate and vcrf are not set, the highest resolution generated by the ContentAdaptStream parameter is the resolution of the video source, and the video quality is close to vmaf95. To enable this parameter or learn about billing details, please contact your Tencent Cloud Business.
         */
        contentAdaptStream?: number;
        /**
         * Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
         */
        fillType?: string;
        /**
         * Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
         */
        fps?: number;
        /**
         * The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
         */
        gop?: number;
        /**
         * The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
         */
        height?: number;
        /**
         * Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
         */
        resolutionAdaptive?: string;
        /**
         * Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
         */
        vcrf?: number;
        /**
         * The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
         */
        width?: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameter {
        /**
         * Audio stream configuration parameters, when RemoveAudio is 0, this field is required.
         */
        audioTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate;
        /**
         * Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
         */
        container: string;
        /**
         * Whether to remove audio data, value:0: reserved.1: remove.Default: 0.
         */
        removeAudio?: number;
        /**
         * Whether to remove video data, value:0: reserved.1: remove.Default: 0.
         */
        removeVideo?: number;
        /**
         * Ultra-fast HD transcoding parameters.
         */
        tehdConfig?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig;
        /**
         * Video stream configuration parameters, when RemoveVideo is 0, this field is required.
         */
        videoTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate {
        /**
         * Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
         */
        audioChannel?: number;
        /**
         * Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
         */
        bitrate: number;
        /**
         * Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
         */
        codec: string;
        /**
         * Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
         */
        sampleRate: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig {
        /**
         * The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
         */
        maxVideoBitrate?: number;
        /**
         * Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
         */
        type: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate {
        /**
         * Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
         */
        bitrate: number;
        /**
         * Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
         */
        codec: string;
        /**
         * Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
         */
        fillType?: string;
        /**
         * Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
         */
        fps: number;
        /**
         * The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
         */
        gop?: number;
        /**
         * The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
         */
        height?: number;
        /**
         * Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
         */
        resolutionAdaptive?: string;
        /**
         * Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
         */
        vcrf?: number;
        /**
         * The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
         */
        width?: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet {
        /**
         * Watermark Template ID.
         */
        definition: number;
        /**
         * End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
         */
        endTimeOffset?: number;
        /**
         * Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
         */
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter;
        /**
         * The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
         */
        startTimeOffset?: number;
        /**
         * SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
         */
        svgContent?: string;
        /**
         * Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
         */
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter {
        /**
         * Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
         */
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate;
        /**
         * Watermark type, optional value:image: image watermark.
         */
        type: string;
        /**
         * The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
         */
        xPos?: string;
        /**
         * The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
         */
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate {
        /**
         * The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
         */
        height?: string;
        /**
         * The input content of the watermark image. Support jpeg, png image format.
         */
        imageContent: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        /**
         * Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
         */
        repeatType?: string;
        /**
         * The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
         */
        width?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        /**
         * Valid when Type is COS, this item is required, indicating media processing COS object information.
         */
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        /**
         * Enter the type of source object, which supports COS and URL.
         */
        type: string;
        /**
         * Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
         */
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        /**
         * The name of the COS Bucket where the media processing object file is located.
         */
        bucket: string;
        /**
         * Input path for media processing object files.
         */
        object: string;
        /**
         * The park to which the COS Bucket where the media processing target file resides belongs.
         */
        region: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        /**
         * Video URL.
         */
        url: string;
    }

    export interface WorkflowOutputStorage {
        /**
         * Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosOutputStorage?: outputs.Mps.WorkflowOutputStorageCosOutputStorage;
        /**
         * The type of media processing output object storage location, now only supports COS.
         */
        type: string;
    }

    export interface WorkflowOutputStorageCosOutputStorage {
        /**
         * The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
         */
        bucket?: string;
        /**
         * The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
         */
        region?: string;
    }

    export interface WorkflowTaskNotifyConfig {
        /**
         * CMQ or TDMQ-CMQ model, there are two kinds of Queue and Topic.
         */
        cmqModel?: string;
        /**
         * Region of CMQ or TDMQ-CMQ, such as sh, bj, etc.
         */
        cmqRegion?: string;
        /**
         * The mode of the workflow notification, the possible values are Finish and Change, leaving blank means Finish.
         */
        notifyMode?: string;
        /**
         * Notification type, optional value:CMQ: offline, it is recommended to switch to TDMQ-CMQ.TDMQ-CMQ: message queue.URL: When the URL is specified, the HTTP callback is pushed to the address specified by NotifyUrl, the callback protocol is http+json, and the package body content is the same as the output parameters of the parsing event notification interface.SCF: not recommended, additional configuration of SCF in the console is required.Note: CMQ is the default when not filled or empty, if you need to use other types, you need to fill in the corresponding type value.
         */
        notifyType?: string;
        /**
         * HTTP callback address, required when NotifyType is URL.
         */
        notifyUrl?: string;
        /**
         * Valid when the model is Queue, indicating the queue name of the CMQ or TDMQ-CMQ that receives the event notification.
         */
        queueName?: string;
        /**
         * Valid when the model is a Topic, indicating the topic name of the CMQ or TDMQ-CMQ that receives event notifications.
         */
        topicName?: string;
    }

    export interface WorkflowTrigger {
        /**
         * Mandatory and valid when Type is CosFileUpload, the rule is triggered for COS.Note: This field may return null, indicating that no valid value can be obtained.
         */
        cosFileUploadTrigger?: outputs.Mps.WorkflowTriggerCosFileUploadTrigger;
        /**
         * The type of trigger, currently only supports CosFileUpload.
         */
        type: string;
    }

    export interface WorkflowTriggerCosFileUploadTrigger {
        /**
         * The name of the COS Bucket bound to the workflow.
         */
        bucket: string;
        /**
         * The input path directory of the workflow binding must be an absolute path, that is, start and end with `/`.
         */
        dir?: string;
        /**
         * A list of file formats that are allowed to be triggered by the workflow, if not filled in, it means that files of all formats can trigger the workflow.
         */
        formats: string[];
        /**
         * The park to which the COS Bucket bound to the workflow belongs.
         */
        region: string;
    }

}

export namespace Mysql {
    export interface AuditLogFileFilter {
        /**
         * Affects the number of rows. Indicates to filter audit logs whose number of affected rows is greater than this value.
         */
        affectRows?: number;
        /**
         * Database name.
         */
        dbNames?: string[];
        /**
         * Execution time. The unit is: ms. Indicates to filter audit logs whose execution time is greater than this value.
         */
        execTime?: number;
        /**
         * Client address.
         */
        hosts?: string[];
        /**
         * The name of policy.
         */
        policyNames?: string[];
        /**
         * SQL statement. support fuzzy matching.
         */
        sql?: string;
        /**
         * SQL type. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
         */
        sqlType?: string;
        /**
         * SQL type. Supports simultaneous query of multiple types. Currently supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, SET, REPLACE, EXECUTE.
         */
        sqlTypes?: string[];
        /**
         * SQL statement. Support passing multiple sql statements.
         */
        sqls?: string[];
        /**
         * Table name.
         */
        tableNames?: string[];
        /**
         * User name.
         */
        users?: string[];
    }

    export interface BackupDownloadRestrictionLimitVpc {
        /**
         * Restrict downloads from regions. Currently only the current region is supported.
         */
        region: string;
        /**
         * List of vpcs to limit downloads.
         */
        vpcLists: string[];
    }

    export interface GetBackupListList {
        /**
         * ID of Backup task.
         */
        backupId: number;
        /**
         * Backup method. Supported values include: `physical` - physical backup, and `logical` - logical backup.
         */
        backupModel: string;
        /**
         * The owner of the backup files.
         */
        creator: string;
        /**
         * The time at which the backup finishes.
         */
        finishTime: string;
        /**
         * URL for downloads externally.
         */
        internetUrl: string;
        /**
         * URL for downloads internally.
         */
        intranetUrl: string;
        /**
         * the size of backup file.
         */
        size: number;
        /**
         * The earliest time at which the backup starts. For example, `2` indicates 2:00 am.
         */
        time: string;
    }

    export interface GetBackupSummariesItem {
        /**
         * The number of automatic data backups for this instance.
         */
        autoBackupCount: number;
        /**
         * The automatic data backup capacity of this instance.
         */
        autoBackupVolume: number;
        /**
         * The total backup (including data backup and log backup) of the instance occupies capacity.
         */
        backupVolume: number;
        /**
         * The number of log backups for this instance.
         */
        binlogBackupCount: number;
        /**
         * The capacity of the instance log backup.
         */
        binlogBackupVolume: number;
        /**
         * The total number of data backups (including automatic backups and manual backups) of the instance.
         */
        dataBackupCount: number;
        /**
         * The total data backup capacity of this instance.
         */
        dataBackupVolume: number;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * The number of manual data backups for this instance.
         */
        manualBackupCount: number;
        /**
         * The capacity of manual data backup for this instance.
         */
        manualBackupVolume: number;
    }

    export interface GetBinLogItem {
        /**
         * binlog file deadline.
         */
        binlogFinishTime: string;
        /**
         * Binlog file start time.
         */
        binlogStartTime: string;
        /**
         * Storage method, 0-regular storage, 1-archive storage, the default is 0.
         */
        cosStorageType: number;
        /**
         * File storage time, time format: 2016-03-17 02:10:37.
         */
        date: string;
        /**
         * Instance ID, in the format: cdb-c1nl9rpv. Same instance ID as displayed in the ApsaraDB for Console page.
         */
        instanceId: string;
        /**
         * download link.
         */
        internetUrl: string;
        /**
         * download link.
         */
        intranetUrl: string;
        /**
         * binlog log backup file name.
         */
        name: string;
        /**
         * The region where remote backup is located.
         */
        region: string;
        /**
         * Binlog remote backup details.
         */
        remoteInfos: outputs.Mysql.GetBinLogItemRemoteInfo[];
        /**
         * Backup file size, unit: Byte.
         */
        size: number;
        /**
         * Backup task status. Possible values are `SUCCESS`: backup succeeded, `FAILED`: backup failed, `RUNNING`: backup in progress.
         */
        status: string;
        /**
         * Specific log type, possible values are: binlog - binary log.
         */
        type: string;
    }

    export interface GetBinLogItemRemoteInfo {
        /**
         * End time of remote backup task.
         */
        finishTime: string;
        /**
         * The region where remote backup is located.
         */
        region: string;
        /**
         * Start time of remote backup task.
         */
        startTime: string;
        /**
         * Backup task status. Possible values are `SUCCESS`: backup succeeded, `FAILED`: backup failed, `RUNNING`: backup in progress.
         */
        status: string;
        /**
         * The ID of the remote backup subtask.
         */
        subBackupIds: number[];
        /**
         * download link.
         */
        url: string;
    }

    export interface GetCloneListItem {
        /**
         * Id of the task list corresponding to the clone task.
         */
        cloneJobId: number;
        /**
         * The newly spawned instance Id of the clone task.
         */
        dstInstanceId: string;
        /**
         * Task end time.
         */
        endTime: string;
        /**
         * Id of the region where the cloned instance is located.
         */
        newRegionId: number;
        /**
         * The strategy used by the clone instance includes the following types: timepoint: specify the point-in-time rollback, backupset: specify the backup file rollback.
         */
        rollbackStrategy: string;
        /**
         * The time point when the clone instance is rolled back.
         */
        rollbackTargetTime: string;
        /**
         * The source instance Id of the clone task.
         */
        srcInstanceId: string;
        /**
         * Id of the region where the source instance is located.
         */
        srcRegionId: number;
        /**
         * Task start time.
         */
        startTime: string;
        /**
         * Task status, including the following status: initial, running, wait_complete, success, failed.
         */
        taskStatus: string;
    }

    export interface GetDatabasesDatabaseList {
        /**
         * character set type.
         */
        characterSet: string;
        /**
         * The name of database.
         */
        databaseName: string;
    }

    export interface GetDefaultParamsParamList {
        /**
         * Param current value.
         */
        currentValue: string;
        /**
         * Param default value.
         */
        default: string;
        /**
         * Param description.
         */
        description: string;
        /**
         * Params available values if type of param is enum.
         */
        enumValues: string[];
        /**
         * Param maximum value if type of param is integer.
         */
        max: number;
        /**
         * Param minimum value if type of param is integer.
         */
        min: number;
        /**
         * Param key name.
         */
        name: string;
        /**
         * Indicates weather the database instance reboot if param modified.
         */
        needReboot: number;
        /**
         * Type of param.
         */
        paramType: string;
    }

    export interface GetErrorLogItem {
        /**
         * error details.
         */
        content: string;
        /**
         * The time the error occurred.
         */
        timestamp: number;
    }

    export interface GetInstanceInstanceList {
        /**
         * Auto renew flag. NOTES: Only supported prepay instance.
         */
        autoRenewFlag: number;
        /**
         * Pay type of instance, valid values are `PREPAID` and `POSTPAID`.
         */
        chargeType: string;
        /**
         * CPU count.
         */
        cpuCoreCount: number;
        /**
         * The time at which a instance is created.
         */
        createTime: string;
        /**
         * Expire date of instance. NOTES: Only supported prepay instance.
         */
        deadLineTime: string;
        /**
         * Supported instance model. `HA` - high available version; `Basic` - basic version.
         */
        deviceType: string;
        /**
         * ID list of disaster-recovery type associated with the current instance.
         */
        drInstanceIds: string[];
        /**
         * The version number of the database engine to use. Supported versions include 5.5/5.6/5.7/8.0.
         */
        engineVersion: string;
        /**
         * Initialization mark. Available values: `0` - Uninitialized; `1` - Initialized.
         */
        initFlag: number;
        /**
         * Name of mysql instance.
         */
        instanceName: string;
        /**
         * Instance type. Supported values include: `master` - master instance, `dr` - disaster recovery instance, and `ro` - read-only instance.
         */
        instanceRole: string;
        /**
         * Public network domain name.
         */
        internetHost: string;
        /**
         * Public network port.
         */
        internetPort: number;
        /**
         * Status of public network.
         */
        internetStatus: number;
        /**
         * Instance IP for internal access.
         */
        intranetIp: string;
        /**
         * Transport layer port number for internal purpose.
         */
        intranetPort: number;
        /**
         * Indicates the master instance ID of recovery instances.
         */
        masterInstanceId: string;
        /**
         * Memory size (in MB).
         */
        memorySize: number;
        /**
         * Instance ID, such as `cdb-c1nl9rpv`. It is identical to the instance ID displayed in the database console page.
         */
        mysqlId: string;
        /**
         * It has been deprecated from version 1.36.0. Please use `chargeType` instead. Pay type of instance, `0`: prepay, `1`: postpaid.
         */
        payType: number;
        /**
         * Project ID to which the current instance belongs.
         */
        projectId: number;
        /**
         * read-only instance group.
         */
        roGroups: outputs.Mysql.GetInstanceInstanceListRoGroup[];
        /**
         * ID list of read-only type associated with the current instance.
         */
        roInstanceIds: string[];
        /**
         * Data replication mode. `0` - Async replication; `1` - Semisync replication; `2` - Strongsync replication.
         */
        slaveSyncMode: number;
        /**
         * Instance status. Available values: `0` - Creating; `1` - Running; `4` - Isolating; `5` - Isolated.
         */
        status: number;
        /**
         * ID of subnet to which the current instance belongs.
         */
        subnetId: string;
        /**
         * Disk capacity (in GB).
         */
        volumeSize: number;
        /**
         * ID of Virtual Private Cloud.
         */
        vpcId: string;
        /**
         * Information of available zone.
         */
        zone: string;
    }

    export interface GetInstanceInstanceListRoGroup {
        /**
         * Group ID, such as `cdbrg-pz7vg37p`.
         */
        groupId: string;
        /**
         * ID list of read-only type associated with the current instance.
         */
        instanceIds: string[];
    }

    export interface GetInstanceParamRecordItem {
        /**
         * Instance ID, the format is: cdb-c1nl9rpv, which is the same as the instance ID displayed on the cloud database console page, and you can use the [query instance list] (https://cloud.tencent.com/document/api/236/15872) interface Gets the value of the field InstanceId in the output parameter.
         */
        instanceId: string;
        /**
         * Whether the parameter is modified successfully.
         */
        isSuccess: boolean;
        /**
         * Change the time.
         */
        modifyTime: string;
        /**
         * The modified value of the parameter.
         */
        newValue: string;
        /**
         * The value of the parameter before modification.
         */
        oldValue: string;
        /**
         * parameter name.
         */
        paramName: string;
    }

    export interface GetInstanceRebootTimeItem {
        /**
         * Instance ID, the format is: cdb-c1nl9rpv, which is the same as the instance ID displayed on the cloud database console page.
         */
        instanceId: string;
        /**
         * expected restart time.
         */
        timeInSeconds: number;
    }

    export interface GetParameterListParameterList {
        /**
         * Current value.
         */
        currentValue: string;
        /**
         * Default value.
         */
        defaultValue: string;
        /**
         * Parameter specification description.
         */
        description: string;
        /**
         * Enumerated value.
         */
        enumValues: string[];
        /**
         * Maximum value for the parameter.
         */
        max: number;
        /**
         * Minimum value for the parameter.
         */
        min: number;
        /**
         * Indicates whether reboot is needed to enable the new parameters.
         */
        needReboot: number;
        /**
         * Parameter name.
         */
        parameterName: string;
        /**
         * Parameter type.
         */
        parameterType: string;
    }

    export interface GetProjectSecurityGroupGroup {
        /**
         * Creation time, time format: yyyy-mm-dd hh:mm:sss.
         */
        createTime: string;
        /**
         * inbound rules.
         */
        inbounds: outputs.Mysql.GetProjectSecurityGroupGroupInbound[];
        /**
         * outbound rules.
         */
        outbounds: outputs.Mysql.GetProjectSecurityGroupGroupOutbound[];
        /**
         * project id.
         */
        projectId: number;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * Security group name.
         */
        securityGroupName: string;
        /**
         * Security group remark.
         */
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupGroupInbound {
        /**
         * Policy, ACCEPT or DROP.
         */
        action: string;
        /**
         * Destination IP or IP segment, such as 172.16.0.0/12.
         */
        cidrIp: string;
        /**
         * Rule description.
         */
        desc: string;
        /**
         * The direction defined by the rule, the inbound rule is OUTPUT.
         */
        dir: string;
        /**
         * Network protocol, support UDP, TCP, etc.
         */
        ipProtocol: string;
        /**
         * port or port range.
         */
        portRange: string;
    }

    export interface GetProjectSecurityGroupGroupOutbound {
        /**
         * Policy, ACCEPT or DROP.
         */
        action: string;
        /**
         * Destination IP or IP segment, such as 172.16.0.0/12.
         */
        cidrIp: string;
        /**
         * Rule description.
         */
        desc: string;
        /**
         * The direction defined by the rule, the inbound rule is OUTPUT.
         */
        dir: string;
        /**
         * Network protocol, support UDP, TCP, etc.
         */
        ipProtocol: string;
        /**
         * port or port range.
         */
        portRange: string;
    }

    export interface GetProxyCustomCustomConf {
        /**
         * number of cores.
         */
        cpu: number;
        /**
         * equipment.
         */
        device: string;
        /**
         * Equipment type.
         */
        deviceType: string;
        /**
         * Memory.
         */
        memory: number;
        /**
         * type.
         */
        type: string;
    }

    export interface GetProxyCustomWeightRule {
        /**
         * division ceiling.
         */
        lessThan: number;
        /**
         * weight limit.
         */
        weight: number;
    }

    export interface GetRollbackRangeTimeItem {
        /**
         * Query database error code.
         */
        code: number;
        /**
         * A list of instance IDs. The format of a single instance ID is: cdb-c1nl9rpv. Same as the instance ID displayed in the cloud database console page.
         */
        instanceId: string;
        /**
         * Query database error information.
         */
        message: string;
        /**
         * Retrievable time range.
         */
        times: outputs.Mysql.GetRollbackRangeTimeItemTime[];
    }

    export interface GetRollbackRangeTimeItemTime {
        /**
         * Instance rollback start time, time format: 2016-10-29 01:06:04.
         */
        begin: string;
        /**
         * End time of instance rollback, time format: 2016-11-02 11:44:47.
         */
        end: string;
    }

    export interface GetSlowLogDataItem {
        /**
         * database name.
         */
        database: string;
        /**
         * Lock duration (seconds).
         */
        lockTime: number;
        /**
         * The md5 of the Sql statement.
         */
        md5: string;
        /**
         * Sql execution time (seconds).
         */
        queryTime: number;
        /**
         * The number of rows to scan.
         */
        rowsExamined: number;
        /**
         * The number of rows in the result set.
         */
        rowsSent: number;
        /**
         * Sql template.
         */
        sqlTemplate: string;
        /**
         * Sql statement.
         */
        sqlText: string;
        /**
         * Sql execution time.
         */
        timestamp: number;
        /**
         * client address.
         */
        userHost: string;
        /**
         * user name.
         */
        userName: string;
    }

    export interface GetSlowLogItem {
        /**
         * Backup snapshot time, time format: 2016-03-17 02:10:37.
         */
        date: string;
        /**
         * External network download address.
         */
        internetUrl: string;
        /**
         * Intranet download address.
         */
        intranetUrl: string;
        /**
         * backup file name.
         */
        name: string;
        /**
         * Backup file size, unit: Byte.
         */
        size: number;
        /**
         * Log specific type, possible values: slowlog - slow log.
         */
        type: string;
    }

    export interface GetSwitchRecordItem {
        /**
         * Switching time, the format is: 2017-09-03 01:34:31.
         */
        switchTime: string;
        /**
         * Switch type, possible return values: TRANSFER - data migration; MASTER2SLAVE - master-standby switch; RECOVERY - master-slave recovery.
         */
        switchType: string;
    }

    export interface GetUserTaskItem {
        /**
         * Asynchronous task request ID, the AsyncRequestId returned by executing cloud database-related operations.
         */
        asyncRequestId: string;
        /**
         * error code.
         */
        code: number;
        /**
         * Instance task end time.
         */
        endTime: string;
        /**
         * The instance ID associated with the task. Note: This field may return null, indicating that no valid value can be obtained.
         */
        instanceIds: string[];
        /**
         * Instance task ID.
         */
        jobId: number;
        /**
         * error message.
         */
        message: string;
        /**
         * Instance task progress.
         */
        progress: number;
        /**
         * Instance task start time.
         */
        startTime: string;
        /**
         * Task status. If no value is passed, all task statuses will be queried. Supported values include: `UNDEFINED` - undefined; `INITIAL` - initialization; `RUNNING` - running; `SUCCEED` - the execution was successful; `FAILED` - execution failed; `KILLED` - terminated; `REMOVED` - removed; `PAUSED` - Paused.
         */
        taskStatus: string;
        /**
         * Instance task type, possible values include:ROLLBACK - database rollback;SQL OPERATION - SQL operation;IMPORT DATA - data import;MODIFY PARAM - parameter setting;INITIAL - initialize the cloud database instance;REBOOT - restarts the cloud database instance;OPEN GTID - open the cloud database instance GTID;UPGRADE RO - read-only instance upgrade;BATCH ROLLBACK - database batch rollback;UPGRADE MASTER - master upgrade;DROP TABLES - delete cloud database tables;SWITCH DR TO MASTER - The disaster recovery instance.
         */
        taskType: string;
    }

    export interface GetZoneConfigList {
        /**
         * Information about available zones of recovery.
         */
        disasterRecoveryZones: string[];
        /**
         * The version number of the database engine to use. Supported versions include `5.5`/`5.6`/`5.7`.
         */
        engineVersions: string[];
        /**
         * Zone information about first slave instance.
         */
        firstSlaveZones: string[];
        hourInstanceSaleMaxNum: number;
        /**
         * Indicates whether the current DC is the default DC for the region. Possible returned values: `0` - no; `1` - yes.
         */
        isDefault: number;
        /**
         * Indicates whether recovery is supported: `0` - No; `1` - Yes.
         */
        isSupportDisasterRecovery: number;
        /**
         * Indicates whether VPC is supported: `0` - No; `1` - Yes.
         */
        isSupportVpc: number;
        /**
         * The name of available zone which is equal to a specific datacenter.
         */
        name: string;
        payTypes: number[];
        /**
         * Zone information about remote ro instance.
         */
        remoteRoZones: string[];
        /**
         * Zone information about second slave instance.
         */
        secondSlaveZones: string[];
        /**
         * A list of supported instance types for sell:
         */
        sells: outputs.Mysql.GetZoneConfigListSell[];
        /**
         * Availability zone deployment method. Available values: `0` - Single availability zone; `1` - Multiple availability zones.
         */
        slaveDeployModes: number[];
        /**
         * Data replication mode. `0` - Async replication; `1` - Semisync replication; `2` - Strongsync replication.
         */
        supportSlaveSyncModes: number[];
    }

    export interface GetZoneConfigListSell {
        /**
         * Instance type, the possible value ranges are: `UNIVERSAL` (universal type), `EXCLUSIVE` (exclusive type), `BASIC` (basic type), `BASIC_V2` (basic type v2).
         */
        cdbType: string;
        /**
         * Number of CPU cores.
         */
        cpu: number;
        /**
         * Application Scenario Description.
         */
        info: string;
        /**
         * Maximum disk size (in GB).
         */
        maxVolumeSize: number;
        /**
         * Memory size (in MB).
         */
        memSize: number;
        /**
         * Minimum disk size (in GB).
         */
        minVolumeSize: number;
        /**
         * Queries per second.
         */
        qps: number;
        /**
         * Disk increment (in GB).
         */
        volumeStep: number;
    }

    export interface ParamTemplateParamList {
        /**
         * The value of parameter.
         */
        currentValue: string;
        /**
         * The name of parameter.
         */
        name: string;
    }

    export interface PasswordComplexityParamList {
        /**
         * Parameter value.
         */
        currentValue?: string;
        /**
         * Parameter name.
         */
        name?: string;
    }

    export interface PrivilegeColumn {
        /**
         * Column name.
         */
        columnName: string;
        /**
         * Database name.
         */
        databaseName: string;
        /**
         * Column privilege.available values for Privileges:SELECT,INSERT,UPDATE,REFERENCES.
         */
        privileges: string[];
        /**
         * Table name.
         */
        tableName: string;
    }

    export interface PrivilegeDatabase {
        /**
         * Database name.
         */
        databaseName: string;
        /**
         * Database privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE TEMPORARY TABLES,LOCK TABLES,EXECUTE,CREATE VIEW,SHOW VIEW,CREATE ROUTINE,ALTER ROUTINE,EVENT,TRIGGER.
         */
        privileges: string[];
    }

    export interface PrivilegeTable {
        /**
         * Database name.
         */
        databaseName: string;
        /**
         * Table privilege.available values for Privileges:SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,INDEX,ALTER,CREATE VIEW,SHOW VIEW,TRIGGER.
         */
        privileges: string[];
        /**
         * Table name.
         */
        tableName: string;
    }

    export interface ProxyProxyNodeCustom {
        /**
         * Number of CPU cores.
         */
        cpu: number;
        /**
         * Memory size.
         */
        mem: number;
        /**
         * Number of nodes.
         */
        nodeCount: number;
        /**
         * Region.
         */
        region: string;
        /**
         * Zone.
         */
        zone: string;
    }

    export interface RoGroupRoGroupInfo {
        /**
         * The minimum number of reserved instances. It can be set to any value less than or equal to the number of RO instances under this RO group. Note that if the setting value is greater than the number of RO instances, it will not be removed; if it is set to 0, all instances whose latency exceeds the limit will be removed.
         */
        minRoInGroup?: number;
        /**
         * Delayed replication time.
         */
        replicationDelayTime?: number;
        /**
         * RO group name.
         */
        roGroupName?: string;
        /**
         * RO instance maximum latency threshold. The unit is seconds, the minimum value is 1. Note that the RO group must have enabled instance delay culling policy for this value to be valid.
         */
        roMaxDelayTime?: number;
        /**
         * Whether to enable delayed culling of instances. Supported values are: 1 - on; 0 - not on. Note that if you enable instance delay culling, you must set the delay threshold (RoMaxDelayTime) parameter.
         */
        roOfflineDelay?: number;
        /**
         * weight mode. Supported values include: `system` - automatically assigned by the system; `custom` - user-defined settings. Note that if the `custom` mode is set, the RO instance weight configuration (RoWeightValues) parameter must be set.
         */
        weightMode?: string;
    }

    export interface RoGroupRoWeightValue {
        /**
         * RO instance ID.
         */
        instanceId: string;
        /**
         * Weights. The value range is [0, 100].
         */
        weight: number;
    }

    export interface RollbackDatabase {
        /**
         * The original database name before rollback.
         */
        databaseName: string;
        /**
         * The new database name after rollback.
         */
        newDatabaseName: string;
    }

    export interface RollbackTable {
        /**
         * Database name.
         */
        database: string;
        /**
         * Database table details.
         */
        tables: outputs.Mysql.RollbackTableTable[];
    }

    export interface RollbackTableTable {
        /**
         * New database table name after rollback.
         */
        newTableName: string;
        /**
         * The original database table name before rollback.
         */
        tableName: string;
    }

}

export namespace Nat {
    export interface GetDcRouteNatDirectConnectGatewayRouteSet {
        /**
         * Create time of route.
         */
        createTime: string;
        /**
         * IPv4 CIDR of subnet.
         */
        destinationCidrBlock: string;
        /**
         * Id of next-hop gateway.
         */
        gatewayId: string;
        /**
         * Type of next-hop gateway, valid values: DIRECTCONNECT.
         */
        gatewayType: string;
        /**
         * Update time of route.
         */
        updateTime: string;
    }

    export interface GetGatewaySnatsSnatList {
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Description.
         */
        description: string;
        /**
         * Instance ID.
         */
        instanceId?: string;
        /**
         * Private IPs of the instance's primary ENI, required when `resourceType` is NETWORKINTERFACE.
         */
        instancePrivateIpAddr?: string;
        /**
         * NAT gateway ID.
         */
        natGatewayId: string;
        /**
         * Elastic IP address pool.
         */
        publicIpAddrs: string[];
        /**
         * Resource type. Valid values: SUBNET, NETWORKINTERFACE.
         */
        resourceType: string;
        /**
         * SNAT rule ID.
         */
        snatId: string;
        /**
         * The IPv4 CIDR of the subnet, required when `resourceType` is SUBNET.
         */
        subnetCidrBlock?: string;
        /**
         * Subnet instance ID.
         */
        subnetId?: string;
    }

    export interface GetGatewaysNat {
        /**
         * EIP IP address set bound to the gateway. The value of at least 1.
         */
        assignedEipSets: string[];
        /**
         * The maximum public network output bandwidth of NAT gateway (unit: Mbps), the available values include: 20,50,100,200,500,1000,2000,5000. Default is 100.
         */
        bandwidth: number;
        /**
         * Create time of the NAT gateway.
         */
        createTime: string;
        /**
         * ID of the NAT gateway.
         */
        id: string;
        /**
         * The upper limit of concurrent connection of NAT gateway, the available values include: 1000000,3000000,10000000. Default is 1000000.
         */
        maxConcurrent: number;
        /**
         * Name of the NAT gateway.
         */
        name: string;
        /**
         * State of the NAT gateway.
         */
        state: string;
        /**
         * The available tags within this NAT gateway.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC.
         */
        vpcId: string;
    }

}

export namespace Oceanus {
    export interface GetClustersClusterSet {
        /**
         * The user AppID.
         */
        appId: number;
        /**
         * V3 version = 2.Note: This field may return null, indicating that no valid values can be obtained.
         */
        archGeneration: number;
        /**
         * 1 - auto-renewal.Note: This field may return null, indicating that no valid values can be obtained.
         */
        autoRenewFlag: number;
        /**
         * The network.
         */
        ccns: outputs.Oceanus.GetClustersClusterSetCcn[];
        /**
         * The name of the CLS logset of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clsLogName: string;
        /**
         * The CLS logset of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clsLogSet: string;
        /**
         * The CLS topic ID of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clsTopicId: string;
        /**
         * The name of the CLS topic of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clsTopicName: string;
        /**
         * The ID of the cluster.
         */
        clusterId: string;
        /**
         * Session cluster information.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterSessions: outputs.Oceanus.GetClustersClusterSetClusterSession[];
        /**
         * 0: TKE, 1: EKS.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterType: number;
        /**
         * Space information.Note: This field may return null, indicating that no valid values can be obtained.
         */
        correlations: outputs.Oceanus.GetClustersClusterSetCorrelation[];
        /**
         * Creation time.Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Creator.Note: This field may return null, indicating that no valid values can be obtained.
         */
        creatorUin: string;
        /**
         * The memory specification of the CU.
         */
        cuMem: number;
        /**
         * The number of CUs.
         */
        cuNum: number;
        /**
         * Value: 0 - not set, 1 - set, 2 - not allowed to set.Note: This field may return null, indicating that no valid values can be obtained.
         */
        customizedDnsEnabled: number;
        /**
         * The default COS bucket of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        defaultCosBucket: string;
        /**
         * The default log collection configuration of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        defaultLogCollectConf: string;
        /**
         * The expiration time of the cluster. If the cluster does not have an expiration time, this field will be -.Note: This field may return null, indicating that no valid values can be obtained.
         */
        expireTime: string;
        /**
         * The number of free CUs at the granularity level.Note: This field may return null, indicating that no valid values can be obtained.
         */
        freeCu: number;
        /**
         * The number of free CUs.
         */
        freeCuNum: number;
        /**
         * Front-end distinguishes whether the cluster needs 2CU logic, because historical clusters do not need to be changed. Default is 1. All new clusters need to be changed.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isNeedManageNode: number;
        /**
         * The time when the cluster was isolated. If the cluster has not been isolated, this field will be -.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isolatedTime: string;
        /**
         * The field to be filtered.
         */
        name: string;
        /**
         * The network.
         */
        netEnvironmentType: number;
        /**
         * Order information.Note: This field may return null, indicating that no valid values can be obtained.
         */
        orders: outputs.Oceanus.GetClustersClusterSetOrder[];
        /**
         * The main account UIN.
         */
        ownerUin: string;
        /**
         * 0 - postpaid, 1 - prepaid.Note: This field may return null, indicating that no valid values can be obtained.
         */
        payMode: number;
        /**
         * The region where the cluster is located.
         */
        region: string;
        /**
         * A description of the cluster.
         */
        remark: string;
        /**
         * Running CU.Note: This field may return null, indicating that no valid values can be obtained.
         */
        runningCu: number;
        /**
         * The number of seconds until the cluster expires. If the cluster does not have an expiration time, this field will be -.Note: This field may return null, indicating that no valid values can be obtained.
         */
        secondsUntilExpiry: string;
        /**
         * Gateway information.Note: This field may return null, indicating that no valid values can be obtained.
         */
        sqlGateways: outputs.Oceanus.GetClustersClusterSetSqlGateway[];
        /**
         * The status of the cluster. Possible values are 1 (uninitialized), 3 (initializing), and 2 (running).
         */
        status: number;
        /**
         * The status description.
         */
        statusDesc: string;
        /**
         * The tags bound to the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        tags: outputs.Oceanus.GetClustersClusterSetTag[];
        /**
         * The time of the last operation on the cluster.
         */
        updateTime: string;
        /**
         * The version information of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        versions: outputs.Oceanus.GetClustersClusterSetVersion[];
        /**
         * The availability zone.
         */
        zone: string;
    }

    export interface GetClustersClusterSetCcn {
        /**
         * The ID of the Cloud Connect Network (CCN), such as ccn-rahigzjd.
         */
        ccnId: string;
        /**
         * The ID of the subnet.
         */
        subnetId: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
    }

    export interface GetClustersClusterSetClusterSession {
    }

    export interface GetClustersClusterSetCorrelation {
        /**
         * Cluster ID.
         */
        clusterGroupId: number;
        /**
         * Cluster SerialId.
         */
        clusterGroupSerialId: string;
        /**
         * Cluster name.
         */
        clusterName: string;
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * Project ID in string format.Note: This field may return null, indicating that no valid values can be obtained.
         */
        projectIdStr: string;
        /**
         * The status of the cluster. Possible values are 1 (uninitialized), 3 (initializing), and 2 (running).
         */
        status: number;
        /**
         * Workspace SerialId.
         */
        workSpaceId: string;
        /**
         * Workspace name.
         */
        workSpaceName: string;
    }

    export interface GetClustersClusterSetOrder {
        /**
         * 1 - auto-renewal.Note: This field may return null, indicating that no valid values can be obtained.
         */
        autoRenewFlag: number;
        /**
         * The number of CUs in the final cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        computeCu: number;
        /**
         * UIN of the operator.Note: This field may return null, indicating that no valid values can be obtained.
         */
        operateUin: string;
        /**
         * The time of the order.Note: This field may return null, indicating that no valid values can be obtained.
         */
        orderTime: string;
        /**
         * Reference type. 0: user resource.Note: This field may return null, indicating that no valid values can be obtained.
         */
        type: number;
    }

    export interface GetClustersClusterSetSqlGateway {
        /**
         * Creation time.Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Creator.Note: This field may return null, indicating that no valid values can be obtained.
         */
        creatorUin: string;
        /**
         * CU specification.Note: This field may return null, indicating that no valid values can be obtained.
         */
        cuSpec: number;
        /**
         * Flink kernel version.Note: This field may return null, indicating that no valid values can be obtained.
         */
        flinkVersion: string;
        /**
         * Configuration parameters.Note: This field may return null, indicating that no valid values can be obtained.
         */
        properties: outputs.Oceanus.GetClustersClusterSetSqlGatewayProperty[];
        /**
         * Reference resources.Note: This field may return null, indicating that no valid values can be obtained.
         */
        resourceRefs: outputs.Oceanus.GetClustersClusterSetSqlGatewayResourceRef[];
        /**
         * Unique identifier.Note: This field may return null, indicating that no valid values can be obtained.
         */
        serialId: string;
        /**
         * The status of the cluster. Possible values are 1 (uninitialized), 3 (initializing), and 2 (running).
         */
        status: number;
        /**
         * The time of the last operation on the cluster.
         */
        updateTime: string;
    }

    export interface GetClustersClusterSetSqlGatewayProperty {
        /**
         * Key of the system configuration.
         */
        key: string;
        /**
         * Value of the system configuration.
         */
        value: string;
    }

    export interface GetClustersClusterSetSqlGatewayResourceRef {
        /**
         * Unique identifier of the resource.
         */
        resourceId: string;
        /**
         * Reference type. 0: user resource.Note: This field may return null, indicating that no valid values can be obtained.
         */
        type: number;
        /**
         * The version information of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        version: number;
        /**
         * Unique identifier of the space.
         */
        workspaceId: string;
    }

    export interface GetClustersClusterSetTag {
        /**
         * The tag key.Note: This field may return null, indicating that no valid values can be obtained.
         */
        tagKey: string;
        /**
         * The tag value.Note: This field may return null, indicating that no valid values can be obtained.
         */
        tagValue: string;
    }

    export interface GetClustersClusterSetVersion {
        /**
         * The Flink version of the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        flink: string;
        /**
         * The Flink versions supported by the cluster.Note: This field may return null, indicating that no valid values can be obtained.
         */
        supportedFlinks: string[];
    }

    export interface GetClustersFilter {
        /**
         * The field to be filtered.
         */
        name: string;
        /**
         * The filtering values of the field.
         */
        values: string[];
    }

    export interface GetJobEventsEvent {
        /**
         * Description text of the event type.
         */
        description: string;
        /**
         * Some optional explanations of the eventNote: This field may return null, indicating that no valid values can be obtained.
         */
        message: string;
        /**
         * Running ID when the event occurredNote: This field may return null, indicating that no valid values can be obtained.
         */
        runningOrderId: number;
        /**
         * Troubleshooting manual link for the abnormal eventNote: This field may return null, indicating that no valid values can be obtained.
         */
        solutionLink: string;
        /**
         * Unix timestamp (seconds) when the event occurred.
         */
        timestamp: number;
        /**
         * Internally defined event type.
         */
        type: string;
    }

    export interface GetJobSubmissionLogJobInstanceList {
        /**
         * The startup time of the instance.
         */
        jobInstanceStartTime: string;
        /**
         * Job instance ID.
         */
        runningOrderId: number;
        /**
         * The startup time of the instance in milliseconds.
         */
        startingMillis: number;
    }

    export interface GetJobSubmissionLogLogContentList {
        /**
         * The name of the container to which the log belongs.
         */
        containerName: string;
        /**
         * The content of the log.
         */
        log: string;
        /**
         * The ID of the log group.
         */
        pkgId: string;
        /**
         * The ID of the log, which is unique within the log group.
         */
        pkgLogId: number;
        /**
         * The timestamp in milliseconds.
         */
        time: number;
    }

    export interface GetResourceRelatedJobRefJobInfo {
        /**
         * Job configuration version.
         */
        jobConfigVersion: number;
        /**
         * Job ID.
         */
        jobId: string;
        /**
         * Resource version.
         */
        resourceVersion: number;
    }

    export interface GetSavepointListSavepoint {
        /**
         * Creation timeNote: This field may return null, indicating that no valid value was found.
         */
        createTime: number;
        /**
         * DescriptionNote: This field may return null, indicating that no valid value was found.
         */
        description: string;
        /**
         * Primary keyNote: This field may return null, indicating that no valid value was found.
         */
        id: number;
        /**
         * Sequential ID of the running job instanceNote: This field may return null, indicating that no valid value was found.
         */
        jobRuntimeId: number;
        /**
         * PathNote: This field may return null, indicating that no valid value was found.
         */
        path: string;
        /**
         * Snapshot path status: 1=available; 2=unavailable;Note: This field may return null, indicating that no valid value was found.
         */
        pathStatus: number;
        /**
         * Snapshot type: 1=savepoint; 2=checkpoint; 3=cancelWithSavepointNote: This field may return null, indicating that no valid value was found.
         */
        recordType: number;
        /**
         * Snapshot SerialIdNote: This field may return null, indicating that no valid value was found.
         */
        serialId: string;
        /**
         * SizeNote: This field may return null, indicating that no valid value was found.
         */
        size: number;
        /**
         * Status: 1=Active; 2=Expired; 3=InProgress; 4=Failed; 5=TimeoutNote: This field may return null, indicating that no valid value was found.
         */
        status: number;
        /**
         * Time consumptionNote: This field may return null, indicating that no valid value was found.
         */
        timeConsuming: number;
        /**
         * Fixed timeoutNote: This field may return null, indicating that no valid value was found.
         */
        timeout: number;
        /**
         * Update timeNote: This field may return null, indicating that no valid value was found.
         */
        updateTime: number;
        /**
         * Version numberNote: This field may return null, indicating that no valid value was found.
         */
        versionId: number;
    }

    export interface GetSystemResourceFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter values for the field.
         */
        values: string[];
    }

    export interface GetSystemResourceResourceSet {
        /**
         * Latest version of the resource.
         */
        latestResourceConfigVersion: number;
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Region to which the resource belongs.
         */
        region: string;
        /**
         * Resource remarks.
         */
        remark: string;
        /**
         * Resource ID.
         */
        resourceId: string;
        /**
         * Resource type. 1 indicates JAR package, which is currently the only supported value.
         */
        resourceType: number;
    }

    export interface GetTreeJobsFilter {
        /**
         * Field to be filtered. Can only be set `Zone` or `JobType` or `JobStatus`.
         */
        name: string;
        /**
         * Filter values for the field.
         */
        values: string[];
    }

    export interface GetTreeJobsTreeInfo {
        /**
         * Subdirectory Information.
         */
        children: string;
        /**
         * ID.
         */
        id: string;
        /**
         * List of jobs.
         */
        jobSets: outputs.Oceanus.GetTreeJobsTreeInfoJobSet[];
        /**
         * Field to be filtered. Can only be set `Zone` or `JobType` or `JobStatus`.
         */
        name: string;
        /**
         * Parent Id.
         */
        parentId: string;
    }

    export interface GetTreeJobsTreeInfoJobSet {
        /**
         * Job ID.
         */
        jobId: string;
        /**
         * Job Type.
         */
        jobType: number;
        /**
         * Field to be filtered. Can only be set `Zone` or `JobType` or `JobStatus`.
         */
        name: string;
        /**
         * Resources occupied by homework.
         */
        runningCu: number;
        /**
         * Job status.
         */
        status: number;
    }

    export interface GetTreeResourcesTreeInfo {
        /**
         * Subdirectory Information.
         */
        children: string;
        /**
         * ID.
         */
        id: string;
        /**
         * List of items.
         */
        items: outputs.Oceanus.GetTreeResourcesTreeInfoItem[];
        /**
         * Name.
         */
        name: string;
        /**
         * Parent Id.
         */
        parentId: string;
    }

    export interface GetTreeResourcesTreeInfoItem {
        /**
         * File name.
         */
        fileName: string;
        /**
         * Folder id.
         */
        folderId: string;
        /**
         * Name.
         */
        name: string;
        /**
         * Counting the number of associated tasks by state.
         */
        refJobStatusCountSets: outputs.Oceanus.GetTreeResourcesTreeInfoItemRefJobStatusCountSet[];
        /**
         * Remark.
         */
        remark: string;
        /**
         * Resource Id.
         */
        resourceId: string;
        /**
         * Resource Type.
         */
        resourceType: number;
    }

    export interface GetTreeResourcesTreeInfoItemRefJobStatusCountSet {
        /**
         * Job count.
         */
        count: number;
        /**
         * Job status.
         */
        jobStatus: number;
    }

    export interface GetWorkSpacesFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter values for the field.
         */
        values: string[];
    }

    export interface GetWorkSpacesWorkSpaceSetItem {
        /**
         * User AppID.
         */
        appId: number;
        /**
         * Workspace cluster information.
         */
        clusterGroupSetItems: outputs.Oceanus.GetWorkSpacesWorkSpaceSetItemClusterGroupSetItem[];
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Creator UIN.
         */
        creatorUin: string;
        /**
         * Workspace description.
         */
        description: string;
        /**
         * Note: This field may return null, indicating that no valid values can be obtained.
         */
        jobsCount: number;
        /**
         * Main account UIN.
         */
        ownerUin: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Workspace member count.
         */
        roleAuthCount: number;
        /**
         * Workspace role information.
         */
        roleAuths: outputs.Oceanus.GetWorkSpacesWorkSpaceSetItemRoleAuth[];
        /**
         * Workspace SerialId.
         */
        serialId: string;
        /**
         * 1:uninitialized; 2:available; -1:deleted.
         */
        status: number;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * Workspace SerialId.
         */
        workSpaceId: string;
        /**
         * Workspace name.
         */
        workSpaceName: string;
    }

    export interface GetWorkSpacesWorkSpaceSetItemClusterGroupSetItem {
        /**
         * User AppID.
         */
        appId: number;
        /**
         * SerialId of the clusterGroup.
         */
        clusterId: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Creator UIN.
         */
        creatorUin: string;
        /**
         * CU memory specification.
         */
        cuMem: number;
        /**
         * CU quantity.
         */
        cuNum: number;
        /**
         * Free CU under fine-grained resources.
         */
        freeCu: number;
        /**
         * Free CU.
         */
        freeCuNum: number;
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Network.
         */
        netEnvironmentType: number;
        /**
         * Main account UIN.
         */
        ownerUin: string;
        /**
         * Payment mode.
         */
        payMode: number;
        /**
         * Region.
         */
        region: string;
        /**
         * Description.
         */
        remark: string;
        /**
         * Running CU.
         */
        runningCu: number;
        /**
         * 1:uninitialized; 2:available; -1:deleted.
         */
        status: number;
        /**
         * Status description.
         */
        statusDesc: string;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * Zone.
         */
        zone: string;
    }

    export interface GetWorkSpacesWorkSpaceSetItemRoleAuth {
        /**
         * User AppID.
         */
        appId: number;
        /**
         * Bound authorized UIN.
         */
        authSubAccountUin: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Creator UIN.
         */
        creatorUin: string;
        /**
         * IDNote: This field may return null, indicating that no valid values can be obtained.
         */
        id: number;
        /**
         * Main account UIN.
         */
        ownerUin: string;
        /**
         * Corresponding to the ID in the role table.
         */
        permission: number;
        /**
         * Permission nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        roleName: string;
        /**
         * 1:uninitialized; 2:available; -1:deleted.
         */
        status: number;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * Workspace SerialId.
         */
        workSpaceId: number;
        /**
         * Workspace SerialId.
         */
        workSpaceSerialId: string;
    }

    export interface JobConfigClazzLevel {
        /**
         * Java class full pathNote: This field may return null, indicating that no valid value can be obtained.
         */
        clazz: string;
        /**
         * Log level TRACE, DEBUG, INFO, WARN, ERRORNote: This field may return null, indicating that no valid value can be obtained.
         */
        level: string;
    }

    export interface JobConfigExpertModeConfiguration {
        /**
         * Job graphNote: This field may return null, indicating that no valid value can be obtained.
         */
        jobGraph?: outputs.Oceanus.JobConfigExpertModeConfigurationJobGraph;
        /**
         * Node configurationNote: This field may return null, indicating that no valid value can be obtained.
         */
        nodeConfigs?: outputs.Oceanus.JobConfigExpertModeConfigurationNodeConfig[];
        /**
         * Slot sharing groupsNote: This field may return null, indicating that no valid value can be obtained.
         */
        slotSharingGroups?: outputs.Oceanus.JobConfigExpertModeConfigurationSlotSharingGroup[];
    }

    export interface JobConfigExpertModeConfigurationJobGraph {
        /**
         * Edge set of the running graphNote: This field may return null, indicating that no valid value can be obtained.
         */
        edges?: outputs.Oceanus.JobConfigExpertModeConfigurationJobGraphEdge[];
        /**
         * Point set of the running graphNote: This field may return null, indicating that no valid value can be obtained.
         */
        nodes?: outputs.Oceanus.JobConfigExpertModeConfigurationJobGraphNode[];
    }

    export interface JobConfigExpertModeConfigurationJobGraphEdge {
        /**
         * Starting node ID of the edgeNote: This field may return null, indicating that no valid value can be obtained.
         */
        source: number;
        /**
         * Target node ID of the edgeNote: This field may return null, indicating that no valid value can be obtained.
         */
        target: number;
    }

    export interface JobConfigExpertModeConfigurationJobGraphNode {
        /**
         * Node descriptionNote: This field may return null, indicating that no valid value can be obtained.
         */
        description: string;
        /**
         * Node IDNote: This field may return null, indicating that no valid value can be obtained.
         */
        id: number;
        /**
         * Node nameNote: This field may return null, indicating that no valid value can be obtained.
         */
        name: string;
        /**
         * Node parallelismNote: This field may return null, indicating that no valid value can be obtained.
         */
        parallelism: number;
    }

    export interface JobConfigExpertModeConfigurationNodeConfig {
        /**
         * Configuration propertiesNote: This field may return null, indicating that no valid value can be obtained.
         */
        configurations?: outputs.Oceanus.JobConfigExpertModeConfigurationNodeConfigConfiguration[];
        /**
         * Node IDNote: This field may return null, indicating that no valid value can be obtained.
         */
        id: number;
        /**
         * Node parallelismNote: This field may return null, indicating that no valid value can be obtained.
         */
        parallelism?: number;
        /**
         * Slot sharing groupNote: This field may return null, indicating that no valid value can be obtained.
         */
        slotSharingGroup?: string;
        /**
         * State TTL configuration of the node, separated by semicolonsNote: This field may return null, indicating that no valid value can be obtained.
         */
        stateTtl?: string;
    }

    export interface JobConfigExpertModeConfigurationNodeConfigConfiguration {
        /**
         * System configuration key.
         */
        key: string;
        /**
         * System configuration value.
         */
        value: string;
    }

    export interface JobConfigExpertModeConfigurationSlotSharingGroup {
        /**
         * Description of the SlotSharingGroupNote: This field may return null, indicating that no valid value can be obtained.
         */
        description?: string;
        /**
         * Name of the SlotSharingGroupNote: This field may return null, indicating that no valid value can be obtained.
         */
        name: string;
        /**
         * Specification of the SlotSharingGroupNote: This field may return null, indicating that no valid value can be obtained.
         */
        spec: outputs.Oceanus.JobConfigExpertModeConfigurationSlotSharingGroupSpec;
    }

    export interface JobConfigExpertModeConfigurationSlotSharingGroupSpec {
        /**
         * Applicable CPUNote: This field may return null, indicating that no valid value can be obtained.
         */
        cpu: number;
        /**
         * Default is b, supporting units are b, kb, mb, gbNote: This field may return null, indicating that no valid value can be obtained.
         */
        heapMemory: string;
        /**
         * Default is b, supporting units are b, kb, mb, gbNote: This field may return null, indicating that no valid value can be obtained.
         */
        managedMemory?: string;
        /**
         * Default is b, supporting units are b, kb, mb, gbNote: This field may return null, indicating that no valid value can be obtained.
         */
        offHeapMemory?: string;
    }

    export interface JobConfigProperty {
        /**
         * System configuration key.
         */
        key: string;
        /**
         * System configuration value.
         */
        value: string;
    }

    export interface JobConfigResourceRef {
        /**
         * Resource ID.
         */
        resourceId: string;
        /**
         * Reference resource type, for example, setting the main resource to 1 represents the jar package where the main class is located.
         */
        type: number;
        /**
         * Resource version ID, -1 indicates the latest version.
         */
        version: number;
    }

    export interface ResourceConfigResourceLoc {
        /**
         * Json to describe resource location.
         */
        param: outputs.Oceanus.ResourceConfigResourceLocParam;
        /**
         * The available storage types for resource location are currently limited to 1:COS.
         */
        storageType: number;
    }

    export interface ResourceConfigResourceLocParam {
        /**
         * Resource bucket.
         */
        bucket: string;
        /**
         * Resource path.
         */
        path: string;
        /**
         * Resource region, if not set, use resource region, note: this field may return null, indicating that no valid values can be obtained.
         */
        region?: string;
    }

    export interface ResourceResourceLoc {
        /**
         * Json to describe resource location.
         */
        param: outputs.Oceanus.ResourceResourceLocParam;
        /**
         * The available storage types for resource location are currently limited to 1:COS.
         */
        storageType: number;
    }

    export interface ResourceResourceLocParam {
        /**
         * Resource bucket.
         */
        bucket: string;
        /**
         * Resource path.
         */
        path: string;
        /**
         * Resource region, if not set, use resource region, note: this field may return null, indicating that no valid values can be obtained.
         */
        region?: string;
    }

    export interface RunJobRunJobDescription {
        /**
         * Custom timestamp.
         */
        customTimestamp?: number;
        /**
         * A certain version of the current job(Not passed by default as a non-draft job version).
         */
        jobConfigVersion?: number;
        /**
         * Job ID.
         */
        jobId: string;
        /**
         * The type of the run. 1 indicates start, and 2 indicates resume.
         */
        runType: number;
        /**
         * Savepoint ID.
         */
        savepointId?: string;
        /**
         * Savepoint path.
         */
        savepointPath?: string;
        /**
         * Compatible with the startup parameters of the old SQL type job: specify the start time point of data source consumption (recommended to pass the value)Ensure that the parameter is LATEST, EARLIEST, T+Timestamp (example: T1557394288000).
         */
        startMode?: string;
        /**
         * Use the historical version of the system dependency.
         */
        useOldSystemConnector?: boolean;
    }

    export interface StopJobStopJobDescription {
        /**
         * Job Id.
         */
        jobId: string;
        /**
         * Stop type,1 stopped 2 paused.
         */
        stopType: number;
    }

}

export namespace Organization {
    export interface GetMembersItem {
        /**
         * Security information binding status. Valid values: `Unbound`, `Valid`, `Success`, `Failed`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        bindStatus: string;
        /**
         * Creation timeNote: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Whether the member is allowed to leave. Valid values: `Allow`, `Denied`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        isAllowQuit: string;
        /**
         * Member type. Valid values: `Invite` (invited); `Create` (created).Note: This field may return null, indicating that no valid values can be obtained.
         */
        memberType: string;
        /**
         * Member UINNote: This field may return null, indicating that no valid values can be obtained.
         */
        memberUin: number;
        /**
         * Permission name.
         */
        name: string;
        /**
         * Node IDNote: This field may return null, indicating that no valid values can be obtained.
         */
        nodeId: number;
        /**
         * Node nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        nodeName: string;
        /**
         * Management identityNote: This field may return null, indicating that no valid values can be obtained.
         */
        orgIdentities: outputs.Organization.GetMembersItemOrgIdentity[];
        /**
         * Relationship policy permissionNote: This field may return null, indicating that no valid values can be obtained.
         */
        orgPermissions: outputs.Organization.GetMembersItemOrgPermission[];
        /**
         * Relationship policy nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        orgPolicyName: string;
        /**
         * Relationship policy typeNote: This field may return null, indicating that no valid values can be obtained.
         */
        orgPolicyType: string;
        /**
         * Payer nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        payName: string;
        /**
         * Payer UINNote: This field may return null, indicating that no valid values can be obtained.
         */
        payUin: string;
        /**
         * Member permission status. Valid values: `Confirmed`, `UnConfirmed`.Note: This field may return null, indicating that no valid values can be obtained.
         */
        permissionStatus: string;
        /**
         * RemarksNote: This field may return null, indicating that no valid values can be obtained.
         */
        remark: string;
        /**
         * Update timeNote: This field may return null, indicating that no valid values can be obtained.
         */
        updateTime: string;
    }

    export interface GetMembersItemOrgIdentity {
        /**
         * Identity name.Note: This field may return null, indicating that no valid values can be obtained.
         */
        identityAliasName: string;
        /**
         * Identity ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        identityId: number;
    }

    export interface GetMembersItemOrgPermission {
        /**
         * Permission ID.
         */
        id: number;
        /**
         * Permission name.
         */
        name: string;
    }

    export interface GetOrgAuthNodeItem {
        /**
         * Verified company name.
         */
        authName: string;
        /**
         * Organization auth manager.
         */
        managers: outputs.Organization.GetOrgAuthNodeItemManager[];
        /**
         * Relationship Id.
         */
        relationId: number;
    }

    export interface GetOrgAuthNodeItemManager {
        /**
         * Member name.
         */
        memberName: string;
        /**
         * Member uin.
         */
        memberUin: number;
    }

    export interface GetOrgFinancialByMemberItem {
        /**
         * Member name.
         */
        memberName: string;
        /**
         * Member uin.
         */
        memberUin: number;
        /**
         * The percentage of the organization total cost that is accounted for by the member.
         */
        ratio: string;
        /**
         * Total cost of the member.
         */
        totalCost: number;
    }

    export interface GetOrgFinancialByMonthItem {
        /**
         * Growth rate compared to last month.
         */
        growthRate: string;
        /**
         * Record ID.
         */
        id: number;
        /**
         * Month.
         */
        month: string;
        /**
         * Total cost of the month.
         */
        totalCost: number;
    }

    export interface GetOrgFinancialByProductItem {
        /**
         * Product code.
         */
        productCode: string;
        /**
         * Product name.
         */
        productName: string;
        /**
         * The percentage of the organization total cost that is accounted for by the product.
         */
        ratio: string;
        /**
         * Total cost of the product.
         */
        totalCost: number;
    }

    export interface GetOrgShareAreaItem {
        /**
         * Region identifier.
         */
        area: string;
        /**
         * Region ID.
         */
        areaId: number;
        /**
         * Region name.
         */
        name: string;
    }

    export interface InstanceOrgPermission {
        /**
         * Permissions ID.
         */
        id: number;
        /**
         * Permission name.
         */
        name: string;
    }

    export interface OrgIdentityIdentityPolicy {
        /**
         * Customize policy content and follow CAM policy syntax. Valid and required when PolicyType is the 1-custom policy.
         */
        policyDocument?: string;
        /**
         * CAM default policy ID. Valid and required when PolicyType is the 2-preset policy.
         */
        policyId?: number;
        /**
         * CAM default policy name. Valid and required when PolicyType is the 2-preset policy.
         */
        policyName?: string;
        /**
         * Policy type. Value 1-custom policy 2-preset policy; default value 2.
         */
        policyType?: number;
    }

    export interface OrgMemberOrgPermission {
        /**
         * Permissions ID.
         */
        id: number;
        /**
         * Member name.
         */
        name: string;
    }

    export interface OrgShareUnitMemberMember {
        /**
         * Member uin.
         */
        shareMemberUin: number;
    }

}

export namespace Placement {
    export interface GetGroupsPlacementGroupList {
        /**
         * Creation time of the placement group.
         */
        createTime: string;
        /**
         * Number of hosts in the placement group.
         */
        currentNum: number;
        /**
         * Maximum number of hosts in the placement group.
         */
        cvmQuotaTotal: number;
        /**
         * Host IDs in the placement group.
         */
        instanceIds: string[];
        /**
         * Name of the placement group to be queried.
         */
        name: string;
        /**
         * ID of the placement group to be queried.
         */
        placementGroupId: string;
        /**
         * Type of the placement group.
         */
        type: string;
    }

}

export namespace Postgresql {
    export interface GetBackupDownloadUrlsBackupDownloadRestriction {
        /**
         * Whether IP is allowed. Valid values: `ALLOW` (allow), `DENY` (deny).
         */
        ipRestrictionEffect?: string;
        /**
         * Whether it is allowed to download IP list of the backup files.
         */
        ipSets?: string[];
        /**
         * Type of the network restrictions for downloading backup files. Valid values: `NONE` (backups can be downloaded over both private and public networks), `INTRANET` (backups can only be downloaded over the private network), `CUSTOMIZE` (backups can be downloaded over specified VPCs or at specified IPs).
         */
        restrictionType?: string;
        /**
         * Whether it is allowed to download the VPC ID list of the backup files.
         */
        vpcIdSets?: string[];
        /**
         * Whether VPC is allowed. Valid values: `ALLOW` (allow), `DENY` (deny).
         */
        vpcRestrictionEffect?: string;
    }

    export interface GetBaseBackupsBaseBackupSet {
        /**
         * Backup method, including physical and logical.
         */
        backupMethod: string;
        /**
         * Backup mode, including automatic and manual.
         */
        backupMode: string;
        /**
         * Instance ID.
         */
        dbInstanceId: string;
        /**
         * Backup expiration time.
         */
        expireTime: string;
        /**
         * Backup end time.
         */
        finishTime: string;
        /**
         * Unique ID of a backup file.
         */
        id: string;
        /**
         * Filter name.
         */
        name: string;
        /**
         * Backup set size in bytes.
         */
        size: number;
        /**
         * Backup start time.
         */
        startTime: string;
        /**
         * Backup task status.
         */
        state: string;
    }

    export interface GetBaseBackupsFilter {
        /**
         * Filter name.
         */
        name?: string;
        /**
         * One or more filter values.
         */
        values?: string[];
    }

    export interface GetDbInstanceClassesClassInfoSet {
        /**
         * Number of CPU cores.
         */
        cpu: number;
        /**
         * Maximum storage capacity in GB supported by this specification.
         */
        maxStorage: number;
        /**
         * Memory size in MB.
         */
        memory: number;
        /**
         * Minimum storage capacity in GB supported by this specification.
         */
        minStorage: number;
        /**
         * Estimated QPS for this specification.
         */
        qps: number;
        /**
         * Specification ID.
         */
        specCode: string;
    }

    export interface GetDbInstanceVersionsVersionSet {
        /**
         * List of versions to which this database version (`DBKernelVersion`) can be upgraded.
         */
        availableUpgradeTargets: string[];
        /**
         * Database engines. Valid values:1. `postgresql` (TencentDB for PostgreSQL)2. `mssqlCompatible` (MSSQL compatible-TencentDB for PostgreSQL).
         */
        dbEngine: string;
        /**
         * Database kernel version, such as v12.4_r1.3.
         */
        dbKernelVersion: string;
        /**
         * Database major version, such as 12.
         */
        dbMajorVersion: string;
        /**
         * Database version, such as 12.4.
         */
        dbVersion: string;
        /**
         * Database version status. Valid values:`AVAILABLE`.`DEPRECATED`.
         */
        status: string;
        /**
         * List of features supported by the database kernel, such as:TDE: Supports data encryption.
         */
        supportedFeatureNames: string[];
    }

    export interface GetDefaultParametersParamInfoSet {
        /**
         * Whether it is a key parameter. Valid values: `true` (yes, and modifying it may affect instance performance), `false` (no)Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        advanced: boolean;
        /**
         * Parameter category in ChineseNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        classificationCn: string;
        /**
         * Parameter category in EnglishNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        classificationEn: string;
        /**
         * Current value of the parameter, which is returned as a stringNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        currentValue: string;
        /**
         * Default value of the parameter, which is returned as a stringNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        defaultValue: string;
        /**
         * Value range of the enum parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        enumValues: string[];
        /**
         * Parameter IDNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        id: number;
        /**
         * The last modified time of the parameterNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        lastModifyTime: string;
        /**
         * The maximum value of the `integer` or `real` parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        max: number;
        /**
         * The minimum value of the `integer` or `real` parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        min: number;
        /**
         * Parameter nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        name: string;
        /**
         * Whether to restart the instance for the modified parameter to take effect. Valid values: `true` (yes), `false` (no)Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        needReboot: boolean;
        /**
         * Parameter description in ChineseNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        paramDescriptionCh: string;
        /**
         * Parameter description in EnglishNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        paramDescriptionEn: string;
        /**
         * Value type of the parameter. Valid values: `integer`, `real` (floating-point), `bool`, `enum`, `mutilEnum` (this type of parameter can be set to multiple enumerated values).For an `integer` or `real` parameter, the `Min` field represents the minimum value and the `Max` field the maximum value. For a `bool` parameter, the valid values include `true` and `false`; For an `enum` or `mutilEnum` parameter, the `EnumValue` field represents the valid values.Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        paramValueType: string;
        /**
         * Whether the parameter is related to specifications. Valid values: `true` (yes), `false` (no)Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        specRelated: boolean;
        /**
         * Associated parameter specification information, which refers to the detailed parameter information of the specifications.Note: This field may return null, indicating that no valid values can be obtained.
         */
        specRelationSets: outputs.Postgresql.GetDefaultParametersParamInfoSetSpecRelationSet[];
        /**
         * Primary-standby constraint. Valid values: `0` (no constraint), `1` (The parameter value of the standby server must be greater than that of the primary server), `2` (The parameter value of the primary server must be greater than that of the standby server.)Note: This field may return null, indicating that no valid values can be obtained.
         */
        standbyRelated: number;
        /**
         * Unit of the parameter value. If the parameter has no unit, this field will return null.Note: This field may return null, indicating that no valid values can be obtained.
         */
        unit: string;
        /**
         * Associated parameter version information, which refers to the detailed parameter information of the kernel version.Note: This field may return null, indicating that no valid values can be obtained.
         */
        versionRelationSets: outputs.Postgresql.GetDefaultParametersParamInfoSetVersionRelationSet[];
    }

    export interface GetDefaultParametersParamInfoSetSpecRelationSet {
        /**
         * Value range of the enum parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        enumValues: string[];
        /**
         * The maximum value of the `integer` or `real` parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        max: number;
        /**
         * The specification that corresponds to the parameter informationNote: This field may return null, indicating that no valid values can be obtained.
         */
        memory: string;
        /**
         * The minimum value of the `integer` or `real` parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        min: number;
        /**
         * Parameter nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        name: string;
        /**
         * Unit of the parameter value. If the parameter has no unit, this field will return null.Note: This field may return null, indicating that no valid values can be obtained.
         */
        unit: string;
        /**
         * Default parameter value under the kernel version and specification of the instanceNote: This field may return null, indicating that no valid values can be obtained.
         */
        value: string;
    }

    export interface GetDefaultParametersParamInfoSetVersionRelationSet {
        /**
         * The kernel version that corresponds to the parameter informationNote: This field may return null, indicating that no valid values can be obtained.
         */
        dbKernelVersion: string;
        /**
         * Value range of the enum parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        enumValues: string[];
        /**
         * The maximum value of the `integer` or `real` parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        max: number;
        /**
         * The minimum value of the `integer` or `real` parameterNote: This field may return null, indicating that no valid values can be obtained.
         */
        min: number;
        /**
         * Parameter nameNote: This field may return null, indicating that no valid values can be obtained.
         */
        name: string;
        /**
         * Unit of the parameter value. If the parameter has no unit, this field will return null.Note: This field may return null, indicating that no valid values can be obtained.
         */
        unit: string;
        /**
         * Default parameter value under the kernel version and specification of the instanceNote: This field may return null, indicating that no valid values can be obtained.
         */
        value: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * Auto renew flag.
         */
        autoRenewFlag: number;
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * Pay type of the postgresql instance.
         */
        chargeType: string;
        /**
         * Charset of the postgresql instance.
         */
        charset: string;
        /**
         * Create time of the postgresql instance.
         */
        createTime: string;
        /**
         * Version of the postgresql database engine.
         */
        engineVersion: string;
        /**
         * ID of the postgresql instance to be query.
         */
        id: string;
        /**
         * Memory size(in GB).
         */
        memory: number;
        /**
         * Name of the postgresql instance to be query.
         */
        name: string;
        /**
         * IP address for private access.
         */
        privateAccessIp: string;
        /**
         * Port for private access.
         */
        privateAccessPort: number;
        /**
         * Project ID of the postgresql instance to be query.
         */
        projectId: number;
        /**
         * Host for public access.
         */
        publicAccessHost: string;
        /**
         * Port for public access.
         */
        publicAccessPort: number;
        /**
         * Indicates whether to enable the access to an instance from public network or not.
         */
        publicAccessSwitch: boolean;
        /**
         * Instance root account name, default value is `root`.
         */
        rootUser: string;
        /**
         * Volume size(in GB).
         */
        storage: number;
        /**
         * ID of subnet.
         */
        subnetId: string;
        /**
         * The available tags within this postgresql.
         */
        tags: {[key: string]: any};
        /**
         * ID of VPC.
         */
        vpcId: string;
    }

    export interface GetLogBackupsFilter {
        /**
         * Filter name.
         */
        name?: string;
        /**
         * One or more filter values.
         */
        values?: string[];
    }

    export interface GetLogBackupsLogBackupSet {
        /**
         * Backup method, including physical and logical.
         */
        backupMethod: string;
        /**
         * Backup mode, including automatic and manual.
         */
        backupMode: string;
        /**
         * Instance ID.
         */
        dbInstanceId: string;
        /**
         * Backup expiration time.
         */
        expireTime: string;
        /**
         * Backup end time.
         */
        finishTime: string;
        /**
         * Unique ID of a backup file.
         */
        id: string;
        /**
         * Filter name.
         */
        name: string;
        /**
         * Backup set size in bytes.
         */
        size: number;
        /**
         * Backup start time.
         */
        startTime: string;
        /**
         * Backup task status.
         */
        state: string;
    }

    export interface GetParameterTemplatesFilter {
        /**
         * Filter name.
         */
        name?: string;
        /**
         * One or more filter values.
         */
        values?: string[];
    }

    export interface GetParameterTemplatesList {
        /**
         * the database engine for which the parameter template applies.
         */
        dbEngine: string;
        /**
         * the database version to which the parameter template applies.
         */
        dbMajorVersion: string;
        /**
         * parameter template description.
         */
        templateDescription: string;
        /**
         * parameter template ID.
         */
        templateId: string;
        /**
         * parameter template name.
         */
        templateName: string;
    }

    export interface GetReadonlyGroupsFilter {
        /**
         * Filter name.
         */
        name?: string;
        /**
         * One or more filter values.
         */
        values?: string[];
    }

    export interface GetReadonlyGroupsReadOnlyGroupList {
        /**
         * instance network connection information.
         */
        dbInstanceNetInfos: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListDbInstanceNetInfo[];
        /**
         * Master instance information, only returned when the instance is read-onlyNote: This field may return null, indicating that no valid value can be obtained.
         */
        masterDbInstanceId: string;
        /**
         * delay time size threshold.
         */
        maxReplayLag: number;
        /**
         * delay space size threshold.
         */
        maxReplayLatency: number;
        /**
         * Minimum Number of Reserved InstancesNote: This field may return null, indicating that no valid value can be obtained.
         */
        minDelayEliminateReserve: number;
        /**
         * Instance network information list (this field is obsolete)Note: This field may return null, indicating that no valid value can be obtained.
         */
        networkAccessLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListNetworkAccessList[];
        /**
         * project ID.
         */
        projectId: number;
        /**
         * instance details.
         */
        readOnlyDbInstanceLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceList[];
        /**
         * read-only group idNote: This field may return null, indicating that no valid value can be obtained.
         */
        readOnlyGroupId: string;
        /**
         * read-only group nameNote: This field may return null, indicating that no valid value can be obtained.
         */
        readOnlyGroupName: string;
        /**
         * automatic load balancing switch.
         */
        rebalance: number;
        /**
         * region id.
         */
        region: string;
        /**
         * delay time switch.
         */
        replayLagEliminate: number;
        /**
         * delay size switch.
         */
        replayLatencyEliminate: number;
        /**
         * state.
         */
        status: string;
        /**
         * subnet-idNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * virtual network id.
         */
        vpcId: string;
        /**
         * region id.
         */
        zone: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListDbInstanceNetInfo {
        /**
         * DNS domain name.
         */
        address: string;
        /**
         * IP address.
         */
        ip: string;
        /**
         * network type, 1. inner (intranet address of the basic network); 2. private (intranet address of the private network); 3. public (extranet address of the basic network or private network);.
         */
        netType: string;
        /**
         * connection port address.
         */
        port: number;
        /**
         * The protocol type for connecting to the database, currently supported: postgresql, mssql (MSSQL compatible syntax)Note: This field may return null, indicating that no valid value can be obtained.
         */
        protocolType: string;
        /**
         * state.
         */
        status: string;
        /**
         * subnet-idNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * virtual network id.
         */
        vpcId: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListNetworkAccessList {
        /**
         * Network resource id, instance id or RO group idNote: This field may return null, indicating that no valid value can be obtained.
         */
        resourceId: string;
        /**
         * Resource type, 1-instance 2-RO groupNote: This field may return null, indicating that no valid value can be obtained.
         */
        resourceType: number;
        /**
         * subnet-idNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * IPV4 addressNote: This field may return null, indicating that no valid value can be obtained.
         */
        vip: string;
        /**
         * IPV6 addressNote: This field may return null, indicating that no valid value can be obtained.
         */
        vip6: string;
        /**
         * virtual network id.
         */
        vpcId: string;
        /**
         * Network status, 1-applying, 2-using, 3-deleting, 4-deletedNote: This field may return null, indicating that no valid value can be obtained.
         */
        vpcStatus: number;
        /**
         * access portNote: This field may return null, indicating that no valid value can be obtained.
         */
        vport: number;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceList {
        /**
         * user&#39;s AppId.
         */
        appId: number;
        /**
         * auto-renew, 1: auto-renew, 0: no auto-renew.
         */
        autoRenew: number;
        /**
         * instance creation time.
         */
        createTime: string;
        /**
         * instance DB character set.
         */
        dbCharset: string;
        /**
         * Database engine that supports:1. postgresql (cloud database PostgreSQL);2. mssqlCompatible (MSSQL compatible - cloud database PostgreSQL);Note: This field may return null, indicating that no valid value can be obtained.
         */
        dbEngine: string;
        /**
         * Configuration information for the database engineNote: This field may return null, indicating that no valid value can be obtained.
         */
        dbEngineConfig: string;
        /**
         * sales specification ID.
         */
        dbInstanceClass: string;
        /**
         * the number of CPUs allocated by the instance.
         */
        dbInstanceCpu: number;
        /**
         * instance ID.
         */
        dbInstanceId: string;
        /**
         * the memory size allocated by the instance, unit: GB.
         */
        dbInstanceMemory: number;
        /**
         * instance name.
         */
        dbInstanceName: string;
        /**
         * instance network connection information.
         */
        dbInstanceNetInfos: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbInstanceNetInfo[];
        /**
         * Instance status, respectively: applying (applying), init (to be initialized), initing (initializing), running (running), limited run (limited run), isolated (isolated), recycling (recycling ), recycled (recycled), job running (task execution), offline (offline), migrating (migration), expanding (expanding), waitSwitch (waiting for switching), switching (switching), readonly (read-only ), restarting (restarting), network changing (network changing), upgrading (kernel version upgrade).
         */
        dbInstanceStatus: string;
        /**
         * the size of the storage space allocated by the instance, unit: GB.
         */
        dbInstanceStorage: number;
        /**
         * instance type, the types are: 1. primary (primary instance); 2. readonly (read-only instance); 3. guard (disaster recovery instance); 4. temp (temporary instance).
         */
        dbInstanceType: string;
        /**
         * instance version, currently only supports standard (dual machine high availability version, one master and one slave).
         */
        dbInstanceVersion: string;
        /**
         * Database kernel versionNote: This field may return null, indicating that no valid value can be obtained.
         */
        dbKernelVersion: string;
        /**
         * PostgreSQL major versionNote: This field may return null, indicating that no valid value can be obtained.
         */
        dbMajorVersion: string;
        /**
         * Instance node informationNote: This field may return null, indicating that no valid value can be obtained.
         */
        dbNodeSets: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbNodeSet[];
        /**
         * PostgreSQL version.
         */
        dbVersion: string;
        /**
         * instance expiration time.
         */
        expireTime: string;
        /**
         * Whether the instance supports TDE data encryption 0: not supported, 1: supportedNote: This field may return null, indicating that no valid value can be obtained.
         */
        isSupportTDE: number;
        /**
         * instance isolation time.
         */
        isolatedTime: string;
        /**
         * Master instance information, only returned when the instance is read-onlyNote: This field may return null, indicating that no valid value can be obtained.
         */
        masterDbInstanceId: string;
        /**
         * Instance network information list (this field is obsolete)Note: This field may return null, indicating that no valid value can be obtained.
         */
        networkAccessLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListNetworkAccessList[];
        /**
         * offline timeNote: This field may return null, indicating that no valid value can be obtained.
         */
        offlineTime: string;
        /**
         * billing mode, 1. prepaid (subscription, prepaid); 2. postpaid (billing by volume, postpaid).
         */
        payType: string;
        /**
         * project ID.
         */
        projectId: number;
        /**
         * Number of read-only instancesNote: This field may return null, indicating that no valid value can be obtained.
         */
        readOnlyInstanceNum: number;
        /**
         * region id.
         */
        region: string;
        /**
         * Status of the read-only instance in the read-only groupNote: This field may return null, indicating that no valid value can be obtained.
         */
        statusInReadonlyGroup: string;
        /**
         * subnet-idNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * Whether the instance supports Ipv6, 1: support, 0: not support.
         */
        supportIpv6: number;
        /**
         * Label information bound to the instanceNote: This field may return null, indicating that no valid value can be obtained.
         */
        tagLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListTagList[];
        /**
         * machine type.
         */
        type: string;
        /**
         * Uid of the instance.
         */
        uid: number;
        /**
         * The time when the instance performed the last update.
         */
        updateTime: string;
        /**
         * virtual network id.
         */
        vpcId: string;
        /**
         * region id.
         */
        zone: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbInstanceNetInfo {
        /**
         * DNS domain name.
         */
        address: string;
        /**
         * IP address.
         */
        ip: string;
        /**
         * network type, 1. inner (intranet address of the basic network); 2. private (intranet address of the private network); 3. public (extranet address of the basic network or private network);.
         */
        netType: string;
        /**
         * connection port address.
         */
        port: number;
        /**
         * The protocol type for connecting to the database, currently supported: postgresql, mssql (MSSQL compatible syntax)Note: This field may return null, indicating that no valid value can be obtained.
         */
        protocolType: string;
        /**
         * state.
         */
        status: string;
        /**
         * subnet-idNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * virtual network id.
         */
        vpcId: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbNodeSet {
        /**
         * Node type, the value can be:Primary, representing the primary node;Standby, stands for standby node.
         */
        role: string;
        /**
         * region id.
         */
        zone: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListNetworkAccessList {
        /**
         * Network resource id, instance id or RO group idNote: This field may return null, indicating that no valid value can be obtained.
         */
        resourceId: string;
        /**
         * Resource type, 1-instance 2-RO groupNote: This field may return null, indicating that no valid value can be obtained.
         */
        resourceType: number;
        /**
         * subnet-idNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * IPV4 addressNote: This field may return null, indicating that no valid value can be obtained.
         */
        vip: string;
        /**
         * IPV6 addressNote: This field may return null, indicating that no valid value can be obtained.
         */
        vip6: string;
        /**
         * virtual network id.
         */
        vpcId: string;
        /**
         * Network status, 1-applying, 2-using, 3-deleting, 4-deletedNote: This field may return null, indicating that no valid value can be obtained.
         */
        vpcStatus: number;
        /**
         * access portNote: This field may return null, indicating that no valid value can be obtained.
         */
        vport: number;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListTagList {
        /**
         * label key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

    export interface GetRegionsRegionSet {
        /**
         * Region abbreviation.
         */
        region: string;
        /**
         * Region number.
         */
        regionId: number;
        /**
         * Region name.
         */
        regionName: string;
        /**
         * Availability status. UNAVAILABLE: unavailable, AVAILABLE: available.
         */
        regionState: string;
        /**
         * Whether the resource can be purchased in this region. Valid values: `0` (no), `1` (yes).Note: this field may return `null`, indicating that no valid values can be obtained.
         */
        supportInternational: number;
    }

    export interface GetSpecinfosList {
        /**
         * The CPU number of the postgresql instance.
         */
        cpu: number;
        /**
         * Version of the postgresql database engine.
         */
        engineVersion: string;
        /**
         * Version name of the postgresql database engine.
         */
        engineVersionName: string;
        /**
         * ID of the postgresql instance speccode.
         */
        id: string;
        /**
         * Memory size(in GB).
         */
        memory: number;
        /**
         * The QPS of the postgresql instance.
         */
        qps: number;
        /**
         * The maximum volume size(in GB).
         */
        storageMax: number;
        /**
         * The minimum volume size(in GB).
         */
        storageMin: number;
    }

    export interface GetXlogsList {
        /**
         * Xlog end time, format `yyyy-MM-dd hh:mm:ss`.
         */
        endTime: string;
        /**
         * Xlog external download address.
         */
        externalAddr: string;
        /**
         * Xlog id.
         */
        id: number;
        /**
         * Xlog internal download address.
         */
        internalAddr: string;
        /**
         * Xlog file size.
         */
        size: number;
        /**
         * Xlog start time, format `yyyy-MM-dd hh:mm:ss`, start time cannot before 7 days ago.
         */
        startTime: string;
    }

    export interface GetZonesZoneSet {
        /**
         * AZs that can be used as standby when this AZ is primaryNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        standbyZoneSets: string[];
        /**
         * AZ abbreviation.
         */
        zone: string;
        /**
         * AZ number.
         */
        zoneId: number;
        /**
         * AZ name.
         */
        zoneName: string;
        /**
         * Availability status. Valid values:`UNAVAILABLE`.`AVAILABLE`.`SELLOUT`.`SUPPORTMODIFYONLY` (supports configuration adjustment).
         */
        zoneState: string;
        /**
         * Whether the AZ supports IPv6 address access.
         */
        zoneSupportIpv6: number;
    }

    export interface InstanceBackupPlan {
        /**
         * List of backup period per week, available values: `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `sunday`. NOTE: At least specify two days.
         */
        backupPeriods?: string[];
        /**
         * Specify days of the retention.
         */
        baseBackupRetentionPeriod?: number;
        /**
         * Specify latest backup start time, format `hh:mm:ss`.
         */
        maxBackupStartTime?: string;
        /**
         * Specify earliest backup start time, format `hh:mm:ss`.
         */
        minBackupStartTime?: string;
    }

    export interface InstanceDbNodeSet {
        /**
         * Indicates node type, available values:`Primary`, `Standby`. Default: `Standby`.
         */
        role?: string;
        /**
         * Indicates the node available zone.
         */
        zone: string;
    }

    export interface ParameterTemplateModifyParamEntrySet {
        /**
         * Modify the parameter value. The input parameters are passed in the form of strings, for example: decimal `0.1`, integer `1000`, enumeration `replica`.
         */
        expectedValue: string;
        /**
         * The parameter name.
         */
        name: string;
    }

    export interface ReadonlyGroupNetInfoList {
        /**
         * Ip address of the net info.
         */
        ip: string;
        /**
         * Port of the net info.
         */
        port: number;
    }

}

export namespace PrivateDns {
    export interface GetPrivateZoneListFilter {
        /**
         * name.
         */
        name: string;
        /**
         * values.
         */
        values: string[];
    }

    export interface GetPrivateZoneListPrivateZoneSet {
        /**
         * VPC list of bound associated accounts.
         */
        accountVpcSets: outputs.PrivateDns.GetPrivateZoneListPrivateZoneSetAccountVpcSet[];
        /**
         * CNAME acceleration status: enabled: ENABLED, off, DISABLED.
         */
        cnameSpeedupStatus: string;
        /**
         * Create time.
         */
        createdOn: string;
        /**
         * List of deleted VPCs.
         */
        deletedVpcSets: outputs.PrivateDns.GetPrivateZoneListPrivateZoneSetDeletedVpcSet[];
        /**
         * Domain name recursive resolution status: enabled: ENABLED, disabled, DISABLED.
         */
        dnsForwardStatus: string;
        /**
         * Domain.
         */
        domain: string;
        /**
         * End point name.
         */
        endPointName: string;
        /**
         * Forwarded address.
         */
        forwardAddress: string;
        /**
         * Forwarding rule name.
         */
        forwardRuleName: string;
        /**
         * Forwarding rule type: from cloud to cloud, DOWN; From cloud to cloud, UP, currently only supports DOWN.
         */
        forwardRuleType: string;
        /**
         * Custom TLD.
         */
        isCustomTld: boolean;
        /**
         * Owner Uin.
         */
        ownerUin: number;
        /**
         * Record count.
         */
        recordCount: number;
        /**
         * Remark.
         */
        remark: string;
        /**
         * Private domain bound VPC status, not associated with vpc: SUSPEND, associated with VPC: ENABLED, associated with VPC failed: FAILED.
         */
        status: string;
        /**
         * tags.
         */
        tags: outputs.PrivateDns.GetPrivateZoneListPrivateZoneSetTag[];
        /**
         * Update time.
         */
        updatedOn: string;
        /**
         * Vpc list.
         */
        vpcSets: outputs.PrivateDns.GetPrivateZoneListPrivateZoneSetVpcSet[];
        /**
         * PrivateZone ID.
         */
        zoneId: string;
    }

    export interface GetPrivateZoneListPrivateZoneSetAccountVpcSet {
        /**
         * Region.
         */
        region: string;
        /**
         * uin.
         */
        uin: string;
        /**
         * Vpc Id.
         */
        uniqVpcId: string;
    }

    export interface GetPrivateZoneListPrivateZoneSetDeletedVpcSet {
        /**
         * Region.
         */
        region: string;
        /**
         * Vpc Id.
         */
        uniqVpcId: string;
    }

    export interface GetPrivateZoneListPrivateZoneSetTag {
        /**
         * tag key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

    export interface GetPrivateZoneListPrivateZoneSetVpcSet {
        /**
         * Region.
         */
        region: string;
        /**
         * Vpc Id.
         */
        uniqVpcId: string;
    }

    export interface GetRecordsFilter {
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetRecordsRecordSet {
        /**
         * Record creation time.
         */
        createdOn: string;
        /**
         * Enabled. 0 meaning paused, 1 meaning senabled.
         */
        enabled: number;
        /**
         * Additional information.
         */
        extra: string;
        /**
         * MX priority: required if the record type is MX. Value range: 5,10,15,20,30,40,50.
         */
        mx: number;
        /**
         * Record sid.
         */
        recordId: string;
        /**
         * Record type, optional record type are: A, AAAA, CNAME, MX, TXT, PTR.
         */
        recordType: string;
        /**
         * Record value.
         */
        recordValue: string;
        /**
         * Record status.
         */
        status: string;
        /**
         * Subdomain name.
         */
        subDomain: string;
        /**
         * Record cache time, the smaller the value, the faster it takes effect. The value is 1-86400s. The default is 600.
         */
        ttl: number;
        /**
         * Record update time.
         */
        updatedOn: string;
        /**
         * Record weight, value is 1-100.
         */
        weight: number;
        /**
         * Private zone id: zone-xxxxxx.
         */
        zoneId: string;
    }

    export interface ZoneAccountVpcSet {
        /**
         * Region.
         */
        region: string;
        /**
         * UIN of the VPC account.
         */
        uin: string;
        /**
         * VPC ID.
         */
        uniqVpcId: string;
        /**
         * VPC NAME.
         */
        vpcName: string;
    }

    export interface ZoneTagSet {
        /**
         * Key of Tag.
         */
        tagKey: string;
        /**
         * Value of Tag.
         */
        tagValue: string;
    }

    export interface ZoneVpcAttachmentAccountVpcSet {
        /**
         * Vpc region.
         */
        region: string;
        /**
         * Vpc owner uin. To grant role authorization to this account.
         */
        uin: string;
        /**
         * Uniq Vpc Id.
         */
        uniqVpcId: string;
    }

    export interface ZoneVpcAttachmentVpcSet {
        /**
         * Vpc region.
         */
        region: string;
        /**
         * Uniq Vpc Id.
         */
        uniqVpcId: string;
    }

    export interface ZoneVpcSet {
        /**
         * VPC REGION.
         */
        region: string;
        /**
         * VPC ID.
         */
        uniqVpcId: string;
    }

}

export namespace Projects {
    export interface GetInstanceProject {
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Uin of Creator.
         */
        creatorUin: number;
        /**
         * ID of Project.
         */
        projectId: number;
        /**
         * Description of project.
         */
        projectInfo: string;
        /**
         * Name of Project.
         */
        projectName: string;
    }

}

export namespace Protocol {
    export interface GetTemplateGroupsGroupList {
        /**
         * ID of the protocol template group to query.
         */
        id: string;
        /**
         * Name of the protocol template group to query.
         */
        name: string;
        /**
         * ID set of the protocol template.
         */
        templateIds: string[];
    }

    export interface GetTemplatesTemplateList {
        /**
         * ID of the protocol template to query.
         */
        id: string;
        /**
         * Name of the protocol template to query.
         */
        name: string;
        /**
         * Set of the protocols.
         */
        protocols: string[];
    }

}

export namespace Pts {
    export interface FileFileInfo {
        /**
         * File id.
         */
        fileId?: string;
        /**
         * File name.
         */
        name?: string;
        /**
         * File size.
         */
        size?: number;
        /**
         * File type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSet {
        /**
         * Jobs related to the scenario.
         */
        jobs: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJob[];
        /**
         * The returned scenario.
         */
        scenarios: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenario[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJob {
        /**
         * The reason for aborting the job.
         */
        abortReason: number;
        /**
         * Deprecated.
         */
        configs: string[];
        /**
         * The creation time of the scenario.
         */
        createdAt: string;
        /**
         * The cron job ID.
         */
        cronId: string;
        /**
         * The test data sets for the load test.
         */
        datasets: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobDataset[];
        /**
         * Whether to run the job in the debug mode. The default value is false.
         */
        debug: boolean;
        /**
         * The configuration for parsing domain names.
         */
        domainNameConfigs: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobDomainNameConfig[];
        /**
         * Job running duration.
         */
        duration: number;
        /**
         * The job ending time.
         */
        endTime: string;
        /**
         * Error rate.
         */
        errorRate: number;
        /**
         * Deprecated.
         */
        extensions: string[];
        /**
         * Job ID.
         */
        jobId: string;
        /**
         * Job owner.
         */
        jobOwner: string;
        /**
         * The load source information.
         */
        loadSourceInfos: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadSourceInfo[];
        /**
         * Deprecated.
         */
        loadSources: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadSource[];
        /**
         * Scenario is load test configuration.
         */
        loads: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoad[];
        /**
         * The maximum RPS.
         */
        maxRequestsPerSecond: number;
        /**
         * The maximum VU of the job.
         */
        maxVirtualUserCount: number;
        /**
         * The message describing the job running status.
         */
        message: string;
        /**
         * The rate of receiving bytes.
         */
        networkReceiveRate: number;
        /**
         * The rate of sending bytes.
         */
        networkSendRate: number;
        /**
         * The note of the job.
         */
        note: string;
        /**
         * The notification hooks.
         */
        notificationHooks: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobNotificationHook[];
        /**
         * Plugins.
         */
        plugins: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobPlugin[];
        /**
         * Project ID.
         */
        projectId: string;
        /**
         * Project name.
         */
        projectName: string;
        /**
         * The protocol file.
         */
        protocols: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobProtocol[];
        /**
         * The files in the request.
         */
        requestFiles: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobRequestFile[];
        /**
         * The total reqeust count.
         */
        requestTotal: number;
        /**
         * The configuration of the RPS mode load test.
         */
        requestsPerSecond: number;
        /**
         * The average response time.
         */
        responseTimeAverage: number;
        /**
         * The maximum response time.
         */
        responseTimeMax: number;
        /**
         * The minimum response time.
         */
        responseTimeMin: number;
        /**
         * The 90 percentile of the response time.
         */
        responseTimeP90: number;
        /**
         * The 95 percentile of the response time.
         */
        responseTimeP95: number;
        /**
         * The 99 percentile of the response time.
         */
        responseTimeP99: number;
        /**
         * Scenario ID.
         */
        scenarioId: string;
        /**
         * Scenario name.
         */
        scenarioName: string;
        /**
         * Deprecated.
         */
        scripts: string[];
        /**
         * The job starting time.
         */
        startTime: string;
        /**
         * Scenario status.
         */
        status: number;
        /**
         * The script of the load test.
         */
        testScripts: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobTestScript[];
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobDataset {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * The header lines of the file.
         */
        headLines: string[];
        /**
         * The parameter name list.
         */
        headerColumns: string[];
        /**
         * Whether the first line contains the parameter names.
         */
        headerInFile: boolean;
        /**
         * The line count of the file.
         */
        lineCount: number;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Whether to split the test data.
         */
        split: boolean;
        /**
         * The tail lines of the file.
         */
        tailLines: string[];
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobDomainNameConfig {
        /**
         * The DNS configuration.
         */
        dnsConfigs: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobDomainNameConfigDnsConfig[];
        /**
         * The configuration for host aliases.
         */
        hostAliases: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobDomainNameConfigHostAlias[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobDomainNameConfigDnsConfig {
        /**
         * DNS IP list.
         */
        nameservers: string[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobDomainNameConfigHostAlias {
        /**
         * Host names.
         */
        hostNames: string[];
        /**
         * IP.
         */
        ip: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoad {
        /**
         * The geographical distribution of the load source.
         */
        geoRegionsLoadDistributions: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadGeoRegionsLoadDistribution[];
        /**
         * Scenario is load specification.
         */
        loadSpecs: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpec[];
        /**
         * The distribution of the load source.
         */
        vpcLoadDistributions: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadVpcLoadDistribution[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadGeoRegionsLoadDistribution {
        /**
         * Percentage.
         */
        percentage: number;
        /**
         * Region.
         */
        region: string;
        /**
         * Region ID.
         */
        regionId: number;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpec {
        /**
         * The configuration for the concurrency mode.
         */
        concurrencies: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecConcurrency[];
        /**
         * The configuration of the RPS mode load test.
         */
        requestsPerSeconds: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecRequestsPerSecond[];
        /**
         * The script origin.
         */
        scriptOrigins: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecScriptOrigin[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecConcurrency {
        /**
         * The waiting period for a graceful shutdown.
         */
        gracefulStopSeconds: number;
        /**
         * The iteration count of the load test.
         */
        iterationCount: number;
        /**
         * The maximum RPS.
         */
        maxRequestsPerSecond: number;
        /**
         * The recource count of the load test.
         */
        resources: number;
        /**
         * The configuration for the multi-stage load test.
         */
        stages: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecConcurrencyStage[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecConcurrencyStage {
        /**
         * The load test execution time.
         */
        durationSeconds: number;
        /**
         * Deprecated.
         */
        targetVirtualUsers: number;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecRequestsPerSecond {
        /**
         * The load test execution time.
         */
        durationSeconds: number;
        /**
         * The waiting period for a graceful shutdown.
         */
        gracefulStopSeconds: number;
        /**
         * The maximum RPS.
         */
        maxRequestsPerSecond: number;
        /**
         * The recource count of the load test.
         */
        resources: number;
        /**
         * The starting minimum RPS.
         */
        startRequestsPerSecond: number;
        /**
         * The target RPS.
         */
        targetRequestsPerSecond: number;
        /**
         * Deprecated.
         */
        targetVirtualUsers: number;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadLoadSpecScriptOrigin {
        /**
         * The load test execution time.
         */
        durationSeconds: number;
        /**
         * The load test machine number.
         */
        machineNumber: number;
        /**
         * The load test machine specification.
         */
        machineSpecification: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadSource {
        /**
         * IP.
         */
        ip: string;
        /**
         * The pod name of the load source.
         */
        podName: string;
        /**
         * Region.
         */
        region: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadSourceInfo {
        /**
         * IP.
         */
        ip: string;
        /**
         * The pod name of the load source.
         */
        podName: string;
        /**
         * Region.
         */
        region: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobLoadVpcLoadDistribution {
        /**
         * Region.
         */
        region: string;
        /**
         * Region ID.
         */
        regionId: number;
        /**
         * The subnet ID list.
         */
        subnetIds: string[];
        /**
         * The VPC ID.
         */
        vpcId: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobNotificationHook {
        /**
         * The notification hook.
         */
        events: string[];
        /**
         * The callback URL.
         */
        url: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobPlugin {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobProtocol {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobRequestFile {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetJobTestScript {
        /**
         * The base64 encoded content.
         */
        encodedContent: string;
        /**
         * The base64 encoded HAR.
         */
        encodedHttpArchive: string;
        /**
         * File ID.
         */
        fileId: string;
        /**
         * The weight of the script, ranging from 1 to 100.
         */
        loadWeight: number;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenario {
        /**
         * AppId.
         */
        appId: number;
        /**
         * Deprecated.
         */
        configs: string[];
        /**
         * The creation time of the scenario.
         */
        createdAt: string;
        /**
         * The cron job ID.
         */
        cronId: string;
        /**
         * The test data sets for the load test.
         */
        datasets: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioDataset[];
        /**
         * Scenario description.
         */
        description: string;
        /**
         * The configuration for parsing domain names.
         */
        domainNameConfigs: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioDomainNameConfig[];
        /**
         * Deprecated.
         */
        encodedScripts: string;
        /**
         * Deprecated.
         */
        extensions: string[];
        /**
         * Scenario is load test configuration.
         */
        loads: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoad[];
        /**
         * File name.
         */
        name: string;
        /**
         * The notification hooks.
         */
        notificationHooks: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioNotificationHook[];
        /**
         * The job owner.
         */
        owner: string;
        /**
         * Plugins.
         */
        plugins: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioPlugin[];
        /**
         * Project ID.
         */
        projectId: string;
        /**
         * Project name.
         */
        projectName: string;
        /**
         * The protocol file.
         */
        protocols: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioProtocol[];
        /**
         * The files in the request.
         */
        requestFiles: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioRequestFile[];
        /**
         * Scenario ID.
         */
        scenarioId: string;
        /**
         * The ID of the SLA policy.
         */
        slaId: string;
        /**
         * The SLA policy.
         */
        slaPolicies: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicy[];
        /**
         * Scenario status.
         */
        status: number;
        /**
         * SubAccountUin.
         */
        subAccountUin: string;
        /**
         * The script of the load test.
         */
        testScripts: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioTestScript[];
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * Uin.
         */
        uin: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioDataset {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * The header lines of the file.
         */
        headLines: string[];
        /**
         * The parameter name list.
         */
        headerColumns: string[];
        /**
         * Whether the first line contains the parameter names.
         */
        headerInFile: boolean;
        /**
         * The line count of the file.
         */
        lineCount: number;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Whether to split the test data.
         */
        split: boolean;
        /**
         * The tail lines of the file.
         */
        tailLines: string[];
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioDomainNameConfig {
        /**
         * The DNS configuration.
         */
        dnsConfigs: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioDomainNameConfigDnsConfig[];
        /**
         * The configuration for host aliases.
         */
        hostAliases: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioDomainNameConfigHostAlias[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioDomainNameConfigDnsConfig {
        /**
         * DNS IP list.
         */
        nameservers: string[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioDomainNameConfigHostAlias {
        /**
         * Host names.
         */
        hostNames: string[];
        /**
         * IP.
         */
        ip: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoad {
        /**
         * The geographical distribution of the load source.
         */
        geoRegionsLoadDistributions: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoadGeoRegionsLoadDistribution[];
        /**
         * Scenario is load specification.
         */
        loadSpecs: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpec[];
        /**
         * The distribution of the load source.
         */
        vpcLoadDistributions: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoadVpcLoadDistribution[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoadGeoRegionsLoadDistribution {
        /**
         * Percentage.
         */
        percentage: number;
        /**
         * Region.
         */
        region: string;
        /**
         * Region ID.
         */
        regionId: number;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpec {
        /**
         * The configuration for the concurrency mode.
         */
        concurrencies: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecConcurrency[];
        /**
         * The configuration of the RPS mode load test.
         */
        requestsPerSeconds: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecRequestsPerSecond[];
        /**
         * The script origin.
         */
        scriptOrigins: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecScriptOrigin[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecConcurrency {
        /**
         * The waiting period for a graceful shutdown.
         */
        gracefulStopSeconds: number;
        /**
         * The iteration count of the load test.
         */
        iterationCount: number;
        /**
         * The maximum RPS.
         */
        maxRequestsPerSecond: number;
        /**
         * The recource count of the load test.
         */
        resources: number;
        /**
         * The configuration for the multi-stage load test.
         */
        stages: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecConcurrencyStage[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecConcurrencyStage {
        /**
         * The load test execution time.
         */
        durationSeconds: number;
        /**
         * Deprecated.
         */
        targetVirtualUsers: number;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecRequestsPerSecond {
        /**
         * The load test execution time.
         */
        durationSeconds: number;
        /**
         * The waiting period for a graceful shutdown.
         */
        gracefulStopSeconds: number;
        /**
         * The maximum RPS.
         */
        maxRequestsPerSecond: number;
        /**
         * The recource count of the load test.
         */
        resources: number;
        /**
         * The starting minimum RPS.
         */
        startRequestsPerSecond: number;
        /**
         * The target RPS.
         */
        targetRequestsPerSecond: number;
        /**
         * Deprecated.
         */
        targetVirtualUsers: number;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoadLoadSpecScriptOrigin {
        /**
         * The load test execution time.
         */
        durationSeconds: number;
        /**
         * The load test machine number.
         */
        machineNumber: number;
        /**
         * The load test machine specification.
         */
        machineSpecification: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioLoadVpcLoadDistribution {
        /**
         * Region.
         */
        region: string;
        /**
         * Region ID.
         */
        regionId: number;
        /**
         * The subnet ID list.
         */
        subnetIds: string[];
        /**
         * The VPC ID.
         */
        vpcId: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioNotificationHook {
        /**
         * The notification hook.
         */
        events: string[];
        /**
         * The callback URL.
         */
        url: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioPlugin {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioProtocol {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioRequestFile {
        /**
         * File ID.
         */
        fileId: string;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicy {
        /**
         * The alert channel.
         */
        alertChannels: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicyAlertChannel[];
        /**
         * The SLA rules.
         */
        slaRules: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicySlaRule[];
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicyAlertChannel {
        /**
         * AMP consumer ID.
         */
        ampConsumerId: string;
        /**
         * The notice ID bound with this alert channel.
         */
        noticeId: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicySlaRule {
        /**
         * Whether to abort the load test job.
         */
        abortFlag: boolean;
        /**
         * The aggregation method of the metrics.
         */
        aggregation: string;
        /**
         * The operator for checking the condition.
         */
        condition: string;
        /**
         * The duration for checking the condition.
         */
        for: string;
        /**
         * The label filter.
         */
        labelFilters: outputs.Pts.GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicySlaRuleLabelFilter[];
        /**
         * The load test metrics.
         */
        metric: string;
        /**
         * The threshold in the condition.
         */
        value: number;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioSlaPolicySlaRuleLabelFilter {
        /**
         * Label name.
         */
        labelName: string;
        /**
         * Label value.
         */
        labelValue: string;
    }

    export interface GetScenarioWithJobsScenarioWithJobsSetScenarioTestScript {
        /**
         * The base64 encoded content.
         */
        encodedContent: string;
        /**
         * The base64 encoded HAR.
         */
        encodedHttpArchive: string;
        /**
         * File ID.
         */
        fileId: string;
        /**
         * The weight of the script, ranging from 1 to 100.
         */
        loadWeight: number;
        /**
         * File name.
         */
        name: string;
        /**
         * File size.
         */
        size: number;
        /**
         * Scenario type, e.g.: pts-http, pts-js, pts-trpc, pts-jmeter.
         */
        type: string;
        /**
         * The updating time of the scenario.
         */
        updatedAt: string;
    }

    export interface JobDataset {
        /**
         * File ID.
         */
        fileId?: string;
        /**
         * Header data row.
         */
        headLines?: string[];
        /**
         * Parameter name array.
         */
        headerColumns?: string[];
        /**
         * Whether the first line is the parameter name.
         */
        headerInFile: boolean;
        /**
         * Number of file lines.
         */
        lineCount?: number;
        /**
         * The file name where the test dataset is located.
         */
        name: string;
        /**
         * Number of file bytes.
         */
        size?: number;
        /**
         * Test whether the dataset is fragmented.
         */
        split: boolean;
        /**
         * Trailing data row.
         */
        tailLines?: string[];
        /**
         * Scene Type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface JobDomainNameConfig {
        /**
         * DNS configuration.
         */
        dnsConfig?: outputs.Pts.JobDomainNameConfigDnsConfig;
        /**
         * Domain name binding configuration.
         */
        hostAliases?: outputs.Pts.JobDomainNameConfigHostAlias[];
    }

    export interface JobDomainNameConfigDnsConfig {
        /**
         * DNS IP List.
         */
        nameservers?: string[];
    }

    export interface JobDomainNameConfigHostAlias {
        /**
         * List of domain names to be bound.
         */
        hostNames?: string[];
        /**
         * The IP address to be bound.
         */
        ip?: string;
    }

    export interface JobLoad {
        /**
         * Pressure distribution.
         */
        geoRegionsLoadDistributions?: outputs.Pts.JobLoadGeoRegionsLoadDistribution[];
        /**
         * Pressure allocation.
         */
        loadSpec?: outputs.Pts.JobLoadLoadSpec;
        /**
         * Source of stress.
         */
        vpcLoadDistribution?: outputs.Pts.JobLoadVpcLoadDistribution;
    }

    export interface JobLoadGeoRegionsLoadDistribution {
        /**
         * Percentage.
         */
        percentage?: number;
        /**
         * Region.
         */
        region?: string;
        /**
         * Regional ID.
         */
        regionId: number;
    }

    export interface JobLoadLoadSpec {
        /**
         * Configuration of concurrent pressure mode.
         */
        concurrency?: outputs.Pts.JobLoadLoadSpecConcurrency;
        /**
         * Average number of requests per second.
         */
        requestsPerSecond?: outputs.Pts.JobLoadLoadSpecRequestsPerSecond;
        /**
         * Built-in stress mode in script.
         */
        scriptOrigin?: outputs.Pts.JobLoadLoadSpecScriptOrigin;
    }

    export interface JobLoadLoadSpecConcurrency {
        /**
         * Wait time for graceful termination of the task.
         */
        gracefulStopSeconds?: number;
        /**
         * Number of runs.
         */
        iterationCount?: number;
        /**
         * Maximum requests per second.
         */
        maxRequestsPerSecond?: number;
        /**
         * Multi-phase configuration array.
         */
        stages?: outputs.Pts.JobLoadLoadSpecConcurrencyStage[];
    }

    export interface JobLoadLoadSpecConcurrencyStage {
        /**
         * Pressure time.
         */
        durationSeconds?: number;
        /**
         * Number of virtual users.
         */
        targetVirtualUsers?: number;
    }

    export interface JobLoadLoadSpecRequestsPerSecond {
        /**
         * Pressure time.
         */
        durationSeconds?: number;
        /**
         * Elegant shutdown waiting time.
         */
        gracefulStopSeconds?: number;
        /**
         * Maximum requests per second.
         */
        maxRequestsPerSecond?: number;
        /**
         * Number of resources.
         */
        resources?: number;
        /**
         * Initial RPS.
         */
        startRequestsPerSecond?: number;
        /**
         * Target RPS, invalid input parameter.
         */
        targetRequestsPerSecond?: number;
    }

    export interface JobLoadLoadSpecScriptOrigin {
        /**
         * Pressure testing time.
         */
        durationSeconds: number;
        /**
         * Number of machines.
         */
        machineNumber: number;
        /**
         * Machine specification.
         */
        machineSpecification: string;
    }

    export interface JobLoadVpcLoadDistribution {
        /**
         * Region.
         */
        region?: string;
        /**
         * Regional ID.
         */
        regionId: number;
        /**
         * Subnet ID list.
         */
        subnetIds?: string[];
        /**
         * VPC ID.
         */
        vpcId?: string;
    }

    export interface JobPlugin {
        /**
         * File id.
         */
        fileId?: string;
        /**
         * File name.
         */
        name?: string;
        /**
         * File size.
         */
        size?: number;
        /**
         * Scene Type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface JobProtocol {
        /**
         * File ID.
         */
        fileId?: string;
        /**
         * Protocol name.
         */
        name?: string;
        /**
         * File name.
         */
        size?: number;
        /**
         * Scene Type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface JobRequestFile {
        /**
         * File id.
         */
        fileId?: string;
        /**
         * File name.
         */
        name?: string;
        /**
         * File size.
         */
        size?: number;
        /**
         * Scene Type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface JobTestScript {
        /**
         * Base64 encoded file content.
         */
        encodedContent?: string;
        /**
         * Base64 encoded har structure.
         */
        encodedHttpArchive?: string;
        /**
         * Script weight, range 1-100.
         */
        loadWeight?: number;
        /**
         * File name.
         */
        name?: string;
        /**
         * File size.
         */
        size?: number;
        /**
         * Scene Type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface ProjectTag {
        /**
         * tag key.
         */
        tagKey?: string;
        /**
         * tag value.
         */
        tagValue?: string;
    }

    export interface ScenarioDataset {
        /**
         * File ID.
         */
        fileId?: string;
        /**
         * Header data row.
         */
        headLines?: string[];
        /**
         * Parameter name array.
         */
        headerColumns?: string[];
        /**
         * Whether the first line is the parameter name.
         */
        headerInFile: boolean;
        /**
         * Number of file lines.
         */
        lineCount?: number;
        /**
         * The file name where the test dataset is located.
         */
        name: string;
        /**
         * Number of file bytes.
         */
        size?: number;
        /**
         * Test whether the dataset is fragmented.
         */
        split: boolean;
        /**
         * Trailing data row.
         */
        tailLines?: string[];
        /**
         * File type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface ScenarioDomainNameConfig {
        /**
         * DNS configuration.
         */
        dnsConfig?: outputs.Pts.ScenarioDomainNameConfigDnsConfig;
        /**
         * Domain name binding configuration.
         */
        hostAliases?: outputs.Pts.ScenarioDomainNameConfigHostAlias[];
    }

    export interface ScenarioDomainNameConfigDnsConfig {
        /**
         * DNS IP List.
         */
        nameservers?: string[];
    }

    export interface ScenarioDomainNameConfigHostAlias {
        /**
         * List of domain names to be bound.
         */
        hostNames?: string[];
        /**
         * The IP address to be bound.
         */
        ip?: string;
    }

    export interface ScenarioLoad {
        /**
         * Pressure distribution.
         */
        geoRegionsLoadDistributions?: outputs.Pts.ScenarioLoadGeoRegionsLoadDistribution[];
        /**
         * Pressure allocation.
         */
        loadSpec?: outputs.Pts.ScenarioLoadLoadSpec;
        /**
         * Source of stress.
         */
        vpcLoadDistribution?: outputs.Pts.ScenarioLoadVpcLoadDistribution;
    }

    export interface ScenarioLoadGeoRegionsLoadDistribution {
        /**
         * Percentage.
         */
        percentage?: number;
        /**
         * Region.
         */
        region?: string;
        /**
         * Regional ID.
         */
        regionId: number;
    }

    export interface ScenarioLoadLoadSpec {
        /**
         * Configuration of concurrent pressure mode.
         */
        concurrency?: outputs.Pts.ScenarioLoadLoadSpecConcurrency;
        /**
         * Configuration of RPS pressure mode.
         */
        requestsPerSecond?: outputs.Pts.ScenarioLoadLoadSpecRequestsPerSecond;
        /**
         * Built-in stress mode in script.
         */
        scriptOrigin?: outputs.Pts.ScenarioLoadLoadSpecScriptOrigin;
    }

    export interface ScenarioLoadLoadSpecConcurrency {
        /**
         * Wait time for graceful termination of the task.
         */
        gracefulStopSeconds?: number;
        /**
         * Number of runs.
         */
        iterationCount?: number;
        /**
         * Maximum RPS.
         */
        maxRequestsPerSecond?: number;
        /**
         * Multi-phase configuration array.
         */
        stages?: outputs.Pts.ScenarioLoadLoadSpecConcurrencyStage[];
    }

    export interface ScenarioLoadLoadSpecConcurrencyStage {
        /**
         * Pressure time.
         */
        durationSeconds?: number;
        /**
         * Number of virtual users.
         */
        targetVirtualUsers?: number;
    }

    export interface ScenarioLoadLoadSpecRequestsPerSecond {
        /**
         * Pressure time.
         */
        durationSeconds?: number;
        /**
         * Elegant shutdown waiting time.
         */
        gracefulStopSeconds?: number;
        /**
         * Maximum RPS.
         */
        maxRequestsPerSecond?: number;
        /**
         * Number of resources.
         */
        resources?: number;
        /**
         * Initial RPS.
         */
        startRequestsPerSecond?: number;
        /**
         * Target RPS, invalid input parameter.
         */
        targetRequestsPerSecond?: number;
    }

    export interface ScenarioLoadLoadSpecScriptOrigin {
        /**
         * Pressure testing time.
         */
        durationSeconds: number;
        /**
         * Number of machines.
         */
        machineNumber: number;
        /**
         * Machine specification.
         */
        machineSpecification: string;
    }

    export interface ScenarioLoadVpcLoadDistribution {
        /**
         * Region.
         */
        region?: string;
        /**
         * Regional ID.
         */
        regionId: number;
        /**
         * Subnet ID list.
         */
        subnetIds?: string[];
        /**
         * VPC ID.
         */
        vpcId?: string;
    }

    export interface ScenarioPlugin {
        /**
         * File id.
         */
        fileId?: string;
        /**
         * File name.
         */
        name?: string;
        /**
         * File size.
         */
        size?: number;
        /**
         * File type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface ScenarioProtocol {
        /**
         * File ID.
         */
        fileId?: string;
        /**
         * Protocol name.
         */
        name?: string;
        /**
         * File name.
         */
        size?: number;
        /**
         * File type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface ScenarioRequestFile {
        /**
         * File id.
         */
        fileId?: string;
        /**
         * File name.
         */
        name?: string;
        /**
         * File size.
         */
        size?: number;
        /**
         * File type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface ScenarioSlaPolicy {
        /**
         * Alarm notification channel.
         */
        alertChannel?: outputs.Pts.ScenarioSlaPolicyAlertChannel;
        /**
         * SLA rules.
         */
        slaRules?: outputs.Pts.ScenarioSlaPolicySlaRule[];
    }

    export interface ScenarioSlaPolicyAlertChannel {
        /**
         * AMP consumer ID.
         */
        ampConsumerId?: string;
        /**
         * Notification template ID.
         */
        noticeId?: string;
    }

    export interface ScenarioSlaPolicySlaRule {
        /**
         * Whether to stop the stress test task.
         */
        abortFlag?: boolean;
        /**
         * Aggregation method of pressure test index.
         */
        aggregation?: string;
        /**
         * Pressure test index condition judgment symbol.
         */
        condition?: string;
        /**
         * duraion.
         */
        for?: string;
        /**
         * tag.
         */
        labelFilters?: outputs.Pts.ScenarioSlaPolicySlaRuleLabelFilter[];
        /**
         * Pressure test index.
         */
        metric?: string;
        /**
         * Threshold value.
         */
        value?: number;
    }

    export interface ScenarioSlaPolicySlaRuleLabelFilter {
        /**
         * Label name.
         */
        labelName?: string;
        /**
         * Label value.
         */
        labelValue?: string;
    }

    export interface ScenarioTestScript {
        /**
         * Base64 encoded file content.
         */
        encodedContent?: string;
        /**
         * Base64 encoded har structure.
         */
        encodedHttpArchive?: string;
        /**
         * Script weight, range 1-100.
         */
        loadWeight?: number;
        /**
         * File name.
         */
        name?: string;
        /**
         * File size.
         */
        size?: number;
        /**
         * File type.
         */
        type?: string;
        /**
         * Update time.
         */
        updatedAt?: string;
    }

    export interface TmpKeyGenerateCredential {
        /**
         * Temporary secret ID.
         */
        tmpSecretId: string;
        /**
         * Temporary secret key.
         */
        tmpSecretKey: string;
        /**
         * Temporary token.
         */
        token: string;
    }

}

export namespace Redis {
    export interface BackupDownloadRestrictionLimitVpc {
        /**
         * Customize the region of the VPC to which the backup file is downloaded.
         */
        region: string;
        /**
         * Customize the list of VPCs to download backup files.
         */
        vpcLists: string[];
    }

    export interface GetBackupBackupSet {
        /**
         * Backup ID.
         */
        backupId: string;
        /**
         * Internal fields, which can be ignored by the user.
         */
        backupSize: number;
        /**
         * Backup type.1: User-initiated manual backup.0: System-initiated backup in the early morning.
         */
        backupType: string;
        /**
         * End time, such as 2017-02-08 19:09:26.Query the list of backups that the instance started backing up during the [beginTime, endTime] time period.
         */
        endTime: string;
        /**
         * Backup file expiration time.
         */
        expireTime: string;
        /**
         * Back up file types.
         */
        fileType: string;
        /**
         * Internal fields, which can be ignored by the user.
         */
        fullBackup: number;
        /**
         * The ID of instance.
         */
        instanceId: string;
        /**
         * Instance name, which supports fuzzy search based on instance name.
         */
        instanceName: string;
        /**
         * Internal fields, which can be ignored by the user.
         */
        instanceType: number;
        /**
         * Whether the backup is locked.0: Not locked.1: Has been locked.
         */
        locked: number;
        /**
         * The region where the backup is located.
         */
        region: string;
        /**
         * Notes information for the backup.
         */
        remark: string;
        /**
         * Backup start time.
         */
        startTime: string;
        /**
         * Status of the backup task:1: Backup is in the process.2: The backup is normal.3: Backup to RDB file processing.4: RDB conversion completed.-1: The backup has expired.-2: Backup deleted.
         */
        status: number;
    }

    export interface GetBackupDownloadInfoBackupInfo {
        /**
         * Backup file download address on the Internet (6 hours).
         */
        downloadUrl: string;
        /**
         * Backup file name.
         */
        fileName: string;
        /**
         * The backup file size is in unit B, if it is 0, it is invalid.
         */
        fileSize: number;
        /**
         * Backup file intranet download address (6 hours).
         */
        innerDownloadUrl: string;
    }

    export interface GetBackupDownloadInfoLimitVpc {
        /**
         * Customize the region of the VPC to which the backup file is downloaded.
         */
        region: string;
        /**
         * Customize the list of VPCs to download backup files.
         */
        vpcLists: string[];
    }

    export interface GetInstanceNodeInfoProxy {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Zone ID.
         */
        zoneId: number;
    }

    export interface GetInstanceNodeInfoRedi {
        /**
         * Shard ID.
         */
        clusterId: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node role.
         */
        nodeRole: string;
        /**
         * Zone ID.
         */
        zoneId: number;
    }

    export interface GetInstanceShardsInstanceShard {
        /**
         * Service status: 0-down;1-on.
         */
        connected: number;
        /**
         * Number of keys.
         */
        keys: number;
        /**
         * role.
         */
        role: number;
        /**
         * The node ID of the instance runtime.
         */
        runid: string;
        /**
         * Shard node ID.
         */
        shardId: string;
        /**
         * Shard node name.
         */
        shardName: string;
        /**
         * Slot information.
         */
        slots: string;
        /**
         * Used capacity.
         */
        storage: number;
        /**
         * Capacity tilt.
         */
        storageSlope: number;
    }

    export interface GetInstanceTaskListTask {
        /**
         * Termination time.
         */
        endTime: string;
        /**
         * The ID of instance.
         */
        instanceId: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Task progress.
         */
        progress: number;
        /**
         * The project ID.
         */
        projectId: number;
        /**
         * Task status.
         */
        result: number;
        /**
         * Start time.
         */
        startTime: string;
        /**
         * Task ID.
         */
        taskId: number;
        /**
         * Task type.
         */
        taskType: string;
    }

    export interface GetInstanceZoneInfoReplicaGroup {
        /**
         * Node group ID.
         */
        groupId: number;
        /**
         * Node group Name.
         */
        groupName: string;
        /**
         * Node group node list.
         */
        redisNodes: outputs.Redis.GetInstanceZoneInfoReplicaGroupRedisNode[];
        /**
         * The node group type, master is the primary node, and replica is the replica node.
         */
        role: string;
        /**
         * he availability zone ID of the node, such as ap-guangzhou-1.
         */
        zoneId: string;
    }

    export interface GetInstanceZoneInfoReplicaGroupRedisNode {
        /**
         * The number of node keys.
         */
        keys: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * The node group type, master is the primary node, and replica is the replica node.
         */
        role: string;
        /**
         * Node slot distribution.
         */
        slot: string;
        /**
         * Node status.
         */
        status: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * The charge type of instance. Valid values are `POSTPAID` and `PREPAID`.
         */
        chargeType: string;
        /**
         * The time when the instance is created.
         */
        createTime: string;
        /**
         * IP address of an instance.
         */
        ip: string;
        /**
         * Memory size in MB.
         */
        memSize: number;
        /**
         * Name of a redis instance.
         */
        name: string;
        /**
         * List of instance node information. Currently, information about the node type (master or replica) and node availability zone can be passed in.
         */
        nodeInfos: outputs.Redis.GetInstancesInstanceListNodeInfo[];
        /**
         * The port used to access a redis instance.
         */
        port: number;
        /**
         * ID of the project to which redis instance belongs.
         */
        projectId: number;
        /**
         * ID of a redis instance.
         */
        redisId: string;
        /**
         * The number of instance copies.
         */
        redisReplicasNum: number;
        /**
         * The number of instance shard.
         */
        redisShardNum: number;
        /**
         * Current status of an instance, maybe: `init`, `processing`, `online`, `isolate` and `todelete`.
         */
        status: string;
        /**
         * ID of the vpc subnet.
         */
        subnetId: string;
        /**
         * Tags of redis instance.
         */
        tags: {[key: string]: any};
        /**
         * (**Deprecated**) It has been deprecated from version 1.33.1. Please use 'type_id' instead. Instance type. Available values: `masterSlaveRedis`, `masterSlaveCkv`, `clusterCkv`, `clusterRedis` and `standaloneRedis`.
         *
         * @deprecated It has been deprecated from version 1.33.1. Please use 'type_id' instead.
         */
        type: string;
        /**
         * Instance type. Refer to `data.tencentcloud_redis_zone_config.list.type_id` get available values.
         */
        typeId: number;
        /**
         * ID of the vpc with which the instance is associated.
         */
        vpcId: string;
        /**
         * ID of an available zone.
         */
        zone: string;
    }

    export interface GetInstancesInstanceListNodeInfo {
        /**
         * ID of the master or replica node.
         */
        id: number;
        /**
         * Indicates whether the node is master.
         */
        master: boolean;
        /**
         * ID of the availability zone of the master or replica node.
         */
        zoneId: number;
    }

    export interface GetParamRecordsInstanceParamHistory {
        /**
         * Modification time.
         */
        modifyTime: string;
        /**
         * The modified value.
         */
        newValue: string;
        /**
         * The parameter name.
         */
        paramName: string;
        /**
         * Modify the previous value.
         */
        preValue: string;
        /**
         * Parameter status:1: parameter configuration modification.2: The parameter configuration is modified successfully.3: Parameter configuration modification failed.
         */
        status: number;
    }

    export interface GetZoneConfigList {
        /**
         * (**Deprecated**) It has been deprecated from version 1.26.0. Use `shardMemories` instead. The memory volume of an available instance(in MB).
         *
         * @deprecated It has been deprecated from version 1.26.0. Use `shardMemories` instead.
         */
        memSizes: number[];
        /**
         * The support numbers of instance copies.
         */
        redisReplicasNums: number[];
        /**
         * The support numbers of instance shard.
         */
        redisShardNums: number[];
        /**
         * The memory volume list of an available instance shard(in MB).
         */
        shardMemories: number[];
        /**
         * (**Deprecated**) It has been deprecated from version 1.33.1. Please use 'type_id' instead. Instance type. Available values: `masterSlaveRedis`, `masterSlaveCkv`, `clusterCkv`, `clusterRedis` and `standaloneRedis`.
         *
         * @deprecated It has been deprecated from version 1.33.1. Please use 'type_id' instead.
         */
        type: string;
        /**
         * Instance type ID.
         */
        typeId: number;
        /**
         * Version description of an available instance. Possible values: `Redis 3.2`, `Redis 4.0`.
         */
        version: string;
        /**
         * ID of available zone.
         */
        zone: string;
    }

    export interface InstanceNodeInfo {
        /**
         * ID of the master or replica node.
         */
        id: number;
        /**
         * Indicates whether the node is master.
         */
        master: boolean;
        /**
         * ID of the availability zone of the master or replica node.
         */
        zoneId: number;
    }

    export interface ParamTemplateParamDetail {
        /**
         * Current value.
         */
        currentValue: string;
        /**
         * Default value.
         */
        default: string;
        /**
         * Parameter template description.
         */
        description: string;
        /**
         * Enum values.
         */
        enumValues: string[];
        /**
         * Maximum value.
         */
        max: string;
        /**
         * Minimum value.
         */
        min: string;
        /**
         * Parameter template name.
         */
        name: string;
        /**
         * Indicates whether to reboot redis instance if modified.
         */
        needReboot: number;
        /**
         * Parameter type.
         */
        paramType: string;
    }

    export interface ParamTemplateParamsOverride {
        /**
         * Parameter key e.g. `timeout`, check https://www.tencentcloud.com/document/product/239/39796 for more reference.
         */
        key: string;
        /**
         * Parameter value, check https://www.tencentcloud.com/document/product/239/39796 for more reference.
         */
        value: string;
    }

}

export namespace Reserved {
    export interface GetInstanceConfigsConfigList {
        /**
         * The available zone that the reserved instance locates at.
         */
        availabilityZone: string;
        /**
         * Configuration ID of the purchasable reserved instance.
         */
        configId: string;
        /**
         * Settlement currency of the reserved instance, which is a standard currency code as listed in ISO 4217.
         */
        currencyCode: string;
        /**
         * Validity period of the reserved instance. Valid values are `31536000`(1 year) and `94608000`(3 years).
         */
        duration: number;
        /**
         * The type of reserved instance.
         */
        instanceType: string;
        /**
         * Filter by Payment Type. Such as All Upfront.
         */
        offeringType: string;
        /**
         * Platform of the reserved instance.
         */
        platform: string;
        /**
         * Purchase price of the reserved instance.
         */
        price: number;
        /**
         * UsagePrice of the reserved instance.
         */
        usagePrice: number;
    }

    export interface GetInstancesReservedInstanceList {
        /**
         * The available zone that the reserved instance locates at.
         */
        availabilityZone: string;
        /**
         * Expiry time of the reserved instance.
         */
        endTime: string;
        /**
         * Number of reserved instance.
         */
        instanceCount: number;
        /**
         * The type of reserved instance.
         */
        instanceType: string;
        /**
         * ID of the reserved instance to be query.
         */
        reservedInstanceId: string;
        /**
         * Start time of the reserved instance.
         */
        startTime: string;
        /**
         * Status of the reserved instance.
         */
        status: string;
    }

}

export namespace Rum {
    export interface GetProjectProjectSet {
        /**
         * CreateTime.
         */
        createTime: string;
        /**
         * Creator ID.
         */
        creator: string;
        /**
         * Project description.
         */
        desc: string;
        /**
         * Whether to enable URL aggregation.
         */
        enableUrlGroup: number;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Instance key.
         */
        instanceKey: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Starred status. `1`: yes; `0`: no.
         */
        isStar: number;
        /**
         * Unique project key (12 characters).
         */
        key: string;
        /**
         * Project name.
         */
        name: string;
        /**
         * Project ID.
         */
        pid: number;
        /**
         * Project status (`1`: Creating; `2`: Running; `3`: Abnormal; `4`: Restarting; `5`: Stopping; `6`: Stopped; `7`: Terminating; `8`: Terminated).
         */
        projectStatus: number;
        /**
         * Project sample rate.
         */
        rate: string;
        /**
         * Project repository address.
         */
        repo: string;
        /**
         * Project type.
         */
        type: string;
        /**
         * Project URL.
         */
        url: string;
    }

    export interface GetScoresScoreSet {
        /**
         * The mean duration of api request.
         */
        apiDuration: string;
        /**
         * The number of failed api.
         */
        apiFail: string;
        /**
         * The number of all request api.
         */
        apiNum: string;
        /**
         * Project record created time.
         */
        createTime: string;
        /**
         * The duration of page load.
         */
        pageDuration: string;
        /**
         * The number of exception which happened on page.
         */
        pageError: string;
        /**
         * Pv.
         */
        pagePv: string;
        /**
         * User view.
         */
        pageUv: string;
        /**
         * Project ID.
         */
        projectId: number;
        /**
         * The number of record.
         */
        recordNum: number;
        /**
         * The score of project.
         */
        score: string;
        /**
         * Duration.
         */
        staticDuration: string;
        /**
         * The number of failed request static resource.
         */
        staticFail: string;
        /**
         * The number of static resource on page.
         */
        staticNum: string;
    }

    export interface GetTawAreaAreaSet {
        /**
         * Region abbreviation.
         */
        areaAbbr: string;
        /**
         * Area id.
         */
        areaId: number;
        /**
         * Area key.
         */
        areaKey: string;
        /**
         * Area name.
         */
        areaName: string;
        /**
         * Area code.
         */
        areaRegionCode: string;
        /**
         * Area code id.
         */
        areaRegionId: string;
        /**
         * Area status `1`:&amp;#39;valid&amp;#39;; `2`:&amp;#39;invalid&amp;#39;.
         */
        areaStatus: number;
    }

    export interface GetTawInstanceInstanceSet {
        /**
         * Area ID.
         */
        areaId: number;
        /**
         * Billing status (`1` = in use, `2` = expired, `3` = destroyed, `4` = assigning, `5` = failed).
         */
        chargeStatus: number;
        /**
         * Billing type (`1` = free version, `2` = prepaid, `3` = postpaid).
         */
        chargeType: number;
        /**
         * Cluster ID.
         */
        clusterId: number;
        /**
         * Create time.
         */
        createdAt: string;
        /**
         * Data retention time (days).
         */
        dataRetentionDays: number;
        /**
         * Instance Desc.
         */
        instanceDesc: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Instance status (`1` = creating, `2` = running, `3` = exception, `4` = restarting, `5` = stopping, `6` = stopped, `7` = deleted).
         */
        instanceStatus: number;
        /**
         * Tag List.
         */
        tags: outputs.Rum.GetTawInstanceInstanceSetTag[];
        /**
         * Update time.
         */
        updatedAt: string;
    }

    export interface GetTawInstanceInstanceSetTag {
        /**
         * Tag Key.
         */
        key: string;
        /**
         * Tag Value.
         */
        value: string;
    }

    export interface GetWhitelistWhitelistSet {
        /**
         * Business identifier.
         */
        aid: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Creator ID.
         */
        createUser: string;
        /**
         * Remarks.
         */
        remark: string;
        /**
         * End time.
         */
        ttl: string;
        /**
         * uin: business identifier.
         */
        whitelistUin: string;
        /**
         * Auto-Increment allowlist ID.
         */
        wid: string;
    }

}

export namespace Scf {
    export interface FunctionAliasRoutingConfig {
        /**
         * Additional version with rule-based routing.
         */
        additionalVersionMatches?: outputs.Scf.FunctionAliasRoutingConfigAdditionalVersionMatch[];
        /**
         * Additional version with random weight-based routing.
         */
        additionalVersionWeights?: outputs.Scf.FunctionAliasRoutingConfigAdditionalVersionWeight[];
    }

    export interface FunctionAliasRoutingConfigAdditionalVersionMatch {
        /**
         * Rule requirements for range match:It should be described in an open or closed range, i.e., (a,b) or [a,b], where both a and b are integersRule requirements for exact match:Exact string match.
         */
        expression: string;
        /**
         * Matching rule key. When the API is called, pass in the key to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for key and pass in RoutingKey:{User:value} when invoking a function through invoke for invocation based on rule matching.
         */
        key: string;
        /**
         * Match method. Valid values:range: Range matchexact: exact string match.
         */
        method: string;
        /**
         * Function version name.
         */
        version: string;
    }

    export interface FunctionAliasRoutingConfigAdditionalVersionWeight {
        /**
         * Function version name.
         */
        version: string;
        /**
         * Version weight.
         */
        weight: number;
    }

    export interface FunctionCfsConfig {
        /**
         * File system instance ID.
         */
        cfsId: string;
        /**
         * (Readonly) File system ip address.
         */
        ipAddress: string;
        /**
         * Local mount directory.
         */
        localMountDir: string;
        /**
         * File system mount instance ID.
         */
        mountInsId: string;
        /**
         * (Readonly) File system subnet ID.
         */
        mountSubnetId: string;
        /**
         * (Readonly) File system virtual private network ID.
         */
        mountVpcId: string;
        /**
         * Remote mount directory.
         */
        remoteMountDir: string;
        /**
         * ID of user group.
         */
        userGroupId: string;
        /**
         * ID of user.
         */
        userId: string;
    }

    export interface FunctionEventInvokeConfigAsyncTriggerConfig {
        /**
         * Message retention period.
         */
        msgTtl: number;
        /**
         * Async retry configuration of function upon user error.
         */
        retryConfigs: outputs.Scf.FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig[];
    }

    export interface FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig {
        /**
         * Number of retry attempts.
         */
        retryNum: number;
    }

    export interface FunctionImageConfig {
        /**
         * the parameters of command.
         */
        args?: string;
        /**
         * The command of entrypoint.
         */
        command?: string;
        /**
         * Image accelerate switch.
         */
        containerImageAccelerate?: boolean;
        /**
         * The entrypoint of app.
         */
        entryPoint?: string;
        /**
         * Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
         */
        imagePort?: number;
        /**
         * The image type. personal or enterprise.
         */
        imageType: string;
        /**
         * The uri of image.
         */
        imageUri: string;
        /**
         * The registry id of TCR. When image type is enterprise, it must be set.
         */
        registryId?: string;
    }

    export interface FunctionIntranetConfig {
        /**
         * If fixed intranet IP is enabled, this field returns the IP list used.
         */
        ipAddresses: string[];
        /**
         * Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
         */
        ipFixed: string;
    }

    export interface FunctionLayer {
        /**
         * The name of Layer.
         */
        layerName: string;
        /**
         * The version of layer.
         */
        layerVersion: number;
    }

    export interface FunctionTrigger {
        /**
         * Region of cos bucket. if `type` is `cos`, `cosRegion` is required.
         */
        cosRegion?: string;
        /**
         * Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
         */
        name: string;
        /**
         * TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
         */
        triggerDesc: string;
        /**
         * Type of the SCF function trigger, support `cos`, `cmq`, `timer`, `ckafka`, `apigw`.
         */
        type: string;
    }

    export interface FunctionTriggerInfo {
        /**
         * Create time of SCF function trigger.
         */
        createTime: string;
        /**
         * User-defined parameters of SCF function trigger.
         */
        customArgument: string;
        /**
         * Whether SCF function trigger is enable.
         */
        enable: boolean;
        /**
         * Modify time of SCF function trigger.
         */
        modifyTime: string;
        /**
         * Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
         */
        name: string;
        /**
         * TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
         */
        triggerDesc: string;
        /**
         * Type of the SCF function trigger, support `cos`, `cmq`, `timer`, `ckafka`, `apigw`.
         */
        type: string;
    }

    export interface GetAccountInfoAccountLimit {
        /**
         * Namespace name.
         */
        namespaces: outputs.Scf.GetAccountInfoAccountLimitNamespace[];
        /**
         * Number of namespaces.
         */
        namespacesCount: number;
    }

    export interface GetAccountInfoAccountLimitNamespace {
        /**
         * Concurrency.
         */
        concurrentExecutions: number;
        /**
         * Number of functions in namespace.
         */
        functionsCount: number;
        /**
         * Initialization timeout limit.
         */
        initTimeoutLimit: number;
        /**
         * Upper limit of message retention time for async retry.
         */
        maxMsgTtl: number;
        /**
         * Lower limit of message retention time for async retry.
         */
        minMsgTtl: number;
        /**
         * Namespace name.
         */
        namespace: string;
        /**
         * Limit of async retry attempt quantity.
         */
        retryNumLimit: number;
        /**
         * Test event limit Note: this field may return null, indicating that no valid values can be obtained.
         */
        testModelLimit: number;
        /**
         * Timeout limit.
         */
        timeoutLimit: number;
        /**
         * Trigger information.
         */
        triggers: outputs.Scf.GetAccountInfoAccountLimitNamespaceTrigger[];
    }

    export interface GetAccountInfoAccountLimitNamespaceTrigger {
        /**
         * Number of API Gateway triggers.
         */
        apigw: number;
        /**
         * Number of CKafka triggers.
         */
        ckafka: number;
        /**
         * Number of CLB triggers.
         */
        clb: number;
        /**
         * Number of CLS triggers.
         */
        cls: number;
        /**
         * Number of CM triggers.
         */
        cm: number;
        /**
         * Number of CMQ triggers.
         */
        cmq: number;
        /**
         * Number of COS triggers.
         */
        cos: number;
        /**
         * Number of EventBridge triggers Note: This field may return null, indicating that no valid values can be obtained.
         */
        eb: number;
        /**
         * Number of MPS triggers.
         */
        mps: number;
        /**
         * Number of timer triggers.
         */
        timer: number;
        /**
         * Total number of triggers.
         */
        total: number;
        /**
         * Number of VOD triggers.
         */
        vod: number;
    }

    export interface GetAccountInfoAccountUsage {
        /**
         * Namespace name.
         */
        namespaces: outputs.Scf.GetAccountInfoAccountUsageNamespace[];
        /**
         * Number of namespaces.
         */
        namespacesCount: number;
        /**
         * Quota of configured user concurrency memory in the current region.
         */
        totalAllocatedConcurrencyMem: number;
        /**
         * Upper limit of user concurrency memory in the current region.
         */
        totalConcurrencyMem: number;
        /**
         * Quota of account concurrency actually configured by user.
         */
        userConcurrencyMemLimit: number;
    }

    export interface GetAccountInfoAccountUsageNamespace {
        /**
         * Function array.
         */
        functions: string[];
        /**
         * Number of functions in namespace.
         */
        functionsCount: number;
        /**
         * Namespace name.
         */
        namespace: string;
        /**
         * Quota of configured user concurrency memory in the current region.
         */
        totalAllocatedConcurrencyMem: number;
        /**
         * Provisioned concurrency usage of the namespace Note: This field may return null, indicating that no valid value can be obtained.
         */
        totalAllocatedProvisionedMem: number;
        /**
         * Upper limit of user concurrency memory in the current region.
         */
        totalConcurrencyMem: number;
    }

    export interface GetAsyncEventManagementEventList {
        /**
         * Invocation end time in the format of %Y-%m-%d %H:%M:%S.%f.
         */
        endTime: string;
        /**
         * Filter (event invocation request ID).
         */
        invokeRequestId: string;
        /**
         * Filter (invocation type list), Values: CMQ, CKAFKA_TRIGGER, APIGW, COS, TRIGGER_TIMER, MPS_TRIGGER, CLS_TRIGGER, OTHERS.
         */
        invokeType: string;
        /**
         * Filter (function version).
         */
        qualifier: string;
        /**
         * Invocation start time in the format of %Y-%m-%d %H:%M:%S.%f.
         */
        startTime: string;
        /**
         * Filter (event status list), Values: RUNNING, FINISHED, ABORTED, FAILED.
         */
        status: string;
    }

    export interface GetAsyncEventStatusResult {
        /**
         * ID of the async execution request.
         */
        invokeRequestId: string;
        /**
         * Async event status. Values: `RUNNING` (running); `FINISHED` (invoked successfully); `ABORTED` (invocation ended); `FAILED` (invocation failed).
         */
        status: string;
        /**
         * Request status code.
         */
        statusCode: number;
    }

    export interface GetFunctionAliasesAlias {
        /**
         * Creation timeNote: this field may return null, indicating that no valid values can be obtained.
         */
        addTime: string;
        /**
         * DescriptionNote: this field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * If this parameter is provided, only aliases associated with this function version will be returned.
         */
        functionVersion: string;
        /**
         * Update timeNote: this field may return null, indicating that no valid values can be obtained.
         */
        modTime: string;
        /**
         * Alias name.
         */
        name: string;
        /**
         * Routing information of aliasNote: this field may return null, indicating that no valid values can be obtained.
         */
        routingConfigs: outputs.Scf.GetFunctionAliasesAliasRoutingConfig[];
    }

    export interface GetFunctionAliasesAliasRoutingConfig {
        /**
         * Additional version with rule-based routing.
         */
        additionVersionMatchs: outputs.Scf.GetFunctionAliasesAliasRoutingConfigAdditionVersionMatch[];
        /**
         * Additional version with random weight-based routing.
         */
        additionalVersionWeights: outputs.Scf.GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeight[];
    }

    export interface GetFunctionAliasesAliasRoutingConfigAdditionVersionMatch {
        /**
         * Rule requirements for range match:It should be described in an open or closed range, i.e., `(a,b)` or `[a,b]`, where both a and b are integersRule requirements for exact match:Exact string match.
         */
        expression: string;
        /**
         * Matching rule key. When the API is called, pass in the `key` to route the request to the specified version based on the matching ruleHeader method:Enter invoke.headers.User for `key` and pass in `RoutingKey:{User:value}` when invoking a function through `invoke` for invocation based on rule matching.
         */
        key: string;
        /**
         * Match method. Valid values:range: range matchexact: exact string match.
         */
        method: string;
        /**
         * Function version name.
         */
        version: string;
    }

    export interface GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeight {
        /**
         * Function version name.
         */
        version: string;
        /**
         * Version weight.
         */
        weight: number;
    }

    export interface GetFunctionVersionsVersion {
        /**
         * The creation timeNote: This field may return null, indicating that no valid value was found.
         */
        addTime: string;
        /**
         * Version descriptionNote: This field may return null, indicating that no valid values is found.
         */
        description: string;
        /**
         * Update timeNote: This field may return null, indicating that no valid value was found.
         */
        modTime: string;
        /**
         * Version statusNote: this field may return `null`, indicating that no valid values can be obtained.
         */
        status: string;
        /**
         * Function version name.
         */
        version: string;
    }

    export interface GetFunctionsFunction {
        /**
         * Whether asynchronous attribute is enabled.
         */
        asyncRunEnable: string;
        /**
         * CLS logset ID of the SCF function.
         */
        clsLogsetId: string;
        /**
         * CLS topic ID of the SCF function.
         */
        clsTopicId: string;
        /**
         * Code error of the SCF function.
         */
        codeError: string;
        /**
         * Code result of the SCF function.
         */
        codeResult: string;
        /**
         * Code size of the SCF function.
         */
        codeSize: number;
        /**
         * Create time of the SCF function trigger.
         */
        createTime: string;
        /**
         * Description of the SCF function to be queried.
         */
        description: string;
        /**
         * Whether to enable Dns caching capability, only the EVENT function is supported. Default is false.
         */
        dnsCache: boolean;
        /**
         * Whether EIP is a fixed IP.
         */
        eipFixed: boolean;
        /**
         * EIP list of the SCF function.
         */
        eips: string[];
        /**
         * Whether the EIP enabled.
         */
        enableEipConfig: boolean;
        /**
         * Whether the public net enabled.
         */
        enablePublicNet: boolean;
        /**
         * Environment variable of the SCF function.
         */
        environment: {[key: string]: any};
        /**
         * Errno of the SCF function.
         */
        errNo: number;
        /**
         * Handler of the SCF function.
         */
        handler: string;
        /**
         * Host of the SCF function.
         */
        host: string;
        /**
         * Image of the SCF function, conflict with `cosBucketName`, `cosObjectName`, `cosBucketRegion`, `zipFile`.
         */
        imageConfigs: outputs.Scf.GetFunctionsFunctionImageConfig[];
        /**
         * Whether to automatically install dependencies.
         */
        installDependency: boolean;
        /**
         * Intranet access configuration.
         */
        intranetConfigs: outputs.Scf.GetFunctionsFunctionIntranetConfig[];
        /**
         * Whether to enable L5.
         */
        l5Enable: boolean;
        /**
         * Memory size of the SCF function runtime, unit is M.
         */
        memSize: number;
        /**
         * Modify time of the SCF function trigger.
         */
        modifyTime: string;
        /**
         * Name of the SCF function to be queried.
         */
        name: string;
        /**
         * Namespace of the SCF function to be queried.
         */
        namespace: string;
        /**
         * CAM role of the SCF function.
         */
        role: string;
        /**
         * Runtime of the SCF function.
         */
        runtime: string;
        /**
         * Status of the SCF function.
         */
        status: string;
        /**
         * Status description of the SCF function.
         */
        statusDesc: string;
        /**
         * Subnet ID of the SCF function.
         */
        subnetId: string;
        /**
         * Tags of the SCF function to be queried, can use up to 10 tags.
         */
        tags: {[key: string]: any};
        /**
         * Timeout of the SCF function maximum execution time, unit is second.
         */
        timeout: number;
        /**
         * Trigger details list the SCF function. Each element contains the following attributes:
         */
        triggerInfos: outputs.Scf.GetFunctionsFunctionTriggerInfo[];
        /**
         * Vip of the SCF function.
         */
        vip: string;
        /**
         * VPC ID of the SCF function.
         */
        vpcId: string;
    }

    export interface GetFunctionsFunctionImageConfig {
        /**
         * the parameters of command.
         */
        args: string;
        /**
         * The command of entrypoint.
         */
        command: string;
        /**
         * Image accelerate switch.
         */
        containerImageAccelerate: boolean;
        /**
         * The entrypoint of app.
         */
        entryPoint: string;
        /**
         * Image function port setting. Default is `9000`, -1 indicates no port mirroring function. Other value ranges 0 ~ 65535.
         */
        imagePort: number;
        /**
         * The image type. personal or enterprise.
         */
        imageType: string;
        /**
         * The uri of image.
         */
        imageUri: string;
        /**
         * The registry id of TCR. When image type is enterprise, it must be set.
         */
        registryId: string;
    }

    export interface GetFunctionsFunctionIntranetConfig {
        /**
         * If fixed intranet IP is enabled, this field returns the IP list used.
         */
        ipAddresses: string[];
        /**
         * Whether to enable fixed intranet IP, ENABLE is enabled, DISABLE is disabled.
         */
        ipFixed: string;
    }

    export interface GetFunctionsFunctionTriggerInfo {
        /**
         * Create time of the SCF function trigger.
         */
        createTime: string;
        /**
         * user-defined parameter of the SCF function trigger.
         */
        customArgument: string;
        /**
         * Whether to enable SCF function trigger.
         */
        enable: boolean;
        /**
         * Modify time of the SCF function trigger.
         */
        modifyTime: string;
        /**
         * Name of the SCF function to be queried.
         */
        name: string;
        /**
         * TriggerDesc of the SCF function trigger.
         */
        triggerDesc: string;
        /**
         * Type of the SCF function trigger.
         */
        type: string;
    }

    export interface GetLayerVersionsLayerVersion {
        /**
         * Creation time.
         */
        addTime: string;
        /**
         * Runtime applicable to a versionNote: This field may return null, indicating that no valid values can be obtained.
         */
        compatibleRuntimes: string[];
        /**
         * Version descriptionNote: This field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * Layer name.
         */
        layerName: string;
        /**
         * Version number.
         */
        layerVersion: number;
        /**
         * License informationNote: This field may return null, indicating that no valid values can be obtained.
         */
        licenseInfo: string;
        /**
         * StampNote: This field may return null, indicating that no valid values can be obtained.
         */
        stamp: string;
        /**
         * Current status of specific layer version. For valid values, please see [here](https://intl.cloud.tencent.com/document/product/583/47175?from_cn_redirect=1#.E5.B1.82.EF.BC.88layer.EF.BC.89.E7.8A.B6.E6.80.81).
         */
        status: string;
    }

    export interface GetLayersLayer {
        /**
         * Creation time.
         */
        addTime: string;
        /**
         * Runtime applicable to a versionNote: This field may return null, indicating that no valid values can be obtained.
         */
        compatibleRuntimes: string[];
        /**
         * Version descriptionNote: This field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * Layer name.
         */
        layerName: string;
        /**
         * Version number.
         */
        layerVersion: number;
        /**
         * License informationNote: This field may return null, indicating that no valid values can be obtained.
         */
        licenseInfo: string;
        /**
         * StampNote: This field may return null, indicating that no valid values can be obtained.
         */
        stamp: string;
        /**
         * Current status of specific layer version. For valid values, please see [here](https://intl.cloud.tencent.com/document/product/583/47175?from_cn_redirect=1#.E5.B1.82.EF.BC.88layer.EF.BC.89.E7.8A.B6.E6.80.81).
         */
        status: string;
    }

    export interface GetLogsLog {
        /**
         * Function billing time, according to duration up to the last 100ms, unit is ms.
         */
        billDuration: number;
        /**
         * Function execution time-consuming, unit is ms.
         */
        duration: number;
        /**
         * Name of the SCF function to be queried.
         */
        functionName: string;
        /**
         * Whether the function call ends, `1` means the execution ends, other values indicate the call exception.
         */
        invokeFinished: number;
        /**
         * Log level.
         */
        level: string;
        /**
         * Log output during function execution.
         */
        log: string;
        /**
         * The actual memory size consumed in the execution of the function, unit is Byte.
         */
        memUsage: number;
        /**
         * Execute the requestId corresponding to the function.
         */
        requestId: string;
        /**
         * Use to filter log, optional value: `not0` only returns the error log. `is0` only returns the correct log. `TimeLimitExceeded` returns the log of the function call timeout. `ResourceLimitExceeded` returns the function call generation resource overrun log. `UserCodeException` returns logs of the user code error that occurred in the function call. Not passing the parameter means returning all logs.
         */
        retCode: number;
        /**
         * Return value after function execution is completed.
         */
        retMsg: string;
        /**
         * Log source.
         */
        source: string;
        /**
         * The start time of the query, the format is `2017-05-16 20:00:00`, which can only be within one day from `endTime`.
         */
        startTime: string;
    }

    export interface GetNamespacesNamespace {
        /**
         * Create time of the SCF namespace.
         */
        createTime: string;
        /**
         * Description of the SCF namespace to be queried.
         */
        description: string;
        /**
         * Modify time of the SCF namespace.
         */
        modifyTime: string;
        /**
         * Name of the SCF namespace to be queried.
         */
        namespace: string;
        /**
         * Type of the SCF namespace.
         */
        type: string;
    }

    export interface GetRequestStatusData {
        /**
         * Time consumed for the request in ms.
         */
        duration: number;
        /**
         * Function name.
         */
        functionName: string;
        /**
         * Time consumed by the request in MB.
         */
        memUsage: number;
        /**
         * Request ID.
         */
        requestId: string;
        /**
         * Result of the request. `0`: succeeded, `1`: running, `-1`: exception.
         */
        retCode: number;
        /**
         * Return value after the function is executed.
         */
        retMsg: string;
        /**
         * Retry Attempts.
         */
        retryNum: number;
        /**
         * Start time of the query, for example `2017-05-16 20:00:00`. If it's left empty, it defaults to 15 minutes before the current time.
         */
        startTime: string;
    }

    export interface GetTriggersFilter {
        /**
         * Fields to be filtered. Up to 10 conditions allowed.Values of Name: VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip. Values limit: 1.Name options: Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable. Values limit: 20.When Name is Runtime, CustomImage refers to the image type function.
         */
        name: string;
        /**
         * Filter values of the field.
         */
        values: string[];
    }

    export interface GetTriggersTrigger {
        /**
         * Trigger creation time.
         */
        addTime: string;
        /**
         * Whether the trigger is available.
         */
        availableStatus: string;
        /**
         * Trigger-Function binding status.
         */
        bindStatus: string;
        /**
         * Custom parameterNote: this field may return null, indicating that no valid values can be obtained.
         */
        customArgument: string;
        /**
         * Whether to enable.
         */
        enable: number;
        /**
         * Trigger last modified time.
         */
        modTime: string;
        /**
         * Function version or alias.
         */
        qualifier: string;
        /**
         * Minimum resource ID of trigger.
         */
        resourceId: string;
        /**
         * Trigger type. Two-way means that the trigger can be manipulated in both consoles, while one-way means that the trigger can be created only in the SCF Console.
         */
        triggerAttribute: string;
        /**
         * Detailed configuration of trigger.
         */
        triggerDesc: string;
        /**
         * Trigger name.
         */
        triggerName: string;
        /**
         * Trigger type.
         */
        type: string;
    }

    export interface LayerContent {
        /**
         * Cos bucket name of the SCF layer, such as `cos-1234567890`, conflict with `zipFile`.
         */
        cosBucketName?: string;
        /**
         * Cos bucket region of the SCF layer, conflict with `zipFile`.
         */
        cosBucketRegion?: string;
        /**
         * Cos object name of the SCF layer, should have suffix `.zip` or `.jar`, conflict with `zipFile`.
         */
        cosObjectName?: string;
        /**
         * Zip file of the SCF layer, conflict with `cosBucketName`, `cosObjectName`, `cosBucketRegion`.
         */
        zipFile?: string;
    }

    export interface ProvisionedConcurrencyConfigTriggerAction {
        /**
         * The provision type. Value: Default Note: This field may return null, indicating that no valid value can be found.
         */
        provisionedType?: string;
        /**
         * Trigger time of the scheduled action in Cron expression. Seven fields are required and should be separated with a space. Note: this field may return null, indicating that no valid values can be obtained.
         */
        triggerCronConfig: string;
        /**
         * Scheduled action name Note: this field may return null, indicating that no valid values can be obtained.
         */
        triggerName: string;
        /**
         * Target provisioned concurrency of the scheduled scaling action Note: this field may return null, indicating that no valid values can be obtained.
         */
        triggerProvisionedConcurrencyNum: number;
    }

}

export namespace Security {
    export interface GetGroupsSecurityGroup {
        /**
         * Number of security group binding resources.
         */
        beAssociateCount: number;
        /**
         * Creation time of security group.
         */
        createTime: string;
        /**
         * Description of the security group.
         */
        description: string;
        /**
         * Egress rules set. For items like `[action]#[cidrIp]#[port]#[protocol]`, it means a regular rule; for items like `sg-XXXX`, it means a nested security group.
         */
        egresses: string[];
        /**
         * Ingress rules set. For items like `[action]#[cidrIp]#[port]#[protocol]`, it means a regular rule; for items like `sg-XXXX`, it means a nested security group.
         */
        ingresses: string[];
        /**
         * Name of the security group to be queried. Conflict with `securityGroupId`.
         */
        name: string;
        /**
         * Project ID of the security group to be queried. Conflict with `securityGroupId`.
         */
        projectId: number;
        /**
         * ID of the security group to be queried. Conflict with `name` and `projectId`.
         */
        securityGroupId: string;
        /**
         * Tags of the security group to be queried. Conflict with `securityGroupId`.
         */
        tags: {[key: string]: any};
    }

    export interface GroupRuleSetEgress {
        /**
         * Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
         */
        action: string;
        /**
         * Specify Group ID of Address template like `ipmg-xxxxxxxx`, conflict with `sourceSecurityId` and `cidrBlock`.
         */
        addressTemplateGroup?: string;
        /**
         * Specify Address template ID like `ipm-xxxxxxxx`, conflict with `sourceSecurityId` and `cidrBlock`.
         */
        addressTemplateId?: string;
        /**
         * An IP address network or CIDR segment. NOTE: `cidrBlock`, `ipv6CidrBlock`, `sourceSecurityId` and `address_template_*` are exclusive and cannot be set in the same time.
         */
        cidrBlock?: string;
        /**
         * Description of the security group rule.
         */
        description?: string;
        /**
         * An IPV6 address network or CIDR segment, and conflict with `sourceSecurityId` and `address_template_*`.
         */
        ipv6CidrBlock?: string;
        /**
         * The security group rule index number, whose value dynamically changes with changes in security group rules.
         */
        policyIndex: number;
        /**
         * Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and conflicts with `service_template_*`.
         */
        port: string;
        /**
         * Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `service_template_*`.
         */
        protocol: string;
        /**
         * Specify Group ID of Protocol template ID like `ppmg-xxxxxxxx`, conflict with `cidrBlock` and `port`.
         */
        serviceTemplateGroup?: string;
        /**
         * Specify Protocol template ID like `ppm-xxxxxxxx`, conflict with `cidrBlock` and `port`.
         */
        serviceTemplateId?: string;
        /**
         * ID of the nested security group, and conflicts with `cidrBlock` and `address_template_*`.
         */
        sourceSecurityId?: string;
    }

    export interface GroupRuleSetIngress {
        /**
         * Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
         */
        action: string;
        /**
         * Specify Group ID of Address template like `ipmg-xxxxxxxx`, conflict with `sourceSecurityId` and `cidrBlock`.
         */
        addressTemplateGroup?: string;
        /**
         * Specify Address template ID like `ipm-xxxxxxxx`, conflict with `sourceSecurityId` and `cidrBlock`.
         */
        addressTemplateId?: string;
        /**
         * An IP address network or CIDR segment. NOTE: `cidrBlock`, `ipv6CidrBlock`, `sourceSecurityId` and `address_template_*` are exclusive and cannot be set in the same time.
         */
        cidrBlock?: string;
        /**
         * Description of the security group rule.
         */
        description?: string;
        /**
         * An IPV6 address network or CIDR segment, and conflict with `sourceSecurityId` and `address_template_*`.
         */
        ipv6CidrBlock?: string;
        /**
         * The security group rule index number, whose value dynamically changes with changes in security group rules.
         */
        policyIndex: number;
        /**
         * Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and conflicts with `service_template_*`.
         */
        port: string;
        /**
         * Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `service_template_*`.
         */
        protocol: string;
        /**
         * Specify Group ID of Protocol template ID like `ppmg-xxxxxxxx`, conflict with `cidrBlock` and `port`.
         */
        serviceTemplateGroup?: string;
        /**
         * Specify Protocol template ID like `ppm-xxxxxxxx`, conflict with `cidrBlock` and `port`.
         */
        serviceTemplateId?: string;
        /**
         * ID of the nested security group, and conflicts with `cidrBlock` and `address_template_*`.
         */
        sourceSecurityId?: string;
    }

}

export namespace Ses {
    export interface BatchSendEmailAttachment {
        /**
         * Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
         */
        content: string;
        /**
         * Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
         */
        fileName: string;
    }

    export interface BatchSendEmailCycleParam {
        /**
         * Start time of the task.
         */
        beginTime: string;
        /**
         * Task recurrence in hours.
         */
        intervalTime: number;
        /**
         * Specifies whether to end the cycle. This parameter is used to update the task. Valid values: 0: No; 1: Yes.
         */
        termCycle?: number;
    }

    export interface BatchSendEmailTemplate {
        /**
         * Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
         */
        templateData: string;
        /**
         * Template ID. If you do not have any template, please create one.
         */
        templateId: number;
    }

    export interface BatchSendEmailTimedParam {
        /**
         * Start time of a scheduled sending task.
         */
        beginTime: string;
    }

    export interface DomainAttribute {
        /**
         * Values that need to be configured.
         */
        expectedValue: string;
        /**
         * Domain name.
         */
        sendDomain: string;
        /**
         * Record Type CNAME | A | TXT | MX.
         */
        type: string;
    }

    export interface GetBlackEmailAddressBlackList {
        /**
         * Time when the email address is blocklisted.
         */
        bounceTime: string;
        /**
         * You can specify an email address to query.
         */
        emailAddress: string;
    }

    export interface GetEmailIdentitiesEmailIdentity {
        /**
         * Current credit rating.
         */
        currentReputationLevel: number;
        /**
         * Highest number of letters of the day.
         */
        dailyQuota: number;
        /**
         * Sending domain name.
         */
        identityName: string;
        /**
         * Authentication type, fixed as DOMAIN.
         */
        identityType: string;
        /**
         * Is it verified.
         */
        sendingEnabled: boolean;
    }

    export interface GetReceiversData {
        /**
         * Total number of recipient email addresses.
         */
        count: number;
        /**
         * Creation time, such as 2021-09-28 16:40:35.
         */
        createTime: string;
        /**
         * Recipient group descriptionNote: This field may return `null`, indicating that no valid value can be found.
         */
        desc: string;
        /**
         * Recipient group ID.
         */
        receiverId: number;
        /**
         * Recipient group name.
         */
        receiversName: string;
        /**
         * Group status (`1`: to be uploaded; `2` uploading; `3` uploaded)Note: This field may return `null`, indicating that no valid value can be found.
         */
        receiversStatus: number;
    }

    export interface GetSendEmailStatusEmailStatusList {
        /**
         * Description of the recipient processing status.
         */
        deliverMessage: string;
        /**
         * Recipient processing status0: Tencent Cloud has accepted the request and added it to the send queue.1: The email is delivered successfully. DeliverTime indicates the time when the email is delivered successfully.2: The email is discarded. DeliverMessage indicates the reason for discarding.3: The recipient&amp;#39;s ESP rejects the email, probably because the email address does not exist or due to other reasons.8: The email is delayed by the ESP. DeliverMessage indicates the reason for delay.
         */
        deliverStatus: number;
        /**
         * Timestamp when Tencent Cloud delivers the email.
         */
        deliverTime: number;
        /**
         * Sender email address.
         */
        fromEmailAddress: string;
        /**
         * The MessageId field returned by the SendMail API.
         */
        messageId: string;
        /**
         * Timestamp when the request arrives at Tencent Cloud.
         */
        requestTime: number;
        /**
         * Tencent Cloud processing status: `0`: Successful. `1001`: Internal system exception. `1002`: Internal system exception. `1003`: Internal system exception. `1003`: Internal system exception. `1004`: Email sending timed out. `1005`: Internal system exception. `1006`: You have sent too many emails to the same address in a short period. `1007`: The email address is in the blocklist. `1008`: The sender domain is rejected by the recipient. `1009`: Internal system exception. `1010`: The daily email sending limit is exceeded. `1011`: You have no permission to send custom content. Use a template. `1013`: The sender domain is unsubscribed from by the recipient. `2001`: No results were found. `3007`: The template ID is invalid or the template is unavailable. `3008`: The sender domain is temporarily blocked by the recipient domain. `3009`: You have no permission to use this template. `3010`: The format of the TemplateData field is incorrect. `3014`: The email cannot be sent because the sender domain is not verified. `3020`: The recipient email address is in the blocklist. `3024`: Failed to precheck the email address format. `3030`: Email sending is restricted temporarily due to a high bounce rate. `3033`: The account has insufficient balance or overdue payment.
         */
        sendStatus: number;
        /**
         * Recipient email address.
         */
        toEmailAddress: string;
        /**
         * Whether the recipient has clicked the links in the email.
         */
        userClicked: boolean;
        /**
         * Whether the recipient has reported the sender.
         */
        userComplainted: boolean;
        /**
         * Whether the recipient has opened the email.
         */
        userOpened: boolean;
        /**
         * Whether the recipient has unsubscribed from the email sent by the sender.
         */
        userUnsubscribed: boolean;
    }

    export interface GetSendTasksData {
        /**
         * Number of emails cached.
         */
        cacheCount: number;
        /**
         * Task creation time.
         */
        createTime: string;
        /**
         * Parameters of a recurring taskNote: This field may return `null`, indicating that no valid value can be found.
         */
        cycleParams: outputs.Ses.GetSendTasksDataCycleParam[];
        /**
         * Task exception informationNote: This field may return `null`, indicating that no valid value can be found.
         */
        errMsg: string;
        /**
         * Sender address.
         */
        fromEmailAddress: string;
        /**
         * Recipient group ID.
         */
        receiverId: number;
        /**
         * Recipient group name.
         */
        receiversName: string;
        /**
         * Number of emails requested to be sent.
         */
        requestCount: number;
        /**
         * Number of emails sent.
         */
        sendCount: number;
        /**
         * Email subject.
         */
        subject: string;
        /**
         * Task ID.
         */
        taskId: number;
        /**
         * Task status. `1`: to start; `5`: sending; `6`: sending suspended today; `7`: sending error; `10`: sent.
         */
        taskStatus: number;
        /**
         * Task type. `1`: immediate; `2`: scheduled; `3`: recurring. To query tasks of all types, do not pass in this parameter.
         */
        taskType: number;
        /**
         * Template and template dataNote: This field may return `null`, indicating that no valid value can be found.
         */
        templates: outputs.Ses.GetSendTasksDataTemplate[];
        /**
         * Parameters of a scheduled taskNote: This field may return `null`, indicating that no valid value can be found.
         */
        timedParams: outputs.Ses.GetSendTasksDataTimedParam[];
        /**
         * Task update time.
         */
        updateTime: string;
    }

    export interface GetSendTasksDataCycleParam {
        /**
         * Start time of a scheduled sending task.
         */
        beginTime: string;
        /**
         * Task recurrence in hours.
         */
        intervalTime: number;
        /**
         * Specifies whether to end the cycle. This parameter is used to update the task. Valid values: 0: No; 1: Yes.
         */
        termCycle: number;
    }

    export interface GetSendTasksDataTemplate {
        /**
         * Variable parameters in the template. Please use `json.dump` to format the JSON object into a string type. The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the corresponding value (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
         */
        templateData: string;
        /**
         * Template ID. If you do not have any template, please create one.
         */
        templateId: number;
    }

    export interface GetSendTasksDataTimedParam {
        /**
         * Start time of a scheduled sending task.
         */
        beginTime: string;
    }

    export interface GetStatisticsReportDailyVolume {
        /**
         * Number of email requests accepted by Tencent Cloud.
         */
        acceptedCount: number;
        /**
         * Number of bounced emails.
         */
        bounceCount: number;
        /**
         * Number of recipients who clicked on links in emails.
         */
        clickedCount: number;
        /**
         * Number of delivered emails.
         */
        deliveredCount: number;
        /**
         * Number of users (deduplicated) who opened emails.
         */
        openedCount: number;
        /**
         * Number of email requests.
         */
        requestCount: number;
        /**
         * Date Note: this field may return null, indicating that no valid values can be obtained.
         */
        sendDate: string;
        /**
         * Number of users who canceled subscriptions. Note: this field may return null, indicating that no valid values can be obtained.
         */
        unsubscribeCount: number;
    }

    export interface GetStatisticsReportOverallVolume {
        /**
         * Number of email requests accepted by Tencent Cloud.
         */
        acceptedCount: number;
        /**
         * Number of bounced emails.
         */
        bounceCount: number;
        /**
         * Number of recipients who clicked on links in emails.
         */
        clickedCount: number;
        /**
         * Number of delivered emails.
         */
        deliveredCount: number;
        /**
         * Number of users (deduplicated) who opened emails.
         */
        openedCount: number;
        /**
         * Number of email requests.
         */
        requestCount: number;
        /**
         * Date Note: this field may return null, indicating that no valid values can be obtained.
         */
        sendDate: string;
        /**
         * Number of users who canceled subscriptions. Note: this field may return null, indicating that no valid values can be obtained.
         */
        unsubscribeCount: number;
    }

    export interface ReceiverData {
        /**
         * Recipient email addresses.
         */
        email: string;
        /**
         * Variable parameters in the template, please use json.dump to format the JSON object as a string type. The object is a set of key-value pairs, where each key represents a variable in the template, and the variables in the template are represented by {{key}}, and the corresponding values will be replaced with {{value}} when sent.Note: Parameter values cannot be complex data such as HTML. The total length of TemplateData (the entire JSON structure) should be less than 800 bytes.
         */
        templateData?: string;
    }

    export interface SendEmailAttachment {
        /**
         * Base64-encoded attachment content. You can send attachments of up to 4 MB in the total size.Note: The TencentCloud API supports a request packet of up to 8 MB in size, and the size of the attachmentcontent will increase by 1.5 times after Base64 encoding. Therefore, you need to keep the total size of allattachments below 4 MB. If the entire request exceeds 8 MB, the API will return an error.
         */
        content: string;
        /**
         * Attachment name, which cannot exceed 255 characters. Some attachment types are not supported. For details, see [Attachment Types.](https://www.tencentcloud.com/document/product/1084/42373?has_map=1).
         */
        fileName: string;
    }

    export interface SendEmailTemplate {
        /**
         * Variable parameters in the template. Please use json.dump to format the JSON object into a string type.The object is a set of key-value pairs. Each key denotes a variable, which is represented by {{key}}. The key will be replaced with the correspondingvalue (represented by {{value}}) when sending the email.Note: The parameter value cannot be data of a complex type such as HTML.Example: {name:xxx,age:xx}.
         */
        templateData: string;
        /**
         * Template ID. If you do not have any template, please create one.
         */
        templateId: number;
    }

    export interface TemplateTemplateContent {
        /**
         * Html code after base64.
         */
        html?: string;
        /**
         * Text content after base64.
         */
        text?: string;
    }

}

export namespace Sqlserver {
    export interface BusinessIntelligenceInstanceResourceTag {
        /**
         * Tag key.
         */
        tagKey?: string;
        /**
         * Tag value.
         */
        tagValue?: string;
    }

    export interface ConfigInstanceParamParamList {
        /**
         * Parameter value.
         */
        currentValue?: string;
        /**
         * Parameter name.
         */
        name?: string;
    }

    export interface ConfigInstanceRoGroupWeightPair {
        /**
         * Read-only instance ID, in the format: mssqlro-3l3fgqn7.
         */
        readOnlyInstanceId: string;
        /**
         * Read-only instance weight, the range is 0-100.
         */
        readOnlyWeight: number;
    }

    export interface GeneralCloudInstanceResourceTag {
        /**
         * tag key.
         */
        tagKey?: string;
        /**
         * tag value.
         */
        tagValue?: string;
    }

    export interface GetAccountDbAttachmentsList {
        /**
         * Name of the SQL Server account to be queried.
         */
        accountName: string;
        /**
         * Name of the DB to be queried.
         */
        dbName: string;
        /**
         * SQL Server instance ID that the account belongs to.
         */
        instanceId: string;
        /**
         * Privilege of the account on DB. Valid value are `ReadOnly`, `ReadWrite`.
         */
        privilege: string;
    }

    export interface GetAccountsList {
        /**
         * Create time of the SQL Server account.
         */
        createTime: string;
        /**
         * SQL server instance ID that the account belongs to.
         */
        instanceId: string;
        /**
         * Name of the SQL server account to be queried.
         */
        name: string;
        /**
         * Remark of the SQL Server account.
         */
        remark: string;
        /**
         * Status of the SQL Server account. `1` for creating, `2` for running, `3` for modifying, 4 for resetting password, -1 for deleting.
         */
        status: number;
        /**
         * Last updated time of the SQL Server account.
         */
        updateTime: string;
    }

    export interface GetBackupCommandsList {
        /**
         * Create backup command.
         */
        command: string;
        /**
         * Request ID.
         */
        requestId: string;
    }

    export interface GetBackupUploadSizeCosUploadBackupFileSet {
        /**
         * Backup name.
         */
        fileName: string;
        /**
         * Backup size.
         */
        size: number;
    }

    export interface GetBackupsList {
        /**
         * Database name list of the backup.
         */
        dbLists: string[];
        /**
         * End time of the instance list, like yyyy-MM-dd HH:mm:ss.
         */
        endTime: string;
        /**
         * File name of the backup.
         */
        fileName: string;
        /**
         * ID of the backup.
         */
        id: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * URL for downloads externally.
         */
        internetUrl: string;
        /**
         * URL for downloads internally.
         */
        intranetUrl: string;
        /**
         * The size of backup file. Unit is KB.
         */
        size: number;
        /**
         * Start time of the instance list, like yyyy-MM-dd HH:mm:ss.
         */
        startTime: string;
        /**
         * Status of the backup. `1` for creating, `2` for successfully created, 3 for failed.
         */
        status: number;
        /**
         * Strategy of the backup. `0` for instance backup, `1` for multi-databases backup.
         */
        strategy: number;
        /**
         * The way to trigger backup. `0` for timed trigger, `1` for manual trigger.
         */
        triggerModel: number;
    }

    export interface GetBasicInstancesInstanceList {
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * Pay type of the SQL Server basic instance. For now, only `POSTPAID_BY_HOUR` is valid.
         */
        chargeType: string;
        /**
         * The CPU number of the SQL Server basic instance.
         */
        cpu: number;
        /**
         * Create time of the SQL Server basic instance.
         */
        createTime: string;
        /**
         * Version of the SQL Server basic database engine. Allowed values are `2008R2`(SQL Server 2008 Enterprise), `2012SP3`(SQL Server 2012 Enterprise), `2016SP1` (SQL Server 2016 Enterprise), `201602`(SQL Server 2016 Standard) and `2017`(SQL Server 2017 Enterprise). Default is `2008R2`.
         */
        engineVersion: string;
        /**
         * ID of the SQL Server basic instance to be query.
         */
        id: string;
        /**
         * Memory size (in GB). Allowed value must be larger than `memory` that data source `tencentcloudSqlserverSpecinfos` provides.
         */
        memory: number;
        /**
         * Name of the SQL Server basic instance to be query.
         */
        name: string;
        /**
         * Project ID of the SQL Server basic instance to be query.
         */
        projectId: number;
        /**
         * Status of the SQL Server basic instance. `1` for applying, `2` for running, `3` for running with limit, `4` for isolated, `5` for recycling, `6` for recycled, `7` for running with task, `8` for off-line, `9` for expanding, `10` for migrating, `11` for readonly, `12` for rebooting.
         */
        status: number;
        /**
         * Disk size (in GB). Allowed value must be a multiple of 10. The storage must be set with the limit of `storageMin` and `storageMax` which data source `tencentcloudSqlserverSpecinfos` provides.
         */
        storage: number;
        /**
         * Subnet ID of the SQL Server basic instance to be query.
         */
        subnetId: string;
        /**
         * Tags of the SQL Server basic instance.
         */
        tags: {[key: string]: any};
        /**
         * Used storage.
         */
        usedStorage: number;
        /**
         * IP for private access.
         */
        vip: string;
        /**
         * Vpc ID of the SQL Server basic instance to be query.
         */
        vpcId: string;
        /**
         * Port for private access.
         */
        vport: number;
    }

    export interface GetDbsDbList {
        /**
         * Character set DB uses, could be `Chinese_PRC_CI_AS`, `Chinese_PRC_CS_AS`, `Chinese_PRC_BIN`, `Chinese_Taiwan_Stroke_CI_AS`, `SQL_Latin1_General_CP1_CI_AS`, and `SQL_Latin1_General_CP1_CS_AS`.
         */
        charset: string;
        /**
         * Database creation time.
         */
        createTime: string;
        /**
         * SQL Server instance ID which DB belongs to.
         */
        instanceId: string;
        /**
         * Name of DB.
         */
        name: string;
        /**
         * Remark of the DB.
         */
        remark: string;
        /**
         * Database status. Valid values are `creating`, `running`, `modifying`, `dropping`.
         */
        status: string;
    }

    export interface GetDescHaLogSwitchLog {
        /**
         * Switch end time Note: This field may return null, indicating that no valid value can be obtained.
         */
        endTime: string;
        /**
         * Switch event ID Note: This field may return null, indicating that no valid value can be obtained.
         */
        eventId: string;
        /**
         * Machine failure causes automatic switching Note: This field may return null, indicating that no valid value can be obtained.
         */
        reason: string;
        /**
         * Switch start time Note: This field may return null, indicating that no valid value can be obtained.
         */
        startTime: string;
        /**
         * Switching mode 0-system automatic switching, 1-manual switching Note: This field may return null, indicating that no valid value can be obtained.
         */
        switchType: number;
    }

    export interface GetInsAttributeSslConfig {
        /**
         * TDE encryption, 'enable' - enabled, 'disable' - not enabled.
         */
        encryption: string;
        /**
         * SSL certificate validity, 0-invalid, 1-valid Note: This field may return null, indicating that no valid value can be obtained.
         */
        sslValidity: number;
        /**
         * SSL certificate validity period, time format YYYY-MM-DD HH:MM:SS Note: This field may return null, indicating that no valid value can be obtained.
         */
        sslValidityPeriod: string;
    }

    export interface GetInsAttributeTdeConfig {
        /**
         * Certificate ownership. Self - indicates using the account's own certificate, others - indicates referencing certificates from other accounts, and none - indicates no certificate.
         */
        certificateAttribution: string;
        /**
         * TDE encryption, 'enable' - enabled, 'disable' - not enabled.
         */
        encryption: string;
        /**
         * Other primary account IDs referenced when activating TDE encryption
         * Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        quoteUin: string;
    }

    export interface GetInstanceParamRecordsItem {
        /**
         * Instance ID in the format of mssql-dj5i29c5n. It is the same as the instance ID displayed in the TencentDB console and the response parameter InstanceId of the DescribeDBInstances API.
         */
        instanceId: string;
        /**
         * Modification time.
         */
        modifyTime: string;
        /**
         * Parameter value after modification.
         */
        newValue: string;
        /**
         * Parameter value before modification.
         */
        oldValue: string;
        /**
         * Parameter name.
         */
        paramName: string;
        /**
         * Parameter modification status. Valid values: 1 (initializing and waiting for modification), 2 (modification succeed), 3 (modification failed), 4 (modifying).
         */
        status: number;
    }

    export interface GetInstancesInstanceList {
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * Pay type of the SQL Server instance. For now, only `POSTPAID_BY_HOUR` is valid.
         */
        chargeType: string;
        /**
         * Create time of the SQL Server instance.
         */
        createTime: string;
        /**
         * Version of the SQL Server database engine. Allowed values are `2008R2`(SQL Server 2008 Enterprise), `2012SP3`(SQL Server 2012 Enterprise), `2016SP1` (SQL Server 2016 Enterprise), `201602`(SQL Server 2016 Standard) and `2017`(SQL Server 2017 Enterprise). Default is `2008R2`.
         */
        engineVersion: string;
        /**
         * Instance type. `DUAL` (dual-server high availability), `CLUSTER` (cluster).
         */
        haType: string;
        /**
         * ID of the SQL Server instance to be query.
         */
        id: string;
        /**
         * Memory size (in GB). Allowed value must be larger than `memory` that data source `tencentcloudSqlserverSpecinfos` provides.
         */
        memory: number;
        /**
         * Name of the SQL Server instance to be query.
         */
        name: string;
        /**
         * Project ID of the SQL Server instance to be query.
         */
        projectId: number;
        /**
         * Readonly flag. `RO` (read-only instance), `MASTER` (primary instance with read-only instances). If it is left empty, it refers to an instance which is not read-only and has no RO group.
         */
        roFlag: string;
        /**
         * Status of the SQL Server instance. 1 for applying, 2 for running, 3 for running with limit, 4 for isolated, 5 for recycling, 6 for recycled, 7 for running with task, 8 for off-line, 9 for expanding, 10 for migrating, 11 for readonly, 12 for rebooting.
         */
        status: number;
        /**
         * Disk size (in GB). Allowed value must be a multiple of 10. The storage must be set with the limit of `storageMin` and `storageMax` which data source `tencentcloudSqlserverSpecinfos` provides.
         */
        storage: number;
        /**
         * Subnet ID of the SQL Server instance to be query.
         */
        subnetId: string;
        /**
         * Tags of the SQL Server instance.
         */
        tags: {[key: string]: any};
        /**
         * Used storage.
         */
        usedStorage: number;
        /**
         * IP for private access.
         */
        vip: string;
        /**
         * Vpc ID of the SQL Server instance to be query.
         */
        vpcId: string;
        /**
         * Port for private access.
         */
        vport: number;
    }

    export interface GetProjectSecurityGroupsSecurityGroupSet {
        /**
         * Creation time, time format: yyyy-mm-dd hh:mm:ss.
         */
        createTime: string;
        /**
         * inbound rules.
         */
        inboundSets: outputs.Sqlserver.GetProjectSecurityGroupsSecurityGroupSetInboundSet[];
        /**
         * outbound rules.
         */
        outboundSets: outputs.Sqlserver.GetProjectSecurityGroupsSecurityGroupSetOutboundSet[];
        /**
         * Project ID, which can be viewed through the console project management.
         */
        projectId: number;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * security group name.
         */
        securityGroupName: string;
        /**
         * Security Group Remarks.
         */
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsSecurityGroupSetInboundSet {
        /**
         * Policy, ACCEPT or DROP.
         */
        action: string;
        /**
         * Destination IP or IP segment, such as 172.16.0.0/12.
         */
        cidrIp: string;
        /**
         * The direction defined by the rules, OUTPUT-outgoing rules INPUT-inbound rules.
         */
        dir: string;
        /**
         * Network protocol, support UDP, TCP, etc.
         */
        ipProtocol: string;
        /**
         * port or port range.
         */
        portRange: string;
    }

    export interface GetProjectSecurityGroupsSecurityGroupSetOutboundSet {
        /**
         * Policy, ACCEPT or DROP.
         */
        action: string;
        /**
         * Destination IP or IP segment, such as 172.16.0.0/12.
         */
        cidrIp: string;
        /**
         * The direction defined by the rules, OUTPUT-outgoing rules INPUT-inbound rules.
         */
        dir: string;
        /**
         * Network protocol, support UDP, TCP, etc.
         */
        ipProtocol: string;
        /**
         * port or port range.
         */
        portRange: string;
    }

    export interface GetPublishSubscribesPublishSubscribeList {
        /**
         * Database Publish and Publish relationship list.
         */
        databaseTuples: outputs.Sqlserver.GetPublishSubscribesPublishSubscribeListDatabaseTuple[];
        /**
         * ID of the SQL Server instance which publish.
         */
        publishInstanceId: string;
        /**
         * IP of the the SQL Server instance which publish.
         */
        publishInstanceIp: string;
        /**
         * Name of the SQL Server instance which publish.
         */
        publishInstanceName: string;
        /**
         * The id of the Publish and Subscribe.
         */
        publishSubscribeId: number;
        /**
         * The name of the Publish and Subscribe.
         */
        publishSubscribeName: string;
        /**
         * ID of the SQL Server instance which subscribe.
         */
        subscribeInstanceId: string;
        /**
         * IP of the SQL Server instance which subscribe.
         */
        subscribeInstanceIp: string;
        /**
         * Name of the SQL Server instance which subscribe.
         */
        subscribeInstanceName: string;
    }

    export interface GetPublishSubscribesPublishSubscribeListDatabaseTuple {
        /**
         * Last sync time.
         */
        lastSyncTime: string;
        /**
         * Name of publish database.
         */
        publishDatabase: string;
        /**
         * Publish and subscribe status between databases, valid values are `running`, `success`, `fail`, `unknow`.
         */
        status: string;
        /**
         * Name of subscribe database.
         */
        subscribeDatabase: string;
    }

    export interface GetQueryXeventEvent {
        /**
         * Generation end time of an extended file.
         */
        endTime: string;
        /**
         * Event type. Valid values: slow (Slow SQL event), blocked (blocking event), deadlock` (deadlock event).
         */
        eventType: string;
        /**
         * Download address on the public network.
         */
        externalAddr: string;
        /**
         * File name of an extended event.
         */
        fileName: string;
        /**
         * ID.
         */
        id: number;
        /**
         * Download address on the private network.
         */
        internalAddr: string;
        /**
         * File size of an extended event.
         */
        size: number;
        /**
         * Generation start time of an extended file.
         */
        startTime: string;
        /**
         * Event record status. Valid values: 1 (succeeded), 2 (failed).
         */
        status: number;
    }

    export interface GetReadonlyGroupsList {
        /**
         * ID of the readonly group.
         */
        id: string;
        /**
         * Indicate whether to offline delayed readonly instances.
         */
        isOfflineDelay: number;
        /**
         * Master SQL Server instance ID.
         */
        masterInstanceId: string;
        /**
         * Maximum delay time of the readonly instances.
         */
        maxDelayTime: number;
        /**
         * Minimum readonly instances that stays in the group.
         */
        minInstances: number;
        /**
         * Name of the readonly group.
         */
        name: string;
        /**
         * Readonly instance ID set of the readonly group.
         */
        readonlyInstanceSets: string[];
        /**
         * Status of the readonly group. `1` for running, `5` for applying.
         */
        status: number;
        /**
         * Virtual IP address of the readonly group.
         */
        vip: string;
        /**
         * Virtual port of the readonly group.
         */
        vport: number;
    }

    export interface GetRegionsRegionSet {
        /**
         * Region ID in the format of ap-guangzhou.
         */
        region: string;
        /**
         * Numeric ID of region.
         */
        regionId: number;
        /**
         * Region name.
         */
        regionName: string;
        /**
         * Current purchasability of this region. UNAVAILABLE: not purchasable, AVAILABLE: purchasable.
         */
        regionState: string;
    }

    export interface GetRollbackTimeDetail {
        /**
         * Database name.
         */
        dbName: string;
        /**
         * End time of time range available for rollback.
         */
        endTime: string;
        /**
         * Start time of time range available for rollback.
         */
        startTime: string;
    }

    export interface GetSlowlogsSlowlog {
        /**
         * Number of logs in file.
         */
        count: number;
        /**
         * Query end time.
         */
        endTime: string;
        /**
         * Download address for public network.
         */
        externalAddr: string;
        /**
         * Unique ID of slow query log file.
         */
        id: number;
        /**
         * Download address for private network.
         */
        internalAddr: string;
        /**
         * File size in KB.
         */
        size: number;
        /**
         * Query start time.
         */
        startTime: string;
        /**
         * Status (1: success, 2: failure) Note: this field may return null, indicating that no valid values can be obtained.
         */
        status: number;
    }

    export interface GetZoneConfigZoneList {
        /**
         * Alphabet ID of availability zone.
         */
        availabilityZone: string;
        /**
         * A list of specinfo configurations for the specific availability zone. Each element contains the following attributes:
         */
        specinfoLists: outputs.Sqlserver.GetZoneConfigZoneListSpecinfoList[];
        /**
         * Number ID of availability zone.
         */
        zoneId: number;
    }

    export interface GetZoneConfigZoneListSpecinfoList {
        /**
         * Billing mode under this specification. Valid values are `POSTPAID_BY_HOUR`, `PREPAID` and `ALL`. `ALL` means both POSTPAID_BY_HOUR and PREPAID.
         */
        chargeType: string;
        /**
         * Number of CPU cores.
         */
        cpu: number;
        /**
         * Database version information. Valid values: `2008R2 (SQL Server 2008 Enterprise)`, `2012SP3 (SQL Server 2012 Enterprise)`, `2016SP1 (SQL Server 2016 Enterprise)`, `201602 (SQL Server 2016 Standard)`, `2017 (SQL Server 2017 Enterprise)`.
         */
        dbVersion: string;
        /**
         * Version name corresponding to the `dbVersion` field.
         */
        dbVersionName: string;
        /**
         * Model ID.
         */
        machineType: string;
        /**
         * Maximum disk size under this specification in GB.
         */
        maxStorageSize: number;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Minimum disk size under this specification in GB.
         */
        minStorageSize: number;
        /**
         * QPS of this specification.
         */
        qps: number;
        /**
         * Instance specification ID.
         */
        specId: number;
    }

    export interface MigrationMigrateDbSet {
        /**
         * Name of the migration database.
         */
        dbName?: string;
    }

    export interface MigrationRenameRestore {
        /**
         * When the new name of the library is used for offline migration, if it is not filled in, it will be named according to OldName. OldName and NewName cannot be filled in at the same time. OldName and NewName must be filled in and cannot be duplicate when used for cloning database.
         */
        newName?: string;
        /**
         * The name of the library. If oldName does not exist, a failure is returned.It can be left blank when used for offline migration tasks.
         */
        oldName?: string;
    }

    export interface MigrationSource {
        /**
         * ID of the migration source Cvm, used when MigrateType=2 (cloud server self-built SQL Server database).
         */
        cvmId?: string;
        /**
         * The ID of the migration source instance, which is used when MigrateType=1 (TencentDB for SQLServers). The format is mssql-si2823jyl.
         */
        instanceId?: string;
        /**
         * Migrate the intranet IP of the self-built database of the source Cvm, and use it when MigrateType=2 (self-built SQL Server database of the cloud server).
         */
        ip?: string;
        /**
         * Password, MigrateType=1 or MigrateType=2.
         */
        password?: string;
        /**
         * The port number of the self-built database of the migration source Cvm, which is used when MigrateType=2 (self-built SQL Server database of the cloud server).
         */
        port?: number;
        /**
         * The subnet ID under the Vpc of the source Cvm is used when MigrateType=2 (ECS self-built SQL Server database). The format is as follows subnet-h9extioi.
         */
        subnetId?: string;
        /**
         * The source backup password for offline migration, MigrateType=4 or MigrateType=5.
         */
        urlPassword?: string;
        /**
         * The source backup address for offline migration. MigrateType=4 or MigrateType=5.
         */
        urls?: string[];
        /**
         * User name, MigrateType=1 or MigrateType=2.
         */
        userName?: string;
        /**
         * The Vpc network ID of the migration source Cvm is used when MigrateType=2 (cloud server self-built SQL Server database). The format is as follows vpc-6ys9ont9.
         */
        vpcId: string;
    }

    export interface MigrationTarget {
        /**
         * The ID of the migration target instance, in the format mssql-si2823jyl.
         */
        instanceId?: string;
        /**
         * Password of the migration target instance.
         */
        password?: string;
        /**
         * User name of the migration target instance.
         */
        userName?: string;
    }

    export interface PublishSubscribeDatabaseTuple {
        /**
         * Publish the database.
         */
        publishDatabase: string;
        /**
         * Subscribe the database.
         */
        subscribeDatabase: string;
    }

    export interface RestoreInstanceEncryption {
        /**
         * Database name.
         */
        dbName: string;
        /**
         * encryption, `enable` encrypted, `disable` unencrypted.
         */
        status: string;
    }

    export interface RestoreInstanceRenameRestore {
        /**
         * New database name. In offline migration, OldName will be used if NewName is left empty (OldName and NewName cannot be both empty). In database cloning, OldName and NewName must be both specified and cannot have the same value.
         */
        newName: string;
        /**
         * Database name. If the OldName database does not exist, a failure will be returned.It can be left empty in offline migration tasks.
         */
        oldName: string;
    }

    export interface RollbackInstanceEncryption {
        /**
         * Database name.
         */
        dbName: string;
        /**
         * encryption, `enable` encrypted, `disable` unencrypted.
         */
        status: string;
    }

    export interface RollbackInstanceRenameRestore {
        /**
         * New database name.
         */
        newName: string;
        /**
         * Database name. If the OldName database does not exist, a failure will be returned. It can be left empty in offline migration tasks.
         */
        oldName: string;
    }

    export interface StartXeventEventConfig {
        /**
         * Event type. Valid values: slow (set threshold for slow SQL ), blocked (set threshold for the blocking and deadlock).
         */
        eventType: string;
        /**
         * Threshold in milliseconds. Valid values: 0(disable), non-zero (enable).
         */
        threshold: number;
    }

}

export namespace Ssl {
    export interface FreeCertificateDvAuth {
        /**
         * DV authentication key.
         */
        dvAuthKey: string;
        /**
         * DV authentication value.
         */
        dvAuthValue: string;
        /**
         * DV authentication type.
         */
        dvAuthVerifyType: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * Beginning time of the SSL certificate.
         */
        beginTime: string;
        /**
         * Content of the SSL certificate.
         */
        cert: string;
        /**
         * Creation time of the SSL certificate.
         */
        createTime: string;
        /**
         * Primary domain of the SSL certificate.
         */
        domain: string;
        /**
         * DV certification information.
         */
        dvAuths: outputs.Ssl.GetCertificatesCertificateDvAuth[];
        /**
         * Ending time of the SSL certificate.
         */
        endTime: string;
        /**
         * ID of the SSL certificate to be queried.
         */
        id: string;
        /**
         * Key of the SSL certificate.
         */
        key: string;
        /**
         * Name of the SSL certificate to be queried.
         */
        name: string;
        /**
         * Order ID returned.
         */
        orderId: string;
        /**
         * Certificate authority.
         */
        productZhName: string;
        /**
         * Project ID of the SSL certificate.
         */
        projectId: number;
        /**
         * Status of the SSL certificate.
         */
        status: number;
        /**
         * ALL domains included in the SSL certificate. Including the primary domain name.
         */
        subjectNames: string[];
        /**
         * Type of the SSL certificate to be queried. Available values includes: `CA` and `SVR`.
         */
        type: string;
    }

    export interface GetCertificatesCertificateDvAuth {
        /**
         * DV authentication key.
         */
        dvAuthKey: string;
        /**
         * DV authentication value.
         */
        dvAuthValue: string;
        /**
         * DV authentication type.
         */
        dvAuthVerifyType: string;
    }

    export interface GetDescribeCertificateResult {
        /**
         * Remark name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        alias: string;
        /**
         * All general names of the CA certificateNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        cACommonNames: string[];
        /**
         * All encryption methods of CA certificateNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        cAEncryptAlgorithms: string[];
        /**
         * CA certificate all maturity timeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        cAEndTimes: string[];
        /**
         * Certificate takes effect time.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certBeginTime: string;
        /**
         * The certificate is invalid time.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certEndTime: string;
        /**
         * Certificate extension information.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certificateExtras: outputs.Ssl.GetDescribeCertificateResultCertificateExtra[];
        /**
         * Certificate type: CA = CA certificate, SVR = server certificate.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certificateType: string;
        /**
         * Whether it can be deployed.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        deployable: boolean;
        /**
         * domain name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        domain: string;
        /**
         * DV certification information.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthDetails: outputs.Ssl.GetDescribeCertificateResultDvAuthDetail[];
        /**
         * DV certificate revoking verification valueNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvRevokeAuthDetails: outputs.Ssl.GetDescribeCertificateResultDvRevokeAuthDetail[];
        /**
         * Certificate source: Trustasia,uploadNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        from: string;
        /**
         * application time.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        insertTime: string;
        /**
         * Whether it is the DV version.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        isDv: boolean;
        /**
         * Whether it is a VIP customer.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        isVip: boolean;
        /**
         * Whether the vulnerability scanning function is enabled.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        isVulnerability: boolean;
        /**
         * Whether it is a pan -domain certificate certificate.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        isWildcard: boolean;
        /**
         * Order ID.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        orderId: string;
        /**
         * Account UIN.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        ownerUin: string;
        /**
         * Types of Certificate Package: 1 = Geotrust DV SSL CA -G3, 2 = Trustasia TLS RSA CA, 3 = SecureSite Enhanced Enterprise Edition (EV Pro), 4 = SecureSite enhanced (EV), 5 = SecureSite Enterprise Professional Edition (OVPro), 6 = SecureSite Enterprise (OV), 7 = SecureSite Enterprise (OV) compatriots, 8 = Geotrust enhanced type (EV), 9 = Geotrust Enterprise (OV), 10 = Geotrust Enterprise (OV) pass,11 = Trustasia Domain Multi -domain SSL certificate, 12 = Trustasia domain model (DV) passing, 13 = Trustasia Enterprise Passing Character (OV) SSL certificate (D3), 14 = Trustasia Enterprise (OV) SSL certificate (D3), 15= Trustasia Enterprise Multi -domain name (OV) SSL certificate (D3), 16 = Trustasia enhanced (EV) SSL certificate (D3), 17 = Trustasia enhanced multi -domain name (EV) SSL certificate (D3), 18 = GlobalSign enterprise type enterprise type(OV) SSL certificate, 19 = GlobalSign Enterprise Type -type STL Certificate, 20 = GlobalSign enhanced (EV) SSL certificate, 21 = Trustasia Enterprise Tongzhi Multi -domain name (OV) SSL certificate (D3), 22 = GlobalSignignMulti -domain name (OV) SSL certificate, 23 = GlobalSign Enterprise Type -type multi -domain name (OV) SSL certificate, 24 = GlobalSign enhanced multi -domain name (EV) SSL certificate.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        packageType: string;
        /**
         * Certificate type name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        packageTypeName: string;
        /**
         * Certificate issuer name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        productZhName: string;
        /**
         * Project ID.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        projectId: string;
        /**
         * Whether you can issue a certificate.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        renewAble: boolean;
        /**
         * = Submitted information, to be uploaded to confirmation letter, 9 = Certificate is revoked, 10 = revoked, 11 = Re -issuance, 12 = Upload and revoke the confirmation letter.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        status: number;
        /**
         * status information.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        statusMsg: string;
        /**
         * status description.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        statusName: string;
        /**
         * The certificate contains multiple domain names (containing the main domain name).Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        subjectAltNames: string[];
        /**
         * Submitted information information.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        submittedDatas: outputs.Ssl.GetDescribeCertificateResultSubmittedData[];
        /**
         * Validity period: unit (month).Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        validityPeriod: string;
        /**
         * Verification type: DNS_AUTO = Automatic DNS verification, DNS = manual DNS verification, file = file verification, email = email verification.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        verifyType: string;
        /**
         * Vulnerability scanning evaluation report.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        vulnerabilityReport: string;
        /**
         * Vulnerability scanning status.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        vulnerabilityStatus: string;
    }

    export interface GetDescribeCertificateResultCertificateExtra {
        /**
         * Type of company. Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        companyType: number;
        /**
         * Certificate can be configured in the number of domain names.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        domainNumber: string;
        /**
         * Original certificate ID.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        originCertificateId: string;
        /**
         * New order certificate ID.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        renewOrder: string;
        /**
         * Re -issue the original ID of the certificate.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        replacedBy: string;
        /**
         * Re -issue a new ID.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        replacedFor: string;
        /**
         * Is it a national secret certificateNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        sMCert: number;
    }

    export interface GetDescribeCertificateResultDvAuthDetail {
        /**
         * DV authentication value domain name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthDomain: string;
        /**
         * DV certification key.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthKey: string;
        /**
         * DV certification sub -domain name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthKeySubDomain: string;
        /**
         * DV authentication value path.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthPath: string;
        /**
         * DV certification value.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthValue: string;
        /**
         * DV certification information.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuths: outputs.Ssl.GetDescribeCertificateResultDvAuthDetailDvAuth[];
    }

    export interface GetDescribeCertificateResultDvAuthDetailDvAuth {
        /**
         * DV authentication value domain name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthDomain: string;
        /**
         * DV certification key.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthKey: string;
        /**
         * DV authentication value path.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthPath: string;
        /**
         * DV certification sub -domain name,Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthSubDomain: string;
        /**
         * DV certification value.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthValue: string;
        /**
         * DV certification type.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthVerifyType: string;
    }

    export interface GetDescribeCertificateResultDvRevokeAuthDetail {
        /**
         * DV authentication value domain name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthDomain: string;
        /**
         * DV certification key.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthKey: string;
        /**
         * DV authentication value path.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthPath: string;
        /**
         * DV certification sub -domain name,Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthSubDomain: string;
        /**
         * DV certification value.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthValue: string;
        /**
         * DV certification type.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        dvAuthVerifyType: string;
    }

    export interface GetDescribeCertificateResultSubmittedData {
        /**
         * Administrator mailbox address.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        adminEmail: string;
        /**
         * Administrator name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        adminFirstName: string;
        /**
         * The surname of the administrator.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        adminLastName: string;
        /**
         * Administrator phone number.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        adminPhoneNum: string;
        /**
         * Administrator position.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        adminPosition: string;
        /**
         * Domain information.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certificateDomain: string;
        /**
         * Contact mailbox address,Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        contactEmail: string;
        /**
         * Contact name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        contactFirstName: string;
        /**
         * Contact surname.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        contactLastName: string;
        /**
         * Contact phone number.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        contactNumber: string;
        /**
         * Contact position.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        contactPosition: string;
        /**
         * CSR content.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        csrContent: string;
        /**
         * CSR type, (online = online CSR, PARSE = paste CSR).Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        csrType: string;
        /**
         * DNS information.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        domainLists: string[];
        /**
         * Private key password.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        keyPassword: string;
        /**
         * address.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        organizationAddress: string;
        /**
         * city.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        organizationCity: string;
        /**
         * nation.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        organizationCountry: string;
        /**
         * department.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        organizationDivision: string;
        /**
         * Enterprise or unit name.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        organizationName: string;
        /**
         * Province.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        organizationRegion: string;
        /**
         * Local region code.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        phoneAreaCode: string;
        /**
         * Landline number.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        phoneNumber: string;
        /**
         * Postal code.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        postalCode: string;
        /**
         * Verification type: DNS_AUTO = Automatic DNS verification, DNS = manual DNS verification, file = file verification, email = email verification.Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        verifyType: string;
    }

    export interface GetDescribeCompaniesCompany {
        /**
         * Detailed address where the company is located.
         */
        companyAddress: string;
        /**
         * The city where the company is.
         */
        companyCity: string;
        /**
         * Company country.
         */
        companyCountry: string;
        /**
         * Company ID.
         */
        companyId: number;
        /**
         * Company Name.
         */
        companyName: string;
        /**
         * company phone.
         */
        companyPhone: string;
        /**
         * Province where the company is located.
         */
        companyProvince: string;
        /**
         * ID numberNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        idNumber: string;
        /**
         * typeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        idType: string;
    }

    export interface GetDescribeHostApiGatewayInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostApiGatewayInstanceListInstanceList {
        /**
         * Certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certId: string;
        /**
         * domain name.
         */
        domain: string;
        /**
         * Use Agreement.
         */
        protocol: string;
        /**
         * Instance ID.
         */
        serviceId: string;
        /**
         * Example name.
         */
        serviceName: string;
    }

    export interface GetDescribeHostCdnInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostCdnInstanceListInstanceList {
        /**
         * Deployment certificate ID.
         */
        certId: string;
        /**
         * domain name.
         */
        domain: string;
        /**
         * Domain name billing status.
         */
        httpsBillingSwitch: string;
        /**
         * Domain name.
         */
        status: string;
    }

    export interface GetDescribeHostClbInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostClbInstanceListInstanceList {
        /**
         * CLB listener listNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        listeners: outputs.Ssl.GetDescribeHostClbInstanceListInstanceListListener[];
        /**
         * CLB instance ID.
         */
        loadBalancerId: string;
        /**
         * CLB instance name name.
         */
        loadBalancerName: string;
    }

    export interface GetDescribeHostClbInstanceListInstanceListListener {
        /**
         * Certificate data that has been bound to the rulesNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certificates: outputs.Ssl.GetDescribeHostClbInstanceListInstanceListListenerCertificate[];
        /**
         * Listener ID.
         */
        listenerId: string;
        /**
         * Name of listeners.
         */
        listenerName: string;
        /**
         * List of non -matching fieldsNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        noMatchDomains: string[];
        /**
         * Type of listener protocol, https | TCP_SSL.
         */
        protocol: string;
        /**
         * List of listeners&#39; rulesNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        rules: outputs.Ssl.GetDescribeHostClbInstanceListInstanceListListenerRule[];
        /**
         * Whether to turn on SNI, 1 to open, 0 to close.
         */
        sniSwitch: number;
    }

    export interface GetDescribeHostClbInstanceListInstanceListListenerCertificate {
        /**
         * Root certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certCaId: string;
        /**
         * Certificate ID.
         */
        certId: string;
        /**
         * Domain name binding of certificates.
         */
        dnsNames: string[];
        /**
         * Certificate certification mode: unidirectional unidirectional authentication, Mutual two -way certificationNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        sSLMode: string;
    }

    export interface GetDescribeHostClbInstanceListInstanceListListenerRule {
        /**
         * Certificate data that has been bound to the rulesNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certificates: outputs.Ssl.GetDescribeHostClbInstanceListInstanceListListenerRuleCertificate[];
        /**
         * Domain name binding.
         */
        domain: string;
        /**
         * Whether the rules match the domain name to be bound to the certificate.
         */
        isMatch: boolean;
        /**
         * Rule ID.
         */
        locationId: string;
        /**
         * List of non -matching fieldsNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        noMatchDomains: string[];
    }

    export interface GetDescribeHostClbInstanceListInstanceListListenerRuleCertificate {
        /**
         * Root certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certCaId: string;
        /**
         * Certificate ID.
         */
        certId: string;
        /**
         * Domain name binding of certificates.
         */
        dnsNames: string[];
        /**
         * Certificate certification mode: unidirectional unidirectional authentication, Mutual two -way certificationNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        sSLMode: string;
    }

    export interface GetDescribeHostCosInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostCosInstanceListInstanceList {
        /**
         * Reserve bucket nameNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        bucket: string;
        /**
         * Binded certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certId: string;
        /**
         * domain name.
         */
        domain: string;
        /**
         * Barrel areaNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        region: string;
        /**
         * Enabled: domain name online statusDisabled: Domain name offline status.
         */
        status: string;
    }

    export interface GetDescribeHostDdosInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostDdosInstanceListInstanceList {
        /**
         * Certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certId: string;
        /**
         * domain name.
         */
        domain: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * agreement type.
         */
        protocol: string;
        /**
         * Forwarding port.
         */
        virtualPort: string;
    }

    export interface GetDescribeHostDeployRecordDeployRecordList {
        /**
         * Deployment certificate ID.
         */
        certId: string;
        /**
         * Deployment time.
         */
        createTime: string;
        /**
         * Deployment record ID.
         */
        id: number;
        /**
         * Deployment.
         */
        region: string;
        /**
         * Resource Type.
         */
        resourceType: string;
        /**
         * Deployment state.
         */
        status: number;
        /**
         * Recent update time.
         */
        updateTime: string;
    }

    export interface GetDescribeHostDeployRecordDetailDeployRecordDetailList {
        /**
         * COS storage barrel nameNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        bucket: string;
        /**
         * Deployment certificate ID.
         */
        certId: string;
        /**
         * Deployment record details Create time.
         */
        createTime: string;
        /**
         * List of deployment domain.
         */
        domains: string[];
        /**
         * TCB environment IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        envId: string;
        /**
         * Deployment error messageNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        errorMsg: string;
        /**
         * Deployment record details ID.
         */
        id: number;
        /**
         * Deployment instance ID.
         */
        instanceId: string;
        /**
         * Deployment example name.
         */
        instanceName: string;
        /**
         * Deployment monitor IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        listenerId: string;
        /**
         * Delicate monitor name.
         */
        listenerName: string;
        /**
         * Named space nameNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        namespace: string;
        /**
         * Original binding certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        oldCertId: string;
        /**
         * portNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        port: number;
        /**
         * Deployment monitoring protocolNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        protocol: string;
        /**
         * Deployed TCB regionNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        region: string;
        /**
         * Secret nameNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        secretName: string;
        /**
         * Whether to turn on SNI.
         */
        sniSwitch: number;
        /**
         * Deployment state.
         */
        status: number;
        /**
         * Deployed TCB typeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        tcbType: string;
        /**
         * Deployment record details last update time.
         */
        updateTime: string;
    }

    export interface GetDescribeHostLighthouseInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostLighthouseInstanceListInstanceList {
        /**
         * Optional domain name.
         */
        domains: string[];
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Example name.
         */
        instanceName: string;
        /**
         * IP address.
         */
        ips: string[];
    }

    export interface GetDescribeHostLiveInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostLiveInstanceListInstanceList {
        /**
         * Binded certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certId: string;
        /**
         * domain name.
         */
        domain: string;
        /**
         * -1: Unrelated certificate of domain name.1: The domain name HTTPS has been opened.0: The domain name HTTPS has been closed.
         */
        status: number;
    }

    export interface GetDescribeHostTeoInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostTeoInstanceListInstanceList {
        /**
         * Certificate ID.
         */
        certId: string;
        /**
         * domain name.
         */
        host: string;
        /**
         * Domain name.
         */
        status: string;
        /**
         * Regional IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        zoneId: string;
    }

    export interface GetDescribeHostTkeInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostTkeInstanceListInstanceList {
        /**
         * Cluster ID.
         */
        clusterId: string;
        /**
         * Cluster name.
         */
        clusterName: string;
        /**
         * Cluster.
         */
        clusterType: string;
        /**
         * Cluster.
         */
        clusterVersion: string;
        /**
         * Cluster Naming Space List.
         */
        namespaceLists: outputs.Ssl.GetDescribeHostTkeInstanceListInstanceListNamespaceList[];
    }

    export interface GetDescribeHostTkeInstanceListInstanceListNamespaceList {
        /**
         * Secret name.
         */
        name: string;
        /**
         * Secret list.
         */
        secretLists: outputs.Ssl.GetDescribeHostTkeInstanceListInstanceListNamespaceListSecretList[];
    }

    export interface GetDescribeHostTkeInstanceListInstanceListNamespaceListSecretList {
        /**
         * Certificate ID.
         */
        certId: string;
        /**
         * Ingress list.
         */
        ingressLists: outputs.Ssl.GetDescribeHostTkeInstanceListInstanceListNamespaceListSecretListIngressList[];
        /**
         * Secret name.
         */
        name: string;
        /**
         * List of domain names that are not matched with the new certificateNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        noMatchDomains: string[];
    }

    export interface GetDescribeHostTkeInstanceListInstanceListNamespaceListSecretListIngressList {
        /**
         * Ingress domain name list.
         */
        domains: string[];
        /**
         * Ingress name.
         */
        ingressName: string;
        /**
         * TLS domain name list.
         */
        tlsDomains: string[];
    }

    export interface GetDescribeHostUpdateRecordDeployRecordList {
        /**
         * New certificate ID.
         */
        certId: string;
        /**
         * Deployment time.
         */
        createTime: string;
        /**
         * Record ID.
         */
        id: number;
        /**
         * Original certificate ID.
         */
        oldCertId: string;
        /**
         * List of regional deploymentNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        regions: string[];
        /**
         * List of resource types.
         */
        resourceTypes: string[];
        /**
         * Deployment state.
         */
        status: number;
        /**
         * Last update time.
         */
        updateTime: string;
    }

    export interface GetDescribeHostUpdateRecordDetailRecordDetailList {
        /**
         * List of deployment resources details.
         */
        lists: outputs.Ssl.GetDescribeHostUpdateRecordDetailRecordDetailListList[];
        /**
         * Deploy resource type.
         */
        resourceType: string;
        /**
         * The total number of deployment resources.
         */
        totalCount: number;
    }

    export interface GetDescribeHostUpdateRecordDetailRecordDetailListList {
        /**
         * BUCKET name (COS dedicated)Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        bucket: string;
        /**
         * New certificate ID.
         */
        certId: string;
        /**
         * Deployment time.
         */
        createTime: string;
        /**
         * List of deployment domainNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        domains: string[];
        /**
         * Environment IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        envId: string;
        /**
         * Deployment error messageNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        errorMsg: string;
        /**
         * Detailed record ID.
         */
        id: number;
        /**
         * Deployment instance IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        instanceId: string;
        /**
         * Deployment example nameNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        instanceName: string;
        /**
         * Deploy listener ID (CLB for CLB)Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        listenerId: string;
        /**
         * Deploy listener name (CLB for CLB)Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        listenerName: string;
        /**
         * Naming Space (TKE)Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        namespace: string;
        /**
         * Old certificate ID.
         */
        oldCertId: string;
        /**
         * portNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        port: number;
        /**
         * protocolNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        protocol: string;
        /**
         * DeploymentNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        region: string;
        /**
         * Deploy resource type.
         */
        resourceType: string;
        /**
         * Secret Name (TKE for TKE)Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        secretName: string;
        /**
         * Whether to turn on SNI (CLB dedicated)Note: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        sniSwitch: number;
        /**
         * Deployment state.
         */
        status: number;
        /**
         * TCB deployment typeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        tCBType: string;
        /**
         * Last update time.
         */
        updateTime: string;
    }

    export interface GetDescribeHostVodInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostVodInstanceListInstanceList {
        /**
         * Certificate ID.
         */
        certId: string;
        /**
         * domain name.
         */
        domain: string;
    }

    export interface GetDescribeHostWafInstanceListFilter {
        /**
         * Filter parameter key.
         */
        filterKey: string;
        /**
         * Filter parameter value.
         */
        filterValue: string;
    }

    export interface GetDescribeHostWafInstanceListInstanceList {
        /**
         * Binded certificate IDNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        certId: string;
        /**
         * domain name.
         */
        domain: string;
        /**
         * -1: Unrelated certificate of domain name.1: The domain name HTTPS has been opened.0: The domain name HTTPS has been closed.
         */
        status: number;
    }

    export interface GetDescribeManagerDetailCompanyInfo {
        /**
         * Detailed address where the company is located.
         */
        companyAddress: string;
        /**
         * The city where the company is.
         */
        companyCity: string;
        /**
         * Company country.
         */
        companyCountry: string;
        /**
         * Company ID.
         */
        companyId: number;
        /**
         * Company Name.
         */
        companyName: string;
        /**
         * company phone.
         */
        companyPhone: string;
        /**
         * Province where the company is located.
         */
        companyProvince: string;
        /**
         * ID numberNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        idNumber: string;
        /**
         * typeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        idType: string;
    }

    export interface GetDescribeManagersManager {
        /**
         * Number of administrative certificates.
         */
        certCount: number;
        /**
         * Creation timeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        createTime: string;
        /**
         * Number of administrators.
         */
        domainCount: number;
        /**
         * Examine the validity expiration timeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        expireTime: string;
        /**
         * Administrator department.
         */
        managerDepartment: string;
        /**
         * Manager name.
         */
        managerFirstName: string;
        /**
         * Manager ID.
         */
        managerId: number;
        /**
         * Manager name.
         */
        managerLastName: string;
        /**
         * Vague query manager email (will be abandoned), please use Searchkey.
         */
        managerMail: string;
        /**
         * Manager phone call.
         */
        managerPhone: string;
        /**
         * Manager position.
         */
        managerPosition: string;
        /**
         * Filter according to the status of the manager, and the value is available&amp;#39;None&amp;#39; Unable to submit review&amp;#39;Audit&amp;#39;, Asian Credit Review&amp;#39;Caaudit&amp;#39; CA review&amp;#39;OK&amp;#39; has been reviewed&amp;#39;Invalid&amp;#39; review failed&amp;#39;Expiring&amp;#39; is about to expire&amp;#39;Expired&amp;#39; expired.
         */
        status: string;
        /**
         * The last time the review timeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        submitAuditTime: string;
        /**
         * Examination timeNote: This field may return NULL, indicating that the valid value cannot be obtained.
         */
        verifyTime: string;
    }

    export interface PayCertificateDvAuth {
        /**
         * DV authentication key.
         */
        dvAuthKey: string;
        /**
         * DV authentication value.
         */
        dvAuthValue: string;
        /**
         * DV authentication type.
         */
        dvAuthVerifyType: string;
    }

    export interface PayCertificateInformation {
        /**
         * The administrator's email address.
         */
        adminEmail: string;
        /**
         * The first name of the administrator.
         */
        adminFirstName: string;
        /**
         * The last name of the administrator.
         */
        adminLastName: string;
        /**
         * Manager mobile phone number.
         */
        adminPhoneNum: string;
        /**
         * Manager position.
         */
        adminPosition: string;
        /**
         * Domain name for binding certificate.
         */
        certificateDomain: string;
        /**
         * Contact email address.
         */
        contactEmail: string;
        /**
         * Contact first name.
         */
        contactFirstName: string;
        /**
         * Contact last name.
         */
        contactLastName: string;
        /**
         * Contact phone number.
         */
        contactNumber: string;
        /**
         * Contact position.
         */
        contactPosition: string;
        /**
         * CSR content uploaded.
         */
        csrContent?: string;
        /**
         * CSR generation method. Valid values: `online`, `parse`. `online` means online generation, `parse` means manual upload.
         */
        csrType?: string;
        /**
         * Array of uploaded domain names, multi-domain certificates can be uploaded.
         */
        domainLists?: string[];
        /**
         * Private key password.
         */
        keyPassword?: string;
        /**
         * Company address.
         */
        organizationAddress: string;
        /**
         * Company city.
         */
        organizationCity: string;
        /**
         * Country name, such as China: CN.
         */
        organizationCountry: string;
        /**
         * Department name.
         */
        organizationDivision: string;
        /**
         * Company name.
         */
        organizationName: string;
        /**
         * The province where the company is located.
         */
        organizationRegion: string;
        /**
         * Company landline area code.
         */
        phoneAreaCode: string;
        /**
         * Company landline number.
         */
        phoneNumber: string;
        /**
         * Company postal code.
         */
        postalCode: string;
        /**
         * Certificate verification method. Valid values: `DNS_AUTO`, `DNS`, `FILE`. `DNS_AUTO` means automatic DNS verification, this verification type is only supported for domain names resolved by Tencent Cloud and the resolution status is normal, `DNS` means manual DNS verification, `FILE` means file verification.
         */
        verifyType: string;
    }

    export interface UpdateCertificateInstanceOperationResourceTypesRegion {
        /**
         * Region list.
         */
        regions?: string[];
        /**
         * Cloud resource type.
         */
        resourceType?: string;
    }

}

export namespace Ssm {
    export interface GetSecretVersionsSecretVersionList {
        /**
         * The base64-encoded binary secret.
         */
        secretBinary: string;
        /**
         * The string text of secret.
         */
        secretString: string;
        /**
         * VersionId used to filter result.
         */
        versionId: string;
    }

    export interface GetSecretsSecretList {
        /**
         * When the credential type is SSH key pair credential, this field is valid and is used to represent the CVM instance ID associated with the SSH key pair.
         */
        associatedInstanceIds: string[];
        /**
         * Create time of secret.
         */
        createTime: number;
        /**
         * Uin of Creator.
         */
        createUin: number;
        /**
         * Delete time of CMK.
         */
        deleteTime: number;
        /**
         * Description of secret.
         */
        description: string;
        /**
         * KMS keyId used to encrypt secret.
         */
        kmsKeyId: string;
        /**
         * KMS CMK type used to encrypt credentials, DEFAULT represents the default key created by SecretsManager, and CUSTOMER represents the user specified key.
         */
        kmsKeyType: string;
        /**
         * Next rotation start time, uinx timestamp.
         */
        nextRotationTime: number;
        /**
         * This parameter only takes effect when the SecretType parameter value is 1. When the SecretType value is 1, if the Product Name value is empty, it means to query all types of cloud product credentials. If the Product Name value is MySQL, it means to query MySQL database credentials. If the Product Name value is Tdsql mysql, it means to query Tdsql (MySQL version) credentials.
         */
        productName: string;
        /**
         * When the credential type is SSH key pair credential, this field is valid and represents the item ID to which the SSH key pair belongs.
         */
        projectId: number;
        /**
         * The cloud product instance ID number corresponding to the cloud product credentials.
         */
        resourceId: string;
        /**
         * When the credential type is SSH key pair credential, this field is valid and is used to represent the name of the SSH key pair credential.
         */
        resourceName: string;
        /**
         * The user specified rotation start time.
         */
        rotationBeginTime: string;
        /**
         * The frequency of rotation, in days, takes effect when rotation is on.
         */
        rotationFrequency: number;
        /**
         * 1: - Turn on the rotation; 0- No rotation Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        rotationStatus: number;
        /**
         * Secret name used to filter result.
         */
        secretName: string;
        /**
         * 0- represents user-defined credentials, defaults to 0. 1- represents the user's cloud product credentials. 2- represents SSH key pair credentials. 3- represents cloud API key pair credentials.
         */
        secretType: number;
        /**
         * Status of secret.
         */
        status: string;
        /**
         * When the credential type is a cloud API key pair credential, this field is valid and is used to represent the user UIN to which the cloud API key pair belongs.
         */
        targetUin: number;
    }

    export interface ProductSecretPrivilegesList {
        /**
         * This value takes effect only when `PrivilegeName` is `ColumnPrivileges`, and the following parameters are required in this case:Database: explicitly indicate the database instance.TableName: explicitly indicate the table.
         */
        columnName?: string;
        /**
         * This value takes effect only when `PrivilegeName` is `DatabasePrivileges`.
         */
        database?: string;
        /**
         * Permission name. Valid values: `GlobalPrivileges`, `DatabasePrivileges`, `TablePrivileges`, `ColumnPrivileges`. When the permission is `DatabasePrivileges`, the database name must be specified by the `Database` parameter; When the permission is `TablePrivileges`, the database name and the table name in the database must be specified by the `Database` and `TableName` parameters; When the permission is `ColumnPrivileges`, the database name, table name in the database, and column name in the table must be specified by the `Database`, `TableName`, and `ColumnName` parameters.
         */
        privilegeName: string;
        /**
         * Permission list. For the `Mysql` service, optional permission values are: 1. Valid values of `GlobalPrivileges`: SELECT,INSERT,UPDATE,DELETE,CREATE, PROCESS, DROP,REFERENCES,INDEX,ALTER,SHOW DATABASES,CREATE TEMPORARY TABLES,LOCK TABLES,EXECUTE,CREATE VIEW,SHOW VIEW,CREATE ROUTINE,ALTER ROUTINE,EVENT,TRIGGER. Note: if this parameter is not passed in, it means to clear the permission. 2. Valid values of `DatabasePrivileges`: SELECT,INSERT,UPDATE,DELETE,CREATE, DROP,REFERENCES,INDEX,ALTER,CREATE TEMPORARY TABLES,LOCK TABLES,EXECUTE,CREATE VIEW,SHOW VIEW,CREATE ROUTINE,ALTER ROUTINE,EVENT,TRIGGER. Note: if this parameter is not passed in, it means to clear the permission. 3. Valid values of `TablePrivileges`: SELECT,INSERT,UPDATE,DELETE,CREATE, DROP,REFERENCES,INDEX,ALTER,CREATE VIEW,SHOW VIEW, TRIGGER. Note: if this parameter is not passed in, it means to clear the permission. 4. Valid values of `ColumnPrivileges`: SELECT,INSERT,UPDATE,REFERENCES.Note: if this parameter is not passed in, it means to clear the permission.
         */
        privileges: string[];
        /**
         * This value takes effect only when `PrivilegeName` is `TablePrivileges`, and the `Database` parameter is required in this case to explicitly indicate the database instance.
         */
        tableName?: string;
    }

}

export namespace Tat {
    export interface CommandTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface GetAgentAutomationAgentSet {
        /**
         * Agent status.Ranges:&lt;li&gt; Online:Online&lt;li&gt; Offline:Offline.
         */
        agentStatus: string;
        /**
         * Environment for Agent.Ranges:&lt;li&gt; Linux:Linux instance&lt;li&gt; Windows:Windows instance.
         */
        environment: string;
        /**
         * InstanceId.
         */
        instanceId: string;
        /**
         * Time of last heartbeat.
         */
        lastHeartbeatTime: string;
        /**
         * List of feature Agent support.
         */
        supportFeatures: string[];
        /**
         * Agent version.
         */
        version: string;
    }

    export interface GetAgentFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter values of the field.
         */
        values: string[];
    }

    export interface GetCommandCommandSet {
        /**
         * Command ID.
         */
        commandId: string;
        /**
         * Command name.
         */
        commandName: string;
        /**
         * Command type, Value is `SHELL` or `POWERSHELL`.
         */
        commandType: string;
        /**
         * command.
         */
        content: string;
        /**
         * Command creator. `TAT` indicates a public command and `USER` indicates a personal command.
         */
        createdBy: string;
        /**
         * Command creation time.
         */
        createdTime: string;
        /**
         * Default custom parameter value.
         */
        defaultParameters: string;
        /**
         * Command description.
         */
        description: string;
        /**
         * Whether to enable the custom parameter feature.
         */
        enableParameter: boolean;
        /**
         * Formatted description of the command. This parameter is an empty string for user commands and contains values for public commands.
         */
        formattedDescription: string;
        /**
         * The COS bucket URL for uploading logs.
         */
        outputCosBucketUrl: string;
        /**
         * The COS bucket directory where the logs are saved.
         */
        outputCosKeyPrefix: string;
        /**
         * Tags bound to the command. At most 10 tags are allowed.
         */
        tags: outputs.Tat.GetCommandCommandSetTag[];
        /**
         * Command timeout period.
         */
        timeout: number;
        /**
         * Command update time.
         */
        updatedTime: string;
        /**
         * The user who executes the command on the instance.
         */
        username: string;
        /**
         * Command execution path.
         */
        workingDirectory: string;
    }

    export interface GetCommandCommandSetTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface GetInvocationTaskFilter {
        /**
         * Field to be filtered.
         */
        name: string;
        /**
         * Filter values of the field.
         */
        values: string[];
    }

    export interface GetInvocationTaskInvocationTaskSet {
        /**
         * Command details of the execution task.
         */
        commandDocuments: outputs.Tat.GetInvocationTaskInvocationTaskSetCommandDocument[];
        /**
         * Command ID.
         */
        commandId: string;
        /**
         * Creation time.
         */
        createdTime: string;
        /**
         * End time of the execution task.
         */
        endTime: string;
        /**
         * Error message displayed when the execution task fails.
         */
        errorInfo: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Execution activity ID.
         */
        invocationId: string;
        /**
         * Invocation source.
         */
        invocationSource: string;
        /**
         * Execution task ID.
         */
        invocationTaskId: string;
        /**
         * Start time of the execution task.
         */
        startTime: string;
        /**
         * Execution result.
         */
        taskResults: outputs.Tat.GetInvocationTaskInvocationTaskSetTaskResult[];
        /**
         * Execution task status. Valid values:PENDING: PendingDELIVERING: DeliveringDELIVER_DELAYED: Delivery delayedDELIVER_FAILED: Delivery failedSTART_FAILED: Failed to start the commandRUNNING: RunningSUCCESS: SuccessFAILED: Failed to execute the command. The exit code is not 0 after execution.TIMEOUT: Command timed outTASK_TIMEOUT: Task timed outCANCELLING: CancelingCANCELLED: Canceled (canceled before execution)TERMINATED: Terminated (canceled during execution).
         */
        taskStatus: string;
        /**
         * Update time.
         */
        updatedTime: string;
    }

    export interface GetInvocationTaskInvocationTaskSetCommandDocument {
        /**
         * Command type.
         */
        commandType: string;
        /**
         * Base64-encoded command.
         */
        content: string;
        /**
         * URL of the COS bucket to store the output.
         */
        outputCosBucketUrl: string;
        /**
         * Prefix of the output file name.
         */
        outputCosKeyPrefix: string;
        /**
         * Timeout period.
         */
        timeout: number;
        /**
         * The user who executes the command.
         */
        username: string;
        /**
         * Execution path.
         */
        workingDirectory: string;
    }

    export interface GetInvocationTaskInvocationTaskSetTaskResult {
        /**
         * Dropped bytes of the command output.
         */
        dropped: number;
        /**
         * Time when the execution is ended.
         */
        execEndTime: string;
        /**
         * Time when the execution is started.
         */
        execStartTime: string;
        /**
         * ExitCode of the execution.
         */
        exitCode: number;
        /**
         * Base64-encoded command output. The maximum length is 24 KB.
         */
        output: string;
        /**
         * Error message for uploading logs to COS.
         */
        outputUploadCosErrorInfo: string;
        /**
         * COS URL of the logs.
         */
        outputUrl: string;
    }

    export interface GetInvokerInvokerSet {
        /**
         * Command ID.
         */
        commandId: string;
        /**
         * Creation time.
         */
        createdTime: string;
        /**
         * Whether to enable the invoker.
         */
        enable: boolean;
        /**
         * Instance ID list.
         */
        instanceIds: string[];
        /**
         * Invoker ID.
         */
        invokerId: string;
        /**
         * Invoker name.
         */
        name: string;
        /**
         * Custom parameters.
         */
        parameters: string;
        /**
         * Execution schedule of the invoker. This field is returned for recurring invokers.
         */
        scheduleSettings: outputs.Tat.GetInvokerInvokerSetScheduleSetting[];
        /**
         * Invoker type.
         */
        type: string;
        /**
         * Modification time.
         */
        updatedTime: string;
        /**
         * Username.
         */
        username: string;
    }

    export interface GetInvokerInvokerSetScheduleSetting {
        /**
         * The next execution time of the invoker. This field is required if Policy is ONCE.
         */
        invokeTime: string;
        /**
         * Execution policy: `ONCE`: Execute once; `RECURRENCE`: Execute repeatedly.
         */
        policy: string;
        /**
         * Trigger the crontab expression. This field is required if `Policy` is `RECURRENCE`. The crontab expression is parsed in UTC+8.
         */
        recurrence: string;
    }

    export interface GetInvokerRecordsInvokerRecordSet {
        /**
         * Command execution ID.
         */
        invocationId: string;
        /**
         * Execution time.
         */
        invokeTime: string;
        /**
         * Invoker ID.
         */
        invokerId: string;
        /**
         * Execution reason.
         */
        reason: string;
        /**
         * Trigger result.
         */
        result: string;
    }

    export interface InvokerScheduleSettings {
        /**
         * The next execution time of the invoker. This field is required if Policy is ONCE.
         */
        invokeTime?: string;
        /**
         * Execution policy: `ONCE`: Execute once; `RECURRENCE`: Execute repeatedly.
         */
        policy: string;
        /**
         * Trigger the crontab expression. This field is required if `Policy` is `RECURRENCE`. The crontab expression is parsed in UTC+8.
         */
        recurrence?: string;
    }

}

export namespace Tcaplus {
    export interface GetClustersList {
        /**
         * Access id of the TcaplusDB cluster.For TcaplusDB SDK connect.
         */
        apiAccessId: string;
        /**
         * Access ip of the TcaplusDB cluster.For TcaplusDB SDK connect.
         */
        apiAccessIp: string;
        /**
         * Access port of the TcaplusDB cluster.For TcaplusDB SDK connect.
         */
        apiAccessPort: number;
        /**
         * ID of the TcaplusDB cluster to be query.
         */
        clusterId: string;
        /**
         * Name of the TcaplusDB cluster to be query.
         */
        clusterName: string;
        /**
         * Create time of the TcaplusDB cluster.
         */
        createTime: string;
        /**
         * IDL type of the TcaplusDB cluster.
         */
        idlType: string;
        /**
         * Network type of the TcaplusDB cluster.
         */
        networkType: string;
        /**
         * Expiration time of the old password. If `passwordStatus` is `unmodifiable`, it means the old password has not yet expired.
         */
        oldPasswordExpireTime: string;
        /**
         * Access password of the TcaplusDB cluster.
         */
        password: string;
        /**
         * Password status of the TcaplusDB cluster. Valid values: `unmodifiable`, `modifiable`. `unmodifiable` means the password can not be changed in this moment; `modifiable` means the password can be changed in this moment.
         */
        passwordStatus: string;
        /**
         * Subnet ID of the TcaplusDB cluster.
         */
        subnetId: string;
        /**
         * VPC ID of the TcaplusDB cluster.
         */
        vpcId: string;
    }

    export interface GetIdlsList {
        /**
         * ID of the IDL.
         */
        idlId: string;
    }

    export interface GetTablegroupsList {
        /**
         * Create time of the table group..
         */
        createTime: string;
        /**
         * Number of tables.
         */
        tableCount: number;
        /**
         * Id of the table group to be query.
         */
        tablegroupId: string;
        /**
         * Name of the table group to be query.
         */
        tablegroupName: string;
        /**
         * Total storage size (MB).
         */
        totalSize: number;
    }

    export interface GetTablesList {
        /**
         * Create time of the TcaplusDB table.
         */
        createTime: string;
        /**
         * Description of the TcaplusDB table.
         */
        description: string;
        /**
         * Error message for creating TcaplusDB table.
         */
        error: string;
        /**
         * IDL file id of the TcaplusDB table.
         */
        idlId: string;
        /**
         * Reserved read capacity units of the TcaplusDB table.
         */
        reservedReadCu: number;
        /**
         * Reserved storage capacity of the TcaplusDB table (unit:GB).
         */
        reservedVolume: number;
        /**
         * Reserved write capacity units of the TcaplusDB table.
         */
        reservedWriteCu: number;
        /**
         * Status of the TcaplusDB table.
         */
        status: string;
        /**
         * Table ID to be query.
         */
        tableId: string;
        /**
         * IDL type of  the TcaplusDB table.
         */
        tableIdlType: string;
        /**
         * Table name to be query.
         */
        tableName: string;
        /**
         * Size of the TcaplusDB table.
         */
        tableSize: number;
        /**
         * Type of the TcaplusDB table.
         */
        tableType: string;
        /**
         * ID of the table group to be query.
         */
        tablegroupId: string;
    }

    export interface IdlTableInfo {
        /**
         * Error messages for creating IDL file.
         */
        error: string;
        /**
         * Index key set of the TcaplusDB table.
         */
        indexKeySet: string;
        /**
         * Primary key fields of the TcaplusDB table.
         */
        keyFields: string;
        /**
         * Total size of primary key field of the TcaplusDB table.
         */
        sumKeyFieldSize: number;
        /**
         * Total size of non-primary key fields of the TcaplusDB table.
         */
        sumValueFieldSize: number;
        /**
         * Name of the TcaplusDB table.
         */
        tableName: string;
        /**
         * Non-primary key fields of the TcaplusDB table.
         */
        valueFields: string;
    }

}

export namespace Tcm {
    export interface AccessLogConfigCls {
        /**
         * Whether enable CLS.
         */
        enable: boolean;
        /**
         * Log set of CLS.
         */
        logSet?: string;
        /**
         * Log topic of CLS.
         */
        topic?: string;
    }

    export interface AccessLogConfigSelectedRange {
        /**
         * Select all if true, default false.
         */
        all?: boolean;
        /**
         * Items.
         */
        items?: outputs.Tcm.AccessLogConfigSelectedRangeItem[];
    }

    export interface AccessLogConfigSelectedRangeItem {
        /**
         * Ingress gateway list.
         */
        gateways?: string[];
        /**
         * Namespace.
         */
        namespace?: string;
    }

    export interface ClusterAttachmentClusterList {
        /**
         * TKE Cluster id.
         */
        clusterId: string;
        /**
         * TKE cluster region.
         */
        region: string;
        /**
         * Cluster role in mesh, REMOTE or MASTER.
         */
        role: string;
        /**
         * Subnet id, only needed if it&#39;s standalone mesh.
         */
        subnetId: string;
        /**
         * Cluster type.
         */
        type: string;
        /**
         * Cluster&#39;s VpcId.
         */
        vpcId: string;
    }

    export interface GetMeshMeshList {
        /**
         * Mesh configuration.
         */
        configs: outputs.Tcm.GetMeshMeshListConfig[];
        /**
         * Mesh name.
         */
        displayName: string;
        /**
         * Mesh instance Id.
         */
        meshId: string;
        /**
         * A list of associated tags.
         */
        tagLists: outputs.Tcm.GetMeshMeshListTagList[];
        /**
         * Mesh type.  Value range:- `STANDALONE`: Standalone mesh- `HOSTED`: hosted the mesh.
         */
        type: string;
        /**
         * Mesh version.
         */
        version: string;
    }

    export interface GetMeshMeshListConfig {
        /**
         * Istio configuration.
         */
        istios: outputs.Tcm.GetMeshMeshListConfigIstio[];
    }

    export interface GetMeshMeshListConfigIstio {
        /**
         * Disable http retry.
         */
        disableHttpRetry: boolean;
        /**
         * Disable policy checks.
         */
        disablePolicyChecks: boolean;
        /**
         * Enable HTTP/1.0 support.
         */
        enablePilotHttp: boolean;
        /**
         * Outbound traffic policy.
         */
        outboundTrafficPolicy: string;
        /**
         * SmartDNS configuration.
         */
        smartDns: outputs.Tcm.GetMeshMeshListConfigIstioSmartDn[];
    }

    export interface GetMeshMeshListConfigIstioSmartDn {
        /**
         * Enable auto allocate address.
         */
        istioMetaDnsAutoAllocate: boolean;
        /**
         * Enable dns proxy.
         */
        istioMetaDnsCapture: boolean;
    }

    export interface GetMeshMeshListTagList {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Passthrough to other related product.
         */
        passthrough: boolean;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface MeshConfig {
        /**
         * Sidecar inject configuration.
         */
        inject?: outputs.Tcm.MeshConfigInject;
        /**
         * Istio configuration.
         */
        istio?: outputs.Tcm.MeshConfigIstio;
        /**
         * Prometheus configuration.
         */
        prometheus: outputs.Tcm.MeshConfigPrometheus;
        /**
         * Default sidecar requests and limits.
         */
        sidecarResources?: outputs.Tcm.MeshConfigSidecarResources;
        /**
         * Tracing config.
         */
        tracing: outputs.Tcm.MeshConfigTracing;
    }

    export interface MeshConfigInject {
        /**
         * IP ranges that should not be proxied.
         */
        excludeIpRanges?: string[];
        /**
         * Let istio-proxy(sidecar) start first, before app container.
         */
        holdApplicationUntilProxyStarts?: boolean;
        /**
         * Let istio-proxy(sidecar) stop last, after app container.
         */
        holdProxyUntilApplicationEnds?: boolean;
    }

    export interface MeshConfigIstio {
        /**
         * Disable http retry.
         */
        disableHttpRetry?: boolean;
        /**
         * Disable policy checks.
         */
        disablePolicyChecks?: boolean;
        /**
         * Enable HTTP/1.0 support.
         */
        enablePilotHttp?: boolean;
        /**
         * Outbound traffic policy, REGISTRY_ONLY or ALLOW_ANY, see https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode.
         */
        outboundTrafficPolicy: string;
        /**
         * SmartDNS configuration.
         */
        smartDns?: outputs.Tcm.MeshConfigIstioSmartDns;
        /**
         * Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
         */
        tracing?: outputs.Tcm.MeshConfigIstioTracing;
    }

    export interface MeshConfigIstioSmartDns {
        /**
         * Enable auto allocate address.
         */
        istioMetaDnsAutoAllocate?: boolean;
        /**
         * Enable dns proxy.
         */
        istioMetaDnsCapture?: boolean;
    }

    export interface MeshConfigIstioTracing {
        /**
         * APM config.
         */
        apm?: outputs.Tcm.MeshConfigIstioTracingApm;
        /**
         * Whether enable tracing.
         */
        enable?: boolean;
        /**
         * Tracing sampling, 0.0-1.0.
         */
        sampling: number;
        /**
         * Third party zipkin config.
         */
        zipkin?: outputs.Tcm.MeshConfigIstioTracingZipkin;
    }

    export interface MeshConfigIstioTracingApm {
        /**
         * Whether enable APM.
         */
        enable: boolean;
        /**
         * Instance id of the APM.
         */
        instanceId?: string;
        /**
         * Region.
         */
        region?: string;
    }

    export interface MeshConfigIstioTracingZipkin {
        /**
         * Zipkin address.
         */
        address: string;
    }

    export interface MeshConfigPrometheus {
        /**
         * Custom prometheus.
         */
        customProm: outputs.Tcm.MeshConfigPrometheusCustomProm;
        /**
         * Instance id.
         */
        instanceId: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Subnet id.
         */
        subnetId: string;
        /**
         * Vpc id.
         */
        vpcId: string;
    }

    export interface MeshConfigPrometheusCustomProm {
        /**
         * Authentication type of the prometheus.
         */
        authType: string;
        /**
         * Whether it is public address, default false.
         */
        isPublicAddr: boolean;
        /**
         * Password of the prometheus, used in basic authentication type.
         */
        password: string;
        /**
         * Url of the prometheus.
         */
        url: string;
        /**
         * Username of the prometheus, used in basic authentication type.
         */
        username: string;
        /**
         * Vpc id.
         */
        vpcId: string;
    }

    export interface MeshConfigSidecarResources {
        /**
         * Sidecar limits.
         */
        limits?: outputs.Tcm.MeshConfigSidecarResourcesLimit[];
        /**
         * Sidecar requests.
         */
        requests?: outputs.Tcm.MeshConfigSidecarResourcesRequest[];
    }

    export interface MeshConfigSidecarResourcesLimit {
        /**
         * Resource type name, `cpu/memory`.
         */
        name?: string;
        /**
         * Resource quantity, example: cpu-`100m`, memory-`1Gi`.
         */
        quantity?: string;
    }

    export interface MeshConfigSidecarResourcesRequest {
        /**
         * Resource type name, `cpu/memory`.
         */
        name?: string;
        /**
         * Resource quantity, example: cpu-`100m`, memory-`1Gi`.
         */
        quantity?: string;
    }

    export interface MeshConfigTracing {
        /**
         * APM config.
         */
        apm: outputs.Tcm.MeshConfigTracingApm;
        /**
         * Whether enable tracing.
         */
        enable: boolean;
        /**
         * Tracing sampling, 0.0-1.0.
         */
        sampling: number;
        /**
         * Third party zipkin config.
         */
        zipkin: outputs.Tcm.MeshConfigTracingZipkin;
    }

    export interface MeshConfigTracingApm {
        /**
         * Whether enable APM.
         */
        enable: boolean;
        /**
         * Instance id of the APM.
         */
        instanceId: string;
        /**
         * Region.
         */
        region: string;
    }

    export interface MeshConfigTracingZipkin {
        /**
         * Zipkin address.
         */
        address: string;
    }

    export interface MeshTagList {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Passthrough to other related product.
         */
        passthrough?: boolean;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface PrometheusAttachmentPrometheus {
        /**
         * Third party prometheus.
         */
        customProm: outputs.Tcm.PrometheusAttachmentPrometheusCustomProm;
        /**
         * Existed TMP id, auto create TMP if empty.
         */
        instanceId: string;
        /**
         * Region for TMP.
         */
        region: string;
        /**
         * Subnet id for TMP.
         */
        subnetId: string;
        /**
         * Vpc id for TMP.
         */
        vpcId: string;
    }

    export interface PrometheusAttachmentPrometheusCustomProm {
        /**
         * Authentication type of the prometheus.
         */
        authType: string;
        /**
         * Whether it is public address, default false.
         */
        isPublicAddr: boolean;
        /**
         * Password of the prometheus, used in basic authentication type.
         */
        password: string;
        /**
         * Url of the prometheus.
         */
        url: string;
        /**
         * Username of the prometheus, used in basic authentication type.
         */
        username: string;
        /**
         * Vpc id.
         */
        vpcId: string;
    }

    export interface TracingConfigApm {
        /**
         * Whether enable APM.
         */
        enable?: boolean;
        /**
         * Instance id of the APM.
         */
        instanceId?: string;
        /**
         * Region.
         */
        region?: string;
    }

    export interface TracingConfigZipkin {
        /**
         * Zipkin address.
         */
        address: string;
    }

}

export namespace Tcmq {
    export interface GetQueueFilter {
        /**
         * Filter parameter name.
         */
        name?: string;
        /**
         * Value.
         */
        values?: string[];
    }

    export interface GetQueueQueueList {
        /**
         * Total number of messages in `Active` status (i.e., unconsumed) in the queue, which is an approximate value.
         */
        activeMsgNum: number;
        /**
         * Bandwidth limit.
         */
        bps: number;
        /**
         * Queue creation time. A Unix timestamp accurate down to the millisecond will be returned.
         */
        createTime: number;
        /**
         * Creator `Uin`.
         */
        createUin: number;
        /**
         * Dead letter queue policy.
         */
        deadLetterPolicies: outputs.Tcmq.GetQueueQueueListDeadLetterPolicy[];
        /**
         * Dead letter queue.
         */
        deadLetterSources: outputs.Tcmq.GetQueueQueueListDeadLetterSource[];
        /**
         * Number of delayed messages.
         */
        delayMsgNum: number;
        /**
         * Total number of messages in `Inactive` status (i.e., being consumed) in the queue, which is an approximate value.
         */
        inactiveMsgNum: number;
        /**
         * Time when the queue attribute is last modified. A Unix timestamp accurate down to the millisecond will be returned.
         */
        lastModifyTime: number;
        /**
         * Maximum retention period for inflight messages.
         */
        maxDelaySeconds: number;
        /**
         * Maximum size of heaped messages in bytes.
         */
        maxMsgBacklogSize: number;
        /**
         * Maximum number of heaped messages. The value range is 1,000,000-10,000,000 during the beta test and can be 1,000,000-1,000,000,000 after the product is officially released. The default value is 10,000,000 during the beta test and will be 100,000,000 after the product is officially released.
         */
        maxMsgHeapNum: number;
        /**
         * Maximum message length. Value range: 1024-65536 bytes (i.e., 1-64 KB). Default value: 65536.
         */
        maxMsgSize: number;
        /**
         * The maximum number of unacknowledged messages.
         */
        maxUnackedMsgNum: number;
        /**
         * Minimum unconsumed time of message in seconds.
         */
        minMsgTime: number;
        /**
         * The max period during which a message is retained before it is automatically acknowledged. Value range: 30-43,200 seconds (30 seconds to 12 hours). Default value: 3600 seconds (1 hour).
         */
        msgRetentionSeconds: number;
        /**
         * Namespace name.
         */
        namespaceName: string;
        /**
         * Long polling wait time for message reception. Value range: 0-30 seconds. Default value: 0.
         */
        pollingWaitSeconds: number;
        /**
         * Limit of the number of messages produced per second. The value for consumed messages is 1.1 times this value.
         */
        qps: number;
        /**
         * Message queue ID.
         */
        queueId: string;
        /**
         * Filter by QueueName.
         */
        queueName: string;
        /**
         * Queue storage space configured for message rewind. Value range: 1,024-10,240 MB (if message rewind is enabled). The value `0` indicates that message rewind is not enabled.
         */
        retentionSizeInMb: number;
        /**
         * Number of retained messages which have been deleted by the `DelMsg` API but are still within their rewind time range.
         */
        rewindMsgNum: number;
        /**
         * Rewindable time of messages in the queue. Value range: 0-1,296,000s (if message rewind is enabled). The value `0` indicates that message rewind is not enabled.
         */
        rewindSeconds: number;
        /**
         * Cluster status. `0`: creating; `1`: normal; `2`: terminating; `3`: deleted; `4`: isolated; `5`: creation failed; `6`: deletion failed.
         */
        status: number;
        /**
         * Associated tag.
         */
        tags: outputs.Tcmq.GetQueueQueueListTag[];
        /**
         * Tenant ID.
         */
        tenantId: string;
        /**
         * Message trace. true: enabled; false: not enabled.
         */
        trace: boolean;
        /**
         * 1: transaction queue; 0: general queue.
         */
        transaction: boolean;
        /**
         * Transaction message policy.
         */
        transactionPolicies: outputs.Tcmq.GetQueueQueueListTransactionPolicy[];
        /**
         * Message visibility timeout period. Value range: 1-43200 seconds (i.e., 12 hours). Default value: 30.
         */
        visibilityTimeout: number;
    }

    export interface GetQueueQueueListDeadLetterPolicy {
        /**
         * Dead letter queue.
         */
        deadLetterQueue: string;
        /**
         * Maximum number of receipts.
         */
        maxReceiveCount: number;
        /**
         * Maximum period in seconds before an unconsumed message expires, which is required if `Policy` is 1. Value range: 300-43200. This value should be smaller than `MsgRetentionSeconds` (maximum message retention period).
         */
        maxTimeToLive: number;
        /**
         * Dead letter queue policy.
         */
        policy: number;
    }

    export interface GetQueueQueueListDeadLetterSource {
        /**
         * Message queue ID.
         */
        queueId: string;
        /**
         * Filter by QueueName.
         */
        queueName: string;
    }

    export interface GetQueueQueueListTag {
        /**
         * Value of the tag key.
         */
        tagKey: string;
        /**
         * Value of the tag value.
         */
        tagValue: string;
    }

    export interface GetQueueQueueListTransactionPolicy {
        /**
         * First lookback time.
         */
        firstQueryInterval: number;
        /**
         * Maximum number of queries.
         */
        maxQueryCount: number;
    }

    export interface GetSubscribeSubscriptionList {
        /**
         * Filtering policy for subscribing to and receiving messages.
         */
        bindingKeys: string[];
        /**
         * Subscription creation time. A Unix timestamp accurate down to the millisecond will be returned.
         */
        createTime: number;
        /**
         * Endpoint that receives notifications, which varies by `protocol`: for HTTP, the endpoint must start with `http://`, and the `host` can be a domain or IP; for `queue`, `queueName` should be entered.
         */
        endpoint: string;
        /**
         * Filtering policy selected when a subscription is created:If `filterType` is 1, `filterTag` will be used for filtering. If `filterType` is 2, `bindingKey` will be used for filtering.
         */
        filterTags: string[];
        /**
         * Time when the subscription attribute is last modified. A Unix timestamp accurate down to the millisecond will be returned.
         */
        lastModifyTime: number;
        /**
         * Number of messages to be delivered in the subscription.
         */
        msgCount: number;
        /**
         * Push content format. Valid values: 1. `JSON`; 2. `SIMPLIFIED`, i.e., the raw format. If `Protocol` is `queue`, this value must be `SIMPLIFIED`. If `Protocol` is `http`, both options are acceptable, and the default value is `JSON`.
         */
        notifyContentFormat: string;
        /**
         * CMQ push server retry policy in case an error occurs while pushing a message to `Endpoint`. Valid values: 1. `BACKOFF_RETRY`: backoff retry, which is to retry at a fixed interval, discard the message after a certain number of retries, and continue to push the next message; 2. `EXPONENTIAL_DECAY_RETRY`: exponential decay retry, which is to retry at an exponentially increasing interval, such as 1s, 2s, 4s, 8s, and so on. As a message can be retained in a topic for one day, failed messages will be discarded at most after one day of retry. Default value: `EXPONENTIAL_DECAY_RETRY`.
         */
        notifyStrategy: string;
        /**
         * Subscription protocol. Currently, two protocols are supported: HTTP and queue. To use the HTTP protocol, you need to build your own web server to receive messages. With the queue protocol, messages are automatically pushed to a CMQ queue and you can pull them concurrently.
         */
        protocol: string;
        /**
         * Subscription ID, which will be used during monitoring data pull.
         */
        subscriptionId: string;
        /**
         * Fuzzy search by SubscriptionName.
         */
        subscriptionName: string;
        /**
         * Subscription owner APPID.
         */
        topicOwner: number;
    }

    export interface GetTopicFilter {
        /**
         * Filter parameter name.
         */
        name?: string;
        /**
         * Value.
         */
        values?: string[];
    }

    export interface GetTopicTopicList {
        /**
         * Valid values: `0` (Pulsar), `1` (RocketMQ).
         */
        brokerType: number;
        /**
         * Topic creation time. A Unix timestamp accurate down to the millisecond will be returned.
         */
        createTime: number;
        /**
         * Creator `Uin`. The `resource` field for CAM authentication is composed of this field.
         */
        createUin: number;
        /**
         * Filtering policy selected when a subscription is created: If `filterType` is 1, `FilterTag` will be used for filtering. If `filterType` is 2, `BindingKey` will be used for filtering.
         */
        filterType: number;
        /**
         * Time when the topic attribute is last modified. A Unix timestamp accurate down to the millisecond will be returned.
         */
        lastModifyTime: number;
        /**
         * Maximum message size, which ranges from 1,024 to 1,048,576 bytes (i.e., 1-1,024 KB). The default value is 65,536.
         */
        maxMsgSize: number;
        /**
         * Number of current messages in the topic (number of retained messages).
         */
        msgCount: number;
        /**
         * Maximum lifecycle of message in topic. After the period specified by this parameter has elapsed since a message is sent to the topic, the message will be deleted no matter whether it has been successfully pushed to the user. This parameter is measured in seconds and defaulted to one day (86,400 seconds), which cannot be modified.
         */
        msgRetentionSeconds: number;
        /**
         * Namespace name.
         */
        namespaceName: string;
        /**
         * Number of messages published per second.
         */
        qps: number;
        /**
         * Cluster status. `0`: creating; `1`: normal; `2`: terminating; `3`: deleted; `4`: isolated; `5`: creation failed; `6`: deletion failed.
         */
        status: number;
        /**
         * Associated tag.
         */
        tags: outputs.Tcmq.GetTopicTopicListTag[];
        /**
         * Tenant ID.
         */
        tenantId: string;
        /**
         * Topic ID.
         */
        topicId: string;
        /**
         * Fuzzy search by TopicName.
         */
        topicName: string;
        /**
         * Message trace. true: enabled; false: not enabled.
         */
        trace: boolean;
    }

    export interface GetTopicTopicListTag {
        /**
         * Value of the tag key.
         */
        tagKey: string;
        /**
         * Value of the tag value.
         */
        tagValue: string;
    }

}

export namespace Tcr {
    export interface GetImagesImageInfoList {
        /**
         * specify image digest for lookup.
         */
        digest: string;
        /**
         * image version name, default is fuzzy match.
         */
        imageVersion: string;
        /**
         * product type,note: this field may return null, indicating that no valid value can be obtained.
         */
        kind: string;
        /**
         * kms signature information,note: this field may return null, indicating that no valid value can be obtained.
         */
        kmsSignature: string;
        /**
         * image size (unit: byte).
         */
        size: number;
        /**
         * update time.
         */
        updateTime: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * ID of the TCR instance.
         */
        id: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Internal address for access of the TCR instance.
         */
        internalEndPoint: string;
        /**
         * Name of the TCR instance to query.
         */
        name: string;
        /**
         * Public address for access of the TCR instance.
         */
        publicDomain: string;
        /**
         * Status of the TCR instance.
         */
        status: string;
        /**
         * Tags of the TCR instance.
         */
        tags: {[key: string]: any};
    }

    export interface GetNamespacesNamespaceList {
        /**
         * ID of TCR namespace.
         */
        id: number;
        /**
         * Indicate that the namespace is public or not.
         */
        isPublic: boolean;
        /**
         * Name of TCR namespace.
         */
        name: string;
    }

    export interface GetReplicationInstanceCreateTasksTaskDetail {
        /**
         * task start name.
         */
        createdTime: string;
        /**
         * task end time. Note: This field may return null, indicating that no valid value can be obtained.
         */
        finishedTime: string;
        /**
         * Task status information. Note: This field may return null, indicating that no valid value can be obtained.
         */
        taskMessage: string;
        /**
         * task name.
         */
        taskName: string;
        /**
         * task status.
         */
        taskStatus: string;
        /**
         * task UUID.
         */
        taskUuid: string;
    }

    export interface GetReplicationInstanceSyncStatusReplicationLog {
        /**
         * destination resource. Note: This field may return null, indicating that no valid value can be obtained.
         */
        destination: string;
        /**
         * end time. Note: This field may return null, indicating that no valid value can be obtained.
         */
        endTime: string;
        /**
         * resource type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        resourceType: string;
        /**
         * Source image. Note: This field may return null, indicating that no valid value can be obtained.
         */
        source: string;
        /**
         * start time. Note: This field may return null, indicating that no valid value can be obtained.
         */
        startTime: string;
        /**
         * sync status. Note: This field may return null, indicating that no valid value can be obtained.
         */
        status: string;
    }

    export interface GetRepositoriesRepositoryList {
        /**
         * Brief description of the repository.
         */
        briefDesc: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Description of the repository.
         */
        description: string;
        /**
         * Indicate that the repository is public or not.
         */
        isPublic: boolean;
        /**
         * Name of repository.
         */
        name: string;
        /**
         * Name of the namespace that the repository belongs to.
         */
        namespaceName: string;
        /**
         * Last update time.
         */
        updateTime: string;
        /**
         * URL of the repository.
         */
        url: string;
    }

    export interface GetTagRetentionExecutionTasksRetentionTaskList {
        /**
         * task end time.
         */
        endTime: string;
        /**
         * execution id.
         */
        executionId: number;
        /**
         * repository name.
         */
        repository: string;
        /**
         * Total number of retained tags.
         */
        retained: number;
        /**
         * task start time.
         */
        startTime: string;
        /**
         * the execution status of the task: Failed, Succeed, Stopped, InProgress.
         */
        status: string;
        /**
         * task id.
         */
        taskId: number;
        /**
         * Total number of tags.
         */
        total: number;
    }

    export interface GetTagRetentionExecutionsRetentionExecutionList {
        /**
         * execution end time.
         */
        endTime: string;
        /**
         * execution id.
         */
        executionId: number;
        /**
         * retention id.
         */
        retentionId: number;
        /**
         * execution start time.
         */
        startTime: string;
        /**
         * execution status: Failed, Succeed, Stopped, InProgress.
         */
        status: string;
    }

    export interface GetTokensTokenList {
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Description of the token.
         */
        description: string;
        /**
         * Indicate that the token is enabled or not.
         */
        enable: boolean;
        /**
         * ID of the TCR token to query.
         */
        tokenId: string;
    }

    export interface GetVpcAttachmentsVpcAttachmentList {
        /**
         * IP address of this VPC access.
         */
        accessIp: string;
        /**
         * Whether to enable public domain dns.
         */
        enablePublicDomainDns: boolean;
        /**
         * Whether to enable vpc domain dns.
         */
        enableVpcDomainDns: boolean;
        /**
         * Status of this VPC access.
         */
        status: string;
        /**
         * ID of subnet to query.
         */
        subnetId: string;
        /**
         * ID of VPC to query.
         */
        vpcId: string;
    }

    export interface GetWebhookTriggerLogsLog {
        /**
         * creation time.
         */
        creationTime: string;
        /**
         * webhook trigger detail.
         */
        detail: string;
        /**
         * event type.
         */
        eventType: string;
        /**
         * log id.
         */
        id: number;
        /**
         * notification type.
         */
        notifyType: string;
        /**
         * status.
         */
        status: string;
        /**
         * trigger id.
         */
        triggerId: number;
        /**
         * update time.
         */
        updateTime: string;
    }

    export interface ImmutableTagRuleRule {
        /**
         * disable rule.
         */
        disabled?: boolean;
        /**
         * ID of the resource.
         */
        id: number;
        /**
         * namespace name.
         */
        nsName: string;
        /**
         * repository decoration type:repoMatches or repoExcludes.
         */
        repositoryDecoration: string;
        /**
         * repository matching rules.
         */
        repositoryPattern: string;
        /**
         * tag decoration type: matches or excludes.
         */
        tagDecoration: string;
        /**
         * tag matching rules.
         */
        tagPattern: string;
    }

    export interface InstanceReplication {
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * Replication region ID, check the example at the top of page to find out id of region.
         */
        regionId?: number;
        /**
         * Replication region name.
         */
        regionName?: string;
        /**
         * Specify whether to sync TCR cloud tags to COS Bucket. NOTE: You have to specify when adding, modifying will be ignored for now.
         */
        synTag?: boolean;
    }

    export interface InstanceSecurityPolicy {
        /**
         * The public network IP address of the access source.
         */
        cidrBlock?: string;
        /**
         * Remarks of policy.
         */
        description?: string;
        /**
         * Index of policy.
         */
        index: number;
        /**
         * Version of policy.
         */
        version: string;
    }

    export interface ManageReplicationOperationPeerReplicationOption {
        /**
         * whether to enable cross-master account instance synchronization.
         */
        enablePeerReplication: boolean;
        /**
         * access permanent token of the instance to be synchronized.
         */
        peerRegistryToken: string;
        /**
         * uin of the instance to be synchronized.
         */
        peerRegistryUin: string;
    }

    export interface ManageReplicationOperationRule {
        /**
         * target namespace.
         */
        destNamespace: string;
        /**
         * sync filters.
         */
        filters: outputs.Tcr.ManageReplicationOperationRuleFilter[];
        /**
         * synchronization rule names.
         */
        name: string;
        /**
         * whether to cover.
         */
        override: boolean;
    }

    export interface ManageReplicationOperationRuleFilter {
        /**
         * type (name, tag, and resource).
         */
        type: string;
        /**
         * empty by default.
         */
        value?: string;
    }

    export interface NamespaceCveWhitelistItem {
        /**
         * Vulnerability Whitelist ID.
         */
        cveId?: string;
    }

    export interface ServiceAccountPermission {
        /**
         * Actions, currently support: `tcr:PushRepository`, `tcr:PullRepository`, `tcr:CreateRepository`, `tcr:CreateHelmChart`, `tcr:DescribeHelmCharts`. Note: This field may return null, indicating that no valid value can be obtained.
         */
        actions: string[];
        /**
         * resource path, currently only supports Namespace. Note: This field may return null, indicating that no valid value can be obtained.
         */
        resource: string;
    }

    export interface TagRetentionRuleRetentionRule {
        /**
         * The supported policies are latestPushedK (retain the latest `k` pushed versions) and nDaysSinceLastPush (retain pushed versions within the last `n` days).
         */
        key: string;
        /**
         * corresponding values for rule settings.
         */
        value: number;
    }

    export interface WebhookTriggerTrigger {
        /**
         * trigger rule.
         */
        condition: string;
        /**
         * trigger description.
         */
        description?: string;
        /**
         * enable trigger.
         */
        enabled: boolean;
        /**
         * trigger action.
         */
        eventTypes: string[];
        /**
         * ID of the resource.
         */
        id: number;
        /**
         * trigger name.
         */
        name: string;
        /**
         * the namespace Id to which the trigger belongs.
         */
        namespaceId: number;
        /**
         * trigger target.
         */
        targets: outputs.Tcr.WebhookTriggerTriggerTarget[];
    }

    export interface WebhookTriggerTriggerTarget {
        /**
         * target address.
         */
        address: string;
        /**
         * custom Headers.
         */
        headers?: outputs.Tcr.WebhookTriggerTriggerTargetHeader[];
    }

    export interface WebhookTriggerTriggerTargetHeader {
        /**
         * Header Key.
         */
        key: string;
        /**
         * Header Values.
         */
        values: string[];
    }

}

export namespace Tdcpg {
    export interface GetClustersList {
        /**
         * auto renew flag.
         */
        autoRenewFlag: number;
        /**
         * cluster id.
         */
        clusterId: string;
        /**
         * cluster name.
         */
        clusterName: string;
        /**
         * create time.
         */
        createTime: string;
        /**
         * db charset.
         */
        dbCharset: string;
        /**
         * db kernel version.
         */
        dbKernelVersion: string;
        /**
         * db major version.
         */
        dbMajorVersion: string;
        /**
         * db version.
         */
        dbVersion: string;
        /**
         * endpoint set.
         */
        endpointSets: outputs.Tdcpg.GetClustersListEndpointSet[];
        /**
         * instance count.
         */
        instanceCount: number;
        /**
         * pay mode.
         */
        payMode: string;
        /**
         * pay period expired time.
         */
        payPeriodEndTime: string;
        /**
         * project id, default to 0, means default project.
         */
        projectId: number;
        /**
         * region.
         */
        region: string;
        /**
         * cluster status.
         */
        status: string;
        /**
         * status description.
         */
        statusDesc: string;
        /**
         * storage limit, unit is GB.
         */
        storageLimit: number;
        /**
         * storage pay mode, optional value is PREPAID or POSTPAID_BY_HOUR.
         */
        storagePayMode: string;
        /**
         * storage used, unit is GB.
         */
        storageUsed: number;
        /**
         * zone.
         */
        zone: string;
    }

    export interface GetClustersListEndpointSet {
        /**
         * cluster id.
         */
        clusterId: string;
        /**
         * endpoint id.
         */
        endpointId: string;
        /**
         * endpoint name.
         */
        endpointName: string;
        /**
         * endpoint type.
         */
        endpointType: string;
        /**
         * private ip.
         */
        privateIp: string;
        /**
         * private port.
         */
        privatePort: number;
        /**
         * subnet id.
         */
        subnetId: string;
        /**
         * vpc id.
         */
        vpcId: string;
        /**
         * wan domain.
         */
        wanDomain: string;
        /**
         * wan ip.
         */
        wanIp: string;
        /**
         * wan port.
         */
        wanPort: number;
    }

    export interface GetInstancesList {
        /**
         * instance id.
         */
        clusterId: string;
        /**
         * cpu cores.
         */
        cpu: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * db kernel version.
         */
        dbKernelVersion: string;
        /**
         * db major version.
         */
        dbMajorVersion: string;
        /**
         * db version.
         */
        dbVersion: string;
        /**
         * endpoint id.
         */
        endpointId: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * instance name.
         */
        instanceName: string;
        /**
         * instance type.
         */
        instanceType: string;
        /**
         * memory size, unit is GiB.
         */
        memory: number;
        /**
         * pay mode.
         */
        payMode: string;
        /**
         * pay period expired time.
         */
        payPeriodEndTime: string;
        /**
         * region.
         */
        region: string;
        /**
         * instance status.
         */
        status: string;
        /**
         * status description.
         */
        statusDesc: string;
        /**
         * zone.
         */
        zone: string;
    }

}

export namespace Tdmq {
    export interface GetProInstanceDetailClusterInfo {
        /**
         * Can the route be modifiedNote: This field may return null, indicating that no valid value can be obtained.
         */
        canEditRoute: boolean;
        /**
         * Cluster Id.
         */
        clusterId: string;
        /**
         * Cluster name.
         */
        clusterName: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Maximum storage capacity, unit: MB.
         */
        maxStorage: number;
        /**
         * Node distributionNote: This field may return null, indicating that no valid value can be obtained.
         */
        nodeDistributions: outputs.Tdmq.GetProInstanceDetailClusterInfoNodeDistribution[];
        /**
         * Descriptive information.
         */
        remark: string;
        /**
         * Cluster status, 0: creating, 1: normal, 2: isolated.
         */
        status: number;
        /**
         * cluster version.
         */
        version: string;
    }

    export interface GetProInstanceDetailClusterInfoNodeDistribution {
        /**
         * Number of nodes.
         */
        nodeCount: number;
        /**
         * Availability zone ID.
         */
        zoneId: string;
        /**
         * Availability zone.
         */
        zoneName: string;
    }

    export interface GetProInstanceDetailClusterSpecInfo {
        /**
         * peak bandwidth. Unit: mbps.
         */
        maxBandWidth: number;
        /**
         * Maximum number of namespaces.
         */
        maxNamespaces: number;
        /**
         * Maximum number of topic partitions.
         */
        maxTopics: number;
        /**
         * peak tps.
         */
        maxTps: number;
        /**
         * Elastic TPS outside specificationNote: This field may return null, indicating that no valid value can be obtained.
         */
        scalableTps: number;
        /**
         * Cluster specification name.
         */
        specName: string;
    }

    export interface GetProInstanceDetailNetworkAccessPointInfo {
        /**
         * access address.
         */
        endpoint: string;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * Access point type: 0: support network access point 1: VPC access point 2: public network access point.
         */
        routeType: number;
        /**
         * Subnet id, support network and public network access point, this field is emptyNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * The id of the vpc, the supporting network and the access point of the public network, this field is emptyNote: This field may return null, indicating that no valid value can be obtained.
         */
        vpcId: string;
    }

    export interface GetProInstancesFilter {
        /**
         * The name of the filter parameter.
         */
        name?: string;
        /**
         * value.
         */
        values?: string[];
    }

    export interface GetProInstancesInstance {
        /**
         * Automatic renewal mark, 0 indicates the default state (the user has not set it, that is, the initial state is manual renewal), 1 indicates automatic renewal, 2 indicates that the automatic renewal is not specified (user setting).
         */
        autoRenewFlag: number;
        /**
         * Instance configuration specification name.
         */
        configDisplay: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Instance expiration time, in milliseconds.
         */
        expireTime: number;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Instance version.
         */
        instanceVersion: string;
        /**
         * Peak bandwidth. Unit: mbps.
         */
        maxBandWidth: number;
        /**
         * Storage capacity, in GB.
         */
        maxStorage: number;
        /**
         * Peak TPS.
         */
        maxTps: number;
        /**
         * 0-postpaid, 1-prepaid.
         */
        payMode: number;
        /**
         * RemarksNote: This field may return null, indicating that no valid value can be obtained.
         */
        remark: string;
        /**
         * Elastic TPS outside specificationNote: This field may return null, indicating that no valid value can be obtained.
         */
        scalableTps: number;
        /**
         * Instance Configuration ID.
         */
        specName: string;
        /**
         * Instance status, 0-creating, 1-normal, 2-isolating, 3-destroyed, 4-abnormal, 5-delivery failure, 6-allocation change, 7-allocation failure.
         */
        status: number;
        /**
         * Subnet idNote: This field may return null, indicating that no valid value can be obtained.
         */
        subnetId: string;
        /**
         * Tag list.
         */
        tags: outputs.Tdmq.GetProInstancesInstanceTag[];
        /**
         * Id of the VPCNote: This field may return null, indicating that no valid value can be obtained.
         */
        vpcId: string;
    }

    export interface GetProInstancesInstanceTag {
        /**
         * Tag key.
         */
        tagKey: string;
        /**
         * Tag value.
         */
        tagValue: string;
    }

    export interface GetPublishersFilter {
        /**
         * The name of the filter parameter.
         */
        name?: string;
        /**
         * value.
         */
        values?: string[];
    }

    export interface GetPublishersPublisher {
        /**
         * producer addressNote: This field may return null, indicating that no valid value can be obtained.
         */
        address: string;
        /**
         * Average message size (bytes)Note: This field may return null, indicating that no valid value can be obtained.
         */
        averageMsgSize: number;
        /**
         * client versionNote: This field may return null, indicating that no valid value can be obtained.
         */
        clientVersion: string;
        /**
         * connection timeNote: This field may return null, indicating that no valid value can be obtained.
         */
        connectedSince: string;
        /**
         * Message production rate (articles/second)Note: This field may return null, indicating that no valid value can be obtained.
         */
        msgRateIn: number;
        /**
         * Message production throughput rate (bytes/second)Note: This field may return null, indicating that no valid value can be obtained.
         */
        msgThroughputIn: number;
        /**
         * The topic partition number of the producer connectionNote: This field may return null, indicating that no valid value can be obtained.
         */
        partition: number;
        /**
         * producer idNote: This field may return null, indicating that no valid value can be obtained.
         */
        producerId: number;
        /**
         * producer nameNote: This field may return null, indicating that no valid value can be obtained.
         */
        producerName: string;
    }

    export interface GetPublishersSort {
        /**
         * sorter.
         */
        name: string;
        /**
         * Ascending ASC, descending DESC.
         */
        order: string;
    }

    export interface GetRabbitmqNodeListFilter {
        /**
         * The name of the filter parameter.
         */
        name?: string;
        /**
         * value.
         */
        values?: string[];
    }

    export interface GetRabbitmqNodeListNodeList {
        /**
         * CPU usageNote: This field may return null, indicating that no valid value can be obtained.
         */
        cpuUsage: string;
        /**
         * disk usageNote: This field may return null, indicating that no valid value can be obtained.
         */
        diskUsage: string;
        /**
         * Memory usage, in MBNote: This field may return null, indicating that no valid value can be obtained.
         */
        memory: number;
        /**
         * node nameNote: This field may return null, indicating that no valid value can be obtained.
         */
        nodeName: string;
        /**
         * node statusNote: This field may return null, indicating that no valid value can be obtained.
         */
        nodeStatus: string;
        /**
         * Number of Erlang processes for RabbitmqNote: This field may return null, indicating that no valid value can be obtained.
         */
        processNumber: number;
    }

    export interface GetRabbitmqVipInstanceFilter {
        /**
         * The name of the filter parameter.
         */
        name?: string;
        /**
         * value.
         */
        values?: string[];
    }

    export interface GetRabbitmqVipInstanceInstance {
        /**
         * Automatic renewal mark, 0 indicates the default state (the user has not set it, that is, the initial state is manual renewal), 1 indicates automatic renewal, 2 indicates that the automatic renewal is not specified (user setting).
         */
        autoRenewFlag: number;
        /**
         * Instance configuration specification name.
         */
        configDisplay: string;
        /**
         * The cluster is abnormal.Note: This field may return null, indicating that no valid value can be obtained.
         */
        exceptionInformation: string;
        /**
         * Instance expiration time, in milliseconds.
         */
        expireTime: number;
        /**
         * instance id.
         */
        instanceId: string;
        /**
         * instance name.
         */
        instanceName: string;
        /**
         * instance versionNote: This field may return null, indicating that no valid value can be obtained.
         */
        instanceVersion: string;
        /**
         * Peak bandwidth, in Mbps.
         */
        maxBandWidth: number;
        /**
         * Storage capacity, in GB.
         */
        maxStorage: number;
        /**
         * Peak TPS.
         */
        maxTps: number;
        /**
         * Number of nodes.
         */
        nodeCount: number;
        /**
         * 0-postpaid, 1-prepaid.
         */
        payMode: number;
        /**
         * RemarksNote: This field may return null, indicating that no valid value can be obtained.
         */
        remark: string;
        /**
         * Instance Configuration ID.
         */
        specName: string;
        /**
         * Instance status, 0 means creating, 1 means normal, 2 means isolating, 3 means destroyed, 4 - abnormal, 5 - delivery failed.
         */
        status: number;
    }

    export interface GetRocketmqClusterClusterList {
        /**
         * Cluster configuration information.
         */
        configs: outputs.Tdmq.GetRocketmqClusterClusterListConfig[];
        /**
         * Basic cluster information.
         */
        infos: outputs.Tdmq.GetRocketmqClusterClusterListInfo[];
        /**
         * Cluster status. `0`: Creating; `1`: Normal; `2`: Terminating; `3`: Deleted; `4`: Isolated; `5`: Creation failed; `6`: Deletion failed.
         */
        status: number;
    }

    export interface GetRocketmqClusterClusterListConfig {
        /**
         * Maximum number of groups.
         */
        maxGroupNum: number;
        /**
         * Maximum message delay in millisecond.
         */
        maxLatencyTime: number;
        /**
         * Maximum number of namespaces.
         */
        maxNamespaceNum: number;
        /**
         * Maximum message retention period in milliseconds.
         */
        maxRetentionTime: number;
        /**
         * Maximum number of topics.
         */
        maxTopicNum: number;
        /**
         * Maximum TPS per namespace.
         */
        maxTpsPerNamespace: number;
        /**
         * Number of used groups.
         */
        usedGroupNum: number;
        /**
         * Number of used namespaces.
         */
        usedNamespaceNum: number;
        /**
         * Number of used topics.
         */
        usedTopicNum: number;
    }

    export interface GetRocketmqClusterClusterListInfo {
        /**
         * Cluster ID.
         */
        clusterId: string;
        /**
         * Cluster name.
         */
        clusterName: string;
        /**
         * Creation time in milliseconds.
         */
        createTime: number;
        /**
         * Whether it is an exclusive instance.
         */
        isVip: boolean;
        /**
         * Public network access address.
         */
        publicEndPoint: string;
        /**
         * Region information.
         */
        region: string;
        /**
         * Cluster description (up to 128 characters).
         */
        remark: string;
        /**
         * Rocketmq cluster identification.
         */
        rocketmqFlag: boolean;
        /**
         * Whether the namespace access point is supported.
         */
        supportNamespaceEndpoint: boolean;
        /**
         * VPC access address.
         */
        vpcEndPoint: string;
        /**
         * Vpc list.
         */
        vpcs: outputs.Tdmq.GetRocketmqClusterClusterListInfoVpc[];
    }

    export interface GetRocketmqClusterClusterListInfoVpc {
        /**
         * Subnet ID.
         */
        subnetId: string;
        /**
         * Vpc ID.
         */
        vpcId: string;
    }

    export interface GetRocketmqGroupGroup {
        /**
         * Whether to enable broadcast consumption.
         */
        broadcastEnable: boolean;
        /**
         * Client protocol.
         */
        clientProtocol: string;
        /**
         * The number of online consumers.
         */
        consumerNum: number;
        /**
         * Consumer type. Enumerated values: ACTIVELY or PASSIVELY.
         */
        consumerType: string;
        /**
         * `0`: Cluster consumption mode; `1`: Broadcast consumption mode; `-1`: Unknown.
         */
        consumptionMode: number;
        /**
         * Creation time in milliseconds.
         */
        createTime: number;
        /**
         * Consumer group name.
         */
        name: string;
        /**
         * Whether to enable consumption.
         */
        readEnable: boolean;
        /**
         * Remarks (up to 128 characters).
         */
        remark: string;
        /**
         * The number of partitions in a retry topic.
         */
        retryPartitionNum: number;
        /**
         * The total number of heaped messages.
         */
        totalAccumulative: number;
        /**
         * Consumption TPS.
         */
        tps: number;
        /**
         * Modification time in milliseconds.
         */
        updateTime: number;
    }

    export interface GetRocketmqMessagesMessageTrack {
        /**
         * consumption status.
         */
        consumeStatus: string;
        /**
         * Exception informationNote: This field may return null, indicating that no valid value can be obtained.
         */
        exceptionDesc: string;
        /**
         * consumer group.
         */
        group: string;
        /**
         * message track type.
         */
        trackType: string;
    }

    export interface GetRocketmqNamespaceNamespace {
        /**
         * Namespace name, which can contain 3-64 letters, digits, hyphens, and underscores.
         */
        namespaceId: string;
        /**
         * Public network access point address.
         */
        publicEndpoint: string;
        /**
         * Remarks (up to 128 characters).
         */
        remark: string;
        /**
         * Retention time of persisted messages in milliseconds.
         */
        retentionTime: number;
        /**
         * Retention time of unconsumed messages in milliseconds. Value range: 60 seconds-15 days.
         */
        ttl: number;
        /**
         * VPC access point address.
         */
        vpcEndpoint: string;
    }

    export interface GetRocketmqRoleRoleSet {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Remarks.
         */
        remark: string;
        /**
         * Fuzzy query by role name.
         */
        roleName: string;
        /**
         * Value of the role token.
         */
        token: string;
        /**
         * Update time.
         */
        updateTime: string;
    }

    export interface GetRocketmqTopicTopic {
        /**
         * Creation time in milliseconds.
         */
        createTime: number;
        /**
         * Topic name.
         */
        name: string;
        /**
         * The number of read/write partitions.
         */
        partitionNum: number;
        /**
         * Topic name.
         */
        remark: string;
        /**
         * Update time in milliseconds.
         */
        updateTime: number;
    }

    export interface GetVipInstanceClusterInfo {
        /**
         * Cluster ID.
         */
        clusterId: string;
        /**
         * Cluster Name.
         */
        clusterName: string;
        /**
         * Creation time, in milliseconds.
         */
        createTime: number;
        /**
         * HTTP protocol public network access addressNote: This field may return null, indicating that no valid value can be obtained.
         */
        httpPublicEndpoint: string;
        /**
         * HTTP protocol VPC access addressNote: This field may return null, indicating that no valid value can be obtained.
         */
        httpVpcEndpoint: string;
        /**
         * Whether it is a dedicated instanceNote: This field may return null, indicating that no valid value can be obtained.
         */
        isVip: boolean;
        /**
         * Overdue suspension time, in millisecondsNote: This field may return null, indicating that no valid value can be obtained.
         */
        isolateTime: number;
        /**
         * Public network access address.
         */
        publicEndPoint: string;
        /**
         * Region.
         */
        region: string;
        /**
         * Cluster description informationNote: This field may return null, indicating that no valid value can be obtained.
         */
        remark: string;
        /**
         * Rocketmq cluster identificationNote: This field may return null, indicating that no valid value can be obtained.
         */
        rocketMqFlag: boolean;
        /**
         * Billing status, 1 means normal, 2 means stopped, 3 means destroyedNote: This field may return null, indicating that no valid value can be obtained.
         */
        status: number;
        /**
         * Whether namespace access points are supportedNote: This field may return null, indicating that no valid value can be obtained.
         */
        supportNamespaceEndpoint: boolean;
        /**
         * VPC access address.
         */
        vpcEndPoint: string;
        /**
         * VPC informationNote: This field may return null, indicating that no valid value can be obtained.
         */
        vpcs: outputs.Tdmq.GetVipInstanceClusterInfoVpc[];
    }

    export interface GetVipInstanceClusterInfoVpc {
        /**
         * Subnet Id.
         */
        subnetId: string;
        /**
         * VPC ID.
         */
        vpcId: string;
    }

    export interface GetVipInstanceInstanceConfig {
        /**
         * Cluster type.
         */
        configDisplay: string;
        /**
         * Maximum number of groups.
         */
        maxGroupNum: number;
        /**
         * Maximum number of namespaces.
         */
        maxNamespaceNum: number;
        /**
         * Maximum number of queues per topicNote: This field may return null, indicating that no valid value can be obtained.
         */
        maxQueuesPerTopic: number;
        /**
         * Maximum number of topics.
         */
        maxTopicNum: number;
        /**
         * Single namespace TPS upper limit.
         */
        maxTpsPerNamespace: number;
        /**
         * Number of cluster nodes.
         */
        nodeCount: number;
        /**
         * Node distribution.
         */
        nodeDistributions: outputs.Tdmq.GetVipInstanceInstanceConfigNodeDistribution[];
        /**
         * Topic distribution.
         */
        topicDistributions: outputs.Tdmq.GetVipInstanceInstanceConfigTopicDistribution[];
        /**
         * Number of used groups.
         */
        usedGroupNum: number;
        /**
         * Number of used namespaces.
         */
        usedNamespaceNum: number;
        /**
         * The number of topics used.
         */
        usedTopicNum: number;
    }

    export interface GetVipInstanceInstanceConfigNodeDistribution {
        /**
         * Number of nodes.
         */
        nodeCount: number;
        /**
         * Availability zone id.
         */
        zoneId: string;
        /**
         * Availability zone.
         */
        zoneName: string;
    }

    export interface GetVipInstanceInstanceConfigTopicDistribution {
        /**
         * Number of topics.
         */
        count: number;
        /**
         * Topic type.
         */
        topicType: string;
    }

    export interface NamespaceRetentionPolicy {
        /**
         * the size of message to retain.
         */
        sizeInMb: number;
        /**
         * the time of message to retain.
         */
        timeInMinutes: number;
    }

    export interface ProfessionalClusterVpc {
        /**
         * Id of Subnet.
         */
        subnetId: string;
        /**
         * Id of VPC.
         */
        vpcId: string;
    }

    export interface RocketmqClusterVpc {
        /**
         * Subnet ID.
         */
        subnetId: string;
        /**
         * Vpc ID.
         */
        vpcId: string;
    }

    export interface RocketmqVipInstanceIpRule {
        /**
         * Whether to allow or deny.
         */
        allow: boolean;
        /**
         * IP address block information.
         */
        ipRule: string;
        /**
         * Remark.
         */
        remark: string;
    }

    export interface RocketmqVipInstanceVpcInfo {
        /**
         * Subnet ID.
         */
        subnetId: string;
        /**
         * VPC ID.
         */
        vpcId: string;
    }

}

export namespace Tem {
    export interface AppConfigConfigData {
        /**
         * key.
         */
        key: string;
        /**
         * value.
         */
        value: string;
    }

    export interface ApplicationServiceService {
        /**
         * ip address of application service.
         */
        ip: string;
        /**
         * port mapping item list.
         */
        portMappingItemLists?: outputs.Tem.ApplicationServiceServicePortMappingItemList[];
        /**
         * application service name.
         */
        serviceName?: string;
        /**
         * ID of subnet instance, required when type is `VPC`.
         */
        subnetId?: string;
        /**
         * application service type: EXTERNAL | VPC | CLUSTER.
         */
        type?: string;
        /**
         * ID of vpc instance, required when type is `VPC`.
         */
        vpcId?: string;
    }

    export interface ApplicationServiceServicePortMappingItemList {
        /**
         * container port.
         */
        port?: number;
        /**
         * UDP or TCP.
         */
        protocol?: string;
        /**
         * application listen port.
         */
        targetPort?: number;
    }

    export interface GatewayIngress {
        /**
         * ip version, support IPV4.
         */
        addressIpVersion: string;
        /**
         * related CLB ID, support binding existing clb, does not support modification.
         */
        clbId: string;
        /**
         * creation time.
         */
        createTime: string;
        /**
         * environment ID.
         */
        environmentId: string;
        /**
         * gateway name.
         */
        ingressName: string;
        /**
         * mixing HTTP and HTTPS.
         */
        mixed: boolean;
        /**
         * redirect mode, support AUTO and NONE.
         */
        rewriteType?: string;
        /**
         * proxy rules.
         */
        rules: outputs.Tem.GatewayIngressRule[];
        /**
         * ingress TLS configurations.
         */
        tls?: outputs.Tem.GatewayIngressTl[];
        /**
         * gateway vip.
         */
        vip: string;
    }

    export interface GatewayIngressRule {
        /**
         * host name.
         */
        host?: string;
        /**
         * rule payload.
         */
        http: outputs.Tem.GatewayIngressRuleHttp;
        /**
         * protocol.
         */
        protocol?: string;
    }

    export interface GatewayIngressRuleHttp {
        /**
         * path payload.
         */
        paths: outputs.Tem.GatewayIngressRuleHttpPath[];
    }

    export interface GatewayIngressRuleHttpPath {
        /**
         * backend payload.
         */
        backend: outputs.Tem.GatewayIngressRuleHttpPathBackend;
        /**
         * path.
         */
        path: string;
    }

    export interface GatewayIngressRuleHttpPathBackend {
        /**
         * backend name.
         */
        serviceName: string;
        /**
         * backend port.
         */
        servicePort: number;
    }

    export interface GatewayIngressTl {
        /**
         * certificate ID.
         */
        certificateId: string;
        /**
         * host names.
         */
        hosts: string[];
        /**
         * secret name, if you use a certificate, you don't need to fill in this field.
         */
        secretName: string;
    }

    export interface ScaleRuleAutoscaler {
        /**
         * name.
         */
        autoscalerName: string;
        /**
         * scaler based on cron configuration.
         */
        cronHorizontalAutoscalers?: outputs.Tem.ScaleRuleAutoscalerCronHorizontalAutoscaler[];
        /**
         * description.
         */
        description?: string;
        /**
         * enable AutoScaler.
         */
        enabled: boolean;
        /**
         * scaler based on metrics.
         */
        horizontalAutoscalers?: outputs.Tem.ScaleRuleAutoscalerHorizontalAutoscaler[];
        /**
         * maximal replica number.
         */
        maxReplicas: number;
        /**
         * minimal replica number.
         */
        minReplicas: number;
    }

    export interface ScaleRuleAutoscalerCronHorizontalAutoscaler {
        /**
         * enable scaler.
         */
        enabled: boolean;
        /**
         * name.
         */
        name: string;
        /**
         * period.
         */
        period: string;
        /**
         * priority.
         */
        priority: number;
        /**
         * schedule payload.
         */
        schedules: outputs.Tem.ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule[];
    }

    export interface ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule {
        /**
         * start time.
         */
        startAt: string;
        /**
         * target replica number.
         */
        targetReplicas: number;
    }

    export interface ScaleRuleAutoscalerHorizontalAutoscaler {
        /**
         * enable scaler.
         */
        enabled: boolean;
        /**
         * maximal replica number.
         */
        maxReplicas: number;
        /**
         * metric name.
         */
        metrics: string;
        /**
         * minimal replica number.
         */
        minReplicas: number;
        /**
         * metric threshold.
         */
        threshold: number;
    }

    export interface WorkloadDeployStrategyConf {
        /**
         * interval between batches.
         */
        batchInterval?: number;
        /**
         * beta batch number.
         */
        betaBatchNum?: number;
        /**
         * strategy type, 0 means auto, 1 means manual, 2 means manual with beta batch.
         */
        deployStrategyType: number;
        /**
         * force update.
         */
        force?: boolean;
        /**
         * minimal available instances duration deployment.
         */
        minAvailable?: number;
        /**
         * total batch number.
         */
        totalBatchCount: number;
    }

    export interface WorkloadEnvConf {
        /**
         * referenced config name when type=referenced.
         */
        config?: string;
        /**
         * env key.
         */
        key: string;
        /**
         * referenced secret name when type=referenced.
         */
        secret?: string;
        /**
         * env type, support default, referenced.
         */
        type?: string;
        /**
         * env value.
         */
        value: string;
    }

    export interface WorkloadLiveness {
        /**
         * script.
         */
        exec?: string;
        /**
         * initial delay seconds for liveness check.
         */
        initialDelaySeconds?: number;
        /**
         * path.
         */
        path?: string;
        /**
         * period seconds for liveness check.
         */
        periodSeconds?: number;
        /**
         * liveness check port.
         */
        port?: number;
        /**
         * protocol.
         */
        protocol?: string;
        /**
         * timeout seconds for liveness check.
         */
        timeoutSeconds?: number;
        /**
         * check type, support HttpGet, TcpSocket and Exec.
         */
        type: string;
    }

    export interface WorkloadReadiness {
        /**
         * script.
         */
        exec?: string;
        /**
         * initial delay seconds for readiness check.
         */
        initialDelaySeconds?: number;
        /**
         * path.
         */
        path?: string;
        /**
         * period seconds for readiness check.
         */
        periodSeconds?: number;
        /**
         * readiness check port.
         */
        port?: number;
        /**
         * protocol.
         */
        protocol?: string;
        /**
         * timeout seconds for readiness check.
         */
        timeoutSeconds?: number;
        /**
         * check type, support HttpGet, TcpSocket and Exec.
         */
        type: string;
    }

    export interface WorkloadStartupProbe {
        /**
         * script.
         */
        exec?: string;
        /**
         * initial delay seconds for startup check.
         */
        initialDelaySeconds?: number;
        /**
         * path.
         */
        path?: string;
        /**
         * period seconds for startup check.
         */
        periodSeconds?: number;
        /**
         * startup check port.
         */
        port?: number;
        /**
         * protocol.
         */
        protocol?: string;
        /**
         * timeout seconds for startup check.
         */
        timeoutSeconds?: number;
        /**
         * check type, support HttpGet, TcpSocket and Exec.
         */
        type: string;
    }

    export interface WorkloadStorageConf {
        /**
         * volume ip.
         */
        storageVolIp: string;
        /**
         * volume name.
         */
        storageVolName: string;
        /**
         * volume path.
         */
        storageVolPath: string;
    }

    export interface WorkloadStorageMountConf {
        /**
         * mount path.
         */
        mountPath: string;
        /**
         * volume name.
         */
        volumeName: string;
    }

}

export namespace Teo {
    export interface AccelerationDomainOriginInfo {
        /**
         * ID of the secondary origin group (valid when `OriginType=ORIGIN_GROUP`). If it is not specified, it indicates that secondary origins are not used.
         */
        backupOrigin?: string;
        /**
         * The origin address. Enter the origin group ID if `OriginType=ORIGIN_GROUP`.
         */
        origin: string;
        /**
         * The origin type. Values: `IP_DOMAIN`: IPv4/IPv6 address or domain name; `COS`: COS bucket address; `ORIGIN_GROUP`: Origin group; `AWS_S3`: AWS S3 bucket address; `SPACE`: EdgeOne Shield Space.
         */
        originType: string;
        /**
         * Whether to authenticate access to the private object storage origin (valid when `OriginType=COS/AWS_S3`). Values: `on`: Enable private authentication; `off`: Disable private authentication. If this field is not specified, the default value `off` is used.
         */
        privateAccess?: string;
        /**
         * The private authentication parameters. This field is valid when `PrivateAccess=on`.
         */
        privateParameters?: outputs.Teo.AccelerationDomainOriginInfoPrivateParameter[];
    }

    export interface AccelerationDomainOriginInfoPrivateParameter {
        /**
         * The parameter name. Valid values: `AccessKeyId`: Access Key ID; `SecretAccessKey`: Secret Access Key.
         */
        name: string;
        /**
         * The parameter value.
         */
        value: string;
    }

    export interface ApplicationProxyIpv6 {
        /**
         * - `on`: Enable.- `off`: Disable.
         */
        switch: string;
    }

    export interface CertificateConfigServerCertInfo {
        /**
         * Alias of the certificate.Note: This field may return null, indicating that no valid values can be obtained.
         */
        alias: string;
        /**
         * ID of the server certificate.Note: This field may return null, indicating that no valid values can be obtained.
         */
        certId: string;
        /**
         * Domain name of the certificate. Note: This field may return `null`, indicating that no valid value can be obtained.
         */
        commonName: string;
        /**
         * Time when the certificate is deployed. Note: This field may return null, indicating that no valid values can be obtained.
         */
        deployTime: string;
        /**
         * Time when the certificate expires. Note: This field may return null, indicating that no valid values can be obtained.
         */
        expireTime: string;
        /**
         * Signature algorithm. Note: This field may return null, indicating that no valid values can be obtained.
         */
        signAlgo: string;
        /**
         * Type of the certificate. Values: `default`: Default certificate; `upload`: Specified certificate; `managed`: Tencent Cloud-managed certificate. Note: This field may return `null`, indicating that no valid value can be obtained.
         */
        type: string;
    }

    export interface GetRuleEngineSettingsAction {
        /**
         * Action name.
         */
        action: string;
        /**
         * Action properties.
         */
        properties: outputs.Teo.GetRuleEngineSettingsActionProperty[];
    }

    export interface GetRuleEngineSettingsActionProperty {
        /**
         * Associative properties of this property, they are all required. Note: This field may return null, indicating that no valid value can be obtained.
         */
        choiceProperties: outputs.Teo.GetRuleEngineSettingsActionPropertyChoiceProperty[];
        /**
         * The choices which can be used. This list may be empty.
         */
        choicesValues: string[];
        /**
         * Special parameter. Note: This field may return null, indicating that no valid value can be obtained.
         */
        extraParameters: outputs.Teo.GetRuleEngineSettingsActionPropertyExtraParameter[];
        /**
         * Whether this property is allowed to set empty.
         */
        isAllowEmpty: boolean;
        /**
         * Whether this property is allowed to set multiple values.
         */
        isMultiple: boolean;
        /**
         * Max integer value can bse used when property type is `CUSTOM_NUM`. When `Min` and `Max` both are 0, this field is meaningless.
         */
        max: number;
        /**
         * Min integer value can bse used when property type is `CUSTOM_NUM`. When `Min` and `Max` both are 0, this field is meaningless.
         */
        min: number;
        /**
         * Property name.
         */
        name: string;
        /**
         * Property value type. Valid values:- `CHOICE`: enum type, must select one of the value in `ChoicesValue`.- `TOGGLE`: switch type, must select one of the value in `ChoicesValue`.- `OBJECT`: object type, the `ChoiceProperties` list all properties of the object.- `CUSTOM_NUM`: integer type.- `CUSTOM_STRING`: string type.
         */
        type: string;
    }

    export interface GetRuleEngineSettingsActionPropertyChoiceProperty {
        /**
         * The choices which can be used. This list may be empty.
         */
        choicesValues: string[];
        /**
         * Special parameter. Note: This field may return null, indicating that no valid value can be obtained.
         */
        extraParameters: outputs.Teo.GetRuleEngineSettingsActionPropertyChoicePropertyExtraParameter[];
        /**
         * Whether this property is allowed to set empty.
         */
        isAllowEmpty: boolean;
        /**
         * Whether this property is allowed to set multiple values.
         */
        isMultiple: boolean;
        /**
         * Max integer value can bse used when property type is `CUSTOM_NUM`. When `Min` and `Max` both are 0, this field is meaningless.
         */
        max: number;
        /**
         * Min integer value can bse used when property type is `CUSTOM_NUM`. When `Min` and `Max` both are 0, this field is meaningless.
         */
        min: number;
        /**
         * Property name.
         */
        name: string;
        /**
         * Property value type. Valid values:- `CHOICE`: enum type, must select one of the value in `ChoicesValue`.- `TOGGLE`: switch type, must select one of the value in `ChoicesValue`.- `OBJECT`: object type, the `ChoiceProperties` list all properties of the object.- `CUSTOM_NUM`: integer type.- `CUSTOM_STRING`: string type.
         */
        type: string;
    }

    export interface GetRuleEngineSettingsActionPropertyChoicePropertyExtraParameter {
        /**
         * A list of choices which can be used when `Type` is `CHOICE`.
         */
        choices: string[];
        /**
         * Parameter name. Valid values:- `Action`: this extra parameter is required when modify HTTP header, this action should be a `RewriteAction`.- `StatusCode`: this extra parameter is required when modify HTTP status code, this action should be a `CodeAction`.- `NULL`: this action should be a `NormalAction`.
         */
        id: string;
        /**
         * Property value type. Valid values:- `CHOICE`: enum type, must select one of the value in `ChoicesValue`.- `TOGGLE`: switch type, must select one of the value in `ChoicesValue`.- `OBJECT`: object type, the `ChoiceProperties` list all properties of the object.- `CUSTOM_NUM`: integer type.- `CUSTOM_STRING`: string type.
         */
        type: string;
    }

    export interface GetRuleEngineSettingsActionPropertyExtraParameter {
        /**
         * A list of choices which can be used when `Type` is `CHOICE`.
         */
        choices: string[];
        /**
         * Parameter name. Valid values:- `Action`: this extra parameter is required when modify HTTP header, this action should be a `RewriteAction`.- `StatusCode`: this extra parameter is required when modify HTTP status code, this action should be a `CodeAction`.- `NULL`: this action should be a `NormalAction`.
         */
        id: string;
        /**
         * Property value type. Valid values:- `CHOICE`: enum type, must select one of the value in `ChoicesValue`.- `TOGGLE`: switch type, must select one of the value in `ChoicesValue`.- `OBJECT`: object type, the `ChoiceProperties` list all properties of the object.- `CUSTOM_NUM`: integer type.- `CUSTOM_STRING`: string type.
         */
        type: string;
    }

    export interface GetZoneAvailablePlansPlanInfoList {
        /**
         * Acceleration area of the plan. Valid value: `mainland`, `overseas`.
         */
        area: string;
        /**
         * Settlement Currency Type. Valid values: `CNY`, `USD`.
         */
        currency: string;
        /**
         * The number of fluxes included in the zone plan. Unit: Byte.
         */
        flux: number;
        /**
         * Billing cycle. Valid values:
         */
        frequency: string;
        /**
         * Plan type.
         */
        planType: string;
        /**
         * Price of the plan. Unit: cent.
         */
        price: number;
        /**
         * The number of requests included in the zone plan.
         */
        request: number;
        /**
         * The number of zones this zone plan can bind.
         */
        siteNumber: number;
    }

    export interface L4ProxyDdosProtectionConfig {
        /**
         * Exclusive DDoS protection specifications in the Chinese mainland. For details, see [Dedicated DDoS Mitigation Fee (Pay-as-You-Go)] (https://intl.cloud.tencent.com/document/product/1552/94162?from_cn_redirect=1). `PLATFORM`: Default protection of the platform, i.e., Exclusive DDoS protection is not enabled; `BASE30_MAX300`: Exclusive DDoS protection enabled, providing a baseline protection bandwidth of 30 Gbps and an elastic protection bandwidth of up to 300 Gbps; `BASE60_MAX600`: Exclusive DDoS protection enabled, providing a baseline protection bandwidth of 60 Gbps and an elastic protection bandwidth of up to 600 Gbps. If no parameters are filled, the default value PLATFORM is used.
         */
        levelMainland?: string;
        /**
         * Exclusive DDoS protection specifications in the worldwide region (excluding the Chinese mainland). `PLATFORM`: Default protection of the platform, i.e., Exclusive DDoS protection is not enabled; `ANYCAST300`: Exclusive DDoS protection enabled, offering a total maximum protection bandwidth of 300 Gbps; `ANYCAST_ALLIN`: Exclusive DDoS protection enabled, utilizing all available protection resources for protection. When no parameters are filled, the default value PLATFORM is used.
         */
        levelOverseas?: string;
        /**
         * Configuration of elastic protection bandwidth for exclusive DDoS protection in the Chinese mainland.Valid only when exclusive DDoS protection in the Chinese mainland is enabled (refer to the LevelMainland parameter configuration), and the value has the following limitations: When exclusive DDoS protection is enabled in the Chinese mainland and the 30 Gbps baseline protection bandwidth is used (the LevelMainland parameter value is BASE30_MAX300): the value range is 30 to 300 in Gbps; When exclusive DDoS protection is enabled in the Chinese mainland and the 60 Gbps baseline protection bandwidth is used (the LevelMainland parameter value is BASE60_MAX600): the value range is 60 to 600 in Gbps; When the default protection of the platform is used (the LevelMainland parameter value is PLATFORM): configuration is not supported, and the value of this parameter is invalid.
         */
        maxBandwidthMainland?: number;
    }

    export interface OriginGroupRecord {
        /**
         * Whether to use private authentication, it takes effect when the origin site type RecordType=COS/AWS_S3, the values are:
         */
        private?: boolean;
        /**
         * Parameters for private authentication. Only valid when `Private` is `true`.
         */
        privateParameters?: outputs.Teo.OriginGroupRecordPrivateParameter[];
        /**
         * Origin site record value, does not include port information, can be: IPv4, IPv6, domain name format.
         */
        record: string;
        /**
         * Origin record ID.
         */
        recordId: string;
        /**
         * Origin site type, the values are:
         */
        type?: string;
        /**
         * The weight of the origin site, the value is 0-100. If it is not filled in, it means that the weight will not be set and the system will schedule it freely. If it is filled in with 0, it means that the weight is 0 and the traffic will not be scheduled to this origin site.
         */
        weight?: number;
    }

    export interface OriginGroupRecordPrivateParameter {
        /**
         * Private authentication parameter name, the values are:
         */
        name: string;
        /**
         * Private authentication parameter value.
         */
        value: string;
    }

    export interface OriginGroupReference {
        /**
         * The instance ID of the reference type.
         */
        instanceId: string;
        /**
         * Instance name of the application type.
         */
        instanceName: string;
        /**
         * Reference service type, the values are:
         */
        instanceType: string;
    }

    export interface RuleEngineRule {
        /**
         * Feature to be executed.
         */
        actions: outputs.Teo.RuleEngineRuleAction[];
        /**
         * OR Conditions list of the rule. Rule would be triggered if any of the condition is true.
         */
        ors: outputs.Teo.RuleEngineRuleOr[];
        /**
         * The nested rule.
         */
        subRules?: outputs.Teo.RuleEngineRuleSubRule[];
    }

    export interface RuleEngineRuleAction {
        /**
         * Feature operation with a status code. Features of this type include:
         */
        codeAction?: outputs.Teo.RuleEngineRuleActionCodeAction;
        /**
         * Common operation. Values:
         */
        normalAction?: outputs.Teo.RuleEngineRuleActionNormalAction;
        /**
         * Feature operation with a request/response header. Features of this type include:
         */
        rewriteAction?: outputs.Teo.RuleEngineRuleActionRewriteAction;
    }

    export interface RuleEngineRuleActionCodeAction {
        /**
         * Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.
         */
        action: string;
        /**
         * Operation parameter.
         */
        parameters: outputs.Teo.RuleEngineRuleActionCodeActionParameter[];
    }

    export interface RuleEngineRuleActionCodeActionParameter {
        /**
         * Parameter name.
         */
        name: string;
        /**
         * The status code.
         */
        statusCode: number;
        /**
         * Parameter value.
         */
        values: string[];
    }

    export interface RuleEngineRuleActionNormalAction {
        /**
         * Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.
         */
        action: string;
        /**
         * Parameter.
         */
        parameters: outputs.Teo.RuleEngineRuleActionNormalActionParameter[];
    }

    export interface RuleEngineRuleActionNormalActionParameter {
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter value.
         */
        values: string[];
    }

    export interface RuleEngineRuleActionRewriteAction {
        /**
         * Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.
         */
        action: string;
        /**
         * Parameter.
         */
        parameters: outputs.Teo.RuleEngineRuleActionRewriteActionParameter[];
    }

    export interface RuleEngineRuleActionRewriteActionParameter {
        /**
         * Feature parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name, which has three values:
         * - add: Add the HTTP header.
         * - set: Rewrite the HTTP header.
         * - del: Delete the HTTP header.
         */
        action: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter value.
         */
        values: string[];
    }

    export interface RuleEngineRuleOr {
        /**
         * Rule engine condition. This condition will be considered met if all items in the array are met.
         */
        ands: outputs.Teo.RuleEngineRuleOrAnd[];
    }

    export interface RuleEngineRuleOrAnd {
        /**
         * Whether the parameter value is case insensitive. Default value: false.
         */
        ignoreCase?: boolean;
        /**
         * The parameter name of the match type. This field is required only when `Target=query_string/request_header`.
         */
        name?: string;
        /**
         * Operator. Valid values:
         */
        operator: string;
        /**
         * The match type. Values:
         */
        target: string;
        /**
         * The parameter value of the match type. It can be an empty string only when `Target=query string/request header` and `Operator=exist/notexist`.
         * - When `Target=extension`, enter the file extension, such as "jpg" and "txt".
         * - When `Target=filename`, enter the file name, such as "foo" in "foo.jpg".
         * - When `Target=all`, it indicates any site request.
         * - When `Target=host`, enter the host under the current site, such as "www.maxx55.com".
         * - When `Target=url`, enter the partial URL path under the current site, such as "/example".
         * - When `Target=full_url`, enter the complete URL under the current site. It must contain the HTTP protocol, host, and path, such as "https://www.maxx55.cn/example".
         * - When `Target=client_country`, enter the ISO-3166 country/region code.
         * - When `Target=query_string`, enter the value of the query string, such as "cn" and "1" in "lang=cn&version=1".
         * - When `Target=request_header`, enter the HTTP request header value, such as "zh-CN,zh;q=0.9" in the "Accept-Language:zh-CN,zh;q=0.9" header.
         */
        values?: string[];
    }

    export interface RuleEngineRuleSubRule {
        /**
         * Nested rule settings.
         */
        rules: outputs.Teo.RuleEngineRuleSubRuleRule[];
        /**
         * Tag of the rule.
         */
        tags?: string[];
    }

    export interface RuleEngineRuleSubRuleRule {
        /**
         * Feature to be executed.
         */
        actions: outputs.Teo.RuleEngineRuleSubRuleRuleAction[];
        /**
         * OR Conditions list of the rule. Rule would be triggered if any of the condition is true.
         */
        ors: outputs.Teo.RuleEngineRuleSubRuleRuleOr[];
    }

    export interface RuleEngineRuleSubRuleRuleAction {
        /**
         * Feature operation with a status code. Features of this type include:
         */
        codeAction?: outputs.Teo.RuleEngineRuleSubRuleRuleActionCodeAction;
        /**
         * Common operation. Values:
         */
        normalAction?: outputs.Teo.RuleEngineRuleSubRuleRuleActionNormalAction;
        /**
         * Feature operation with a request/response header. Features of this type include:
         */
        rewriteAction?: outputs.Teo.RuleEngineRuleSubRuleRuleActionRewriteAction;
    }

    export interface RuleEngineRuleSubRuleRuleActionCodeAction {
        /**
         * Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.
         */
        action: string;
        /**
         * Operation parameter.
         */
        parameters: outputs.Teo.RuleEngineRuleSubRuleRuleActionCodeActionParameter[];
    }

    export interface RuleEngineRuleSubRuleRuleActionCodeActionParameter {
        /**
         * Parameter name.
         */
        name: string;
        /**
         * The status code.
         */
        statusCode: number;
        /**
         * Parameter value.
         */
        values: string[];
    }

    export interface RuleEngineRuleSubRuleRuleActionNormalAction {
        /**
         * Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.
         */
        action: string;
        /**
         * Parameter.
         */
        parameters: outputs.Teo.RuleEngineRuleSubRuleRuleActionNormalActionParameter[];
    }

    export interface RuleEngineRuleSubRuleRuleActionNormalActionParameter {
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter value.
         */
        values: string[];
    }

    export interface RuleEngineRuleSubRuleRuleActionRewriteAction {
        /**
         * Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.
         */
        action: string;
        /**
         * Parameter.
         */
        parameters: outputs.Teo.RuleEngineRuleSubRuleRuleActionRewriteActionParameter[];
    }

    export interface RuleEngineRuleSubRuleRuleActionRewriteActionParameter {
        /**
         * Feature parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name, which has three values:
         * - add: Add the HTTP header.
         * - set: Rewrite the HTTP header.
         * - del: Delete the HTTP header.
         */
        action: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter value.
         */
        values: string[];
    }

    export interface RuleEngineRuleSubRuleRuleOr {
        /**
         * Rule engine condition. This condition will be considered met if all items in the array are met.
         */
        ands: outputs.Teo.RuleEngineRuleSubRuleRuleOrAnd[];
    }

    export interface RuleEngineRuleSubRuleRuleOrAnd {
        /**
         * Whether the parameter value is case insensitive. Default value: false.
         */
        ignoreCase?: boolean;
        /**
         * The parameter name of the match type. This field is required only when `Target=query_string/request_header`.
         */
        name?: string;
        /**
         * Operator. Valid values:
         */
        operator: string;
        /**
         * The match type. Values:
         */
        target: string;
        /**
         * The parameter value of the match type. It can be an empty string only when `Target=query string/request header` and `Operator=exist/notexist`.
         * - When `Target=extension`, enter the file extension, such as "jpg" and "txt".
         * - When `Target=filename`, enter the file name, such as "foo" in "foo.jpg".
         * - When `Target=all`, it indicates any site request.
         * - When `Target=host`, enter the host under the current site, such as "www.maxx55.com".
         * - When `Target=url`, enter the partial URL path under the current site, such as "/example".
         * - When `Target=full_url`, enter the complete URL under the current site. It must contain the HTTP protocol, host, and path, such as "https://www.maxx55.cn/example".
         * - When `Target=client_country`, enter the ISO-3166 country/region code.
         * - When `Target=query_string`, enter the value of the query string, such as "cn" and "1" in "lang=cn&version=1".
         * - When `Target=request_header`, enter the HTTP request header value, such as "zh-CN,zh;q=0.9" in the "Accept-Language:zh-CN,zh;q=0.9" header.
         */
        values?: string[];
    }

    export interface ZoneOwnershipVerification {
        /**
         * CNAME access, using DNS to resolve the information required for authentication. For details, please refer to [Site/Domain Name Ownership Verification ](https://cloud.tencent.com/document/product/1552/70789#7af6ecf8-afca-4e35-8811-b5797ed1bde5). Note: This field may return null, indicating that no valid value can be obtained.
         */
        dnsVerifications: outputs.Teo.ZoneOwnershipVerificationDnsVerification[];
    }

    export interface ZoneOwnershipVerificationDnsVerification {
        /**
         * Record type.
         */
        recordType: string;
        /**
         * Record the value.
         */
        recordValue: string;
        /**
         * Host record.
         */
        subdomain: string;
    }

    export interface ZoneSettingCache {
        /**
         * Cache configuration. Note: This field may return null, indicating that no valid value can be obtained.
         */
        cache: outputs.Teo.ZoneSettingCacheCache;
        /**
         * Follows the origin server configuration. Note: This field may return null, indicating that no valid value can be obtained.
         */
        followOrigin: outputs.Teo.ZoneSettingCacheFollowOrigin;
        /**
         * No-cache configuration. Note: This field may return null, indicating that no valid value can be obtained.
         */
        noCache: outputs.Teo.ZoneSettingCacheNoCache;
    }

    export interface ZoneSettingCacheCache {
        /**
         * Cache expiration time settings.
         * Unit: second. The maximum value is 365 days. Note: This field may return null, indicating that no valid value can be obtained.
         */
        cacheTime: number;
        /**
         * Cache configuration switch.
         */
        switch: string;
    }

    export interface ZoneSettingCacheFollowOrigin {
        /**
         * Specifies whether to follow the origin server configuration.
         */
        switch: string;
    }

    export interface ZoneSettingCacheKey {
        /**
         * Specifies whether to enable full-path cache.
         */
        fullUrlCache?: string;
        /**
         * Specifies whether the cache key is case-sensitive. Note: This field may return null, indicating that no valid value can be obtained.
         */
        ignoreCase?: string;
        /**
         * Request parameter contained in CacheKey. Note: This field may return null, indicating that no valid value can be obtained.
         */
        queryString?: outputs.Teo.ZoneSettingCacheKeyQueryString;
    }

    export interface ZoneSettingCacheKeyQueryString {
        /**
         * `includeCustom`: Include the specified query strings.
         */
        action?: string;
        /**
         * Whether to use QueryString as part of CacheKey.
         */
        switch: string;
        /**
         * Array of query strings used/excluded. Note: This field may return null, indicating that no valid value can be obtained.
         */
        values?: string[];
    }

    export interface ZoneSettingCacheNoCache {
        /**
         * Whether to cache the configuration.
         */
        switch: string;
    }

    export interface ZoneSettingCachePrefresh {
        /**
         * Percentage of cache time before try to prefresh. Valid value range: 1-99.
         */
        percent?: number;
        /**
         * Specifies whether to enable cache prefresh.
         */
        switch: string;
    }

    export interface ZoneSettingClientIpHeader {
        /**
         * Name of the origin-pull client IP request header. Note: This field may return null, indicating that no valid value can be obtained.
         */
        headerName?: string;
        /**
         * Specifies whether to enable client IP header.
         */
        switch: string;
    }

    export interface ZoneSettingCompression {
        /**
         * Compression algorithms to select. Valid values: `brotli`, `gzip`.
         */
        algorithms: string[];
        /**
         * Whether to enable Smart compression.
         */
        switch: string;
    }

    export interface ZoneSettingForceRedirect {
        /**
         * Redirection status code.
         * - 301
         * - 302 Note: This field may return null, indicating that no valid value can be obtained.
         */
        redirectStatusCode?: number;
        /**
         * Whether to enable force redirect.
         */
        switch: string;
    }

    export interface ZoneSettingHttps {
        /**
         * HSTS Configuration. Note: This field may return null, indicating that no valid value can be obtained.
         */
        hsts?: outputs.Teo.ZoneSettingHttpsHsts;
        /**
         * HTTP2 configuration switch.
         */
        http2?: string;
        /**
         * OCSP configuration switch.
         */
        ocspStapling?: string;
        /**
         * TLS version settings. Valid values: `TLSv1`, `TLSV1.1`, `TLSV1.2`, and `TLSv1.3`.
         * Only consecutive versions can be enabled at the same time. Note: This field may return null, indicating that no valid value can be obtained.
         *
         * The `ipv6` object supports the following:
         */
        tlsVersions?: string[];
    }

    export interface ZoneSettingHttpsHsts {
        /**
         * Specifies whether to include subdomain names. Valid values: `on` and `off`. Note: This field may return null, indicating that no valid value can be obtained.
         */
        includeSubDomains?: string;
        /**
         * MaxAge value in seconds, should be no more than 1 day. Note: This field may return null, indicating that no valid value can be obtained.
         */
        maxAge?: number;
        /**
         * Specifies whether to preload. Valid values: `on` and `off`. Note: This field may return null, indicating that no valid value can be obtained.
         */
        preload?: string;
        /**
         * `on`: Enable.
         */
        switch: string;
    }

    export interface ZoneSettingIpv6 {
        /**
         * Cache configuration switch.
         */
        switch: string;
    }

    export interface ZoneSettingMaxAge {
        /**
         * Specifies whether to follow the max cache age of the origin server.
         */
        followOrigin?: string;
        /**
         * Specifies the max age of the cache (in seconds). The maximum value is 365 days. Note: the value 0 means not to cache. Note: This field may return null, indicating that no valid value can be obtained.
         */
        maxAgeTime?: number;
    }

    export interface ZoneSettingOfflineCache {
        /**
         * Whether to enable offline cache.
         */
        switch: string;
    }

    export interface ZoneSettingOrigin {
        /**
         * Backup origin sites list. Note: This field may return null, indicating that no valid value can be obtained.
         */
        backupOrigins: string[];
        /**
         * Origin-pull protocol.
         */
        originPullProtocol: string;
        /**
         * Origin sites list. Note: This field may return null, indicating that no valid value can be obtained.
         */
        origins: string[];
    }

    export interface ZoneSettingPostMaxSize {
        /**
         * Maximum size. Value range: 1-500 MB. Note: This field may return null, indicating that no valid value can be obtained.
         */
        maxSize?: number;
        /**
         * Specifies whether to enable custom setting of the maximum file size.
         */
        switch: string;
    }

    export interface ZoneSettingQuic {
        /**
         * Whether to enable QUIC.
         */
        switch: string;
    }

    export interface ZoneSettingSmartRouting {
        /**
         * Whether to enable HTTP2 origin-pull.
         */
        switch: string;
    }

    export interface ZoneSettingUpstreamHttp2 {
        /**
         * Cache configuration switch.
         */
        switch: string;
    }

    export interface ZoneSettingWebSocket {
        /**
         * Whether to enable custom WebSocket timeout setting. When it's off: it means to keep the default WebSocket connection timeout period, which is 15 seconds. To change the timeout period, please set it to on.
         */
        switch: string;
        /**
         * Sets timeout period in seconds. Maximum value: 120.
         */
        timeout?: number;
    }

}

export namespace Trocket {
    export interface RocketmqInstanceIpRule {
        /**
         * Whether to allow release or not.
         */
        allow: boolean;
        /**
         * IP.
         */
        ip: string;
        /**
         * Remark.
         */
        remark: string;
    }

}

export namespace Tse {
    export interface CngwCanaryRuleCanaryRule {
        /**
         * service weight configuration.
         */
        balancedServiceLists?: outputs.Tse.CngwCanaryRuleCanaryRuleBalancedServiceList[];
        /**
         * parameter matching condition list.
         */
        conditionLists?: outputs.Tse.CngwCanaryRuleCanaryRuleConditionList[];
        /**
         * the status of canary rule.
         */
        enabled: boolean;
        /**
         * priority. The value ranges from 0 to 100; the larger the value, the higher the priority; the priority cannot be repeated between different rules.
         */
        priority: number;
        /**
         * service ID.
         */
        serviceId?: string;
        /**
         * service name.
         */
        serviceName?: string;
    }

    export interface CngwCanaryRuleCanaryRuleBalancedServiceList {
        /**
         * percent, 10 is 10%, valid values:0 to 100.
         */
        percent?: number;
        /**
         * service ID, required when used as an input parameter.
         */
        serviceId?: string;
        /**
         * service name, meaningless when used as an input parameter.
         */
        serviceName?: string;
        /**
         * upstream name, meaningless when used as an input parameter.
         */
        upstreamName: string;
    }

    export interface CngwCanaryRuleCanaryRuleConditionList {
        /**
         * delimiter. valid when operator is in or not in, reference value:`,`, `;`,`\n`.
         */
        delimiter?: string;
        /**
         * global configuration ID.
         */
        globalConfigId?: string;
        /**
         * global configuration name.
         */
        globalConfigName?: string;
        /**
         * parameter name.
         */
        key?: string;
        /**
         * operator.Reference value:`le`,`eq`,`lt`,`ne`,`ge`,`gt`,`regex`,`exists`,`in`,`not in`,`prefix`,`exact`,`regex`.
         */
        operator?: string;
        /**
         * type.Reference value:`path`,`method`,`query`,`header`,`cookie`,`body`,`system`.
         */
        type: string;
        /**
         * parameter value.
         */
        value?: string;
    }

    export interface CngwGatewayInstancePort {
        /**
         * Http port range.
         */
        httpPort: string;
        /**
         * Https port range.
         */
        httpsPort: string;
        /**
         * Tcp port range.
         */
        tcpPort: string;
        /**
         * Udp port range.
         */
        udpPort: string;
    }

    export interface CngwGatewayInternetConfig {
        /**
         * description of clb.
         */
        description?: string;
        /**
         * internet type. Reference value: `IPV4`(default value), `IPV6`.
         */
        internetAddressVersion?: string;
        /**
         * public network bandwidth.
         */
        internetMaxBandwidthOut?: number;
        /**
         * trade type of internet. Reference value: `BANDWIDTH`, `TRAFFIC`(default value).
         */
        internetPayMode?: string;
        /**
         * primary availability zone.
         */
        masterZoneId?: string;
        /**
         * Whether load balancing has multiple availability zones.
         */
        multiZoneFlag?: boolean;
        /**
         * specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
         */
        slaType?: string;
        /**
         * alternate availability zone.
         */
        slaveZoneId?: string;
    }

    export interface CngwGatewayNodeConfig {
        /**
         * node number, 2-50.
         */
        number: number;
        /**
         * specification, 1c2g|2c4g|4c8g|8c16g.
         */
        specification: string;
    }

    export interface CngwGatewayVpcConfig {
        /**
         * subnet ID. Assign an IP address to the engine in the VPC subnet. Reference value: subnet-ahde9me9.
         */
        subnetId?: string;
        /**
         * VPC ID. Assign an IP address to the engine in the VPC subnet. Reference value: vpc-conz6aix.
         */
        vpcId?: string;
    }

    export interface CngwGroupInternetConfig {
        /**
         * description of clb.
         */
        description?: string;
        /**
         * internet type. Reference value:- IPV4 (default value)- IPV6.
         */
        internetAddressVersion?: string;
        /**
         * public network bandwidth.
         */
        internetMaxBandwidthOut?: number;
        /**
         * trade type of internet. Reference value:- BANDWIDTH- TRAFFIC (default value).
         */
        internetPayMode?: string;
        /**
         * primary availability zone.
         */
        masterZoneId?: string;
        /**
         * Whether load balancing has multiple availability zones.
         */
        multiZoneFlag?: boolean;
        /**
         * specification type of clb. Default shared type when this parameter is empty. Reference value:- SLA LCU-supported.
         */
        slaType?: string;
        /**
         * alternate availability zone.
         */
        slaveZoneId?: string;
    }

    export interface CngwGroupNodeConfig {
        /**
         * group node number, 2-50.
         */
        number: number;
        /**
         * group specification, 1c2g|2c4g|4c8g|8c16g.
         */
        specification: string;
    }

    export interface CngwNetworkAccessControlAccessControl {
        /**
         * Black list.
         */
        cidrBlackLists?: string[];
        /**
         * White list.
         */
        cidrWhiteLists?: string[];
        /**
         * Access mode: `Whitelist`, `Blacklist`.
         */
        mode: string;
    }

    export interface CngwRouteHeader {
        /**
         * key of header.
         */
        key?: string;
        /**
         * value of header.
         */
        value?: string;
    }

    export interface CngwRouteRateLimitLimitDetail {
        /**
         * status of service rate limit.
         */
        enabled: boolean;
        /**
         * external redis information, maybe null.
         */
        externalRedis?: outputs.Tse.CngwRouteRateLimitLimitDetailExternalRedis;
        /**
         * request headers that require rate limit.
         */
        header?: string;
        /**
         * whether to hide the headers of client.
         */
        hideClientHeaders: boolean;
        /**
         * whether to enable request queuing.
         */
        isDelay: boolean;
        /**
         * basis for service rate limit.Reference value:`ip`,`service`,`consumer`,`credential`,`path`,`header`.
         */
        limitBy: string;
        /**
         * queue time.
         */
        lineUpTime?: number;
        /**
         * request paths that require rate limit.
         */
        path?: string;
        /**
         * counter policy.Reference value:`local`,`redis`,`externalRedis`.
         */
        policy?: string;
        /**
         * qps threshold.
         */
        qpsThresholds: outputs.Tse.CngwRouteRateLimitLimitDetailQpsThreshold[];
        /**
         * response configuration, the response strategy is text, maybe null.
         */
        rateLimitResponse?: outputs.Tse.CngwRouteRateLimitLimitDetailRateLimitResponse;
        /**
         * request forwarding address, maybe null.
         */
        rateLimitResponseUrl?: string;
        /**
         * response strategy.Reference value:`url`: forward request according to url,`text`: response configuration,`default`: return directly.
         */
        responseType: string;
    }

    export interface CngwRouteRateLimitLimitDetailExternalRedis {
        /**
         * redis ip, maybe null.
         */
        redisHost: string;
        /**
         * redis password, maybe null.
         */
        redisPassword: string;
        /**
         * redis port, maybe null.
         */
        redisPort: number;
        /**
         * redis timeout, unit: `ms`, maybe null.
         */
        redisTimeout: number;
    }

    export interface CngwRouteRateLimitLimitDetailQpsThreshold {
        /**
         * the max threshold.
         */
        max: number;
        /**
         * qps threshold unit.Reference value:`second`,`minute`,`hour`,`day`,`month`,`year`.
         */
        unit: string;
    }

    export interface CngwRouteRateLimitLimitDetailRateLimitResponse {
        /**
         * custom response body, maybe bull.
         */
        body?: string;
        /**
         * headrs.
         */
        headers?: outputs.Tse.CngwRouteRateLimitLimitDetailRateLimitResponseHeader[];
        /**
         * http status code.
         */
        httpStatus?: number;
    }

    export interface CngwRouteRateLimitLimitDetailRateLimitResponseHeader {
        /**
         * key of header.
         */
        key?: string;
        /**
         * value of header.
         */
        value?: string;
    }

    export interface CngwServiceRateLimitLimitDetail {
        /**
         * status of service rate limit.
         */
        enabled: boolean;
        /**
         * external redis information, maybe null.
         */
        externalRedis?: outputs.Tse.CngwServiceRateLimitLimitDetailExternalRedis;
        /**
         * request headers that require rate limit.
         */
        header?: string;
        /**
         * whether to hide the headers of client.
         */
        hideClientHeaders: boolean;
        /**
         * whether to enable request queuing.
         */
        isDelay: boolean;
        /**
         * basis for service rate limit.Reference value: `ip`, `service`, `consumer`, `credential`, `path`, `header`.
         */
        limitBy: string;
        /**
         * queue time.
         */
        lineUpTime?: number;
        /**
         * request paths that require rate limit.
         */
        path?: string;
        /**
         * counter policy.Reference value: `local`, `redis`, `externalRedis`.
         */
        policy?: string;
        /**
         * qps threshold.
         */
        qpsThresholds: outputs.Tse.CngwServiceRateLimitLimitDetailQpsThreshold[];
        /**
         * response configuration, the response strategy is text, maybe null.
         */
        rateLimitResponse?: outputs.Tse.CngwServiceRateLimitLimitDetailRateLimitResponse;
        /**
         * request forwarding address, maybe null.
         */
        rateLimitResponseUrl?: string;
        /**
         * response strategy.Reference value: `url`: forward request according to url, `text`: response configuration, `default`: return directly.
         */
        responseType: string;
    }

    export interface CngwServiceRateLimitLimitDetailExternalRedis {
        /**
         * redis ip, maybe null.
         */
        redisHost: string;
        /**
         * redis password, maybe null.
         */
        redisPassword: string;
        /**
         * redis port, maybe null.
         */
        redisPort: number;
        /**
         * redis timeout, unit: `ms`, maybe null.
         */
        redisTimeout: number;
    }

    export interface CngwServiceRateLimitLimitDetailQpsThreshold {
        /**
         * the max threshold.
         */
        max: number;
        /**
         * qps threshold unit.Reference value:`second`, `minute`, `hour`, `day`, `month`, `year`.
         */
        unit: string;
    }

    export interface CngwServiceRateLimitLimitDetailRateLimitResponse {
        /**
         * custom response body, maybe bull.
         */
        body?: string;
        /**
         * headrs.
         */
        headers?: outputs.Tse.CngwServiceRateLimitLimitDetailRateLimitResponseHeader[];
        /**
         * http status code.
         */
        httpStatus?: number;
    }

    export interface CngwServiceRateLimitLimitDetailRateLimitResponseHeader {
        /**
         * key of header.
         */
        key?: string;
        /**
         * value of header.
         */
        value?: string;
    }

    export interface CngwServiceUpstreamInfo {
        /**
         * load balance algorithm,default: `round-robin`, `least-connections` and `consistenHashing` also support.
         */
        algorithm: string;
        /**
         * auto scaling group port of cvm.
         */
        autoScalingCvmPort?: number;
        /**
         * auto scaling group ID of cvm.
         */
        autoScalingGroupId?: string;
        /**
         * hook status in auto scaling group of cvm.
         */
        autoScalingHookStatus?: string;
        /**
         * tat cmd status in auto scaling group of cvm.
         */
        autoScalingTatCmdStatus?: string;
        /**
         * an IP address or domain name.
         */
        host: string;
        /**
         * namespace.
         */
        namespace?: string;
        /**
         * backend service port.valid values: `1` to `65535`.
         */
        port?: number;
        /**
         * exact source service type.
         */
        realSourceType?: string;
        /**
         * scf lambda name.
         */
        scfLambdaName?: string;
        /**
         * scf lambda version.
         */
        scfLambdaQualifier?: string;
        /**
         * scf lambda namespace.
         */
        scfNamespace?: string;
        /**
         * scf lambda type.
         */
        scfType?: string;
        /**
         * the name of the service in registry or kubernetes.
         */
        serviceName?: string;
        /**
         * slow start time, unit: `second`, when it is enabled, weight of the node is increased from 1 to the target value gradually.
         */
        slowStart?: number;
        /**
         * service source ID.
         */
        sourceId?: string;
        /**
         * the name of source service.
         */
        sourceName?: string;
        /**
         * source service type.
         */
        sourceType?: string;
        /**
         * provided when service type is IPList.
         */
        targets?: outputs.Tse.CngwServiceUpstreamInfoTarget[];
    }

    export interface CngwServiceUpstreamInfoTarget {
        /**
         * created time.
         */
        createdTime: string;
        /**
         * health.
         */
        health: string;
        /**
         * host.
         */
        host: string;
        /**
         * port.
         */
        port: number;
        /**
         * source of target.
         */
        source?: string;
        /**
         * weight.
         */
        weight: number;
    }

    export interface CngwStrategyConfig {
        /**
         * behavior configuration of metric
         * Note: This field may return null, indicating that a valid value is not available.
         */
        behavior?: outputs.Tse.CngwStrategyConfigBehavior;
        /**
         * create time
         * Note: This field may return null, indicating that a valid value is not available.
         */
        createTime?: string;
        /**
         * max number of replica for metric scaling.
         */
        maxReplicas?: number;
        /**
         * metric list.
         */
        metrics?: outputs.Tse.CngwStrategyConfigMetric[];
        /**
         * modify time
         * Note: This field may return null, indicating that a valid value is not available.
         */
        modifyTime?: string;
        /**
         * strategy ID
         * Note: This field may return null, indicating that a valid value is not available.
         */
        strategyId?: string;
    }

    export interface CngwStrategyConfigBehavior {
        /**
         * configuration of down scale
         * Note: This field may return null, indicating that a valid value is not available.
         */
        scaleDown?: outputs.Tse.CngwStrategyConfigBehaviorScaleDown;
        /**
         * configuration of up scale
         * Note: This field may return null, indicating that a valid value is not available.
         */
        scaleUp?: outputs.Tse.CngwStrategyConfigBehaviorScaleUp;
    }

    export interface CngwStrategyConfigBehaviorScaleDown {
        /**
         * policies of scale down
         * Note: This field may return null, indicating that a valid value is not available.
         */
        policies?: outputs.Tse.CngwStrategyConfigBehaviorScaleDownPolicy[];
        /**
         * type of policy, default value: max
         * Note: This field may return null, indicating that a valid value is not available.
         */
        selectPolicy?: string;
        /**
         * stability window time, unit:second, default 300 when scale down
         * Note: This field may return null, indicating that a valid value is not available.
         */
        stabilizationWindowSeconds?: number;
    }

    export interface CngwStrategyConfigBehaviorScaleDownPolicy {
        /**
         * period of scale up
         * Note: This field may return null, indicating that a valid value is not available.
         */
        periodSeconds?: number;
        /**
         * type, default value: Pods
         * Note: This field may return null, indicating that a valid value is not available.
         */
        type?: string;
        /**
         * value
         * Note: This field may return null, indicating that a valid value is not available.
         */
        value?: number;
    }

    export interface CngwStrategyConfigBehaviorScaleUp {
        /**
         * policies of scale up
         * Note: This field may return null, indicating that a valid value is not available.
         */
        policies?: outputs.Tse.CngwStrategyConfigBehaviorScaleUpPolicy[];
        /**
         * type of policy, default value: max
         * Note: This field may return null, indicating that a valid value is not available.
         */
        selectPolicy?: string;
        /**
         * stability window time, unit:second, default 0 when scale up
         * Note: This field may return null, indicating that a valid value is not available.
         */
        stabilizationWindowSeconds?: number;
    }

    export interface CngwStrategyConfigBehaviorScaleUpPolicy {
        /**
         * period of scale up
         * Note: This field may return null, indicating that a valid value is not available.
         */
        periodSeconds?: number;
        /**
         * type, default value: Pods
         * Note: This field may return null, indicating that a valid value is not available.
         */
        type?: string;
        /**
         * value
         * Note: This field may return null, indicating that a valid value is not available.
         */
        value?: number;
    }

    export interface CngwStrategyConfigMetric {
        /**
         * metric name. Reference value:
         * - cpu
         * - memory
         * Note: This field may return null, indicating that a valid value is not available.
         */
        resourceName?: string;
        /**
         * target type of metric, currently only supports `Utilization`
         * Note: This field may return null, indicating that a valid value is not available.
         */
        targetType: string;
        /**
         * target value of metric
         * Note: This field may return null, indicating that a valid value is not available.
         */
        targetValue?: number;
        /**
         * metric type. Deafault value
         * - Resource.
         */
        type?: string;
    }

    export interface CngwStrategyCronConfig {
        /**
         * parameter list of timed scaling
         * Note: This field may return null, indicating that a valid value is not available.
         */
        params?: outputs.Tse.CngwStrategyCronConfigParam[];
        /**
         * strategy ID
         * Note: This field may return null, indicating that a valid value is not available.
         */
        strategyId?: string;
    }

    export interface CngwStrategyCronConfigParam {
        /**
         * cron expression of timed scaling, no input required
         * Note: This field may return null, indicating that a valid value is not available.
         */
        crontab?: string;
        /**
         * period of timed scaling
         * Note: This field may return null, indicating that a valid value is not available.
         */
        period?: string;
        /**
         * start time of timed scaling
         * Note: This field may return null, indicating that a valid value is not available.
         */
        startAt?: string;
        /**
         * the number of target nodes for the timed scaling. Do not exceed the max number of replica for metric scaling
         * Note: This field may return null, indicating that a valid value is not available.
         */
        targetReplicas?: number;
    }

    export interface GetAccessAddressEnvAddressInfo {
        /**
         * config public network ip.
         */
        configInternetServiceIp: string;
        /**
         * config Intranet access addressNote: This field may return null, indicating that a valid value is not available.
         */
        configIntranetAddress: string;
        /**
         * Whether to enable the config public network.
         */
        enableConfigInternet: boolean;
        /**
         * Whether to enable the config Intranet clbNote: This field may return null, indicating that a valid value is not available.
         */
        enableConfigIntranet: boolean;
        /**
         * env name.
         */
        envName: string;
        /**
         * Client public network bandwidthNote: This field may return null, indicating that a valid value is not available.
         */
        internetBandWidth: number;
    }

    export interface GetAccessAddressLimiterAddressInfo {
        /**
         * VPC access IP address listNote: This field may return null, indicating that a valid value is not available.
         */
        intranetAddress: string;
    }

    export interface GetGatewayCanaryRulesResult {
        /**
         * canary rule list.
         */
        canaryRuleLists: outputs.Tse.GetGatewayCanaryRulesResultCanaryRuleList[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetGatewayCanaryRulesResultCanaryRuleList {
        /**
         * service weight configuration.
         */
        balancedServiceLists: outputs.Tse.GetGatewayCanaryRulesResultCanaryRuleListBalancedServiceList[];
        /**
         * parameter matching condition list.
         */
        conditionLists: outputs.Tse.GetGatewayCanaryRulesResultCanaryRuleListConditionList[];
        /**
         * the status of canary rule.
         */
        enabled: boolean;
        /**
         * priority. The value ranges from 0 to 100; the larger the value, the higher the priority; the priority cannot be repeated between different rules.
         */
        priority: number;
        /**
         * service ID.
         */
        serviceId: string;
        /**
         * service name.
         */
        serviceName: string;
    }

    export interface GetGatewayCanaryRulesResultCanaryRuleListBalancedServiceList {
        /**
         * percent, 10 is 10%, valid values: 0 to 100.
         */
        percent: number;
        /**
         * service ID.
         */
        serviceId: string;
        /**
         * service name.
         */
        serviceName: string;
        /**
         * upstream name.
         */
        upstreamName: string;
    }

    export interface GetGatewayCanaryRulesResultCanaryRuleListConditionList {
        /**
         * delimiter. valid when operator is in or not in, reference value:`,`, `;`,`\n`.
         */
        delimiter: string;
        /**
         * global configuration ID.
         */
        globalConfigId: string;
        /**
         * global configuration name.
         */
        globalConfigName: string;
        /**
         * parameter name.
         */
        key: string;
        /**
         * operator.Reference value:`le`, `eq`, `lt`, `ne`, `ge`, `gt`, `regex`, `exists`, `in`, `not in`,  `prefix`, `exact`, `regex`.
         */
        operator: string;
        /**
         * type.Reference value:- path- method- query- header- cookie- body- system.
         */
        type: string;
        /**
         * parameter value.
         */
        value: string;
    }

    export interface GetGatewayCertificatesFilter {
        /**
         * Filter name.
         */
        key?: string;
        /**
         * Filter value.
         */
        value?: string;
    }

    export interface GetGatewayCertificatesResult {
        /**
         * Certificate list of gateway. Note: This field may return null, indicating that a valid value is not available.
         */
        certificatesLists: outputs.Tse.GetGatewayCertificatesResultCertificatesList[];
        /**
         * Total count. Note: This field may return null, indicating that a valid value is not available.
         */
        total: number;
    }

    export interface GetGatewayCertificatesResultCertificatesList {
        /**
         * Domains of the binding. Note: This field may return null, indicating that a valid value is not available.
         */
        bindDomains: string[];
        /**
         * Certificate ID of ssl platform. Note: This field may return null, indicating that a valid value is not available.
         */
        certId: string;
        /**
         * Source of certificate. Reference value:- native. Source: konga- ssl. Source: ssl platform. Note: This field may return null, indicating that a valid value is not available.
         */
        certSource: string;
        /**
         * Upload time of certificate. Note: This field may return null, indicating that a valid value is not available.
         */
        createTime: string;
        /**
         * Pem format of certificate. Note: This field may return null, indicating that a valid value is not available.
         */
        crt: string;
        /**
         * Expiration time of certificate. Note: This field may return null, indicating that a valid value is not available.
         */
        expireTime: string;
        /**
         * Certificate ID. Note: This field may return null, indicating that a valid value is not available.
         */
        id: string;
        /**
         * Issuance time of certificateNote: This field may return null, indicating that a valid value is not available.
         */
        issueTime: string;
        /**
         * Filter name.
         */
        key: string;
        /**
         * Certificate name. Note: This field may return null, indicating that a valid value is not available.
         */
        name: string;
        /**
         * Status of certificate. Reference value:- expired- active. Note: This field may return null, indicating that a valid value is not available.
         */
        status: string;
    }

    export interface GetGatewayNodesNodeList {
        /**
         * gateway group ID.
         */
        groupId: string;
        /**
         * Group nameNote: This field may return null, indicating that a valid value is not available.
         */
        groupName: string;
        /**
         * gateway node id.
         */
        nodeId: string;
        /**
         * gateway node ip.
         */
        nodeIp: string;
        /**
         * statusNote: This field may return null, indicating that a valid value is not available.
         */
        status: string;
        /**
         * ZoneNote: This field may return null, indicating that a valid value is not available.
         */
        zone: string;
        /**
         * Zone idNote: This field may return null, indicating that a valid value is not available.
         */
        zoneId: string;
    }

    export interface GetGatewayRoutesResult {
        /**
         * route list.
         */
        routeLists: outputs.Tse.GetGatewayRoutesResultRouteList[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetGatewayRoutesResultRouteList {
        /**
         * created time.
         */
        createdTime: string;
        /**
         * destination port for Layer 4 matching.
         */
        destinationPorts: number[];
        /**
         * whether to enable forced HTTPS, no longer use.
         */
        forceHttps: boolean;
        /**
         * the headers of route.
         */
        headers: outputs.Tse.GetGatewayRoutesResultRouteListHeader[];
        /**
         * host list.
         */
        hosts: string[];
        /**
         * https redirection status code.
         */
        httpsRedirectStatusCode: number;
        /**
         * service ID.
         */
        id: string;
        /**
         * method list.
         */
        methods: string[];
        /**
         * service name.
         */
        name: string;
        /**
         * path list.
         */
        paths: string[];
        /**
         * whether to keep the host when forwarding to the backend.
         */
        preserveHost: boolean;
        /**
         * protocol list.
         */
        protocols: string[];
        /**
         * service ID.
         */
        serviceId: string;
        /**
         * service name.
         */
        serviceName: string;
        /**
         * whether to strip path when forwarding to the backend.
         */
        stripPath: boolean;
    }

    export interface GetGatewayRoutesResultRouteListHeader {
        /**
         * key of header.
         */
        key: string;
        /**
         * value of header.
         */
        value: string;
    }

    export interface GetGatewayServicesFilter {
        /**
         * filter name.
         */
        key?: string;
        /**
         * filter value.
         */
        value?: string;
    }

    export interface GetGatewayServicesResult {
        /**
         * service list.
         */
        serviceLists: outputs.Tse.GetGatewayServicesResultServiceList[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetGatewayServicesResultServiceList {
        /**
         * created time.
         */
        createdTime: string;
        /**
         * editable status.
         */
        editable: boolean;
        /**
         * service ID.
         */
        id: string;
        /**
         * service name.
         */
        name: string;
        /**
         * tag list.
         */
        tags: string[];
        /**
         * upstream information.
         */
        upstreamInfos: outputs.Tse.GetGatewayServicesResultServiceListUpstreamInfo[];
        /**
         * service type.
         */
        upstreamType: string;
    }

    export interface GetGatewayServicesResultServiceListUpstreamInfo {
        /**
         * load balance algorithm,default:round-robin,least-connections and consistenHashing also support.
         */
        algorithm: string;
        /**
         * auto scaling group port of cvm.
         */
        autoScalingCvmPort: number;
        /**
         * auto scaling group ID of cvm.
         */
        autoScalingGroupId: string;
        /**
         * hook status in auto scaling group of cvm.
         */
        autoScalingHookStatus: string;
        /**
         * tat cmd status in auto scaling group of cvm.
         */
        autoScalingTatCmdStatus: string;
        /**
         * Host.
         */
        host: string;
        /**
         * namespace.
         */
        namespace: string;
        /**
         * port.
         */
        port: number;
        /**
         * exact source service type.
         */
        realSourceType: string;
        /**
         * scf lambda name.
         */
        scfLambdaName: string;
        /**
         * scf lambda version.
         */
        scfLambdaQualifier: string;
        /**
         * scf lambda namespace.
         */
        scfNamespace: string;
        /**
         * scf lambda type.
         */
        scfType: string;
        /**
         * the name of the service in registry or kubernetes.
         */
        serviceName: string;
        /**
         * slow start time, unit:second,when it&#39;s enabled, weight of the node is increased from 1 to the target value gradually.
         */
        slowStart: number;
        /**
         * service source ID.
         */
        sourceId: string;
        /**
         * the name of source service.
         */
        sourceName: string;
        /**
         * source service type.
         */
        sourceType: string;
        /**
         * provided when service type is IPList.
         */
        targets: outputs.Tse.GetGatewayServicesResultServiceListUpstreamInfoTarget[];
    }

    export interface GetGatewayServicesResultServiceListUpstreamInfoTarget {
        /**
         * created time.
         */
        createdTime: string;
        /**
         * health.
         */
        health: string;
        /**
         * Host.
         */
        host: string;
        /**
         * port.
         */
        port: number;
        /**
         * source of target.
         */
        source: string;
        /**
         * weight.
         */
        weight: number;
    }

    export interface GetGatewaysFilter {
        /**
         * filter name.
         */
        name: string;
        /**
         * filter value.
         */
        values: string[];
    }

    export interface GetGatewaysResult {
        /**
         * gateway list.
         */
        gatewayLists: outputs.Tse.GetGatewaysResultGatewayList[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetGatewaysResultGatewayList {
        /**
         * auto renew flag, `0`: default status, `1`: auto renew, `2`: auto not renew.
         */
        autoRenewFlag: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * expire date, for prepaid type.Note: This field may return null, indicating that a valid value is not available.
         */
        curDeadline: string;
        /**
         * description of gateway.
         */
        description: string;
        /**
         * whether to enable CLS log.
         */
        enableCls: boolean;
        /**
         * whether to open the public network of client.Note: This field may return null, indicating that a valid value is not available.
         */
        enableInternet: boolean;
        /**
         * engine region of gateway.
         */
        engineRegion: string;
        /**
         * product version. `TRIAL`, `STANDARD`(default value), `PROFESSIONAL`.
         */
        featureVersion: string;
        /**
         * gateway ID.
         */
        gatewayId: string;
        /**
         * minor version of gateway.
         */
        gatewayMinorVersion: string;
        /**
         * gateway version. Reference value: `2.4.1`, `2.5.1`.
         */
        gatewayVersion: string;
        /**
         * ingress class name.
         */
        ingressClassName: string;
        /**
         * the port information that the instance monitors.
         */
        instancePorts: outputs.Tse.GetGatewaysResultGatewayListInstancePort[];
        /**
         * public network outbound traffic bandwidth.
         */
        internetMaxBandwidthOut: number;
        /**
         * trade type of internet. `BANDWIDTH`, `TRAFFIC`.
         */
        internetPayMode: string;
        /**
         * isolation time, used when the gateway is isolated.
         */
        isolateTime: string;
        /**
         * load balance type of public internet.
         */
        loadBalancerType: string;
        /**
         * filter name.
         */
        name: string;
        /**
         * original node config.
         */
        nodeConfigs: outputs.Tse.GetGatewaysResultGatewayListNodeConfig[];
        /**
         * addresses of public internet.
         */
        publicIpAddresses: string[];
        /**
         * status of gateway. May return values: `Creating`, `CreateFailed`, `Running`, `Modifying`, `UpdatingSpec`, `UpdateFailed`, `Deleting`, `DeleteFailed`, `Isolating`.
         */
        status: string;
        /**
         * tags information of gatewayNote: This field may return null, indicating that a valid value is not available.
         */
        tags: outputs.Tse.GetGatewaysResultGatewayListTag[];
        /**
         * trade type. `0`: postpaid, `1`: Prepaid.
         */
        tradeType: number;
        /**
         * gateway type.
         */
        type: string;
        /**
         * vpc information.
         */
        vpcConfigs: outputs.Tse.GetGatewaysResultGatewayListVpcConfig[];
    }

    export interface GetGatewaysResultGatewayListInstancePort {
        /**
         * http port.
         */
        httpPort: string;
        /**
         * https port.
         */
        httpsPort: string;
    }

    export interface GetGatewaysResultGatewayListNodeConfig {
        /**
         * node number, 2-50.
         */
        number: number;
        /**
         * specification, 1c2g|2c4g|4c8g|8c16g.
         */
        specification: string;
    }

    export interface GetGatewaysResultGatewayListTag {
        /**
         * tag key.
         */
        tagKey: string;
        /**
         * tag value.
         */
        tagValue: string;
    }

    export interface GetGatewaysResultGatewayListVpcConfig {
        /**
         * subnet ID. Assign an IP address to the engine in the VPC subnet.
         */
        subnetId: string;
        /**
         * subnet ID. Assign an IP address to the engine in the VPC subnet.
         */
        vpcId: string;
    }

    export interface GetGroupsFilter {
        /**
         * filter name.
         */
        name: string;
        /**
         * filter values.
         */
        values: string[];
    }

    export interface GetGroupsResult {
        /**
         * group list of gateway.
         */
        gatewayGroupLists: outputs.Tse.GetGroupsResultGatewayGroupList[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetGroupsResultGatewayGroupList {
        /**
         * associated strategy informationNote: This field may return null, indicating that a valid value is not available.
         */
        bindingStrategies: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategy[];
        /**
         * group create time.
         */
        createTime: string;
        /**
         * group description.
         */
        description: string;
        /**
         * gateway ID.
         */
        gatewayId: string;
        /**
         * group Id.
         */
        groupId: string;
        /**
         * public network outbound traffic bandwidth.
         */
        internetMaxBandwidthOut: number;
        /**
         * whether it is the default group- 0: false.- 1: yes.
         */
        isFirstGroup: number;
        /**
         * modify time.
         */
        modifyTime: string;
        /**
         * filter name.
         */
        name: string;
        /**
         * group node configration.
         */
        nodeConfigs: outputs.Tse.GetGroupsResultGatewayGroupListNodeConfig[];
        /**
         * group status.
         */
        status: string;
        /**
         * subnet IDs.
         */
        subnetIds: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategy {
        /**
         * auto scaling configurationNote: This field may return null, indicating that a valid value is not available.
         */
        configs: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyConfig[];
        /**
         * group create time.
         */
        createTime: string;
        /**
         * timing scaling configurationNote: This field may return null, indicating that a valid value is not available.
         */
        cronConfigs: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyCronConfig[];
        /**
         * group description.
         */
        description: string;
        /**
         * gateway ID.
         */
        gatewayId: string;
        /**
         * maximum number of replicas.
         */
        maxReplicas: number;
        /**
         * modify time.
         */
        modifyTime: string;
        /**
         * strategy ID.
         */
        strategyId: string;
        /**
         * strategy nameNote: This field may return null, indicating that a valid value is not available.
         */
        strategyName: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyConfig {
        /**
         * auto scaler IDNote: This field may return null, indicating that a valid value is not available.
         */
        autoScalerId: string;
        /**
         * group create time.
         */
        createTime: string;
        /**
         * whether to enable timing auto scaling.
         */
        enabled: boolean;
        /**
         * maximum number of replicas.
         */
        maxReplicas: number;
        /**
         * metric listNote: This field may return null, indicating that a valid value is not available.
         */
        metrics: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyConfigMetric[];
        /**
         * modify time.
         */
        modifyTime: string;
        /**
         * strategy ID.
         */
        strategyId: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyConfigMetric {
        /**
         * metric resource nameNote: This field may return null, indicating that a valid value is not available.
         */
        resourceName: string;
        /**
         * metric target typeNote: This field may return null, indicating that a valid value is not available.
         */
        targetType: string;
        /**
         * metric target valueNote: This field may return null, indicating that a valid value is not available.
         */
        targetValue: number;
        /**
         * metric typeNote: This field may return null, indicating that a valid value is not available.
         */
        type: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyCronConfig {
        /**
         * group create time.
         */
        createTime: string;
        /**
         * whether to enable timing auto scaling.
         */
        enabled: boolean;
        /**
         * modify time.
         */
        modifyTime: string;
        /**
         * params of timing auto scaling.
         */
        params: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyCronConfigParam[];
        /**
         * strategy ID.
         */
        strategyId: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyCronConfigParam {
        /**
         * cron expression.
         */
        crontab: string;
        /**
         * period of timing auto scaling.
         */
        period: string;
        /**
         * start time.
         */
        startAt: string;
        /**
         * target replicas.
         */
        targetReplicas: number;
    }

    export interface GetGroupsResultGatewayGroupListNodeConfig {
        /**
         * group node number, 2-50.
         */
        number: number;
        /**
         * group specification, 1c2g|2c4g|4c8g|8c16g.
         */
        specification: string;
    }

    export interface GetNacosReplicasReplica {
        /**
         * name.
         */
        name: string;
        /**
         * role.
         */
        role: string;
        /**
         * status.
         */
        status: string;
        /**
         * Subnet IDNote: This field may return null, indicating that a valid value is not available.
         */
        subnetId: string;
        /**
         * VPC IDNote: This field may return null, indicating that a valid value is not available.
         */
        vpcId: string;
        /**
         * Available area NameNote: This field may return null, indicating that a valid value is not available.
         */
        zone: string;
        /**
         * Available area IDNote: This field may return null, indicating that a valid value is not available.
         */
        zoneId: string;
    }

    export interface GetNacosServerInterfacesContent {
        /**
         * interface nameNote: This field may return null, indicating that a valid value is not available.
         */
        interface: string;
    }

    export interface GetZookeeperReplicasReplica {
        /**
         * aliasNote: This field may return null, indicating that a valid value is not available.
         */
        aliasName: string;
        /**
         * name.
         */
        name: string;
        /**
         * role.
         */
        role: string;
        /**
         * status.
         */
        status: string;
        /**
         * Subnet IDNote: This field may return null, indicating that a valid value is not available.
         */
        subnetId: string;
        /**
         * VPC IDNote: This field may return null, indicating that a valid value is not available.
         */
        vpcId: string;
        /**
         * Available area IDNote: This field may return null, indicating that a valid value is not available.
         */
        zone: string;
        /**
         * Available area IDNote: This field may return null, indicating that a valid value is not available.
         */
        zoneId: string;
    }

    export interface GetZookeeperServerInterfacesContent {
        /**
         * interface nameNote: This field may return null, indicating that a valid value is not available.
         */
        interface: string;
    }

    export interface InstanceEngineRegionInfo {
        /**
         * Engine node region.
         */
        engineRegion: string;
        /**
         * The number of nodes allocated in this region.
         */
        replica: number;
        /**
         * Cluster network information.
         */
        vpcInfos: outputs.Tse.InstanceEngineRegionInfoVpcInfo[];
    }

    export interface InstanceEngineRegionInfoVpcInfo {
        /**
         * Intranet access addressNote: This field may return null, indicating that a valid value is not available..
         */
        intranetAddress?: string;
        /**
         * Subnet ID.
         */
        subnetId: string;
        /**
         * Vpc Id.
         */
        vpcId: string;
    }

}

export namespace Tsf {
    export interface ApiGroupBindedGatewayDeployGroup {
        /**
         * application ID.
         */
        applicationId: string;
        /**
         * Application Name.
         */
        applicationName: string;
        /**
         * Application classification: V: virtual machine application, C: container application.
         */
        applicationType: string;
        /**
         * Cluster type, C: container, V: virtual machine.
         */
        clusterType: string;
        /**
         * Gateway deployment group ID.
         */
        deployGroupId: string;
        /**
         * Gateway deployment group name.
         */
        deployGroupName: string;
        /**
         * Deployment group application status, values: Running, Waiting, Paused, Updating, RollingBack, Abnormal, Unknown.
         */
        groupStatus: string;
    }

    export interface ApplicationServiceConfigList {
        /**
         * Health check configuration.
         */
        healthCheck?: outputs.Tsf.ApplicationServiceConfigListHealthCheck;
        /**
         * Service name.
         */
        name: string;
        /**
         * List of port information.
         */
        ports: outputs.Tsf.ApplicationServiceConfigListPort[];
    }

    export interface ApplicationServiceConfigListHealthCheck {
        /**
         * Health check path.
         */
        path?: string;
    }

    export interface ApplicationServiceConfigListPort {
        /**
         * Port protocol.
         */
        protocol: string;
        /**
         * Service port.
         */
        targetPort: number;
    }

    export interface ClusterOperationInfo {
        /**
         * Add the control information of the instance button.
         */
        addInstances: outputs.Tsf.ClusterOperationInfoAddInstance[];
        /**
         * Destroy the control information of the machine.
         */
        destroys: outputs.Tsf.ClusterOperationInfoDestroy[];
        /**
         * Initialize the control information of the button.
         */
        inits: outputs.Tsf.ClusterOperationInfoInit[];
    }

    export interface ClusterOperationInfoAddInstance {
        /**
         * Reason for not showing.
         */
        disabledReason: string;
        /**
         * Is the button clickable.
         */
        enabled: boolean;
        /**
         * whether to show the button.
         */
        supported: boolean;
    }

    export interface ClusterOperationInfoDestroy {
        /**
         * Reason for not showing.
         */
        disabledReason: string;
        /**
         * Is the button clickable.
         */
        enabled: boolean;
        /**
         * whether to show the button.
         */
        supported: boolean;
    }

    export interface ClusterOperationInfoInit {
        /**
         * Reason for not showing.
         */
        disabledReason: string;
        /**
         * Is the button clickable.
         */
        enabled: boolean;
        /**
         * whether to show the button.
         */
        supported: boolean;
    }

    export interface DeployContainerGroupAgentProfileList {
        /**
         * Agent type.
         */
        agentType: string;
        /**
         * Agent version.
         */
        agentVersion: string;
    }

    export interface DeployContainerGroupEnv {
        /**
         * env param name.
         */
        name: string;
        /**
         * value of env.
         */
        value: string;
        /**
         * Kubernetes ValueFrom configuration. Note: This field may return null, indicating that no valid values can be obtained.
         */
        valueFrom: outputs.Tsf.DeployContainerGroupEnvValueFrom;
    }

    export interface DeployContainerGroupEnvValueFrom {
        /**
         * The FieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
         */
        fieldRef: outputs.Tsf.DeployContainerGroupEnvValueFromFieldRef;
        /**
         * The ResourceFieldRef configuration of Kubernetes env. Note: This field may return null, indicating that no valid values can be obtained.
         */
        resourceFieldRef: outputs.Tsf.DeployContainerGroupEnvValueFromResourceFieldRef;
    }

    export interface DeployContainerGroupEnvValueFromFieldRef {
        /**
         * The FieldPath configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
         */
        fieldPath: string;
    }

    export interface DeployContainerGroupEnvValueFromResourceFieldRef {
        /**
         * The Resource configuration of Kubernetes. Note: This field may return null, indicating that no valid values can be obtained.
         */
        resource: string;
    }

    export interface DeployContainerGroupHealthCheckSettings {
        /**
         * Liveness probe. Note: This field may return null, indicating that no valid values can be obtained.
         */
        livenessProbe?: outputs.Tsf.DeployContainerGroupHealthCheckSettingsLivenessProbe;
        /**
         * Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        readinessProbe?: outputs.Tsf.DeployContainerGroupHealthCheckSettingsReadinessProbe;
    }

    export interface DeployContainerGroupHealthCheckSettingsLivenessProbe {
        /**
         * The health check method. HTTP: checks through an HTTP interface; CMD: checks by executing a command; TCP: checks by establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
         */
        actionType: string;
        /**
         * The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        commands?: string[];
        /**
         * The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
         */
        failureThreshold?: number;
        /**
         * The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        initialDelaySeconds?: number;
        /**
         * The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        path?: string;
        /**
         * The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        periodSeconds?: number;
        /**
         * The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
         */
        port?: number;
        /**
         * The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
         */
        scheme?: string;
        /**
         * The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
         */
        successThreshold?: number;
        /**
         * The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
         */
        timeoutSeconds?: number;
        /**
         * The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
         */
        type?: string;
    }

    export interface DeployContainerGroupHealthCheckSettingsReadinessProbe {
        /**
         * The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
         */
        actionType: string;
        /**
         * The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        commands?: string[];
        /**
         * The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
         */
        failureThreshold?: number;
        /**
         * The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        initialDelaySeconds?: number;
        /**
         * The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        path?: string;
        /**
         * The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        periodSeconds?: number;
        /**
         * The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
         */
        port?: number;
        /**
         * The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
         */
        scheme?: string;
        /**
         * The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
         */
        successThreshold?: number;
        /**
         * The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
         */
        timeoutSeconds?: number;
        /**
         * The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
         */
        type?: string;
    }

    export interface DeployContainerGroupSchedulingStrategy {
        /**
         * NONE: Do not use scheduling strategy; CROSS_AZ: Deploy across availability zones. Note: This field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface DeployContainerGroupServiceSetting {
        /**
         * 0: Public network, 1: Access within the cluster, 2: NodePort, 3: Access within VPC. Note: This field may return null, indicating that no valid values can be obtained.
         */
        accessType: number;
        /**
         * When set to true and DisableService is also true, the previously created service will be deleted. Please use with caution. Note: This field may return null, indicating that no valid values can be obtained.
         */
        allowDeleteService: boolean;
        /**
         * Whether to create a Kubernetes service. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
         */
        disableService: boolean;
        /**
         * Whether the service is of headless type. Note: This field may return null, indicating that no valid values can be obtained.
         */
        headlessService: boolean;
        /**
         * Enable session affinity. true means enabled, false means disabled. The default value is false. Note: This field may return null, indicating that no valid values can be obtained.
         */
        openSessionAffinity: boolean;
        /**
         * Container port mapping. Note: This field may return null, indicating that no valid values can be obtained.
         */
        protocolPorts: outputs.Tsf.DeployContainerGroupServiceSettingProtocolPort[];
        /**
         * Session affinity session time. The default value is 10800. Note: This field may return null, indicating that no valid values can be obtained.
         */
        sessionAffinityTimeoutSeconds: number;
        /**
         * subnet Id.
         */
        subnetId: string;
    }

    export interface DeployContainerGroupServiceSettingProtocolPort {
        /**
         * node port.
         */
        nodePort: number;
        /**
         * port.
         */
        port: number;
        /**
         * TCP or UDP.
         */
        protocol: string;
        /**
         * container port.
         */
        targetPort: number;
    }

    export interface DeployContainerGroupVolumeInfoList {
        /**
         * volume config.
         */
        volumeConfig: string;
        /**
         * volume name.
         */
        volumeName: string;
        /**
         * volume type.
         */
        volumeType: string;
    }

    export interface DeployContainerGroupVolumeMountInfoList {
        /**
         * Read and write access mode. 1: Read-only. 2: Read-write.
         */
        readOrWrite: string;
        /**
         * mount volume name.
         */
        volumeMountName: string;
        /**
         * mount path.
         */
        volumeMountPath: string;
        /**
         * mount subPath.
         */
        volumeMountSubPath: string;
    }

    export interface DeployContainerGroupWarmupSetting {
        /**
         * Preheating curvature, with a value between 1 and 5.
         */
        curvature: number;
        /**
         * Whether to enable preheating.
         */
        enabled: boolean;
        /**
         * Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
         */
        enabledProtection: boolean;
        /**
         * warmup time.
         */
        warmupTime: number;
    }

    export interface DeployVmGroupAgentProfileList {
        /**
         * Agent type.
         */
        agentType: string;
        /**
         * Agent version.
         */
        agentVersion: string;
    }

    export interface DeployVmGroupHealthCheckSettings {
        /**
         * Survival health check. Note: This field may return null, indicating that no valid value was found.
         */
        livenessProbe: outputs.Tsf.DeployVmGroupHealthCheckSettingsLivenessProbe;
        /**
         * Readiness health check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        readinessProbe: outputs.Tsf.DeployVmGroupHealthCheckSettingsReadinessProbe;
    }

    export interface DeployVmGroupHealthCheckSettingsLivenessProbe {
        /**
         * Health check method. HTTP: check through HTTP interface; CMD: check through executing command; TCP: check through establishing TCP connection. Note: This field may return null, indicating that no valid value was found.
         */
        actionType: string;
        /**
         * The command to be executed for command health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        commands: string[];
        /**
         * The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
         */
        failureThreshold: number;
        /**
         * The time delay for the container to start the health check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        initialDelaySeconds: number;
        /**
         * The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        path: string;
        /**
         * The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        periodSeconds: number;
        /**
         * The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
         */
        port: number;
        /**
         * The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
         */
        scheme: string;
        /**
         * The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
         */
        successThreshold: number;
        /**
         * The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
         */
        timeoutSeconds: number;
        /**
         * The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface DeployVmGroupHealthCheckSettingsReadinessProbe {
        /**
         * The health check method. HTTP indicates checking through an HTTP interface, CMD indicates checking through executing a command, and TCP indicates checking through establishing a TCP connection. Note: This field may return null, indicating that no valid values can be obtained.
         */
        actionType: string;
        /**
         * The command to be executed for command check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        commands: string[];
        /**
         * The number of consecutive successful health checks required for the backend container to transition from success to failure. Note: This field may return null, indicating that no valid values can be obtained.
         */
        failureThreshold: number;
        /**
         * The time to delay the start of the container health check. Note: This field may return null, indicating that no valid values can be obtained.
         */
        initialDelaySeconds: number;
        /**
         * The request path for HTTP health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        path: string;
        /**
         * The time interval for performing health checks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        periodSeconds: number;
        /**
         * The port used for health checks, ranging from 1 to 65535. Note: This field may return null, indicating that no valid values can be obtained.
         */
        port: number;
        /**
         * The protocol used for HTTP health checks. HTTP and HTTPS are supported. Note: This field may return null, indicating that no valid values can be obtained.
         */
        scheme: string;
        /**
         * The number of consecutive successful health checks required for the backend container to transition from failure to success. Note: This field may return null, indicating that no valid values can be obtained.
         */
        successThreshold: number;
        /**
         * The maximum timeout period for each health check response. Note: This field may return null, indicating that no valid values can be obtained.
         */
        timeoutSeconds: number;
        /**
         * The type of readiness probe. TSF_DEFAULT represents the default readiness probe of TSF, while K8S_NATIVE represents the native readiness probe of Kubernetes. If this field is not specified, the native readiness probe of Kubernetes is used by default. Note: This field may return null, indicating that no valid values can be obtained.
         */
        type: string;
    }

    export interface DeployVmGroupWarmupSetting {
        /**
         * Preheating curvature, with a value between 1 and 5.
         */
        curvature: number;
        /**
         * Whether to enable preheating.
         */
        enabled: boolean;
        /**
         * Whether to enable preheating protection. If protection is enabled and more than 50% of nodes are in preheating state, preheating will be aborted.
         */
        enabledProtection: boolean;
        /**
         * warmup time.
         */
        warmupTime: number;
    }

    export interface GetApiDetailResult {
        /**
         * can debug or not.
         */
        canRun: boolean;
        /**
         * api data struct.
         */
        definitions: outputs.Tsf.GetApiDetailResultDefinition[];
        /**
         * param description.
         */
        description: string;
        /**
         * api content type.
         */
        requestContentType: string;
        /**
         * api request description.
         */
        requests: outputs.Tsf.GetApiDetailResultRequest[];
        /**
         * api response.
         */
        responses: outputs.Tsf.GetApiDetailResultResponse[];
        /**
         * API status 0: offline 1: online, default 0. Note: This section may return null, indicating that no valid value can be obtained.
         */
        status: number;
    }

    export interface GetApiDetailResultDefinition {
        /**
         * param description.
         */
        name: string;
        /**
         * object property list.
         */
        properties: outputs.Tsf.GetApiDetailResultDefinitionProperty[];
    }

    export interface GetApiDetailResultDefinitionProperty {
        /**
         * param description.
         */
        description: string;
        /**
         * param description.
         */
        name: string;
        /**
         * param type.
         */
        type: string;
    }

    export interface GetApiDetailResultRequest {
        /**
         * default value.
         */
        defaultValue: string;
        /**
         * param description.
         */
        description: string;
        /**
         * param position.
         */
        in: string;
        /**
         * param description.
         */
        name: string;
        /**
         * require or not.
         */
        required: boolean;
        /**
         * param type.
         */
        type: string;
    }

    export interface GetApiDetailResultResponse {
        /**
         * param description.
         */
        description: string;
        /**
         * param description.
         */
        name: string;
        /**
         * param type.
         */
        type: string;
    }

    export interface GetApiGroupResult {
        /**
         * Api group info.
         */
        contents: outputs.Tsf.GetApiGroupResultContent[];
        /**
         * record count.
         */
        totalCount: number;
    }

    export interface GetApiGroupResultContent {
        /**
         * Number of APIs.Note: This field may return null, indicating that no valid values can be obtained.
         */
        aclMode: string;
        /**
         * api count.
         */
        apiCount: number;
        /**
         * Authentication type. secret: Secret key authentication; none: No authentication.
         */
        authType: string;
        /**
         * The gateway group bind with the api group list.
         */
        bindedGatewayDeployGroups: outputs.Tsf.GetApiGroupResultContentBindedGatewayDeployGroup[];
        /**
         * Group creation time.Note: This field may return null, indicating that no valid values can be obtained.
         */
        createdTime: string;
        /**
         * Description.Note: This field may return null, indicating that no valid values can be obtained.
         */
        description: string;
        /**
         * Gateway Instance Id.
         */
        gatewayInstanceId: string;
        /**
         * Gateway Instance Type.Note: This field may return null, indicating that no valid values can be obtained.
         */
        gatewayInstanceType: string;
        /**
         * Api Group Context.Note: This field may return null, indicating that no valid values can be obtained.
         */
        groupContext: string;
        /**
         * Api Group Id.Note: This field may return null, indicating that no valid values can be obtained.
         */
        groupId: string;
        /**
         * Api Group Name.Note: This field may return null, indicating that no valid values can be obtained.
         */
        groupName: string;
        /**
         * Group type. ms: Microservice group; external: External API group.
         */
        groupType: string;
        /**
         * Namespace name key.Note: This field may return null, indicating that no valid values can be obtained.
         */
        namespaceNameKey: string;
        /**
         * Namespace parameter location, path, header, or query, default is path. Note: This field may return null, indicating that no valid values can be obtained.
         */
        namespaceNameKeyPosition: string;
        /**
         * Key value of microservice name parameter.Note: This field may return null, indicating that no valid values can be obtained.
         */
        serviceNameKey: string;
        /**
         * Microservice name parameter location, path, header, or query, default is path.Note: This field may return null, indicating that no valid values can be obtained.
         */
        serviceNameKeyPosition: string;
        /**
         * Publishing status. drafted: Not published. released: Published.
         */
        status: string;
        /**
         * Group creation time, such as: 2019-06-20 15:51:28.Note: This field may return null, indicating that no valid values can be obtained.
         */
        updatedTime: string;
    }

    export interface GetApiGroupResultContentBindedGatewayDeployGroup {
        /**
         * Application ID.Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationId: string;
        /**
         * Application Name.Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationName: string;
        /**
         * Application Name.Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationType: string;
        /**
         * Cluster type, C: container, V: virtual machine.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterType: string;
        /**
         * Gateway deployment group bound to the API group.Note: This field may return null, indicating that no valid values can be obtained.
         */
        deployGroupId: string;
        /**
         * Deploy group name.Note: This field may return null, indicating that no valid values can be obtained.
         */
        deployGroupName: string;
        /**
         * Application category: V: virtual machine application, C: container application. Note: This field may return null, indicating that no valid values can be obtained.
         */
        groupStatus: string;
    }

    export interface GetApplicationAttributeResult {
        /**
         * Number of deployment groups under the application.Note: This field may return null, indicating that no valid values can be obtained.
         */
        groupCount: number;
        /**
         * Total number of instances.Note: This field may return null, indicating that no valid values can be obtained.
         */
        instanceCount: number;
        /**
         * Number of running instances.Note: This field may return null, indicating that no valid values can be obtained.
         */
        runInstanceCount: number;
    }

    export interface GetApplicationConfigResult {
        /**
         * Configuration item list.
         */
        contents: outputs.Tsf.GetApplicationConfigResultContent[];
        /**
         * TsfPageConfig.
         */
        totalCount: number;
    }

    export interface GetApplicationConfigResultContent {
        /**
         * Application ID, query all when not provided.
         */
        applicationId: string;
        /**
         * application Id. Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationName: string;
        /**
         * Configuration ID, query all with higher priority when not provided.
         */
        configId: string;
        /**
         * Configuration name, precise query, query all when not provided.
         */
        configName: string;
        /**
         * Configuration type. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configType: string;
        /**
         * Configuration value. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configValue: string;
        /**
         * Configuration version, precise query, query all when not provided.
         */
        configVersion: string;
        /**
         * config version count.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        configVersionCount: number;
        /**
         * Configuration version description. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configVersionDesc: string;
        /**
         * CreationTime. Note: This field may return null, indicating that no valid values can be obtained.
         */
        creationTime: string;
        /**
         * delete flag, true: allow delete; false: delete prohibit.
         */
        deleteFlag: boolean;
        /**
         * last update time.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        lastUpdateTime: string;
    }

    export interface GetApplicationFileConfigResult {
        /**
         * File configuration array. Note: This field may return null, indicating that no valid values can be obtained.
         */
        contents: outputs.Tsf.GetApplicationFileConfigResultContent[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetApplicationFileConfigResultContent {
        /**
         * Application ID.
         */
        applicationId: string;
        /**
         * application name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationName: string;
        /**
         * Configuration file code. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configFileCode: string;
        /**
         * Configuration item file name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configFileName: string;
        /**
         * file config path. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configFilePath: string;
        /**
         * Configuration file content. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configFileValue: string;
        /**
         * config item content length.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        configFileValueLength: number;
        /**
         * Configuration ID.
         */
        configId: string;
        /**
         * Configuration item name.
         */
        configName: string;
        /**
         * last update time.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        configPostCmd: string;
        /**
         * Configuration item version.
         */
        configVersion: string;
        /**
         * config version count.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        configVersionCount: number;
        /**
         * Configuration item version description. Note: This field may return null, indicating that no valid values can be obtained.
         */
        configVersionDesc: string;
        /**
         * CreationTime. Note: This field may return null, indicating that no valid values can be obtained.
         */
        creationTime: string;
        /**
         * delete flag, true: allow delete; false: delete prohibit.
         */
        deleteFlag: boolean;
        /**
         * last update time.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        lastUpdateTime: string;
    }

    export interface GetApplicationPublicConfigResult {
        /**
         * Config list.
         */
        contents: outputs.Tsf.GetApplicationPublicConfigResultContent[];
        /**
         * TsfPageConfig.
         */
        totalCount: number;
    }

    export interface GetApplicationPublicConfigResultContent {
        /**
         * application Id. Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationId: string;
        /**
         * application Id. Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationName: string;
        /**
         * Config ID. Query all items if not passed, high priority.
         */
        configId: string;
        /**
         * Config name. Exact query. Query all items if not passed.
         */
        configName: string;
        /**
         * Config type. Note: This field may return null, indicating that no valid value can be obtained.
         */
        configType: string;
        /**
         * Config value. Note: This field may return null, indicating that no valid value can be obtained.
         */
        configValue: string;
        /**
         * Config version. Exact query. Query all items if not passed.
         */
        configVersion: string;
        /**
         * config version count.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        configVersionCount: number;
        /**
         * Config version description. Note: This field may return null, indicating that no valid value can be obtained.
         */
        configVersionDesc: string;
        /**
         * CreationTime. Note: This field may return null, indicating that no valid values can be obtained.
         */
        creationTime: string;
        /**
         * delete flag, true: allow delete; false: delete prohibit.
         */
        deleteFlag: boolean;
        /**
         * last update time.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        lastUpdateTime: string;
    }

    export interface GetApplicationResult {
        /**
         * The list of application information.
         */
        contents: outputs.Tsf.GetApplicationResultContent[];
        /**
         * The total number of applications.
         */
        totalCount: number;
    }

    export interface GetApplicationResultContent {
        /**
         * gateway service id.
         */
        apigatewayServiceId: string;
        /**
         * The description of the application.
         */
        applicationDesc: string;
        /**
         * The ID of the application.
         */
        applicationId: string;
        /**
         * The name of the application.
         */
        applicationName: string;
        /**
         * remark name.
         */
        applicationRemarkName: string;
        /**
         * application resource type.
         */
        applicationResourceType: string;
        /**
         * application runtime type.
         */
        applicationRuntimeType: string;
        /**
         * The application type. V OR C, V means VM, C means container.
         */
        applicationType: string;
        /**
         * create time.
         */
        createTime: string;
        /**
         * whether ignore create image repository.
         */
        ignoreCreateImageRepository: boolean;
        /**
         * The microservice type of the application.
         */
        microserviceType: string;
        /**
         * Programming language.
         */
        progLang: string;
        /**
         * service config list.
         */
        serviceConfigLists: outputs.Tsf.GetApplicationResultContentServiceConfigList[];
        /**
         * update time.
         */
        updateTime: string;
    }

    export interface GetApplicationResultContentServiceConfigList {
        /**
         * health check setting.
         */
        healthChecks: outputs.Tsf.GetApplicationResultContentServiceConfigListHealthCheck[];
        /**
         * serviceName.
         */
        name: string;
        /**
         * port list.
         */
        ports: outputs.Tsf.GetApplicationResultContentServiceConfigListPort[];
    }

    export interface GetApplicationResultContentServiceConfigListHealthCheck {
        /**
         * health check path.
         */
        path: string;
    }

    export interface GetApplicationResultContentServiceConfigListPort {
        /**
         * protocol.
         */
        protocol: string;
        /**
         * service port.
         */
        targetPort: number;
    }

    export interface GetBusinessLogConfigsResult {
        /**
         * Log configuration item list. Note: This field may return null, indicating that no valid values can be obtained.
         */
        contents: outputs.Tsf.GetBusinessLogConfigsResultContent[];
        /**
         * Total Count.Note: This field may return null, indicating that no valid values can be obtained.
         */
        totalCount: number;
    }

    export interface GetBusinessLogConfigsResultContent {
        /**
         * the associate group of Config.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configAssociatedGroups: outputs.Tsf.GetBusinessLogConfigsResultContentConfigAssociatedGroup[];
        /**
         * Create time of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configCreateTime: string;
        /**
         * Description of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configDesc: string;
        /**
         * ConfigId.
         */
        configId: string;
        /**
         * ConfigName.
         */
        configName: string;
        /**
         * Log path of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configPath: string;
        /**
         * Pipeline of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configPipeline: string;
        /**
         * ParserSchema of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configSchemas: outputs.Tsf.GetBusinessLogConfigsResultContentConfigSchema[];
        /**
         * configuration Tag.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configTags: string;
        /**
         * Update time of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        configUpdateTime: string;
    }

    export interface GetBusinessLogConfigsResultContentConfigAssociatedGroup {
        /**
         * Application Id of Group. Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationId: string;
        /**
         * Application Name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationName: string;
        /**
         * Application Type. Note: This field may return null, indicating that no valid values can be obtained.
         */
        applicationType: string;
        /**
         * Time when the deployment group is associated with the log configuration.Note: This field may return null, indicating that no valid values can be obtained.
         */
        associatedTime: string;
        /**
         * Cluster ID to which the deployment group belongs.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterId: string;
        /**
         * Cluster Name to which the deployment group belongs.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterName: string;
        /**
         * Cluster type to which the deployment group belongs.Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterType: string;
        /**
         * Group Id. Note: This field may return null, indicating that no valid values can be obtained.
         */
        groupId: string;
        /**
         * Group Name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        groupName: string;
        /**
         * Namespace ID to which the deployment group belongs.Note: This field may return null, indicating that no valid values can be obtained.
         */
        namespaceId: string;
        /**
         * Namespace Name to which the deployment group belongs.Note: This field may return null, indicating that no valid values can be obtained.
         */
        namespaceName: string;
    }

    export interface GetBusinessLogConfigsResultContentConfigSchema {
        /**
         * content of schema.
         */
        schemaContent: string;
        /**
         * Create time of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        schemaCreateTime: string;
        /**
         * Schema format.Note: This field may return null, indicating that no valid values can be obtained.
         */
        schemaDateFormat: string;
        /**
         * Schema pattern of configuration item.Note: This field may return null, indicating that no valid values can be obtained.
         */
        schemaMultilinePattern: string;
        /**
         * User-defined parsing rules.Note: This field may return null, indicating that no valid values can be obtained.
         */
        schemaPatternLayout: string;
        /**
         * Schema type.
         */
        schemaType: number;
    }

    export interface GetClusterResult {
        /**
         * Cluster list. Note: This field may return null, indicating no valid values.
         */
        contents: outputs.Tsf.GetClusterResultContent[];
        /**
         * Total number of items. Note: This field may return null, indicating that no valid value was found.
         */
        totalCount: number;
    }

    export interface GetClusterResultContent {
        /**
         * cluster CIDR. Note: This field may return null, indicating no valid value.
         */
        clusterCidr: string;
        /**
         * Cluster description. Note: This field may return null, indicating no valid value.
         */
        clusterDesc: string;
        /**
         * Cluster ID. Note: This field may return null, indicating no valid value.
         */
        clusterId: string;
        /**
         * Maximum CPU limit of the cluster, in cores. This field may return null, indicating that no valid value was found.
         */
        clusterLimitCpu: number;
        /**
         * Cluster maximum memory limit in GB. This field may return null, indicating that no valid value was found.
         */
        clusterLimitMem: number;
        /**
         * Cluster name. Note: This field may return null, indicating no valid value.
         */
        clusterName: string;
        /**
         * cluster status. Note: This field may return null, indicating no valid value.
         */
        clusterStatus: string;
        /**
         * Total CPU of the cluster, unit: cores. Note: This field may return null, indicating that no valid value was found.
         */
        clusterTotalCpu: number;
        /**
         * Total memory of the cluster, unit: G. Note: This field may return null, indicating that no valid value is obtained.
         */
        clusterTotalMem: number;
        /**
         * The type of cluster to be queried, if left blank or not passed, all content will be queried. C: container, V: virtual machine.
         */
        clusterType: string;
        /**
         * Used CPU of the cluster, in cores. This field may return null, indicating no valid value.
         */
        clusterUsedCpu: number;
        /**
         * Cluster used memory in GB. This field may return null, indicating no valid value.
         */
        clusterUsedMem: number;
        /**
         * The cluster version, may return null if not applicable.
         */
        clusterVersion: string;
        /**
         * CreationTime. Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Deletion tag: true means it can be deleted, false means it cannot be deleted. Note: This field may return null, indicating no valid value.
         */
        deleteFlag: boolean;
        /**
         * Reason why the cluster cannot be deleted.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        deleteFlagReason: string;
        /**
         * Cluster instance number. This field may return null, indicating no valid value.
         */
        instanceCount: number;
        /**
         * Cluster normal instance number. This field may return null, indicating no valid value.
         */
        normalInstanceCount: number;
        /**
         * Control information returned to the frontend. This field may return null, indicating no valid value.
         */
        operationInfos: outputs.Tsf.GetClusterResultContentOperationInfo[];
        /**
         * Cluster running instance number. This field may return null, indicating no valid value.
         */
        runInstanceCount: number;
        /**
         * Number of available service instances in the cluster. Note: This field may return null, indicating no valid value.
         */
        runServiceInstanceCount: number;
        /**
         * Cluster subnet ID. Note: This field may return null, indicating no valid values.
         */
        subnetId: string;
        /**
         * region ID of TSF.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        tsfRegionId: string;
        /**
         * region name of TSF.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        tsfRegionName: string;
        /**
         * Zone Id of TSF.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        tsfZoneId: string;
        /**
         * Zone name of TSF.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        tsfZoneName: string;
        /**
         * last update time.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        updateTime: string;
        /**
         * Private network ID of the cluster. Note: This field may return null, indicating no valid value.
         */
        vpcId: string;
    }

    export interface GetClusterResultContentOperationInfo {
        /**
         * Add instance button control information, Note: This field may return null, indicating that no valid value is obtained.
         */
        addInstances: outputs.Tsf.GetClusterResultContentOperationInfoAddInstance[];
        /**
         * Control information for destroying machine, may return null if no valid value is obtained.
         */
        destroys: outputs.Tsf.GetClusterResultContentOperationInfoDestroy[];
        /**
         * Control information of the initialization button returned to the front end. Note: This field may return null, indicating no valid value.
         */
        inits: outputs.Tsf.GetClusterResultContentOperationInfoInit[];
    }

    export interface GetClusterResultContentOperationInfoAddInstance {
        /**
         * Reason for not displaying. Note: This field may return null, indicating no valid value.
         */
        disabledReason: string;
        /**
         * The availability of the button (whether it is clickable) may return null indicating that the information is not available.
         */
        enabled: boolean;
        /**
         * Whether to display the button. Note: This field may return null, indicating that no valid value was found.
         */
        supported: boolean;
    }

    export interface GetClusterResultContentOperationInfoDestroy {
        /**
         * Reason for not displaying. Note: This field may return null, indicating no valid value.
         */
        disabledReason: string;
        /**
         * The availability of the button (whether it is clickable) may return null indicating that the information is not available.
         */
        enabled: boolean;
        /**
         * Whether to display the button. Note: This field may return null, indicating that no valid value was found.
         */
        supported: boolean;
    }

    export interface GetClusterResultContentOperationInfoInit {
        /**
         * Reason for not displaying. Note: This field may return null, indicating no valid value.
         */
        disabledReason: string;
        /**
         * The availability of the button (whether it is clickable) may return null indicating that the information is not available.
         */
        enabled: boolean;
        /**
         * Whether to display the button. Note: This field may return null, indicating that no valid value was found.
         */
        supported: boolean;
    }

    export interface GetConfigSummaryResult {
        /**
         * config list.
         */
        contents: outputs.Tsf.GetConfigSummaryResultContent[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetConfigSummaryResultContent {
        /**
         * Application ID. If not passed, the query will be for all.
         */
        applicationId: string;
        /**
         * Application Name. Note: This field may return null, indicating that no valid value was found.
         */
        applicationName: string;
        /**
         * Configuration item ID.Note: This field may return null, indicating that no valid value was found.
         */
        configId: string;
        /**
         * Configuration name.Note: This field may return null, indicating that no valid value was found.
         */
        configName: string;
        /**
         * Config type. Note: This field may return null, indicating that no valid value was found.
         */
        configType: string;
        /**
         * Configuration value.Note: This field may return null, indicating that no valid value was found.
         */
        configValue: string;
        /**
         * Configuration version. Note: This field may return null, indicating that no valid value was found.
         */
        configVersion: string;
        /**
         * Configure version count.Note: This field may return null, indicating that no valid value was found.
         */
        configVersionCount: number;
        /**
         * Configuration version description.Note: This field may return null, indicating that no valid value was found.
         */
        configVersionDesc: string;
        /**
         * Create time.Note: This field may return null, indicating that no valid value was found.
         */
        creationTime: string;
        /**
         * Deletion flag, true: deletable; false: not deletable.Note: This field may return null, indicating that no valid value was found.
         */
        deleteFlag: boolean;
        /**
         * Last update time.Note: This field may return null, indicating that no valid value was found.
         */
        lastUpdateTime: string;
    }

    export interface GetContainerGroupResult {
        /**
         * List of deployment groups.Note: This field may return null, indicating that no valid value was found.
         */
        contents: outputs.Tsf.GetContainerGroupResultContent[];
        /**
         * Total count.
         */
        totalCount: number;
    }

    export interface GetContainerGroupResultContent {
        /**
         * The Group description.Note: This field may return null, indicating that no valid value was found.
         */
        alias: string;
        /**
         * Cluster Id.
         */
        clusterId: string;
        /**
         * Cluster name.Note: This field may return null, indicating that no valid value was found.
         */
        clusterName: string;
        /**
         * The maximum amount of CPU, corresponding to K8S limit.Note: This field may return null, indicating that no valid value was found.
         */
        cpuLimit: string;
        /**
         * The initial amount of CPU, corresponding to K8S request.Note: This field may return null, indicating that no valid value was found.
         */
        cpuRequest: string;
        /**
         * Create time.Note: This field may return null, indicating that no valid value was found.
         */
        createTime: string;
        /**
         * Group Id.Note: This field may return null, indicating that no valid value was found.
         */
        groupId: string;
        /**
         * Group name.Note: This field may return null, indicating that no valid value was found.
         */
        groupName: string;
        /**
         * The value of KubeInjectEnable.Note: This field may return null, indicating that no valid value was found.
         */
        kubeInjectEnable: boolean;
        /**
         * The maximum amount of memory allocated in MiB, corresponding to K8S limit.Note: This field may return null, indicating that no valid value was found.
         */
        memLimit: string;
        /**
         * The initial amount of memory allocated in MiB, corresponding to K8S request.Note: This field may return null, indicating that no valid value was found.
         */
        memRequest: string;
        /**
         * Namespace Id.
         */
        namespaceId: string;
        /**
         * Namespace name.Note: This field may return null, indicating that no valid value was found.
         */
        namespaceName: string;
        /**
         * Image name.Note: This field may return null, indicating that no valid value was found.
         */
        repoName: string;
        /**
         * Image server.Note: This field may return null, indicating that no valid value was found.
         */
        server: string;
        /**
         * Image version Name.Note: This field may return null, indicating that no valid value was found.
         */
        tagName: string;
        /**
         * Update type.Note: This field may return null, indicating that no valid value was found.
         */
        updatedTime: string;
    }

    export interface GetDeliveryConfigByGroupIdResult {
        /**
         * Config ID. Note: This field may return null, which means that no valid value was obtained.
         */
        configId: string;
        /**
         * Config Name. Note: This field may return null, which means that no valid value was obtained.
         */
        configName: string;
    }

    export interface GetDeliveryConfigsResult {
        /**
         * content. Note: This field may return null, which means that no valid value was obtained.
         */
        contents: outputs.Tsf.GetDeliveryConfigsResultContent[];
        /**
         * total count. Note: This field may return null, which means that no valid value was obtained.
         */
        totalCount: number;
    }

    export interface GetDeliveryConfigsResultContent {
        /**
         * harvest log path. Note: This field may return null, which means that no valid value was obtained.
         */
        collectPaths: string[];
        /**
         * config id.
         */
        configId: string;
        /**
         * config name.
         */
        configName: string;
        /**
         * Creation time.Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Custom Line Rule.
         */
        customRule: string;
        /**
         * whether use auth for kafka. Note: This field may return null, which means that no valid value was obtained.
         */
        enableAuth: boolean;
        /**
         * Indicates whether a single row rule should be applied.Note: This field may return null, which means that no valid value was obtained.
         */
        enableGlobalLineRule: boolean;
        /**
         * Associated deployment group information.Note: This field may return null, indicating that no valid values can be obtained.
         */
        groups: outputs.Tsf.GetDeliveryConfigsResultContentGroup[];
        /**
         * KafkaAddress refers to the address of a Kafka server.Note: This field may return null, which means that no valid value was obtained.
         */
        kafkaAddress: string;
        /**
         * Kafka Infos. Note: This field may return null, which means that no valid value was obtained.
         */
        kafkaInfos: outputs.Tsf.GetDeliveryConfigsResultContentKafkaInfo[];
        /**
         * Kafka VIP. Note: This field may return null, which means that no valid value was obtained.
         */
        kafkaVIp: string;
        /**
         * Kafka VPort. Note: This field may return null, which means that no valid value was obtained.
         */
        kafkaVPort: string;
        /**
         * Line Rule for log. Note: This field may return null, which means that no valid value was obtained.
         */
        lineRule: string;
        /**
         * Password. Note: This field may return null, which means that no valid value was obtained.
         */
        password: string;
        /**
         * Topic. Note: This field may return null, which means that no valid value was obtained.
         */
        topic: string;
        /**
         * user Name. Note: This field may return null, which means that no valid value was obtained.
         */
        username: string;
    }

    export interface GetDeliveryConfigsResultContentGroup {
        /**
         * Associate Time. Note: This field may return null, indicating that no valid values can be obtained.
         */
        associateTime: string;
        /**
         * Cluster ID. Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterId: string;
        /**
         * Cluster Name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        clusterName: string;
        /**
         * Cluster type.
         */
        clusterType: string;
        /**
         * Group Id.
         */
        groupId: string;
        /**
         * Group Name.
         */
        groupName: string;
        /**
         * Namespace Name. Note: This field may return null, indicating that no valid values can be obtained.
         */
        namespaceName: string;
    }

    export interface GetDeliveryConfigsResultContentKafkaInfo {
        /**
         * Custom Line Rule.
         */
        customRule: string;
        /**
         * Line Rule for log. Note: This field may return null, which means that no valid value was obtained.
         */
        lineRule: string;
        /**
         * harvest log path. Note: This field may return null, which means that no valid value was obtained.
         */
        paths: string[];
        /**
         * Topic. Note: This field may return null, which means that no valid value was obtained.
         */
        topic: string;
    }

    export interface GetGatewayAllGroupApisResult {
        /**
         * gateway group Id.
         */
        gatewayDeployGroupId: string;
        /**
         * Gateway deployment group name.Note: This field may return null, which means no valid value was found.
         */
        gatewayDeployGroupName: string;
        /**
         * Gateway deployment api group number.Note: This field may return null, which means no valid value was found.
         */
        groupNum: number;
        /**
         * Gateway deployment  api group list.Note: This field may return null, which means no valid value was found.
         */
        groups: outputs.Tsf.GetGatewayAllGroupApisResultGroup[];
    }

    export interface GetGatewayAllGroupApisResultGroup {
        /**
         * gateway instance id.Note: This field may return null, which means no valid value was found.
         */
        gatewayInstanceId: string;
        /**
         * Type of the gateway instance.Note: This field may return null, which means no valid value was found.
         */
        gatewayInstanceType: string;
        /**
         * Number of APIs under the group. Note: This field may return null, which means no valid value was found.
         */
        groupApiCount: number;
        /**
         * List of APIs under the group.Note: This field may return null, which means no valid value was found.
         */
        groupApis: outputs.Tsf.GetGatewayAllGroupApisResultGroupGroupApi[];
        /**
         * api group id.Note: This field may return null, which means no valid value was found.
         */
        groupId: string;
        /**
         * api group name.Note: This field may return null, which means no valid value was found.
         */
        groupName: string;
    }

    export interface GetGatewayAllGroupApisResultGroupGroupApi {
        /**
         * API ID.
         */
        apiId: string;
        /**
         * API method.
         */
        method: string;
        /**
         * API service name.
         */
        microserviceName: string;
        /**
         * namespace name.
         */
        namespaceName: string;
        /**
         * API path.
         */
        path: string;
    }

    export interface GetGroupConfigReleaseResult {
        /**
         * Configuration item release list.Note: This field may return null, which means no valid value was found.
         */
        configReleaseLists: outputs.Tsf.GetGroupConfigReleaseResultConfigReleaseList[];
        /**
         * File configuration item release list.Note: This field may return null, which means no valid value was found.
         */
        fileConfigReleaseLists: outputs.Tsf.GetGroupConfigReleaseResultFileConfigReleaseList[];
        /**
         * Package Id.Note: This field may return null, which means no valid value was found.
         */
        packageId: string;
        /**
         * Package name.Note: This field may return null, which means no valid value was found.
         */
        packageName: string;
        /**
         * Package version.Note: This field may return null, which means no valid value was found.
         */
        packageVersion: string;
        /**
         * Release public config list.
         */
        publicConfigReleaseLists: outputs.Tsf.GetGroupConfigReleaseResultPublicConfigReleaseList[];
        /**
         * image name.Note: This field may return null, which means no valid value was found.
         */
        repoName: string;
        /**
         * image tag name.Note: This field may return null, which means no valid value was found.
         */
        tagName: string;
    }

    export interface GetGroupConfigReleaseResultConfigReleaseList {
        /**
         * Configuration item release application ID.Note: This field may return null, which means no valid value was found.
         */
        applicationId: string;
        /**
         * Configuration item release cluster ID.Note: This field may return null, which means no valid value was found.
         */
        clusterId: string;
        /**
         * Configuration item release cluster name.Note: This field may return null, which means no valid value was found.
         */
        clusterName: string;
        /**
         * Configuration item  ID.Note: This field may return null, which means no valid value was found.
         */
        configId: string;
        /**
         * Configuration item name.Note: This field may return null, which means no valid value was found.
         */
        configName: string;
        /**
         * Configuration item release ID.Note: This field may return null, which means no valid value was found.
         */
        configReleaseId: string;
        /**
         * Configuration version.Note: This field may return null, which means no valid value was found.
         */
        configVersion: string;
        /**
         * groupId.
         */
        groupId: string;
        /**
         * Configuration item release group name.Note: This field may return null, which means no valid value was found.
         */
        groupName: string;
        /**
         * Configuration item release namespace ID.Note: This field may return null, which means no valid value was found.
         */
        namespaceId: string;
        /**
         * Configuration item release namespace name.Note: This field may return null, which means no valid value was found.
         */
        namespaceName: string;
        /**
         * Configuration item release description.Note: This field may return null, which means no valid value was found.
         */
        releaseDesc: string;
        /**
         * Configuration item release time.Note: This field may return null, which means no valid value was found.
         */
        releaseTime: string;
    }

    export interface GetGroupConfigReleaseResultFileConfigReleaseList {
        /**
         * Configuration item release cluster ID.Note: This field may return null, which means no valid value was found.
         */
        clusterId: string;
        /**
         * Configuration item release cluster name.Note: This field may return null, which means no valid value was found.
         */
        clusterName: string;
        /**
         * Configuration item  ID.Note: This field may return null, which means no valid value was found.
         */
        configId: string;
        /**
         * Configuration item name.Note: This field may return null, which means no valid value was found.
         */
        configName: string;
        /**
         * Configuration item release ID.Note: This field may return null, which means no valid value was found.
         */
        configReleaseId: string;
        /**
         * Configuration version.Note: This field may return null, which means no valid value was found.
         */
        configVersion: string;
        /**
         * groupId.
         */
        groupId: string;
        /**
         * Configuration item release group name.Note: This field may return null, which means no valid value was found.
         */
        groupName: string;
        /**
         * Configuration item release namespace ID.Note: This field may return null, which means no valid value was found.
         */
        namespaceId: string;
        /**
         * Configuration item release namespace name.Note: This field may return null, which means no valid value was found.
         */
        namespaceName: string;
        /**
         * Configuration item release description.Note: This field may return null, which means no valid value was found.
         */
        releaseDesc: string;
        /**
         * Configuration item release time.Note: This field may return null, which means no valid value was found.
         */
        releaseTime: string;
    }

    export interface GetGroupConfigReleaseResultPublicConfigReleaseList {
        /**
         * Configuration item release application ID.Note: This field may return null, which means no valid value was found.
         */
        applicationId: string;
        /**
         * Configuration item release cluster ID.Note: This field may return null, which means no valid value was found.
         */
        clusterId: string;
        /**
         * Configuration item release cluster name.Note: This field may return null, which means no valid value was found.
         */
        clusterName: string;
        /**
         * Configuration item  ID.Note: This field may return null, which means no valid value was found.
         */
        configId: string;
        /**
         * Configuration item name.Note: This field may return null, which means no valid value was found.
         */
        configName: string;
        /**
         * Configuration item release ID.Note: This field may return null, which means no valid value was found.
         */
        configReleaseId: string;
        /**
         * Configuration version.Note: This field may return null, which means no valid value was found.
         */
        configVersion: string;
        /**
         * groupId.
         */
        groupId: string;
        /**
         * Configuration item release group name.Note: This field may return null, which means no valid value was found.
         */
        groupName: string;
        /**
         * Configuration item release namespace ID.Note: This field may return null, which means no valid value was found.
         */
        namespaceId: string;
        /**
         * Configuration item release namespace name.Note: This field may return null, which means no valid value was found.
         */
        namespaceName: string;
        /**
         * Configuration item release description.Note: This field may return null, which means no valid value was found.
         */
        releaseDesc: string;
        /**
         * Configuration item release time.Note: This field may return null, which means no valid value was found.
         */
        releaseTime: string;
    }

    export interface GetGroupGatewaysResult {
        /**
         * api group Info.
         */
        contents: outputs.Tsf.GetGroupGatewaysResultContent[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetGroupGatewaysResultContent {
        /**
         * ACL type for accessing the group.Note: This field may return null, which means no valid value was found.
         */
        aclMode: string;
        /**
         * Number of APIs.Note: This field may return null, which means no valid value was found.
         */
        apiCount: number;
        /**
         * Authentication type. secret: key authentication; none: no authentication.Note: This field may return null, which means no valid value was found.
         */
        authType: string;
        /**
         * Gateway deployment group bound to the API group.Note: This field may return null, which means no valid value was found.
         */
        bindedGatewayDeployGroups: outputs.Tsf.GetGroupGatewaysResultContentBindedGatewayDeployGroup[];
        /**
         * Group creation time, such as: 2019-06-20 15:51:28.Note: This field may return null, which means no valid value was found.
         */
        createdTime: string;
        /**
         * Description.Note: This field may return null, which means no valid value was found.
         */
        description: string;
        /**
         * Gateway instance ID.Note: This field may return null, which means no valid value was found.
         */
        gatewayInstanceId: string;
        /**
         * Gateway instance type.Note: This field may return null, which means no valid value was found.
         */
        gatewayInstanceType: string;
        /**
         * api group context.Note: This field may return null, which means no valid value was found.
         */
        groupContext: string;
        /**
         * api group id.Note: This field may return null, which means no valid value was found.
         */
        groupId: string;
        /**
         * api group name.Note: This field may return null, which means no valid value was found.
         */
        groupName: string;
        /**
         * Group type. ms: microservice group; external: external API group.This field may return null, which means no valid value was found.
         */
        groupType: string;
        /**
         * Namespace parameter key.Note: This field may return null, which means no valid value was found.
         */
        namespaceNameKey: string;
        /**
         * Namespace parameter location, path, header, or query. The default is path.Note: This field may return null, which means no valid value was found.
         */
        namespaceNameKeyPosition: string;
        /**
         * Microservice name parameter key.Note: This field may return null, which means no valid value was found.
         */
        serviceNameKey: string;
        /**
         * Microservice name parameter location, path, header, or query. The default is path.Note: This field may return null, which means no valid value was found.
         */
        serviceNameKeyPosition: string;
        /**
         * Release status. drafted: not released. released: released.Note: This field may return null, which means no valid value was found.
         */
        status: string;
        /**
         * Group update time, such as: 2019-06-20 15:51:28.Note: This field may return null, which means no valid value was found.
         */
        updatedTime: string;
    }

    export interface GetGroupGatewaysResultContentBindedGatewayDeployGroup {
        /**
         * application ID.Note: This field may return null, which means no valid value was found.
         */
        applicationId: string;
        /**
         * application name.Note: This field may return null, which means no valid value was found.
         */
        applicationName: string;
        /**
         * Application category: V: virtual machine application, C: container application.Note: This field may return null, which means no valid value was found.
         */
        applicationType: string;
        /**
         * Cluster type, with possible values: C: container, V: virtual machine.Note: This field may return null, which means no valid value was found.
         */
        clusterType: string;
        /**
         * Gateway deployment group ID.Note: This field may return null, which means no valid value was found.
         */
        deployGroupId: string;
        /**
         * Gateway deployment group name.Note: This field may return null, which means no valid value was found.
         */
        deployGroupName: string;
        /**
         * Application status of the deployment group, with possible values: Running, Waiting, Paused, Updating, RollingBack, Abnormal, Unknown.Note: This field may return null, which means no valid value was found.
         */
        groupStatus: string;
    }

    export interface GetGroupInstancesResult {
        /**
         * List of machine instances.Note: This field may return null, which means no valid value was found.
         */
        contents: outputs.Tsf.GetGroupInstancesResultContent[];
        /**
         * Total number of machine instances.Note: This field may return null, which means no valid value was found.
         */
        totalCount: number;
    }

    export interface GetGroupInstancesResultContent {
        /**
         * Agent version.Note: This field may return null, which means no valid value was found.
         */
        agentVersion: string;
        /**
         * Application id.Note: This field may return null, which means no valid value was found.
         */
        applicationId: string;
        /**
         * Application name. Note: This field may return null, which means no valid value was found.
         */
        applicationName: string;
        /**
         * application resource id.Note: This field may return null, which means no valid value was found.
         */
        applicationResourceType: string;
        /**
         * Application id.Note: This field may return null, which means no valid value was found.
         */
        applicationType: string;
        /**
         * Cluster id.Note: This field may return null, which means no valid value was found.
         */
        clusterId: string;
        /**
         * Cluster name. Note: This field may return null, which means no valid value was found.
         */
        clusterName: string;
        /**
         * Cluster type.Note: This field may return null, which means no valid value was found.
         */
        clusterType: string;
        /**
         * Indicates whether this instance has been added to the TSF.Note: This field may return null, which means no valid value was found.
         */
        countInTsf: number;
        /**
         * group id.
         */
        groupId: string;
        /**
         * Group name.Note: This field may return null, which means no valid value was found.
         */
        groupName: string;
        /**
         * VM availability status. For virtual machines, it indicates whether the virtual machine can be used as a resource. For containers, it indicates whether the virtual machine can be used to deploy pods.Note: This field may return null, which means no valid value was found.
         */
        instanceAvailableStatus: string;
        /**
         * machine instance charge type.Note: This field may return null, which means no valid value was found.
         */
        instanceChargeType: string;
        /**
         * Creation time of the machine instance in CVM.Note: This field may return null, which means no valid value was found.
         */
        instanceCreatedTime: string;
        /**
         * Description.Note: This field may return null, which means no valid value was found.
         */
        instanceDesc: string;
        /**
         * Expire time of the machine instance in CVM.Note: This field may return null, which means no valid value was found.
         */
        instanceExpiredTime: string;
        /**
         * Machine instance ID.Note: This field may return null, which means no valid value was found.
         */
        instanceId: string;
        /**
         * InstanceImportMode import mode.Note: This field may return null, which means no valid value was found.
         */
        instanceImportMode: string;
        /**
         * Limit CPU information of the machine instance.Note: This field may return null, which means no valid value was found.
         */
        instanceLimitCpu: number;
        /**
         * Limit memory information of the machine instance.Note: This field may return null, which means no valid value was found.
         */
        instanceLimitMem: number;
        /**
         * Machine name.Note: This field may return null, which means no valid value was found.
         */
        instanceName: string;
        /**
         * instance pkg version.Note: This field may return null, which means no valid value was found.
         */
        instancePkgVersion: string;
        /**
         * VM status. For virtual machines, it indicates the status of the virtual machine. For containers, it indicates the status of the virtual machine where the pod is located.Note: This field may return null, which means no valid value was found.
         */
        instanceStatus: string;
        /**
         * Total CPU information of the machine instance.Note: This field may return null, which means no valid value was found.
         */
        instanceTotalCpu: number;
        /**
         * Total memory information of the machine instance.Note: This field may return null, which means no valid value was found.
         */
        instanceTotalMem: number;
        /**
         * CPU information used by the machine instance.Note: This field may return null, which means no valid value was found.
         */
        instanceUsedCpu: number;
        /**
         * Memory information used by the machine instance.Note: This field may return null, which means no valid value was found.
         */
        instanceUsedMem: number;
        /**
         * Instance zone id.Note: This field may return null, which means no valid value was found.
         */
        instanceZoneId: string;
        /**
         * Private IP address.Note: This field may return null, which means no valid value was found.
         */
        lanIp: string;
        /**
         * Namespace id.Note: This field may return null, which means no valid value was found.
         */
        namespaceId: string;
        /**
         * Namespace name.Note: This field may return null, which means no valid value was found.
         */
        namespaceName: string;
        /**
         * Container host instance ID.Note: This field may return null, which means no valid value was found.
         */
        nodeInstanceId: string;
        /**
         * Execution status of the instance.Note: This field may return null, which means no valid value was found.
         */
        operationState: number;
        /**
         * Health checking reason.Note: This field may return null, which means no valid value was found.
         */
        reason: string;
        /**
         * Business status of the machine instance.Note: This field may return null, which means no valid value was found.
         */
        restrictState: string;
        /**
         * Status of service instances under the service. For virtual machines, it indicates whether the application is available and the agent status. For containers, it indicates the status of the pod.Note: This field may return null, which means no valid value was found.
         */
        serviceInstanceStatus: string;
        /**
         * Sidecar status.Note: This field may return null, which means no valid value was found.
         */
        serviceSidecarStatus: string;
        /**
         * Update time.Note: This field may return null, which means no valid value was found.
         */
        updateTime: string;
        /**
         * Public IP address.Note: This field may return null, which means no valid value was found.
         */
        wanIp: string;
    }

    export interface GetGroupsResult {
        /**
         * Virtual machine deployment group list. Note: This field may return null, indicating that no valid value was found.
         */
        contents: outputs.Tsf.GetGroupsResultContent[];
        /**
         * Total count virtual machine deployment group. Note: This field may return null, indicating that no valid value was found.
         */
        totalCount: number;
    }

    export interface GetGroupsResultContent {
        /**
         * Group alias. Note: This field may return null, indicating that no valid value was found.
         */
        alias: string;
        /**
         * applicationId.
         */
        applicationId: string;
        /**
         * Application name. Note: This field may return null, indicating that no valid value was found.
         */
        applicationName: string;
        /**
         * Application type. Note: This field may return null, indicating that no valid value was found.
         */
        applicationType: string;
        /**
         * clusterId.
         */
        clusterId: string;
        /**
         * Cluster name. Note: This field may return null, indicating that no valid value was found.
         */
        clusterName: string;
        /**
         * Create Time. Note: This field may return null, indicating that no valid value was found.
         */
        createTime: string;
        /**
         * Group description. Note: This field may return null, indicating that no valid value was found.
         */
        deployDesc: string;
        /**
         * Group description. Note: This field may return null, indicating that no valid value was found.
         */
        groupDesc: string;
        /**
         * Group ID. Note: This field may return null, indicating that no valid value was found.
         */
        groupId: string;
        /**
         * Group ID. Note: This field may return null, indicating that no valid value was found.
         */
        groupName: string;
        /**
         * Group resource type. Note: This field may return null, indicating that no valid value was found.
         */
        groupResourceType: string;
        /**
         * Microservice type. Note: This field may return null, indicating that no valid value was found.
         */
        microserviceType: string;
        /**
         * namespace Id.
         */
        namespaceId: string;
        /**
         * Namespace name. Note: This field may return null, indicating that no valid value was found.
         */
        namespaceName: string;
        /**
         * Group start up Parameters. Note: This field may return null, indicating that no valid value was found.
         */
        startupParameters: string;
        /**
         * Group update time. Note: This field may return null, indicating that no valid value was found.
         */
        updateTime: string;
        /**
         * Update time. Note: This field may return null, indicating that no valid value was found.
         */
        updatedTime: number;
    }

    export interface GetMicroserviceApiVersionResult {
        /**
         * Application ID.
         */
        applicationId: string;
        /**
         * Application Name.
         */
        applicationName: string;
        /**
         * application pkg version.
         */
        pkgVersion: string;
    }

    export interface GetMicroserviceResult {
        /**
         * Microservice list information. Note: This field may return null, indicating that no valid value can be obtained.
         */
        contents: outputs.Tsf.GetMicroserviceResultContent[];
        /**
         * Microservice paging list information. Note: This field may return null, indicating that no valid value can be obtained.
         */
        totalCount: number;
    }

    export interface GetMicroserviceResultContent {
        /**
         * CreationTime. Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: number;
        /**
         * offline instance count.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        criticalInstanceCount: number;
        /**
         * Microservice description. Note: This field may return null, indicating that no valid value can be obtained.
         */
        microserviceDesc: string;
        /**
         * Microservice Id. Note: This field may return null, indicating that no valid value can be obtained.
         */
        microserviceId: string;
        /**
         * Microservice name. Note: This field may return null, indicating that no valid value can be obtained.
         */
        microserviceName: string;
        /**
         * namespace id.
         */
        namespaceId: string;
        /**
         * run instance count in namespace.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        runInstanceCount: number;
        /**
         * last update time.  Note: This field may return null, indicating that no valid values can be obtained.
         */
        updateTime: number;
    }

    export interface GetMsApiListResult {
        /**
         * api list.
         */
        contents: outputs.Tsf.GetMsApiListResultContent[];
        /**
         * Quantity.
         */
        totalCount: number;
    }

    export interface GetMsApiListResultContent {
        /**
         * Method description. Note: This field may return null, indicating that no valid value was found.
         */
        description: string;
        /**
         * api method.
         */
        method: string;
        /**
         * api path.
         */
        path: string;
        /**
         * API status. 0: offline, 1: online.Note: This field may return null, indicating that no valid value was found.
         */
        status: number;
    }

    export interface GetPodInstancesResult {
        /**
         * Content list.Note: This field may return null, which means no valid value was found.
         */
        contents: outputs.Tsf.GetPodInstancesResultContent[];
        /**
         * Total number of records.Note: This field may return null, which means no valid value was found.
         */
        totalCount: number;
    }

    export interface GetPodInstancesResultContent {
        /**
         * Instance start time.Note: This field may return null, which means no valid value was found.
         */
        createdAt: string;
        /**
         * Instance available status.Note: This field may return null, which means no valid value was found.
         */
        instanceAvailableStatus: string;
        /**
         * Instance status.Note: This field may return null, which means no valid value was found.
         */
        instanceStatus: string;
        /**
         * Instance ip.Note: This field may return null, which means no valid value was found.
         */
        ip: string;
        /**
         * Instance node id.Note: This field may return null, which means no valid value was found.
         */
        nodeInstanceId: string;
        /**
         * Instance node ip.Note: This field may return null, which means no valid value was found.
         */
        nodeIp: string;
        /**
         * Instance id (corresponding to the pod instance id in Kubernetes).Note: This field may return null, which means no valid value was found.
         */
        podId: string;
        /**
         * Instance name (corresponding to the pod name in Kubernetes).Note: This field may return null, which means no valid value was found.
         */
        podName: string;
        /**
         * Instance ready count.Note: This field may return null, which means no valid value was found.
         */
        readyCount: number;
        /**
         * Instance reason for current status.Note: This field may return null, which means no valid value was found.
         */
        reason: string;
        /**
         * Instance restart count.Note: This field may return null, which means no valid value was found.
         */
        restartCount: number;
        /**
         * Instance run time.Note: This field may return null, which means no valid value was found.
         */
        runtime: string;
        /**
         * Instance serve status.Note: This field may return null, which means no valid value was found.
         */
        serviceInstanceStatus: string;
        /**
         * Instance status. Please refer to the definition of instance and container status below. Starting (pod not ready): Starting; Running: Running; Abnormal: Abnormal; Stopped: Stopped;Note: This field may return null, which means no valid value was found.
         */
        status: string;
    }

    export interface GetPublicConfigSummaryResult {
        /**
         * config list.
         */
        contents: outputs.Tsf.GetPublicConfigSummaryResultContent[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetPublicConfigSummaryResultContent {
        /**
         * Application ID.Note: This field may return null, indicating that no valid value was found.
         */
        applicationId: string;
        /**
         * Application Name. Note: This field may return null, indicating that no valid value was found.
         */
        applicationName: string;
        /**
         * Configuration item ID.Note: This field may return null, indicating that no valid value was found.
         */
        configId: string;
        /**
         * Configuration name.Note: This field may return null, indicating that no valid value was found.
         */
        configName: string;
        /**
         * Config type. Note: This field may return null, indicating that no valid value was found.
         */
        configType: string;
        /**
         * Configuration value.Note: This field may return null, indicating that no valid value was found.
         */
        configValue: string;
        /**
         * Configuration version. Note: This field may return null, indicating that no valid value was found.
         */
        configVersion: string;
        /**
         * Configure version count.Note: This field may return null, indicating that no valid value was found.
         */
        configVersionCount: number;
        /**
         * Configuration version description.Note: This field may return null, indicating that no valid value was found.
         */
        configVersionDesc: string;
        /**
         * Create time.Note: This field may return null, indicating that no valid value was found.
         */
        creationTime: string;
        /**
         * Deletion flag, true: deletable; false: not deletable.Note: This field may return null, indicating that no valid value was found.
         */
        deleteFlag: boolean;
        /**
         * Last update time.Note: This field may return null, indicating that no valid value was found.
         */
        lastUpdateTime: string;
    }

    export interface GetRepositoryResult {
        /**
         * Repository information list. Note: This field may return null, indicating that no valid value can be obtained.
         */
        contents: outputs.Tsf.GetRepositoryResultContent[];
        /**
         * Total Repository.
         */
        totalCount: number;
    }

    export interface GetRepositoryResultContent {
        /**
         * Repository bucket name. Note: This field may return null, indicating that no valid value can be obtained.
         */
        bucketName: string;
        /**
         * Repository region. Note: This field may return null, indicating that no valid value can be obtained.
         */
        bucketRegion: string;
        /**
         * CreationTime. Note: This field may return null, indicating that no valid values can be obtained.
         */
        createTime: string;
        /**
         * Repository Directory. Note: This field may return null, indicating that no valid value can be obtained.
         */
        directory: string;
        /**
         * Whether the repository is being used. Note: This field may return null, indicating that no valid value can be obtained.
         */
        isUsed: boolean;
        /**
         * Repository description (default warehouse: default, private warehouse: private).
         */
        repositoryDesc: string;
        /**
         * repository Id.
         */
        repositoryId: string;
        /**
         * Repository Name.
         */
        repositoryName: string;
        /**
         * Repository type (default Repository: default, private Repository: private).
         */
        repositoryType: string;
    }

    export interface GetUnitRulesResult {
        /**
         * record entity list.
         */
        contents: outputs.Tsf.GetUnitRulesResultContent[];
        /**
         * total number of records.
         */
        totalCount: number;
    }

    export interface GetUnitRulesResultContent {
        /**
         * created time.
         */
        createdTime: string;
        /**
         * Rule description.
         */
        description: string;
        /**
         * gateway instance id.
         */
        gatewayInstanceId: string;
        /**
         * rule ID.
         */
        id: string;
        /**
         * rule item name.
         */
        name: string;
        /**
         * Enabled state, disabled: unpublished, enabled: published.
         */
        status: string;
        /**
         * list of rule items.
         */
        unitRuleItemLists: outputs.Tsf.GetUnitRulesResultContentUnitRuleItemList[];
        /**
         * Updated time.
         */
        updatedTime: string;
    }

    export interface GetUnitRulesResultContentUnitRuleItemList {
        /**
         * Rule description.
         */
        description: string;
        /**
         * Destination Namespace ID.
         */
        destNamespaceId: string;
        /**
         * destination namespace name.
         */
        destNamespaceName: string;
        /**
         * rule ID.
         */
        id: string;
        /**
         * rule item name.
         */
        name: string;
        /**
         * Rule order, the smaller the higher the priority: the default is 0.
         */
        priority: number;
        /**
         * Logical relationship: AND/OR.
         */
        relationship: string;
        /**
         * Unitization rule ID.
         */
        unitRuleId: string;
        /**
         * List of rule labels.
         */
        unitRuleTagLists: outputs.Tsf.GetUnitRulesResultContentUnitRuleItemListUnitRuleTagList[];
    }

    export interface GetUnitRulesResultContentUnitRuleItemListUnitRuleTagList {
        /**
         * rule ID.
         */
        id: string;
        /**
         * tag name.
         */
        tagField: string;
        /**
         * Operator: IN/NOT_IN/EQUAL/NOT_EQUAL/REGEX.
         */
        tagOperator: string;
        /**
         * Tag Type: U(User Tag).
         */
        tagType: string;
        /**
         * tag value.
         */
        tagValue: string;
        /**
         * Unitization rule item ID.
         */
        unitRuleItemId: string;
    }

    export interface GetUsableUnitNamespacesResult {
        /**
         * namespace list.
         */
        contents: outputs.Tsf.GetUsableUnitNamespacesResultContent[];
        /**
         * total count.
         */
        totalCount: number;
    }

    export interface GetUsableUnitNamespacesResultContent {
        /**
         * Create time. Note: This field may return null, indicating that no valid value was found.
         */
        createdTime: string;
        /**
         * Gateway instance id Note: This field may return null, indicating that no valid value was found.
         */
        gatewayInstanceId: string;
        /**
         * Unit namespace ID. Note: This field may return null, indicating that no valid value was found.
         */
        id: string;
        /**
         * namespace id.
         */
        namespaceId: string;
        /**
         * namespace name.
         */
        namespaceName: string;
        /**
         * Update time. Note: This field may return null, indicating that no valid value was found.
         */
        updatedTime: string;
    }

    export interface InstancesAttachmentInstanceAdvancedSettings {
        /**
         * Dockerd --graph specifies the value, default is /var/lib/docker Note: This field may return null, indicating that no valid values can be obtained.
         */
        dockerGraphPath: string;
        /**
         * Data disk mount point, data disks are not mounted by default. Data disks with formatted ext3, ext4, xfs file systems will be mounted directly, other file systems or unformatted data disks will be automatically formatted as ext4 and mounted. Please back up your data! This setting does not take effect for cloud servers with no data disks or multiple data disks. Note: This field may return null, indicating that no valid values can be obtained.
         */
        mountTarget: string;
    }

    export interface LaneLaneGroupList {
        /**
         * application ID.
         */
        applicationId?: string;
        /**
         * application name.
         */
        applicationName?: string;
        /**
         * cluster type.
         */
        clusterType?: string;
        /**
         * creation time.
         */
        createTime?: number;
        /**
         * Whether to enter the application.
         */
        entrance: boolean;
        /**
         * Deployment group ID.
         */
        groupId: string;
        /**
         * deployment group name.
         */
        groupName?: string;
        /**
         * Swimlane deployment group ID.
         */
        laneGroupId?: string;
        /**
         * Lane ID.
         */
        laneId?: string;
        /**
         * Namespace ID.
         */
        namespaceId?: string;
        /**
         * namespace name.
         */
        namespaceName?: string;
        /**
         * update time.
         */
        updateTime?: number;
    }

    export interface LaneRuleRuleTagList {
        /**
         * creation time.
         */
        createTime: number;
        /**
         * lane rule ID.
         */
        laneRuleId: string;
        /**
         * label ID.
         */
        tagId: string;
        /**
         * label name.
         */
        tagName: string;
        /**
         * label operator.
         */
        tagOperator: string;
        /**
         * tag value.
         */
        tagValue: string;
        /**
         * update time.
         */
        updateTime: number;
    }

    export interface TaskAdvanceSettings {
        /**
         * Subtask single-machine concurrency limit, the default value is 2.
         */
        subTaskConcurrency?: number;
    }

    export interface TaskShardArgument {
        /**
         * Sharding parameter KEY, integer, range [1,1000].
         */
        shardKey: number;
        /**
         * Shard parameter VALUE.
         */
        shardValue: string;
    }

    export interface TaskTaskRule {
        /**
         * Cron type rule, cron expression.
         */
        expression?: string;
        /**
         * time interval, in milliseconds.
         */
        repeatInterval?: number;
        /**
         * trigger rule type, Cron/Repeat.
         */
        ruleType: string;
    }

    export interface UnitRuleUnitRuleItemList {
        /**
         * rule description.
         */
        description?: string;
        /**
         * destination namespace ID.
         */
        destNamespaceId: string;
        /**
         * destination namespace name.
         */
        destNamespaceName: string;
        /**
         * rule item name.
         */
        name: string;
        /**
         * rule order, the smaller the higher the priority: the default is 0.
         */
        priority?: number;
        /**
         * logical relationship: AND/OR.
         */
        relationship: string;
        /**
         * rule item ID.
         */
        ruleId: string;
        /**
         * Unitization rule ID.
         */
        unitRuleId: string;
        /**
         * list of rule labels.
         */
        unitRuleTagLists?: outputs.Tsf.UnitRuleUnitRuleItemListUnitRuleTagList[];
    }

    export interface UnitRuleUnitRuleItemListUnitRuleTagList {
        /**
         * rule ID.
         */
        ruleId: string;
        /**
         * label name.
         */
        tagField: string;
        /**
         * Operator: IN/NOT_IN/EQUAL/NOT_EQUAL/REGEX.
         */
        tagOperator: string;
        /**
         * Tag Type: U(User Tag).
         */
        tagType: string;
        /**
         * tag value.
         */
        tagValue: string;
        /**
         * Unitization rule item ID.
         */
        unitRuleItemId: string;
    }

}

export namespace Vod {
    export interface AdaptiveDynamicStreamingTemplateStreamInfo {
        /**
         * Audio parameter information.
         */
        audio: outputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoAudio;
        /**
         * Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
         */
        removeAudio?: boolean;
        /**
         * Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
         */
        removeVideo: boolean;
        /**
         * Extremely fast HD transcoding parameters.
         */
        tehdConfig: outputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig;
        /**
         * Video parameter information.
         */
        video: outputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoVideo;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoAudio {
        /**
         * Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
         */
        audioChannel?: string;
        /**
         * Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
         */
        bitrate: number;
        /**
         * Audio stream encoder. Valid value are: `libfdkAac` and `libmp3lame`. while `libfdkAac` is recommended.
         */
        codec: string;
        /**
         * Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
         */
        sampleRate: number;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig {
        /**
         * Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
         */
        maxVideoBitrate: number;
        /**
         * Extreme high-speed HD type, available values:
         * - TEHD-100: super high definition-100th;
         * - OFF: turn off Ultra High definition.
         */
        type: string;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoVideo {
        /**
         * Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
         */
        codec: string;
        /**
         * Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
         * - hvc1: stands for hvc1 tag;
         * - hev1: stands for the hev1 tag;
         * Default value: hvc1.
         */
        codecTag: string;
        /**
         * Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
         */
        fillType?: string;
        /**
         * Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
         */
        fps: number;
        /**
         * Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
         */
        gop: number;
        /**
         * Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        height?: number;
        /**
         * Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
         * - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
         * - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
         * Default value: OFF.
         */
        preserveHdrSwitch: string;
        /**
         * Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        resolutionAdaptive?: boolean;
        /**
         * Video constant bit rate control factor, value range is [1,51].
         * Note:
         * - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
         * - This field is required when the video stream encoding format is H.266. The recommended value is 28;
         * - If there are no special requirements, it is not recommended to specify this parameter.
         */
        vcrf: number;
        /**
         * Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        width?: number;
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateList {
        /**
         * Template description.
         */
        comment: string;
        /**
         * Creation time of template in ISO date format.
         */
        createTime: string;
        /**
         * Unique ID filter of adaptive dynamic streaming template.
         */
        definition: string;
        /**
         * Whether to prohibit transcoding video from low bitrate to high bitrate. `false`: no, `true`: yes.
         */
        disableHigherVideoBitrate: boolean;
        /**
         * Whether to prohibit transcoding from low resolution to high resolution. `false`: no, `true`: yes.
         */
        disableHigherVideoResolution: boolean;
        /**
         * DRM scheme type.
         */
        drmType: string;
        /**
         * Adaptive bitstream format.
         */
        format: string;
        /**
         * Template name.
         */
        name: string;
        /**
         * List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming.
         */
        streamInfos: outputs.Vod.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfo[];
        /**
         * Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
         */
        type: string;
        /**
         * Last modified time of template in ISO date format.
         */
        updateTime: string;
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfo {
        /**
         * Audio parameter information.
         */
        audios: outputs.Vod.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudio[];
        /**
         * Whether to remove audio stream. `false`: no, `true`: yes.
         */
        removeAudio: boolean;
        /**
         * Video parameter information.
         */
        videos: outputs.Vod.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideo[];
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudio {
        /**
         * Audio channel system. Valid values: mono, dual, stereo.
         */
        audioChannel: string;
        /**
         * Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * Video stream encoder. Valid values: `libx264`, `libx265`, `av1`.`libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
         */
        codec: string;
        /**
         * Audio stream sample rate. Valid values: `32000`, `44100`, `48000`. Unit is HZ.
         */
        sampleRate: number;
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideo {
        /**
         * Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * Video stream encoder. Valid values: `libx264`, `libx265`, `av1`.`libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
         */
        codec: string;
        /**
         * Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        fillType: string;
        /**
         * Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
         */
        fps: number;
        /**
         * Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Note: this field may return null, indicating that no valid values can be obtained.
         */
        height: number;
        /**
         * Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Note: this field may return null, indicating that no valid values can be obtained.
         */
        resolutionAdaptive: boolean;
        /**
         * Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Note: this field may return null, indicating that no valid values can be obtained.
         */
        width: number;
    }

    export interface GetImageSpriteTemplatesTemplateList {
        /**
         * Subimage column count of an image sprite.
         */
        columnCount: number;
        /**
         * Template description.
         */
        comment: string;
        /**
         * Creation time of template in ISO date format.
         */
        createTime: string;
        /**
         * Unique ID filter of image sprite template.
         */
        definition: string;
        /**
         * Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks.
         */
        fillType: string;
        /**
         * Maximum value of the `height` (or short side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
         */
        height: number;
        /**
         * Name of a time point screen capturing template.
         */
        name: string;
        /**
         * Resolution adaption. Valid values: `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height.
         */
        resolutionAdaptive: boolean;
        /**
         * Subimage row count of an image sprite.
         */
        rowCount: number;
        /**
         * Sampling interval. If `sampleType` is `Percent`, sampling will be performed at an interval of the specified percentage. If `sampleType` is `Time`, sampling will be performed at the specified time interval in seconds.
         */
        sampleInterval: number;
        /**
         * Sampling type. Valid values: `Percent`, `Time`. `Percent`: by percent. `Time`: by time interval.
         */
        sampleType: string;
        /**
         * Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
         */
        type: string;
        /**
         * Last modified time of template in ISO date format.
         */
        updateTime: string;
        /**
         * Maximum value of the `width` (or long side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, width will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
         */
        width: number;
    }

    export interface GetProcedureTemplatesTemplateList {
        /**
         * Template description.
         */
        comment: string;
        /**
         * Creation time of template in ISO date format.
         */
        createTime: string;
        /**
         * Parameter of video processing task.
         */
        mediaProcessTasks: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTask[];
        /**
         * Name of procedure template.
         */
        name: string;
        /**
         * Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
         */
        type: string;
        /**
         * Last modified time of template in ISO date format.
         */
        updateTime: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTask {
        /**
         * List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        adaptiveDynamicStreamingTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskList[];
        /**
         * List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        animatedGraphicTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskList[];
        /**
         * List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        coverBySnapshotTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskList[];
        /**
         * List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        imageSpriteTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskList[];
        /**
         * List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        sampleSnapshotTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskList[];
        /**
         * List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        snapshotByTimeOffsetTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskList[];
        /**
         * List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        transcodeTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset: number;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
         */
        positionType: string;
        /**
         * Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
         */
        positionValue: number;
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
         */
        extTimeOffsetLists: string[];
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * List of blurs. Up to 10 ones can be supported.
         */
        mosaicLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicList[];
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicList {
        /**
         * Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text.
         */
        coordinateOrigin: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px.
         */
        height: string;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px.
         */
        width: string;
        /**
         * The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px.
         */
        xPos: string;
        /**
         * Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px.
         */
        yPos: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkList {
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface GetSnapshotByTimeOffsetTemplatesTemplateList {
        /**
         * Template description.
         */
        comment: string;
        /**
         * Creation time of template in ISO date format.
         */
        createTime: string;
        /**
         * Unique ID filter of snapshot by time offset template.
         */
        definition: string;
        /**
         * Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot `shorter` or `longer`; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. `white`: fill with white. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with white color blocks. `gauss`: fill with Gaussian blur. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with Gaussian blur.
         */
        fillType: string;
        /**
         * Image format. Valid values: `jpg`, `png`.
         */
        format: string;
        /**
         * Maximum value of the `height` (or short side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
         */
        height: number;
        /**
         * Name of a time point screen capturing template.
         */
        name: string;
        /**
         * Resolution adaption. Valid values: `true`, `false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height.
         */
        resolutionAdaptive: boolean;
        /**
         * Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
         */
        type: string;
        /**
         * Last modified time of template in ISO date format.
         */
        updateTime: string;
        /**
         * Maximum value of the `width` (or long side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, width will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
         */
        width: number;
    }

    export interface GetSuperPlayerConfigsConfigList {
        /**
         * ID of the unencrypted adaptive bitrate streaming template that allows output, which is required if `drmSwitch` is `false`.
         */
        adaptiveDynamicStreamingDefinition: string;
        /**
         * Template description.
         */
        comment: string;
        /**
         * Creation time of template in ISO date format.
         */
        createTime: string;
        /**
         * Domain name used for playback. If it is left empty or set to `Default`, the domain name configured in [Default Distribution Configuration](https://cloud.tencent.com/document/product/266/33373) will be used.
         */
        domain: string;
        /**
         * Content of the DRM-protected adaptive bitrate streaming template that allows output, which is required if `drmSwitch` is `true`.
         */
        drmStreamingInfos: outputs.Vod.GetSuperPlayerConfigsConfigListDrmStreamingInfo[];
        /**
         * Switch of DRM-protected adaptive bitstream playback: `true`: enabled, indicating to play back only output adaptive bitstreams protected by DRM; `false`: disabled, indicating to play back unencrypted output adaptive bitstreams.
         */
        drmSwitch: boolean;
        /**
         * ID of the image sprite template that allows output.
         */
        imageSpriteDefinition: string;
        /**
         * Name of super player config.
         */
        name: string;
        /**
         * Display name of player for substreams with different resolutions. If this parameter is left empty or an empty array, the default configuration will be used: `min_edge_length: 240, name: LD`; `min_edge_length: 480, name: SD`; `min_edge_length: 720, name: HD`; `min_edge_length: 1080, name: FHD`; `min_edge_length: 1440, name: 2K`; `min_edge_length: 2160, name: 4K`; `min_edge_length: 4320, name: 8K`.
         */
        resolutionNames: outputs.Vod.GetSuperPlayerConfigsConfigListResolutionName[];
        /**
         * Scheme used for playback. If it is left empty or set to `Default`, the scheme configured in [Default Distribution Configuration](https://cloud.tencent.com/document/product/266/33373) will be used. Other valid values: `HTTP`; `HTTPS`.
         */
        scheme: string;
        /**
         * Config type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
         */
        type: string;
        /**
         * Last modified time of template in ISO date format.
         */
        updateTime: string;
    }

    export interface GetSuperPlayerConfigsConfigListDrmStreamingInfo {
        /**
         * ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
         */
        simpleAesDefinition: string;
    }

    export interface GetSuperPlayerConfigsConfigListResolutionName {
        /**
         * Length of video short side in px.
         */
        minEdgeLength: number;
        /**
         * Name of super player config.
         */
        name: string;
    }

    export interface ProcedureTemplateAiAnalysisTask {
        /**
         * Video content analysis template ID.
         */
        definition: string;
    }

    export interface ProcedureTemplateAiRecognitionTask {
        /**
         * Intelligent video recognition template ID.
         */
        definition: string;
    }

    export interface ProcedureTemplateMediaProcessTask {
        /**
         * List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        adaptiveDynamicStreamingTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList[];
        /**
         * List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        animatedGraphicTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList[];
        /**
         * List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        coverBySnapshotTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList[];
        /**
         * List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        imageSpriteTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskImageSpriteTaskList[];
        /**
         * List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        sampleSnapshotTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList[];
        /**
         * List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        snapshotByTimeOffsetTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList[];
        /**
         * List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        transcodeTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskList[];
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList {
        /**
         * Adaptive bitrate streaming template ID.
         */
        definition: string;
        /**
         * Subtitle list, element is subtitle ID, support multiple subtitles, up to 16.
         */
        subtitleLists: string[];
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList {
        /**
         * Watermarking template ID.
         */
        definition: string;
        /**
         * End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList {
        /**
         * Animated image generating template ID.
         */
        definition: string;
        /**
         * End time of animated image in video in seconds.
         */
        endTimeOffset: number;
        /**
         * Start time of animated image in video in seconds.
         */
        startTimeOffset: number;
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList {
        /**
         * Time point screen capturing template ID.
         */
        definition: string;
        /**
         * Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
         */
        positionType: string;
        /**
         * Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
         */
        positionValue: number;
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList {
        /**
         * Watermarking template ID.
         */
        definition: string;
        /**
         * End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskImageSpriteTaskList {
        /**
         * Image sprite generating template ID.
         */
        definition: string;
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList {
        /**
         * Sampled screen capturing template ID.
         */
        definition: string;
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList {
        /**
         * Watermarking template ID.
         */
        definition: string;
        /**
         * End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList {
        /**
         * Time point screen capturing template ID.
         */
        definition: string;
        /**
         * The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
         */
        extTimeOffsetLists?: string[];
        /**
         * List of time points for screencapturing in milliseconds. Note: this field may return null, indicating that no valid values can be obtained.
         */
        timeOffsetLists: number[];
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList {
        /**
         * Watermarking template ID.
         */
        definition: string;
        /**
         * End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskList {
        /**
         * opyright watermark.
         */
        copyRightWatermark: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermark;
        /**
         * Video transcoding template ID.
         */
        definition: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset: number;
        /**
         * List of video opening/closing credits configuration template IDs. You can enter up to 10 IDs.
         */
        headTailLists: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailList[];
        /**
         * List of blurs. Up to 10 ones can be supported.
         */
        mosaicLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList[];
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset: number;
        /**
         * Digital watermark.
         */
        traceWatermark: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermark;
        /**
         * List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
         */
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermark {
        /**
         * Copyright information, maximum length is 200 characters.
         */
        text: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailList {
        /**
         * Video opening/closing credits configuration template ID.
         */
        definition: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList {
        /**
         * Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text. Default value: TopLeft.
         */
        coordinateOrigin?: string;
        /**
         * End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px. Default value: `10%`.
         */
        height?: string;
        /**
         * Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px. Default value: `10%`.
         */
        width?: string;
        /**
         * The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px. Default value: `0px`.
         */
        xPos?: string;
        /**
         * Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px. Default value: `0px`.
         */
        yPos?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermark {
        /**
         * Whether to use digital watermarks. This parameter is required. Valid values: ON, OFF.
         */
        switch: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList {
        /**
         * Watermarking template ID.
         */
        definition: string;
        /**
         * End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
         */
        endTimeOffset?: number;
        /**
         * Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
         */
        startTimeOffset?: number;
        /**
         * SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
         */
        svgContent?: string;
        /**
         * Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
         */
        textContent?: string;
    }

    export interface ProcedureTemplateReviewAudioVideoTask {
        /**
         * Review template.
         */
        definition: string;
        /**
         * The type of moderated content. Valid values:
         */
        reviewContents: string[];
    }

    export interface SuperPlayerConfigDrmStreamingInfo {
        /**
         * ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
         */
        simpleAesDefinition?: string;
    }

    export interface SuperPlayerConfigResolutionName {
        /**
         * Length of video short side in px.
         */
        minEdgeLength: number;
        /**
         * Display name.
         */
        name: string;
    }

    export interface TranscodeTemplateAudioTemplate {
        /**
         * Audio channel system. Valid values:1: mono-channel2: dual-channel6: stereoYou cannot set the sound channel as stereo for media files in container formats for audios (FLAC, OGG, MP3, M4A).Default value: 2.
         */
        audioChannel?: number;
        /**
         * Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
         */
        bitrate: number;
        /**
         * The audio codec.If `Container` is `mp3`, the valid value is:`libmp3lame`If `Container` is `ogg` or `flac`, the valid value is:`flac`If `Container` is `m4a`, the valid values are:`libfdkAac``libmp3lame``ac3`If `Container` is `mp4` or `flv`, the valid values are:`libfdkAac` (Recommended for MP4)`libmp3lame` (Recommended for FLV)`mp2`If `Container` is `hls`, the valid value is:`libfdkAac`If `Format` is `HLS` or `MPEG-DASH`, the valid value is:`libfdkAac`If `Container` is `wav`, the valid value is:`pcm16`.
         */
        codec: string;
        /**
         * The audio sample rate. Valid values:`16000` (valid only if `Codec` is `pcm16`)`32000``44100``48000`Unit: Hz.
         */
        sampleRate: number;
    }

    export interface TranscodeTemplateTehdConfig {
        /**
         * Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left blank or 0 is entered, there will be no upper limit for bitrate.
         */
        maxVideoBitrate?: number;
        /**
         * TESHD transcoding type. Valid values: TEHD-100, OFF (default).
         */
        type: string;
    }

    export interface TranscodeTemplateVideoTemplate {
        /**
         * Bitrate of video stream in Kbps. Value range: 0 and [128, 35,000].If the value is 0, the bitrate of the video will be the same as that of the source video.
         */
        bitrate: number;
        /**
         * The video codec. Valid values:libx264: H.264; libx265: H.265; av1: AOMedia Video 1; H.266: H.266. The AOMedia Video 1 and H.266 codecs can only be used for MP4 files. Only CRF is supported for H.266 currently.
         */
        codec: string;
        /**
         * The codec tag. This parameter is valid only if the H.265 codec is used. Valid values:hvc1hev1Default value: hvc1.
         */
        codecTag?: string;
        /**
         * Fill type, the way of processing a screenshot when the configured aspect ratio is different from that of the source video. Valid values:stretch: stretches the video image frame by frame to fill the screen. The video image may become squashed or stretched after transcoding.black: fills the uncovered area with black color, without changing the image&#39;s aspect ratio.white: fills the uncovered area with white color, without changing the image&#39;s aspect ratio.gauss: applies Gaussian blur to the uncovered area, without changing the image&#39;s aspect ratio.Default value: black.
         */
        fillType?: string;
        /**
         * Video frame rate in Hz. Value range: [0,100].If the value is 0, the frame rate will be the same as that of the source video.
         */
        fps: number;
        /**
         * I-frame interval in frames. Valid values: 0 and 1-100000.When this parameter is set to 0 or left empty, `Gop` will be automatically set.
         */
        gop?: number;
        /**
         * The maximum video height (or short side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
         */
        height?: number;
        /**
         * Whether to output an HDR (high dynamic range) video if the source video is HDR. Valid values:ON: If the source video is HDR, output an HDR video; if not, output an SDR (standard dynamic range) video.OFF: Output an SDR video regardless of whether the source video is HDR.Default value: OFF.
         */
        preserveHdrSwitch?: string;
        /**
         * Resolution adaption. Valid values:open: enabled. In this case, `Width` represents the long side of a video, while `Height` the short side;close: disabled. In this case, `Width` represents the width of a video, while `Height` the height.Default value: open.Note: this field may return null, indicating that no valid values can be obtained.
         */
        resolutionAdaptive?: string;
        /**
         * The video constant rate factor (CRF). Value range: 1-51.If this parameter is specified, CRF encoding will be used and the bitrate parameter will be ignored.If `Codec` is `H.266`, this parameter is required (`28` is recommended).We don't recommend using this parameter unless you have special requirements.
         */
        vcrf?: number;
        /**
         * The maximum video width (or long side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
         */
        width?: number;
    }

    export interface WatermarkTemplateImageTemplate {
        /**
         * Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;  If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px. Valid values: 0 or [8,4096]. Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
         */
        height: string;
        /**
         * The [Base64](https://tools.ietf.org/html/rfc4648) encoded string of a watermark image. Only JPEG, PNG, and GIF images are supported.
         */
        imageContent: string;
        /**
         * Repeat type of an animated watermark. Valid values: once: no longer appears after watermark playback ends.  repeat_last_frame: stays on the last frame after watermark playback ends.  repeat (default): repeats the playback until the video ends.
         */
        repeatType: string;
        /**
         * Image watermark transparency: 0: completely opaque  100: completely transparent Default value: 0.
         */
        transparency: number;
        /**
         * Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width. For example, `10%` means that `Width` is 10% of the video width;  If the string ends in px, the `Width` of the watermark will be in pixels. For example, `100px` means that `Width` is 100 pixels. Value range: [8, 4096]. Default value: 10%.
         */
        width: string;
    }

    export interface WatermarkTemplateSvgTemplate {
        /**
         * Watermark height, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px; if `0px` is entered and `Width` is not `0px`, the watermark height will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark height will be the height of the source SVG image;  If the string ends in `W%`, the `Height` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Height` is 10% of the video width;  If the string ends in `H%`, the `Height` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Height` is 10% of the video height;  If the string ends in `S%`, the `Height` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Height` is 10% of the short side of the video;  If the string ends in `L%`, the `Height` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Height` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `H%`. Default value: 0 px.
         */
        height: string;
        /**
         * Watermark width, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px; if `0px` is entered and `Height` is not `0px`, the watermark width will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark width will be the width of the source SVG image;  If the string ends in `W%`, the `Width` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Width` is 10% of the video width;  If the string ends in `H%`, the `Width` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Width` is 10% of the video height;  If the string ends in `S%`, the `Width` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Width` is 10% of the short side of the video;  If the string ends in `L%`, the `Width` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Width` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `W%`. Default value: 10W%.
         */
        width: string;
    }

    export interface WatermarkTemplateTextTemplate {
        /**
         * Text transparency. Value range: (0, 1] 0: completely transparent  1: completely opaque Default value: 1.
         */
        fontAlpha: number;
        /**
         * Font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).
         */
        fontColor: string;
        /**
         * Font size in Npx format where N is a numeric value.
         */
        fontSize: string;
        /**
         * Font type. Currently, two types are supported: simkai.ttf: both Chinese and English are supported;  arial.ttf: only English is supported.
         */
        fontType: string;
    }

}

export namespace Vpc {
    export interface FlowLogFlowLogStorage {
        /**
         * Specify storage instance id, required while `storageType` is `ckafka`.
         */
        storageId: string;
        /**
         * Specify storage topic id, required while `storageType` is `ckafka`.
         */
        storageTopic: string;
    }

    export interface GetAccountAttributesAccountAttributeSet {
        /**
         * Attribute name.
         */
        attributeName: string;
        /**
         * Attribute values.
         */
        attributeValues: string[];
    }

    export interface GetAclsAclList {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Outbound rules of the network ACL.
         */
        egresses: outputs.Vpc.GetAclsAclListEgress[];
        /**
         * ID of the network ACL instance.
         */
        id: string;
        /**
         * Inbound rules of the network ACL.
         */
        ingresses: outputs.Vpc.GetAclsAclListIngress[];
        /**
         * Name of the network ACL.
         */
        name: string;
        /**
         * Subnets associated with the network ACL.
         */
        subnets: outputs.Vpc.GetAclsAclListSubnet[];
        /**
         * ID of the VPC instance.
         */
        vpcId: string;
    }

    export interface GetAclsAclListEgress {
        /**
         * The IPv4 CIDR of the subnet.
         */
        cidrBlock: string;
        /**
         * Rule description.
         */
        description: string;
        /**
         * Rule policy of Network ACL.
         */
        policy: string;
        /**
         * Range of the port.
         */
        port: string;
        /**
         * Type of IP protocol.
         */
        protocol: string;
    }

    export interface GetAclsAclListIngress {
        /**
         * The IPv4 CIDR of the subnet.
         */
        cidrBlock: string;
        /**
         * Rule description.
         */
        description: string;
        /**
         * Rule policy of Network ACL.
         */
        policy: string;
        /**
         * Range of the port.
         */
        port: string;
        /**
         * Type of IP protocol.
         */
        protocol: string;
    }

    export interface GetAclsAclListSubnet {
        /**
         * The IPv4 CIDR of the subnet.
         */
        cidrBlock: string;
        /**
         * Subnet instance ID.
         */
        subnetId: string;
        /**
         * Subnet name.
         */
        subnetName: string;
        /**
         * Tags of the subnet.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC instance.
         */
        vpcId: string;
    }

    export interface GetBandwidthPackageBillUsageBandwidthPackageBillBandwidthSet {
        /**
         * Current billing amount in Mbps.
         */
        bandwidthUsage: number;
    }

    export interface GetBandwidthPackageQuotaQuotaSet {
        /**
         * current amount.
         */
        quotaCurrent: number;
        /**
         * Quota type.
         */
        quotaId: string;
        /**
         * quota amount.
         */
        quotaLimit: number;
    }

    export interface GetClassicLinkInstancesClassicLinkInstanceSet {
        /**
         * The unique ID of the CVM instance.
         */
        instanceId: string;
        /**
         * VPC instance ID.
         */
        vpcId: string;
    }

    export interface GetClassicLinkInstancesFilter {
        /**
         * The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
         */
        name: string;
        /**
         * The attribute value. If there are multiple Values for one Filter, the logical relation between these Values under the same Filter is `OR`.
         */
        values: string[];
    }

    export interface GetCvmInstancesFilter {
        /**
         * The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
         */
        name: string;
        /**
         * Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
         */
        values: string[];
    }

    export interface GetCvmInstancesInstanceSet {
        /**
         * Number of CPU cores in an instance (in core).
         */
        cpu: number;
        /**
         * The creation time.
         */
        createdTime: string;
        /**
         * Private IP quoata for instance ENIs (including primary ENIs).
         */
        eniIpLimit: number;
        /**
         * Instance ENI quota (including primary ENIs).
         */
        eniLimit: number;
        /**
         * The number of ENIs (including primary ENIs) bound to a instance.
         */
        instanceEniCount: number;
        /**
         * CVM instance ID.
         */
        instanceId: string;
        /**
         * CVM Name.
         */
        instanceName: string;
        /**
         * CVM status.
         */
        instanceState: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Instance's memory capacity. Unit: GB.
         */
        memory: number;
        /**
         * Subnet instance ID.
         */
        subnetId: string;
        /**
         * VPC instance ID.
         */
        vpcId: string;
    }

    export interface GetGatewayFlowMonitorDetailGatewayFlowMonitorDetailSet {
        /**
         * Inbound packets.
         */
        inPkg: number;
        /**
         * Inbound traffic, in Byte.
         */
        inTraffic: number;
        /**
         * Outbound packets.
         */
        outPkg: number;
        /**
         * Outbound traffic, in Byte.
         */
        outTraffic: number;
        /**
         * Origin `IP`.
         */
        privateIpAddress: string;
    }

    export interface GetGatewayFlowQosGatewayQosSet {
        /**
         * bandwidth value.
         */
        bandwidth: number;
        /**
         * create time.
         */
        createTime: string;
        /**
         * cvm ip address.
         */
        ipAddress: string;
        /**
         * vpc id.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceList {
        /**
         * Filter VPC with this CIDR.
         */
        cidrBlock: string;
        /**
         * Creation time of VPC.
         */
        createTime: string;
        /**
         * A list of DNS servers which can be used within the VPC.
         */
        dnsServers: string[];
        /**
         * Filter default or no default VPC.
         */
        isDefault: boolean;
        /**
         * Indicates whether VPC multicast is enabled.
         */
        isMulticast: boolean;
        /**
         * Name of the VPC to be queried.
         */
        name: string;
        /**
         * A ID list of subnets within this VPC.
         */
        subnetIds: string[];
        /**
         * Tags of the VPC to be queried.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC to be queried.
         */
        vpcId: string;
    }

    export interface GetLimitsVpcLimitSet {
        /**
         * type of vpc limit.
         */
        limitType: string;
        /**
         * value of vpc limit.
         */
        limitValue: number;
    }

    export interface GetNetDetectStateCheckNetDetectIpStateSet {
        /**
         * The latency. Unit: ms.
         */
        delay: number;
        /**
         * The array of detection destination IPv4 addresses, which contains at most two IP addresses.
         */
        detectDestinationIp: string;
        /**
         * The packet loss rate.
         */
        packetLossRate: number;
        /**
         * The detection result.0: successful;-1: no packet loss occurred during routing;-2: packet loss occurred when outbound traffic is blocked by the ACL;-3: packet loss occurred when inbound traffic is blocked by the ACL;-4: other errors.
         */
        state: number;
    }

    export interface GetNetDetectStatesFilter {
        /**
         * The attribute name. If more than one Filter exists, the logical relation between these Filters is `AND`.
         */
        name: string;
        /**
         * Attribute value. If multiple values exist in one filter, the logical relationship between these values is `OR`. For a `bool` parameter, the valid values include `TRUE` and `FALSE`.
         */
        values: string[];
    }

    export interface GetNetDetectStatesNetDetectStateSet {
        /**
         * The ID of a network detection instance, such as netd-12345678.
         */
        netDetectId: string;
        /**
         * The array of network detection destination IP verification results.
         */
        netDetectIpStateSets: outputs.Vpc.GetNetDetectStatesNetDetectStateSetNetDetectIpStateSet[];
    }

    export interface GetNetDetectStatesNetDetectStateSetNetDetectIpStateSet {
        /**
         * The latency. Unit: ms.
         */
        delay: number;
        /**
         * The destination IPv4 address of network detection.
         */
        detectDestinationIp: string;
        /**
         * The packet loss rate.
         */
        packetLossRate: number;
        /**
         * The detection result.0: successful;-1: no packet loss occurred during routing;-2: packet loss occurred when outbound traffic is blocked by the ACL;-3: packet loss occurred when inbound traffic is blocked by the ACL;-4: other errors.
         */
        state: number;
    }

    export interface GetPrivateIpAddressesVpcPrivateIpAddressSet {
        /**
         * The `CIDR` belonging to the subnet.
         */
        cidrBlock: string;
        /**
         * `IP` application time.
         */
        createdTime: string;
        /**
         * `VPC` private `IP`.
         */
        privateIpAddress: string;
        /**
         * Private `IP` type.
         */
        privateIpAddressType: string;
    }

    export interface GetProductQuotaProductQuotaSet {
        /**
         * Current Quota.
         */
        quotaCurrent: number;
        /**
         * Quota Id.
         */
        quotaId: string;
        /**
         * Quota limit.
         */
        quotaLimit: number;
        /**
         * Quota name.
         */
        quotaName: string;
        /**
         * Quota region.
         */
        quotaRegion: boolean;
    }

    export interface GetResourceDashboardResourceDashboardSet {
        /**
         * Relational database.
         */
        cdb: number;
        /**
         * Cloud file storage - CFS.
         */
        cfs: number;
        /**
         * Cloud Kafka (CKafka).
         */
        ckafka: number;
        /**
         * Classic link.
         */
        classicLink: number;
        /**
         * TencentDB for Memcached.
         */
        cmem: number;
        /**
         * Cnas.
         */
        cnas: number;
        /**
         * Cloud time series database.
         */
        ctsDb: number;
        /**
         * Cloud Virtual Machine.
         */
        cvm: number;
        /**
         * An enterprise-grade TencentDB - CynosDB for MySQL.
         */
        cynosDbMysql: number;
        /**
         * Enterprise TencentDB - CynosDB for Postgres.
         */
        cynosDbPostgres: number;
        /**
         * Cloud database audit.
         */
        dbAudit: number;
        /**
         * A distributed cloud database - TencentDB for TDSQL.
         */
        dcdb: number;
        /**
         * Direct Connect gateway.
         */
        dcg: number;
        /**
         * ElasticSearch Service.
         */
        elasticSearch: number;
        /**
         * EMR cluster.
         */
        emr: number;
        /**
         * Flow log.
         */
        flowLog: number;
        /**
         * Snova data warehouse.
         */
        greenplumn: number;
        /**
         * Grocery.
         */
        grocery: number;
        /**
         * Data encryption service.
         */
        hsm: number;
        /**
         * Total number of used IPs except for CVM IP, EIP and network probe IP. The three IP types will be independently counted.
         */
        ip: number;
        /**
         * Itop.
         */
        itop: number;
        /**
         * Load balancer.
         */
        lb: number;
        /**
         * TencentDB for MariaDB (TDSQL).
         */
        mariaDb: number;
        /**
         * TencentDB for MongoDB.
         */
        mongoDb: number;
        /**
         * Network attached storage.
         */
        nas: number;
        /**
         * NAT gateway.
         */
        nat: number;
        /**
         * Network ACL.
         */
        networkAcl: number;
        /**
         * Network probing.
         */
        networkDetect: number;
        /**
         * Oracle.
         */
        oracle: number;
        /**
         * Peering connection.
         */
        pcx: number;
        /**
         * TencentDB for PostgreSQL.
         */
        postgres: number;
        /**
         * TencentDB for Redis.
         */
        redis: number;
        /**
         * Route table.
         */
        routeTable: number;
        /**
         * SEAL.
         */
        seal: number;
        /**
         * TencentDB for SQL Server.
         */
        sqlServer: number;
        /**
         * Subnets.
         */
        subnet: number;
        /**
         * Subnet instance ID, such as subnet-bthucmmy.
         */
        subnetId: string;
        /**
         * Blockchain service.
         */
        tBaas: number;
        /**
         * Game storage - Tcaplus.
         */
        tcaplus: number;
        /**
         * HTAP database - TiDB.
         */
        tiDb: number;
        /**
         * VPC instance ID, such as `vpc-bq4bzxpj`.
         */
        vpcId: string;
        /**
         * VPN gateway.
         */
        vpngw: number;
    }

    export interface GetRouteConflictsRouteConflictSet {
        /**
         * route conflict list.
         */
        conflictSets: outputs.Vpc.GetRouteConflictsRouteConflictSetConflictSet[];
        /**
         * destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * Routing table instance ID, for example:rtb-azd4dt1c.
         */
        routeTableId: string;
    }

    export interface GetRouteConflictsRouteConflictSetConflictSet {
        /**
         * create time.
         */
        createdTime: string;
        /**
         * destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * Destination of Ipv6 Cidr Block.
         */
        destinationIpv6CidrBlock: string;
        /**
         * if enabled.
         */
        enabled: boolean;
        /**
         * next hop id.
         */
        gatewayId: string;
        /**
         * next gateway type.
         */
        gatewayType: string;
        /**
         * if published To ccn.
         */
        publishedToVbc: boolean;
        /**
         * route description.
         */
        routeDescription: string;
        /**
         * route id.
         */
        routeId: number;
        /**
         * unique policy id.
         */
        routeItemId: string;
        /**
         * Routing table instance ID, for example:rtb-azd4dt1c.
         */
        routeTableId: string;
        /**
         * routr type.
         */
        routeType: string;
    }

    export interface GetRouteTablesInstanceList {
        /**
         * Creation time of the routing table.
         */
        createTime: string;
        /**
         * Indicates whether it is the default routing table.
         */
        isDefault: boolean;
        /**
         * Name of the routing table to be queried.
         */
        name: string;
        /**
         * Detailed information of each entry of the route table.
         */
        routeEntryInfos: outputs.Vpc.GetRouteTablesInstanceListRouteEntryInfo[];
        /**
         * ID of the routing table to be queried.
         */
        routeTableId: string;
        /**
         * List of subnet IDs bound to the route table.
         */
        subnetIds: string[];
        /**
         * Tags of the routing table to be queried.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC to be queried.
         */
        vpcId: string;
    }

    export interface GetRouteTablesInstanceListRouteEntryInfo {
        /**
         * Description information user defined for a route table rule.
         */
        description: string;
        /**
         * The destination address block.
         */
        destinationCidrBlock: string;
        /**
         * ID of next-hop gateway. Note: when 'next_type' is EIP, GatewayId will fix the value `0`.
         */
        nextHub: string;
        /**
         * Type of next-hop, and available values include `CVM`, `VPN`, `DIRECTCONNECT`, `PEERCONNECTION`, `SSLVPN`, `NAT`, `NORMAL_CVM`, `EIP` and `CCN`.
         */
        nextType: string;
        /**
         * ID of a route table entry.
         */
        routeEntryId: string;
    }

    export interface GetSecurityGroupLimitsSecurityGroupLimitSet {
        /**
         * number of instances associated sg.
         */
        instanceSecurityGroupLimit: number;
        /**
         * number of sg can be referred.
         */
        referredSecurityGroupLimit: number;
        /**
         * number of sg extended policy.
         */
        securityGroupExtendedPolicyLimit: number;
        /**
         * number of sg associated instances.
         */
        securityGroupInstanceLimit: number;
        /**
         * number of sg can be created.
         */
        securityGroupLimit: number;
        /**
         * number of sg polciy can be created.
         */
        securityGroupPolicyLimit: number;
        /**
         * number of eni and cvm can be referred.
         */
        securityGroupReferredCvmAndEniLimit: number;
        /**
         * number of svc can be referred.
         */
        securityGroupReferredSvcLimit: number;
    }

    export interface GetSecurityGroupReferencesReferredSecurityGroupSet {
        /**
         * IDs of all referred security group instances.
         */
        referredSecurityGroupIds: string[];
        /**
         * Security group instance ID.
         */
        securityGroupId: string;
    }

    export interface GetSgSnapshotFileContentBackupData {
        /**
         * ACCEPT or DROP.
         */
        action: string;
        /**
         * IP address ID or IP address group ID.
         */
        addressTemplates: outputs.Vpc.GetSgSnapshotFileContentBackupDataAddressTemplate[];
        /**
         * Either `CidrBlock` or `Ipv6CidrBlock can be specified. Note that if `0.0.0.0/n` is entered, it is mapped to 0.0.0.0/0.
         */
        cidrBlock: string;
        /**
         * The CIDR block or IPv6 (mutually exclusive).
         */
        ipv6CidrBlock: string;
        /**
         * The last modification time of the security group.
         */
        modifyTime: string;
        /**
         * Security group policy description.
         */
        policyDescription: string;
        /**
         * The index number of security group rules, which dynamically changes with the rules. This parameter can be obtained via the `DescribeSecurityGroupPolicies` API and used with the `Version` field in the returned value of the API.
         */
        policyIndex: number;
        /**
         * Port (`all`, a single port, or a port range).Note: If the `Protocol` value is set to `ALL`, the `Port` value also needs to be set to `all`.
         */
        port: string;
        /**
         * Protocol. Valid values: TCP, UDP, ICMP, ICMPv6, ALL.
         */
        protocol: string;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * Protocol port ID or protocol port group ID. ServiceTemplate and Protocol+Port are mutually exclusive.
         */
        serviceTemplates: outputs.Vpc.GetSgSnapshotFileContentBackupDataServiceTemplate[];
    }

    export interface GetSgSnapshotFileContentBackupDataAddressTemplate {
        /**
         * The ID of the IP address group, such as `ipmg-2uw6ujo6`.
         */
        addressGroupId: string;
        /**
         * The ID of the IP address, such as `ipm-2uw6ujo6`.
         */
        addressId: string;
    }

    export interface GetSgSnapshotFileContentBackupDataServiceTemplate {
        /**
         * Protocol port group ID, such as `ppmg-f5n1f8da`.
         */
        serviceGroupId: string;
        /**
         * Protocol port ID, such as `ppm-f5n1f8da`.
         */
        serviceId: string;
    }

    export interface GetSgSnapshotFileContentOriginalData {
        /**
         * ACCEPT or DROP.
         */
        action: string;
        /**
         * IP address ID or IP address group ID.
         */
        addressTemplates: outputs.Vpc.GetSgSnapshotFileContentOriginalDataAddressTemplate[];
        /**
         * Either `CidrBlock` or `Ipv6CidrBlock can be specified. Note that if `0.0.0.0/n` is entered, it is mapped to 0.0.0.0/0.
         */
        cidrBlock: string;
        /**
         * The CIDR block or IPv6 (mutually exclusive).
         */
        ipv6CidrBlock: string;
        /**
         * The last modification time of the security group.
         */
        modifyTime: string;
        /**
         * Security group policy description.
         */
        policyDescription: string;
        /**
         * The index number of security group rules, which dynamically changes with the rules. This parameter can be obtained via the `DescribeSecurityGroupPolicies` API and used with the `Version` field in the returned value of the API.
         */
        policyIndex: number;
        /**
         * Port (`all`, a single port, or a port range).Note: If the `Protocol` value is set to `ALL`, the `Port` value also needs to be set to `all`.
         */
        port: string;
        /**
         * Protocol. Valid values: TCP, UDP, ICMP, ICMPv6, ALL.
         */
        protocol: string;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * Protocol port ID or protocol port group ID. ServiceTemplate and Protocol+Port are mutually exclusive.
         */
        serviceTemplates: outputs.Vpc.GetSgSnapshotFileContentOriginalDataServiceTemplate[];
    }

    export interface GetSgSnapshotFileContentOriginalDataAddressTemplate {
        /**
         * The ID of the IP address group, such as `ipmg-2uw6ujo6`.
         */
        addressGroupId: string;
        /**
         * The ID of the IP address, such as `ipm-2uw6ujo6`.
         */
        addressId: string;
    }

    export interface GetSgSnapshotFileContentOriginalDataServiceTemplate {
        /**
         * Protocol port group ID, such as `ppmg-f5n1f8da`.
         */
        serviceGroupId: string;
        /**
         * Protocol port ID, such as `ppm-f5n1f8da`.
         */
        serviceId: string;
    }

    export interface GetSnapshotFilesSnapshotFileSet {
        /**
         * backup time.
         */
        backupTime: string;
        /**
         * InstanceId.
         */
        instanceId: string;
        /**
         * Uin of operator.
         */
        operator: string;
        /**
         * snap shot file id.
         */
        snapshotFileId: string;
        /**
         * Snapshot Policy Id.
         */
        snapshotPolicyId: string;
    }

    export interface GetSubnetResourceDashboardResourceStatisticsSet {
        /**
         * The total number of used IP addresses.
         */
        ip: number;
        /**
         * Information of associated resources.
         */
        resourceStatisticsItemSets: outputs.Vpc.GetSubnetResourceDashboardResourceStatisticsSetResourceStatisticsItemSet[];
        /**
         * Subnet instance ID, such as `subnet-bthucmmy`.
         */
        subnetId: string;
        /**
         * VPC instance ID, such as vpc-f1xjkw1b.
         */
        vpcId: string;
    }

    export interface GetSubnetResourceDashboardResourceStatisticsSetResourceStatisticsItemSet {
        /**
         * Number of resources.
         */
        resourceCount: number;
        /**
         * Resource name.
         */
        resourceName: string;
        /**
         * Resource type, such as CVM, ENI.
         */
        resourceType: string;
    }

    export interface GetSubnetsInstanceList {
        /**
         * Zone of the subnet to be queried.
         */
        availabilityZone: string;
        /**
         * The number of available IPs.
         */
        availableIpCount: number;
        /**
         * Filter subnet with this CIDR.
         */
        cidrBlock: string;
        /**
         * Creation time of the subnet resource.
         */
        createTime: string;
        /**
         * Filter default or no default subnets.
         */
        isDefault: boolean;
        /**
         * Indicates whether multicast is enabled.
         */
        isMulticast: boolean;
        /**
         * Name of the subnet to be queried.
         */
        name: string;
        /**
         * ID of the routing table.
         */
        routeTableId: string;
        /**
         * ID of the subnet to be queried.
         */
        subnetId: string;
        /**
         * Tags of the subnet to be queried.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC to be queried.
         */
        vpcId: string;
    }

    export interface GetTemplateLimitsTemplateLimit {
        /**
         * address template group member limit.
         */
        addressTemplateGroupMemberLimit: number;
        /**
         * address template member limit.
         */
        addressTemplateMemberLimit: number;
        /**
         * service template group member limit.
         */
        serviceTemplateGroupMemberLimit: number;
        /**
         * service template member limit.
         */
        serviceTemplateMemberLimit: number;
    }

    export interface GetUsedIpAddressIpAddressState {
        /**
         * IP address.
         */
        ipAddress: string;
        /**
         * Resource ID.
         */
        resourceId: string;
        /**
         * Resource type.
         */
        resourceType: string;
        /**
         * Subnet instance ID.
         */
        subnetId: string;
        /**
         * VPC instance ID.
         */
        vpcId: string;
    }

    export interface Ipv6SubnetCidrBlockIpv6SubnetCidrBlocks {
        /**
         * `IPv6` subnet segment. Such as: `3402:4e00:20:1001::/64`.
         */
        ipv6CidrBlock: string;
        /**
         * Subnet instance `ID`. Such as:`subnet-pxir56ns`.
         */
        subnetId: string;
    }

    export interface NetworkAclQuintupleNetworkAclQuintupleSet {
        /**
         * Network ACL quintuple outbound rule.
         */
        egresses?: outputs.Vpc.NetworkAclQuintupleNetworkAclQuintupleSetEgress[];
        /**
         * Network ACL quintuple inbound rule.
         */
        ingresses?: outputs.Vpc.NetworkAclQuintupleNetworkAclQuintupleSetIngress[];
    }

    export interface NetworkAclQuintupleNetworkAclQuintupleSetEgress {
        /**
         * Action, ACCEPT or DROP.
         */
        action?: string;
        /**
         * Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
         */
        createTime?: string;
        /**
         * Description.
         */
        description?: string;
        /**
         * Destination CIDR.
         */
        destinationCidr?: string;
        /**
         * Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
         */
        destinationPort?: string;
        /**
         * Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
         */
        networkAclDirection?: string;
        /**
         * Unique ID of a network ACL entry.
         */
        networkAclQuintupleEntryId?: string;
        /**
         * Priority, starting from 1.
         */
        priority?: number;
        /**
         * Protocol, value: TCP,UDP, ICMP, ALL.
         */
        protocol?: string;
        /**
         * Source CIDR.
         */
        sourceCidr?: string;
        /**
         * Source port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
         */
        sourcePort?: string;
    }

    export interface NetworkAclQuintupleNetworkAclQuintupleSetIngress {
        /**
         * Action, ACCEPT or DROP.
         */
        action?: string;
        /**
         * Creation time, used as an output parameter of DescribeNetworkAclQuintupleEntries.
         */
        createTime?: string;
        /**
         * Description.
         */
        description?: string;
        /**
         * Destination CIDR.
         */
        destinationCidr?: string;
        /**
         * Destination port (all, single port, range). When Protocol is ALL or ICMP, Port cannot be specified.
         */
        destinationPort?: string;
        /**
         * Direction, INGRESS or EGRESS, is used as an output parameter of DescribeNetworkAclQuintupleEntries.
         */
        networkAclDirection?: string;
        /**
         * Unique ID of a network ACL entry.
         */
        networkAclQuintupleEntryId?: string;
        /**
         * Priority, starting from 1.
         */
        priority?: number;
        /**
         * Protocol, value: TCP,UDP, ICMP, ALL.
         */
        protocol?: string;
        /**
         * CIDR.
         */
        sourceCidr?: string;
        /**
         * source port (all, single port, range). When the protocol is ALL or ICMP, the port cannot be specified.
         */
        sourcePort?: string;
    }

    export interface SnapshotPolicyAttachmentInstance {
        /**
         * InstanceId.
         */
        instanceId: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * The region where the instance is located.
         */
        instanceRegion: string;
        /**
         * Instance type, currently supports set: `securitygroup`.
         */
        instanceType: string;
        /**
         * Snapshot policy Id.
         */
        snapshotPolicyId: string;
    }

    export interface SnapshotPolicyBackupPolicy {
        /**
         * Backup cycle time, the value can be monday, tuesday, wednesday, thursday, friday, saturday, sunday.
         */
        backupDay: string;
        /**
         * Backup time point, format:HH:mm:ss.
         */
        backupTime: string;
    }

}

export namespace Vpn {
    export interface ConnectionSecurityGroupPolicy {
        /**
         * Local cidr block.
         */
        localCidrBlock: string;
        /**
         * Remote cidr block list.
         */
        remoteCidrBlocks: string[];
    }

    export interface CustomerGatewayConfigurationDownloadCustomerGatewayVendor {
        /**
         * Platform.
         */
        platform: string;
        /**
         * SoftwareVersion.
         */
        softwareVersion: string;
        /**
         * VendorName.
         */
        vendorName: string;
    }

    export interface GetConnectionsConnectionList {
        /**
         * Create time of the VPN connection.
         */
        createTime: string;
        /**
         * Customer gateway ID of the VPN connection.
         */
        customerGatewayId: string;
        /**
         * Encrypt proto of the VPN connection.
         */
        encryptProto: string;
        /**
         * ID of the VPN connection.
         */
        id: string;
        /**
         * DH group name of the IKE operation specification.
         */
        ikeDhGroupName: string;
        /**
         * Exchange mode of the IKE operation specification.
         */
        ikeExchangeMode: string;
        /**
         * Local address of the IKE operation specification.
         */
        ikeLocalAddress: string;
        /**
         * Local FQDN name of the IKE operation specification.
         */
        ikeLocalFqdnName: string;
        /**
         * Local identity of the IKE operation specification.
         */
        ikeLocalIdentity: string;
        /**
         * Proto authenticate algorithm of the IKE operation specification.
         */
        ikeProtoAuthenAlgorithm: string;
        /**
         * Proto encrypt algorithm of the IKE operation specification.
         */
        ikeProtoEncryAlgorithm: string;
        /**
         * Remote address of the IKE operation specification.
         */
        ikeRemoteAddress: string;
        /**
         * Remote FQDN name of the IKE operation specification.
         */
        ikeRemoteFqdnName: string;
        /**
         * Remote identity of the IKE operation specification.
         */
        ikeRemoteIdentity: string;
        /**
         * SA lifetime of the IKE operation specification, unit is `second`.
         */
        ikeSaLifetimeSeconds: number;
        /**
         * Version of the IKE operation specification.
         */
        ikeVersion: string;
        /**
         * Encrypt algorithm of the IPSEC operation specification.
         */
        ipsecEncryptAlgorithm: string;
        /**
         * Integrity algorithm of the IPSEC operation specification.
         */
        ipsecIntegrityAlgorithm: string;
        /**
         * PFS DH group name of the IPSEC operation specification.
         */
        ipsecPfsDhGroup: string;
        /**
         * SA lifetime of the IPSEC operation specification, unit is `second`.
         */
        ipsecSaLifetimeSeconds: number;
        /**
         * SA lifetime traffic of the IPSEC operation specification, unit is `KB`.
         */
        ipsecSaLifetimeTraffic: number;
        /**
         * Name of the VPN connection. The length of character is limited to 1-60.
         */
        name: string;
        /**
         * Net status of the VPN connection.
         */
        netStatus: string;
        /**
         * Pre-shared key of the VPN connection.
         */
        preShareKey: string;
        /**
         * Route type of the VPN connection.
         */
        routeType: string;
        /**
         * Security group policy of the VPN connection.
         */
        securityGroupPolicies: outputs.Vpn.GetConnectionsConnectionListSecurityGroupPolicy[];
        /**
         * State of the VPN connection.
         */
        state: string;
        /**
         * Tags of the VPN connection to be queried.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * VPN gateway ID of the VPN connection.
         */
        vpnGatewayId: string;
        /**
         * Vpn proto of the VPN connection.
         */
        vpnProto: string;
    }

    export interface GetConnectionsConnectionListSecurityGroupPolicy {
        /**
         * Local cidr block.
         */
        localCidrBlock: string;
        /**
         * Remote cidr block list.
         */
        remoteCidrBlocks: string[];
    }

    export interface GetCustomerGatewayVendorsCustomerGatewayVendorSet {
        /**
         * Platform.
         */
        platform: string;
        /**
         * SoftwareVersion.
         */
        softwareVersion: string;
        /**
         * VendorName.
         */
        vendorName: string;
    }

    export interface GetCustomerGatewaysGatewayList {
        /**
         * Create time of the VPN customer gateway.
         */
        createTime: string;
        /**
         * ID of the VPN customer gateway.
         */
        id: string;
        /**
         * Name of the customer gateway. The length of character is limited to 1-60.
         */
        name: string;
        /**
         * Public ip address of the VPN customer gateway.
         */
        publicIpAddress: string;
        /**
         * Tags of the VPN customer gateway to be queried.
         */
        tags: {[key: string]: any};
    }

    export interface GetGatewayRoutesVpnGatewayRouteList {
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Destination IDC IP range.
         */
        destinationCidrBlock: string;
        /**
         * Instance ID of the next hop.
         */
        instanceId: string;
        /**
         * Next hop type (type of the associated instance). Valid values: VPNCONN (VPN tunnel) and CCN (CCN instance).
         */
        instanceType: string;
        /**
         * Priority. Valid values: 0 and 100.
         */
        priority: number;
        /**
         * Route ID.
         */
        routeId: string;
        /**
         * Status. Valid values: ENABLE and DISABLE.
         */
        status: string;
        /**
         * Route type. Default value: Static.
         */
        type: string;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * VPN gateway ID.
         */
        vpnGatewayId: string;
    }

    export interface GetGatewaysGatewayList {
        /**
         * The maximum public network output bandwidth of VPN gateway (unit: Mbps).
         */
        bandwidth: number;
        /**
         * Charge Type of the VPN gateway.
         */
        chargeType: string;
        /**
         * Create time of the VPN gateway.
         */
        createTime: string;
        /**
         * Expired time of the VPN gateway when charge type is `PREPAID`.
         */
        expiredTime: string;
        /**
         * ID of the VPN gateway.
         */
        id: string;
        /**
         * Indicates whether ip address is blocked.
         */
        isAddressBlocked: boolean;
        /**
         * Name of the VPN gateway. The length of character is limited to 1-60.
         */
        name: string;
        /**
         * The plan of new purchase.
         */
        newPurchasePlan: string;
        /**
         * Flag indicates whether to renew or not.
         */
        prepaidRenewFlag: string;
        /**
         * Public ip address of the VPN gateway.
         */
        publicIpAddress: string;
        /**
         * Restrict state of VPN gateway.
         */
        restrictState: string;
        /**
         * State of the VPN gateway.
         */
        state: string;
        /**
         * Tags of the VPN gateway to be queried.
         */
        tags: {[key: string]: any};
        /**
         * Type of gateway instance.
         */
        type: string;
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * Zone of the VPN gateway.
         */
        zone: string;
    }

}

export namespace Waf {
    export interface AntiInfoLeakStrategy {
        /**
         * Matching Content. If field is returncode support: 400, 403, 404, 4xx, 500, 501, 502, 504, 5xx; If field is information support: idcard, phone, bankcard; If field is keywords users input matching content themselves.
         */
        content: string;
        /**
         * Matching Fields. support: returncode, keywords, information.
         */
        field: string;
    }

    export interface ClbDomainLoadBalancerSet {
        /**
         * Unique ID of listener in LB.
         */
        listenerId: string;
        /**
         * Listener name.
         */
        listenerName: string;
        /**
         * LoadBalancer unique ID.
         */
        loadBalancerId: string;
        /**
         * LoadBalancer name.
         */
        loadBalancerName: string;
        /**
         * Network type for load balancer.
         */
        loadBalancerType?: string;
        /**
         * VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditions.
         */
        numericalVpcId?: number;
        /**
         * Protocol of listener, http or https.
         */
        protocol: string;
        /**
         * LoadBalancer region.
         */
        region: string;
        /**
         * LoadBalancer IP.
         */
        vip: string;
        /**
         * LoadBalancer port.
         */
        vport: number;
        /**
         * LoadBalancer zone.
         */
        zone: string;
    }

    export interface CustomRuleStrategy {
        /**
         * Matching parameters.
         */
        arg: string;
        /**
         * Logical symbol.
         */
        compareFunc: string;
        /**
         * Matching Content.
         */
        content: string;
        /**
         * Matching Fields.
         */
        field: string;
    }

    export interface CustomWhiteRuleStrategy {
        /**
         * Matching parameters.
         */
        arg: string;
        /**
         * Logical symbol.
         */
        compareFunc: string;
        /**
         * Matching Content.
         */
        content: string;
        /**
         * Matching Fields.
         */
        field: string;
    }

    export interface GetAttackLogHistogramData {
        /**
         * The count of logs.
         */
        count: number;
        /**
         * Timestamp.
         */
        timeStamp: number;
    }

    export interface GetAttackLogListData {
        /**
         * The detail of attack log.
         */
        content: string;
        /**
         * Useless.
         */
        fileName: string;
        /**
         * Useless.
         */
        source: string;
        /**
         * Time string.
         */
        timeStamp: string;
    }

    export interface GetCiphersCipher {
        /**
         * Encryption Suite IDNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        cipherId: number;
        /**
         * Encryption Suite NameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        cipherName: string;
        /**
         * TLS version IDNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        versionId: number;
    }

    export interface GetDomainsDomain {
        /**
         * Traffic Source: clb represents Tencent Cloud clb, apisix represents apisix gateway, tsegw represents Tencent Cloud API gateway, default clbNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        albType: string;
        /**
         * API security switch status, 0 off, 1 onNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        apiStatus: number;
        /**
         * User appid.
         */
        appId: number;
        /**
         * BOT switch status, 0 off, 1 on.
         */
        botStatus: number;
        /**
         * Waf sandbox export addresses, should be added to the whitelist by the upstreams.
         */
        ccLists: string[];
        /**
         * Cdc clustersNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        cdcClusters: string;
        /**
         * Whether to enable access logs, 1 enable, 0 disable.
         */
        clsStatus: number;
        /**
         * Cname address, used for dns access.
         */
        cname: string;
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Domain name.
         */
        domain: string;
        /**
         * Domain unique ID.
         */
        domainId: string;
        /**
         * Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
         */
        edition: string;
        /**
         * Rule and AI Defense Mode, 10 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Shutdown Mode 11 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Observation Mode 12 Rule Engine Observation&amp;amp;&amp;amp;AI Engine Interception Mode 20 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Shutdown Mode 21 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Observation Mode 22 Rule Engine Interception&amp;amp;&amp;amp;AI Engine Interception Mode.
         */
        engine: number;
        /**
         * CLBWAF traffic mode, 1 cleaning mode, 0 mirroring mode.
         */
        flowMode: number;
        /**
         * Unique ID of Instance.
         */
        instanceId: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Ipv6 switch status, 0 off, 1 on.
         */
        ipv6Status: number;
        /**
         * Instance level.
         */
        level: number;
        /**
         * List of bound LB.
         */
        loadBalancerSets: outputs.Waf.GetDomainsDomainLoadBalancerSet[];
        /**
         * Rule defense mode, 0 observation mode, 1 interception mode.
         */
        mode: number;
        /**
         * Listening ports.
         */
        ports: outputs.Waf.GetDomainsDomainPort[];
        /**
         * Whether to enable the delivery of CKafka function, 0 off, 1 on.
         */
        postCkafkaStatus: number;
        /**
         * Whether to enable the delivery CLS function, 0 off, 1 on.
         */
        postClsStatus: number;
        /**
         * Region.
         */
        region: string;
        /**
         * Waf engine export addresses, should be added to the whitelist by the upstreams.
         */
        rsLists: string[];
        /**
         * Detailed explanation of security group statusNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        sgDetail: string;
        /**
         * Security group status, 0 does not display, 1 non Tencent cloud source site, 2 security group binding failed, 3 security group changedNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        sgState: number;
        /**
         * Clbwaf domain name listener status, 0 operation successful, 4 binding LB, 6 unbinding LB, 7 unbinding LB failed, 8 binding LB failed, 10 internal error.
         */
        state: number;
        /**
         * Waf switch,0 off 1 on.
         */
        status: number;
    }

    export interface GetDomainsDomainLoadBalancerSet {
        /**
         * Listener unique IDNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        listenerId: string;
        /**
         * Listener nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        listenerName: string;
        /**
         * LoadBalancer IDNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        loadBalancerId: string;
        /**
         * LoadBalancer nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        loadBalancerName: string;
        /**
         * Loadbalancer typeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        loadBalancerType: string;
        /**
         * VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditionsNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        numericalVpcId: number;
        /**
         * The listening protocol of listening port.
         */
        protocol: string;
        /**
         * Region.
         */
        region: string;
        /**
         * LoadBalancer ipNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        vip: string;
        /**
         * Listener portNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        vport: number;
        /**
         * Loadbalancer zoneNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        zone: string;
    }

    export interface GetDomainsDomainPort {
        /**
         * Nginx server ID.
         */
        nginxServerId: number;
        /**
         * Listening port.
         */
        port: string;
        /**
         * The listening protocol of listening port.
         */
        protocol: string;
        /**
         * The upstream port for listening port.
         */
        upstreamPort: string;
        /**
         * The upstream protocol for listening port.
         */
        upstreamProtocol: string;
    }

    export interface GetFindDomainsList {
        /**
         * User appid.
         */
        appid: number;
        /**
         * Domain name.
         */
        domain: string;
        /**
         * Domain unique id.
         */
        domainId: string;
        /**
         * Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
         */
        edition: string;
        /**
         * Find time.
         */
        findTime: string;
        /**
         * Instance unique id.
         */
        instanceId: string;
        /**
         * Domain ip.
         */
        ips: string[];
        /**
         * Whether access to waf or not.
         */
        isWafDomain: number;
    }

    export interface GetInstanceQpsLimitQpsData {
        /**
         * Elastic qps default value.
         */
        elasticBillingDefault: number;
        /**
         * Maximum elastic qps.
         */
        elasticBillingMax: number;
        /**
         * Minimum elastic qps.
         */
        elasticBillingMin: number;
        /**
         * Maximum qps of extend package for overseas.
         */
        qpsExtendIntlMax: number;
        /**
         * Maximum qps of extend package.
         */
        qpsExtendMax: number;
    }

    export interface GetPeakPointsPoint {
        /**
         * qps.
         */
        access: number;
        /**
         * Number of web attacks.
         */
        attack: number;
        /**
         * Bot qps.
         */
        botAccess: number;
        /**
         * Number of cc attacks.
         */
        cc: number;
        /**
         * Peak downlink bandwidth, unit B.
         */
        down: number;
        /**
         * Trend chart of the number of status codes returned by WAF to the client.
         */
        statusClientError: number;
        /**
         * Trend chart of the number of status codes returned by WAF to the client.
         */
        statusOk: number;
        /**
         * Trend chart of the number of status codes returned by WAF to the client.
         */
        statusRedirect: number;
        /**
         * Trend chart of the number of status codes returned by WAF to the server.
         */
        statusServerError: number;
        /**
         * Second level timestamp.
         */
        time: number;
        /**
         * Peak uplink bandwidth, unit B.
         */
        up: number;
        /**
         * Trend chart of the number of status codes returned to WAF by the origin site.
         */
        upstreamClientError: number;
        /**
         * Trend chart of the number of status codes returned to WAF by the origin site.
         */
        upstreamRedirect: number;
        /**
         * Trend chart of the number of status codes returned to WAF by the origin site.
         */
        upstreamServerError: number;
    }

    export interface GetTlsVersionsTl {
        /**
         * TLS version IDNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        versionId: number;
        /**
         * Tls version nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        versionName: string;
    }

    export interface GetUserClbRegionsRichData {
        /**
         * Region code.
         */
        code: string;
        /**
         * Region ID.
         */
        id: string;
        /**
         * Chinese description for region.
         */
        text: string;
        /**
         * English description for region.
         */
        value: string;
    }

    export interface GetUserDomainsUsersInfo {
        /**
         * User appid.
         */
        appid: number;
        /**
         * CLS switch 1: write, 0: do not writeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        cls: number;
        /**
         * Domain name.
         */
        domain: string;
        /**
         * Domain unique id.
         */
        domainId: string;
        /**
         * Instance type, sparta-waf represents SAAS WAF, clb-waf represents CLB WAF.
         */
        edition: string;
        /**
         * Instance unique id.
         */
        instanceId: string;
        /**
         * Instance name.
         */
        instanceName: string;
        /**
         * Instance level infoNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        level: string;
        /**
         * Switch for accessing log fieldsNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        writeConfig: string;
    }

    export interface GetWafInfosHostList {
        /**
         * Domain name.
         */
        domain: string;
        /**
         * Domain unique ID.
         */
        domainId: string;
        /**
         * WAF traffic mode, 1 cleaning mode, 0 mirroring mode.
         */
        flowMode: number;
        /**
         * LoadBalancer info bound by waf.
         */
        loadBalancers: outputs.Waf.GetWafInfosHostListLoadBalancer[];
        /**
         * Waf switch,0 off 1 on.
         */
        status: number;
    }

    export interface GetWafInfosHostListLoadBalancer {
        /**
         * Unique ID of listener in LB.
         */
        listenerId: string;
        /**
         * Listener name.
         */
        listenerName: string;
        /**
         * LoadBalancer ID.
         */
        loadBalancerId: string;
        /**
         * LoadBalancer name.
         */
        loadBalancerName: string;
        /**
         * Network type for load balancerNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        loadBalancerType: string;
        /**
         * VPCID for load balancer, public network is -1, and internal network is filled in according to actual conditionsNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        numericalVpcId: number;
        /**
         * Protocol of listenerhttp or https.
         */
        protocol: string;
        /**
         * LoadBalancer region.
         */
        region: string;
        /**
         * LoadBalancer IP.
         */
        vip: string;
        /**
         * LoadBalancer port.
         */
        vport: number;
        /**
         * LoadBalancer zone.
         */
        zone: string;
    }

    export interface GetWafInfosParam {
        /**
         * Domain unique ID.
         */
        domainId?: string;
        /**
         * Listener ID of LoadBalancer.
         */
        listenerId?: string;
        /**
         * Loadbalancer unique ID.If this parameter is not passed, it will operate all listeners of this appid. If this parameter is not empty, it will operate listeners of the LoadBalancer only.
         */
        loadBalancerId: string;
    }

    export interface IpAccessControlItem {
        /**
         * Action value 40 is whitelist, 42 is blacklist.
         */
        action: number;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * IP address.
         */
        ip: string;
        /**
         * Note info.
         */
        note: string;
        /**
         * Source.
         */
        source: string;
        /**
         * Valid status.
         */
        validStatus: number;
        /**
         * Effective date, with a second level timestamp value. For example, 1680570420 represents 2023-04-04 09:07:00; 2019571199 means permanently effective.
         */
        validTs: number;
    }

    export interface SaasDomainPort {
        /**
         * Nginx server ID.
         */
        nginxServerId: string;
        /**
         * Listening port.
         */
        port: string;
        /**
         * The listening protocol of listening port.
         */
        protocol: string;
        /**
         * The upstream port for listening port.
         */
        upstreamPort: string;
        /**
         * The upstream protocol for listening port.
         */
        upstreamProtocol: string;
    }

}

export namespace Wedata {
    export interface BaselineAlarmRuleDto {
        /**
         * Important;Urgent;Normal.
         */
        alarmLevelType?: string;
        /**
         * Alarm Rule ID.
         */
        alarmRuleId?: string;
    }

    export interface BaselineBaselineCreateAlarmRuleRequest {
        /**
         * Alarm Level, 1. Normal, 2. Important, 3. Urgent (default is 1. Normal)Note: This field may return null, indicating no valid value.
         */
        alarmLevel: number;
        /**
         * Alarm Recipient IDsNote: This field may return null, indicating no valid value.
         */
        alarmRecipientIds: string[];
        /**
         * Alarm Recipient Type: 1. Specified Personnel, 2. Task Owner, 3. Duty Roster (default is 1. Specified Personnel)Note: This field may return null, indicating no valid value.
         */
        alarmRecipientType: number;
        /**
         * Alarm RecipientsNote: This field may return null, indicating no valid value.
         */
        alarmRecipients: string[];
        /**
         * Alarm Types, 1. Failure Alarm, 2. Timeout Alarm, 3. Success Alarm, 4. Baseline Violation, 5. Baseline Warning, 6. Baseline Task Failure (default is 1. Failure Alarm)Note: This field may return null, indicating no valid value.
         */
        alarmTypes: string[];
        /**
         * Alarm Methods, 1. Email, 2. SMS, 3. WeChat, 4. Voice, 5. Enterprise WeChat, 6. HTTP, 7. Enterprise WeChat Group; Alarm method code list (default is 1. Email)Note: This field may return null, indicating no valid value.
         */
        alarmWays: string[];
        /**
         * Creator UINNote: This field may return null, indicating no valid value.
         */
        creator: string;
        /**
         * Creator NameNote: This field may return null, indicating no valid value.
         */
        creatorId: string;
        /**
         * Extended Information, 1. Estimated Runtime (default), 2. Estimated Completion Time, 3. Estimated Scheduling Time, 4. Incomplete within the Cycle; Value Types: 1. Specified Value, 2. Historical Average (default is 1. Specified Value)Note: This field may return null, indicating no valid value.
         */
        extInfo: string;
        /**
         * Monitoring ObjectsNote: This field may return null, indicating no valid value.
         */
        monitorObjectIds: string[];
        /**
         * Monitoring Type, 1. Task, 2. Workflow, 3. Project, 4. Baseline (default is 1. Task)Note: This field may return null, indicating no valid value.
         */
        monitorType: number;
        /**
         * Project NameNote: This field may return null, indicating no valid value.
         */
        projectId: string;
        /**
         * Rule NameNote: This field may return null, indicating no valid value.
         */
        ruleName: string;
    }

    export interface BaselinePromiseTask {
        /**
         * Project ID.
         */
        projectId?: string;
        /**
         * Task Scheduling Cycle.
         */
        taskCycle?: string;
        /**
         * Task ID.
         */
        taskId?: string;
        /**
         * Task Owner Name.
         */
        taskInChargeName?: string;
        /**
         * Task Owner ID.
         */
        taskInChargeUin?: string;
        /**
         * Task Name.
         */
        taskName?: string;
        /**
         * Workflow ID.
         */
        workflowId?: string;
        /**
         * Workflow Name.
         */
        workflowName?: string;
    }

    export interface DqRuleCompareRule {
        /**
         * Periodic Indicates the default period of a template, in secondsNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        cycleStep?: number;
        /**
         * Comparison condition listNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        items?: outputs.Wedata.DqRuleCompareRuleItem[];
    }

    export interface DqRuleCompareRuleItem {
        /**
         * Comparison type 1. Fixed value 2. Fluctuating value 3. Comparison of value range 4. Enumeration range comparison 5. Do not compareNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        compareType?: number;
        /**
         * Comparison operation type &amp;lt; &amp;lt;= == =&amp;gt; &amp;gt;Note: This field may return null, indicating that a valid value cannot be obtained.
         */
        operator?: string;
        /**
         * Quality statistics Type 1. Absolute value 2. Increase 3. Decrease 4. C contains 5. N C does not containNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        valueComputeType?: number;
        /**
         * Compare the threshold listNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        valueLists?: outputs.Wedata.DqRuleCompareRuleItemValueList[];
    }

    export interface DqRuleCompareRuleItemValueList {
        /**
         * Threshold valueNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        value?: string;
        /**
         * Threshold type 1. Low threshold 2. High threshold 3. Common threshold 4. Enumerated valueNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        valueType?: number;
    }

    export interface DqRuleFieldConfig {
        /**
         * Library table variableNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        tableConfigs?: outputs.Wedata.DqRuleFieldConfigTableConfig[];
        /**
         * Where variableNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        whereConfigs?: outputs.Wedata.DqRuleFieldConfigWhereConfig[];
    }

    export interface DqRuleFieldConfigTableConfig {
        /**
         * Database idNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        databaseId?: string;
        /**
         * Database nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        databaseName?: string;
        /**
         * Field variableNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        fieldConfigs?: outputs.Wedata.DqRuleFieldConfigTableConfigFieldConfig[];
        /**
         * Table idNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        tableId?: string;
        /**
         * Table keyNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        tableKey?: string;
        /**
         * Table nameNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        tableName?: string;
    }

    export interface DqRuleFieldConfigTableConfigFieldConfig {
        /**
         * Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        fieldDataType?: string;
        /**
         * Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        fieldKey?: string;
        /**
         * Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        fieldValue?: string;
    }

    export interface DqRuleFieldConfigWhereConfig {
        /**
         * Field typeNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        fieldDataType?: string;
        /**
         * Field keyNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        fieldKey?: string;
        /**
         * Field valueNote: This field may return null, indicating that a valid value cannot be obtained.
         */
        fieldValue?: string;
    }

    export interface FunctionResourceList {
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource MD5 Value.
         */
        md5?: string;
        /**
         * Resource Name.
         */
        name: string;
        /**
         * Resource Path.
         */
        path: string;
        /**
         * Resource Type.
         */
        type?: string;
    }

    export interface GetDataSourceListFilter {
        /**
         * Filter name.
         */
        name?: string;
        /**
         * Filter value.
         */
        values?: string[];
    }

    export interface GetDataSourceListOrderField {
        /**
         * OrderFields rule.
         */
        direction: string;
        /**
         * OrderFields name.
         */
        name: string;
    }

    export interface GetDataSourceListRow {
        /**
         * Appid.
         */
        appId: number;
        /**
         * Has Author.
         */
        author: boolean;
        /**
         * Datasource AuthorityProjectName.
         */
        authorityProjectName: string;
        /**
         * Datasource AuthorityUserName.
         */
        authorityUserName: string;
        /**
         * Biz params.
         */
        bizParams: string;
        /**
         * Biz params json string.
         */
        bizParamsString: string;
        /**
         * Datasource category.
         */
        category: string;
        /**
         * Datasource cluster id.
         */
        clusterId: string;
        /**
         * Datasource cluster name.
         */
        clusterName: string;
        /**
         * CreateTime.
         */
        createTime: number;
        /**
         * DatasourceDataSourceStatus.
         */
        dataSourceStatus: string;
        /**
         * DatabaseName.
         */
        databaseName: string;
        /**
         * Can Deliver.
         */
        deliver: boolean;
        /**
         * Description.
         */
        description: string;
        /**
         * Datasource display name.
         */
        display: string;
        /**
         * Datasource can Edit.
         */
        edit: boolean;
        /**
         * ID.
         */
        id: number;
        /**
         * Instance.
         */
        instance: string;
        /**
         * Datasource ModifiedTime.
         */
        modifiedTime: number;
        /**
         * Filter name.
         */
        name: string;
        /**
         * Datasource owner account.
         */
        ownerAccount: string;
        /**
         * Datasource owner account name.
         */
        ownerAccountName: string;
        /**
         * Datasource owner project id.
         */
        ownerProjectId: string;
        /**
         * Datasource OwnerProjectIdent.
         */
        ownerProjectIdent: string;
        /**
         * Datasource OwnerProjectName.
         */
        ownerProjectName: string;
        /**
         * Datasource params.
         */
        params: string;
        /**
         * Params json string.
         */
        paramsString: string;
        /**
         * Datasource engin cluster region.
         */
        region: string;
        /**
         * Datasource show type.
         */
        showType: string;
        /**
         * Datasource status.
         */
        status: number;
        /**
         * Datasource type.
         */
        type: string;
    }

    export interface GetDataSourceWithoutInfoData {
        /**
         * Appid.
         */
        appId: number;
        /**
         * Has Author.
         */
        author: boolean;
        /**
         * Datasource AuthorityProjectName.
         */
        authorityProjectName: string;
        /**
         * Datasource AuthorityUserName.
         */
        authorityUserName: string;
        /**
         * Biz params.
         */
        bizParams: string;
        /**
         * Biz params json string.
         */
        bizParamsString: string;
        /**
         * Datasource category.
         */
        category: string;
        /**
         * Datasource cluster id.
         */
        clusterId: string;
        /**
         * Datasource cluster name.
         */
        clusterName: string;
        /**
         * CreateTime.
         */
        createTime: number;
        /**
         * DatasourceDataSourceStatus.
         */
        dataSourceStatus: string;
        /**
         * DatabaseName.
         */
        databaseName: string;
        /**
         * Can Deliver.
         */
        deliver: boolean;
        /**
         * Description.
         */
        description: string;
        /**
         * Datasource display name.
         */
        display: string;
        /**
         * Datasource can Edit.
         */
        edit: boolean;
        /**
         * ID.
         */
        id: number;
        /**
         * Instance.
         */
        instance: string;
        /**
         * Datasource ModifiedTime.
         */
        modifiedTime: number;
        /**
         * Filter name.
         */
        name: string;
        /**
         * Datasource owner account.
         */
        ownerAccount: string;
        /**
         * Datasource owner account name.
         */
        ownerAccountName: string;
        /**
         * Datasource owner project id.
         */
        ownerProjectId: string;
        /**
         * Datasource OwnerProjectIdent.
         */
        ownerProjectIdent: string;
        /**
         * Datasource OwnerProjectName.
         */
        ownerProjectName: string;
        /**
         * Datasource params.
         */
        params: string;
        /**
         * Params json string.
         */
        paramsString: string;
        /**
         * Datasource engin cluster region.
         */
        region: string;
        /**
         * Datasource show type.
         */
        showType: string;
        /**
         * Datasource status.
         */
        status: number;
        /**
         * Datasource type.
         */
        type: string;
    }

    export interface GetDataSourceWithoutInfoFilter {
        /**
         * Filter name.
         */
        name?: string;
        /**
         * Filter value.
         */
        values?: string[];
    }

    export interface GetDataSourceWithoutInfoOrderField {
        /**
         * OrderFields rule.
         */
        direction: string;
        /**
         * OrderFields name.
         */
        name: string;
    }

    export interface GetRuleTemplatesData {
        /**
         * Citations.
         */
        citationCount: number;
        /**
         * The type of comparison method supported by the rule (1: fixed value comparison, greater than, less than, greater than or equal to, etc. 2: fluctuating value comparison, absolute value, rise, fall).
         */
        compareType: number;
        /**
         * Description of rule template.
         */
        description: string;
        /**
         * Whether to associate other library tables.
         */
        multiSourceFlag: boolean;
        /**
         * Name of rule template.
         */
        name: string;
        /**
         * Quality inspection dimensions. `1`: Accuracy, `2`: Uniqueness, `3`: Completeness, `4`: Consistency, `5`: Timeliness, `6`: Effectiveness.
         */
        qualityDim: number;
        /**
         * ID of rule template.
         */
        ruleTemplateId: number;
        /**
         * Content of rule template.
         */
        sourceContent: string;
        /**
         * Applicable type of source data.
         */
        sourceEngineTypes: number[];
        /**
         * Source data object type. `1`: value, `2`: string.
         */
        sourceObjectDataType: number;
        /**
         * Source data object type. `1`: Constant, `2`: Offline table level, `3`: Offline field level.
         */
        sourceObjectType: number;
        /**
         * Sql Expression.
         */
        sqlExpression: string;
        /**
         * Sub Quality inspection dimensions. `1`: Accuracy, `2`: Uniqueness, `3`: Completeness, `4`: Consistency, `5`: Timeliness, `6`: Effectiveness.
         */
        subQualityDim: number;
        /**
         * Template type. `1` means System template, `2` means Custom template.
         */
        type: number;
        /**
         * update time, like: yyyy-MM-dd HH:mm:ss.
         */
        updateTime: string;
        /**
         * user id.
         */
        userId: number;
        /**
         * user name.
         */
        userName: string;
        /**
         * If add where.
         */
        whereFlag: boolean;
    }

    export interface IntegrationOfflineTaskTaskInfo {
        /**
         * User App Id.
         */
        appId?: string;
        /**
         * Task configuration.
         */
        configs?: outputs.Wedata.IntegrationOfflineTaskTaskInfoConfig[];
        /**
         * Create time.
         */
        createTime?: string;
        /**
         * Creator User ID.
         */
        creatorUin?: string;
        /**
         * Data proxy url.
         */
        dataProxyUrls?: string[];
        /**
         * Execute context.
         */
        executeContexts?: outputs.Wedata.IntegrationOfflineTaskTaskInfoExecuteContext[];
        /**
         * Executor group name.
         */
        executorGroupName?: string;
        /**
         * Executor resource ID.
         */
        executorId?: string;
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationOfflineTaskTaskInfoExtConfig[];
        /**
         * Whether the task been submitted.
         */
        hasVersion?: boolean;
        /**
         * InLong manager url.
         */
        inLongManagerUrl?: string;
        /**
         * InLong manager version.
         */
        inLongManagerVersion?: string;
        /**
         * InLong stream id.
         */
        inLongStreamId?: string;
        /**
         * Incharge user.
         */
        incharge?: string;
        /**
         * Input datasource type.
         */
        inputDatasourceType?: string;
        /**
         * Instance version.
         */
        instanceVersion?: number;
        /**
         * The last time the task was run.
         */
        lastRunTime?: string;
        /**
         * Whether the task been locked.
         */
        locked?: boolean;
        /**
         * User locked task.
         */
        locker?: string;
        /**
         * Node mapping.
         */
        mappings?: outputs.Wedata.IntegrationOfflineTaskTaskInfoMapping[];
        /**
         * Number of reads.
         */
        numRecordsIn?: number;
        /**
         * Number of writes.
         */
        numRecordsOut?: number;
        /**
         * Times of restarts.
         */
        numRestarts?: number;
        /**
         * Offline task scheduling configuration.
         */
        offlineTaskAddEntity?: outputs.Wedata.IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity;
        /**
         * Operator User ID.
         */
        operatorUin?: string;
        /**
         * Output datasource type.
         */
        outputDatasourceType?: string;
        /**
         * Owner User ID.
         */
        ownerUin?: string;
        /**
         * Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
         */
        readPhase?: number;
        /**
         * Read latency.
         */
        readerDelay?: number;
        /**
         * The amount of resources consumed by real-time task.
         */
        runningCu?: number;
        /**
         * Task scheduling id (job id such as oceanus or us).
         */
        scheduleTaskId?: string;
        /**
         * Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
         */
        status?: number;
        /**
         * The time the task was stopped.
         */
        stopTime?: string;
        /**
         * Whether the task version has been submitted for operation and maintenance.
         */
        submit?: boolean;
        /**
         * Resource tiering status, 0: in progress, 1: successful, 2: failed.
         */
        switchResource?: number;
        /**
         * Synchronization type: 1. Whole database synchronization, 2. Single table synchronization.
         */
        syncType?: number;
        /**
         * Task alarm regular.
         */
        taskAlarmRegularLists?: string[];
        /**
         * Inlong Task Group ID.
         */
        taskGroupId?: string;
        /**
         * Task display mode, 0: canvas mode, 1: form mode.
         */
        taskMode?: string;
        /**
         * Update time.
         */
        updateTime?: string;
        /**
         * The workflow id to which the task belongs.
         */
        workflowId?: string;
    }

    export interface IntegrationOfflineTaskTaskInfoConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationOfflineTaskTaskInfoExecuteContext {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationOfflineTaskTaskInfoExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationOfflineTaskTaskInfoMapping {
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationOfflineTaskTaskInfoMappingExtConfig[];
        /**
         * Schema mapping information.
         */
        schemaMappings?: outputs.Wedata.IntegrationOfflineTaskTaskInfoMappingSchemaMapping[];
        /**
         * Sink node ID.
         */
        sinkId?: string;
        /**
         * Source node ID.
         */
        sourceId?: string;
        /**
         * Source node schema information.
         */
        sourceSchemas?: outputs.Wedata.IntegrationOfflineTaskTaskInfoMappingSourceSchema[];
    }

    export interface IntegrationOfflineTaskTaskInfoMappingExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationOfflineTaskTaskInfoMappingSchemaMapping {
        /**
         * Schema ID from sink node.
         */
        sinkSchemaId: string;
        /**
         * Schema ID from source node.
         */
        sourceSchemaId: string;
    }

    export interface IntegrationOfflineTaskTaskInfoMappingSourceSchema {
        /**
         * Schema alias.
         */
        alias?: string;
        /**
         * Schema comment.
         */
        comment?: string;
        /**
         * Schema ID.
         */
        id: string;
        /**
         * Schema name.
         */
        name: string;
        /**
         * Schema extended attributes.
         */
        properties?: outputs.Wedata.IntegrationOfflineTaskTaskInfoMappingSourceSchemaProperty[];
        /**
         * Schema type.
         */
        type: string;
        /**
         * Schema value.
         */
        value?: string;
    }

    export interface IntegrationOfflineTaskTaskInfoMappingSourceSchemaProperty {
        /**
         * Attributes name.
         */
        name?: string;
        /**
         * Attributes value.
         */
        value?: string;
    }

    export interface IntegrationOfflineTaskTaskInfoOfflineTaskAddEntity {
        /**
         * Crontab expression.
         */
        crontabExpression?: string;
        /**
         * Scheduling type, 0: crontab type, 1: minutes, 2: hours, 3: days, 4: weeks, 5: months, 6: one-time, 7: user-driven, 10: elastic period (week), 11: elastic period (month), 12: year, 13: instant trigger.
         */
        cycleType?: number;
        /**
         * Scheduling execution end time.
         */
        executionEndTime?: string;
        /**
         * Scheduling execution start time.
         */
        executionStartTime?: string;
        /**
         * Whether to retry.
         */
        retriable?: number;
        /**
         * Retry waiting time, unit is minutes.
         */
        retryWait?: number;
        /**
         * Self-dependent rules, 1: Ordered serial one at a time, queued execution, 2: Unordered serial one at a time, not queued execution, 3: Parallel, multiple at once.
         */
        selfDepend?: number;
        /**
         * Number of retries.
         */
        tryLimit?: number;
    }

    export interface IntegrationRealtimeTaskTaskInfo {
        /**
         * User App Id.
         */
        appId: string;
        /**
         * Task configuration.
         */
        configs?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoConfig[];
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Creator User ID.
         */
        creatorUin: string;
        /**
         * Data proxy url.
         */
        dataProxyUrls: string[];
        /**
         * Execute context.
         */
        executeContexts?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoExecuteContext[];
        /**
         * Executor group name.
         */
        executorGroupName: string;
        /**
         * Executor resource ID.
         */
        executorId?: string;
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoExtConfig[];
        /**
         * Whether the task been submitted.
         */
        hasVersion: boolean;
        /**
         * InLong manager url.
         */
        inLongManagerUrl: string;
        /**
         * InLong manager version.
         */
        inLongManagerVersion: string;
        /**
         * InLong stream id.
         */
        inLongStreamId: string;
        /**
         * Incharge user.
         */
        incharge?: string;
        /**
         * Input datasource type.
         */
        inputDatasourceType: string;
        /**
         * Instance version.
         */
        instanceVersion: number;
        /**
         * The last time the task was run.
         */
        lastRunTime: string;
        /**
         * Whether the task been locked.
         */
        locked: boolean;
        /**
         * User locked task.
         */
        locker: string;
        /**
         * Node mapping.
         */
        mappings?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoMapping[];
        /**
         * Task Node Information.
         */
        nodes?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNode[];
        /**
         * Number of reads.
         */
        numRecordsIn: number;
        /**
         * Number of writes.
         */
        numRecordsOut: number;
        /**
         * Times of restarts.
         */
        numRestarts: number;
        /**
         * Operator User ID.
         */
        operatorUin: string;
        /**
         * Output datasource type.
         */
        outputDatasourceType: string;
        /**
         * Owner User ID.
         */
        ownerUin: string;
        /**
         * Reading stage, 0: full amount, 1: partial full amount, 2: all incremental.
         */
        readPhase: number;
        /**
         * Read latency.
         */
        readerDelay: number;
        /**
         * The amount of resources consumed by real-time task.
         */
        runningCu: number;
        /**
         * Task scheduling id (job id such as oceanus or us).
         */
        scheduleTaskId: string;
        /**
         * Task status 1. Not started | Task initialization, 2. Task starting, 3. Running, 4. Paused, 5. Task stopping, 6. Stopped, 7. Execution failed, 8. deleted, 9. Locked, 404. unknown status.
         */
        status: number;
        /**
         * The time the task was stopped.
         */
        stopTime: string;
        /**
         * Whether the task version has been submitted for operation and maintenance.
         */
        submit: boolean;
        /**
         * Resource tiering status, 0: in progress, 1: successful, 2: failed.
         */
        switchResource: number;
        /**
         * Task alarm regular.
         */
        taskAlarmRegularLists: string[];
        /**
         * Inlong Task Group ID.
         */
        taskGroupId: string;
        /**
         * Update time.
         */
        updateTime: string;
        /**
         * The workflow id to which the task belongs.
         */
        workflowId: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoExecuteContext {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoMapping {
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoMappingExtConfig[];
        /**
         * Schema mapping information.
         */
        schemaMappings?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoMappingSchemaMapping[];
        /**
         * Sink node ID.
         */
        sinkId?: string;
        /**
         * Source node ID.
         */
        sourceId?: string;
        /**
         * Source node schema information.
         */
        sourceSchemas?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoMappingSourceSchema[];
    }

    export interface IntegrationRealtimeTaskTaskInfoMappingExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoMappingSchemaMapping {
        /**
         * Schema ID from sink node.
         */
        sinkSchemaId: string;
        /**
         * Schema ID from source node.
         */
        sourceSchemaId: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoMappingSourceSchema {
        /**
         * Schema alias.
         */
        alias?: string;
        /**
         * Schema comment.
         */
        comment?: string;
        /**
         * Schema ID.
         */
        id: string;
        /**
         * Schema name.
         */
        name: string;
        /**
         * Schema extended attributes.
         */
        properties?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoMappingSourceSchemaProperty[];
        /**
         * Schema type.
         */
        type: string;
        /**
         * Schema value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoMappingSourceSchemaProperty {
        /**
         * Attributes name.
         */
        name?: string;
        /**
         * Attributes value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNode {
        /**
         * User App Id.
         */
        appId?: string;
        /**
         * Node configuration information.
         */
        configs?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeConfig[];
        /**
         * Create time.
         */
        createTime?: string;
        /**
         * Creator User ID.
         */
        creatorUin?: string;
        /**
         * Data source type: MYSQL, POSTGRE, ORACLE, SQLSERVER, FTP, HIVE, HDFS, ICEBERG, KAFKA, HBASE, SPARK, TBASE, DB2, DM, GAUSSDB, GBASE, IMPALA, ES, S3_DATAINSIGHT, GREENPLUM, PHOENIX, SAP_HANA, SFTP, OCEANBASE, CLICKHOUSE, KUDU, VERTICA, REDIS, COS, DLC, DORIS, CKAFKA, DTS_KAFKA, S3, CDW, TDSQLC, TDSQL, MONGODB, SYBASE, REST_API, StarRocks, TCHOUSE_X.
         */
        dataSourceType?: string;
        /**
         * Datasource ID.
         */
        datasourceId?: string;
        /**
         * Node Description.
         */
        description?: string;
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeExtConfig[];
        /**
         * Node ID.
         */
        id?: string;
        /**
         * Node Name.
         */
        name?: string;
        /**
         * Node mapping.
         */
        nodeMapping?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeNodeMapping;
        /**
         * Node type: INPUT,OUTPUT,JOIN,FILTER,TRANSFORM.
         */
        nodeType?: string;
        /**
         * Operator User ID.
         */
        operatorUin?: string;
        /**
         * Owner User ID.
         */
        ownerUin?: string;
        /**
         * Project ID.
         */
        projectId?: string;
        /**
         * Schema information.
         */
        schemas?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeSchema[];
        /**
         * The task id to which the node belongs.
         */
        taskId?: string;
        /**
         * Update time.
         */
        updateTime?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeNodeMapping {
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfig[];
        /**
         * Schema mapping information.
         */
        schemaMappings?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping[];
        /**
         * Sink node ID.
         */
        sinkId?: string;
        /**
         * Source node ID.
         */
        sourceId?: string;
        /**
         * Source node schema information.
         */
        sourceSchemas?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchema[];
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeNodeMappingExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeNodeMappingSchemaMapping {
        /**
         * Schema ID from sink node.
         */
        sinkSchemaId: string;
        /**
         * Schema ID from source node.
         */
        sourceSchemaId: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchema {
        /**
         * Schema alias.
         */
        alias?: string;
        /**
         * Schema comment.
         */
        comment?: string;
        /**
         * Schema ID.
         */
        id: string;
        /**
         * Schema name.
         */
        name: string;
        /**
         * Schema extended attributes.
         */
        properties?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaProperty[];
        /**
         * Schema type.
         */
        type: string;
        /**
         * Schema value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeNodeMappingSourceSchemaProperty {
        /**
         * Attributes name.
         */
        name?: string;
        /**
         * Attributes value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeSchema {
        /**
         * Schema alias.
         */
        alias?: string;
        /**
         * Schema comment.
         */
        comment?: string;
        /**
         * Schema ID.
         */
        id: string;
        /**
         * Schema name.
         */
        name: string;
        /**
         * Schema extended attributes.
         */
        properties?: outputs.Wedata.IntegrationRealtimeTaskTaskInfoNodeSchemaProperty[];
        /**
         * Schema type.
         */
        type: string;
        /**
         * Schema value.
         */
        value?: string;
    }

    export interface IntegrationRealtimeTaskTaskInfoNodeSchemaProperty {
        /**
         * Attributes name.
         */
        name?: string;
        /**
         * Attributes value.
         */
        value?: string;
    }

    export interface IntegrationTaskNodeNodeInfo {
        /**
         * User App Id.
         */
        appId: string;
        /**
         * Node configuration information.
         */
        configs?: outputs.Wedata.IntegrationTaskNodeNodeInfoConfig[];
        /**
         * Create time.
         */
        createTime: string;
        /**
         * Creator User ID.
         */
        creatorUin: string;
        /**
         * Datasource ID.
         */
        datasourceId?: string;
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationTaskNodeNodeInfoExtConfig[];
        /**
         * Node mapping.
         */
        nodeMapping?: outputs.Wedata.IntegrationTaskNodeNodeInfoNodeMapping;
        /**
         * Operator User ID.
         */
        operatorUin: string;
        /**
         * Owner User ID.
         */
        ownerUin: string;
        /**
         * Schema information.
         */
        schemas?: outputs.Wedata.IntegrationTaskNodeNodeInfoSchema[];
        /**
         * Update time.
         */
        updateTime: string;
    }

    export interface IntegrationTaskNodeNodeInfoConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationTaskNodeNodeInfoExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationTaskNodeNodeInfoNodeMapping {
        /**
         * Node extension configuration information.
         */
        extConfigs?: outputs.Wedata.IntegrationTaskNodeNodeInfoNodeMappingExtConfig[];
        /**
         * Schema mapping information.
         */
        schemaMappings?: outputs.Wedata.IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping[];
        /**
         * Sink node ID.
         */
        sinkId?: string;
        /**
         * Source node ID.
         */
        sourceId?: string;
        /**
         * Source node schema information.
         */
        sourceSchemas?: outputs.Wedata.IntegrationTaskNodeNodeInfoNodeMappingSourceSchema[];
    }

    export interface IntegrationTaskNodeNodeInfoNodeMappingExtConfig {
        /**
         * Configuration name.
         */
        name?: string;
        /**
         * Configuration value.
         */
        value?: string;
    }

    export interface IntegrationTaskNodeNodeInfoNodeMappingSchemaMapping {
        /**
         * Schema ID from sink node.
         */
        sinkSchemaId: string;
        /**
         * Schema ID from source node.
         */
        sourceSchemaId: string;
    }

    export interface IntegrationTaskNodeNodeInfoNodeMappingSourceSchema {
        /**
         * Schema alias.
         */
        alias?: string;
        /**
         * Schema comment.
         */
        comment?: string;
        /**
         * Schema ID.
         */
        id: string;
        /**
         * Schema name.
         */
        name: string;
        /**
         * Schema extended attributes.
         */
        properties?: outputs.Wedata.IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaProperty[];
        /**
         * Schema type.
         */
        type: string;
        /**
         * Schema value.
         */
        value?: string;
    }

    export interface IntegrationTaskNodeNodeInfoNodeMappingSourceSchemaProperty {
        /**
         * Attributes name.
         */
        name?: string;
        /**
         * Attributes value.
         */
        value?: string;
    }

    export interface IntegrationTaskNodeNodeInfoSchema {
        /**
         * Schema alias.
         */
        alias?: string;
        /**
         * Schema comment.
         */
        comment?: string;
        /**
         * Schema ID.
         */
        id: string;
        /**
         * Schema name.
         */
        name: string;
        /**
         * Schema extended attributes.
         */
        properties?: outputs.Wedata.IntegrationTaskNodeNodeInfoSchemaProperty[];
        /**
         * Schema type.
         */
        type: string;
        /**
         * Schema value.
         */
        value?: string;
    }

    export interface IntegrationTaskNodeNodeInfoSchemaProperty {
        /**
         * Attributes name.
         */
        name?: string;
        /**
         * Attributes value.
         */
        value?: string;
    }

}

export namespace config {
    export interface AssumeRole {
        /**
         * A more restrictive policy when making the AssumeRole call. Its content must not contains `principal` elements. Notice: more syntax references, please refer to: [policies syntax logic](https://intl.cloud.tencent.com/document/product/598/10603).
         */
        policy?: string;
        /**
         * The ARN of the role to assume. It can be sourced from the `TENCENTCLOUD_ASSUME_ROLE_ARN`.
         */
        roleArn: string;
        /**
         * The duration of the session when making the AssumeRole call. Its value ranges from 0 to 43200(seconds), and default is 7200 seconds. It can be sourced from the `TENCENTCLOUD_ASSUME_ROLE_SESSION_DURATION`.
         */
        sessionDuration: number;
        /**
         * The session name to use when making the AssumeRole call. It can be sourced from the `TENCENTCLOUD_ASSUME_ROLE_SESSION_NAME`.
         */
        sessionName: string;
    }

}
