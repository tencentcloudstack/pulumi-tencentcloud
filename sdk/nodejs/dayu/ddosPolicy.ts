// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Use this resource to create dayu DDoS policy
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as tencentcloud from "@tencentcloud_iac/pulumi";
 *
 * const testPolicy = new tencentcloud.dayu.DdosPolicy("test_policy", {
 *     resourceType: "bgpip",
 *     name: "tf_test_policy",
 *     blackIps: ["1.1.1.1"],
 *     whiteIps: ["2.2.2.2"],
 *     dropOptions: [{
 *         dropTcp: true,
 *         dropUdp: true,
 *         dropIcmp: true,
 *         dropOther: true,
 *         dropAbroad: true,
 *         checkSyncConn: true,
 *         sNewLimit: 100,
 *         dNewLimit: 100,
 *         sConnLimit: 100,
 *         dConnLimit: 100,
 *         tcpMbpsLimit: 100,
 *         udpMbpsLimit: 100,
 *         icmpMbpsLimit: 100,
 *         otherMbpsLimit: 100,
 *         badConnThreshold: 100,
 *         nullConnEnable: true,
 *         connTimeout: 500,
 *         synRate: 50,
 *         synLimit: 100,
 *     }],
 *     portFilters: [{
 *         startPort: 2000,
 *         endPort: 2500,
 *         protocol: "all",
 *         action: "drop",
 *         kind: 1,
 *     }],
 *     packetFilters: [{
 *         protocol: "tcp",
 *         action: "drop",
 *         dStartPort: 1000,
 *         dEndPort: 1500,
 *         sStartPort: 2000,
 *         sEndPort: 2500,
 *         pktLengthMax: 1400,
 *         pktLengthMin: 1000,
 *         isInclude: true,
 *         matchBegin: "begin_l5",
 *         matchType: "pcre",
 *         depth: 1000,
 *         offset: 500,
 *     }],
 *     watermarkFilters: [{
 *         tcpPortLists: [
 *             "2000-3000",
 *             "3500-4000",
 *         ],
 *         udpPortLists: ["5000-6000"],
 *         offset: 50,
 *         autoRemove: true,
 *         openSwitch: true,
 *     }],
 * });
 * ```
 */
export class DdosPolicy extends pulumi.CustomResource {
    /**
     * Get an existing DdosPolicy resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DdosPolicyState, opts?: pulumi.CustomResourceOptions): DdosPolicy {
        return new DdosPolicy(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'tencentcloud:Dayu/ddosPolicy:DdosPolicy';

    /**
     * Returns true if the given object is an instance of DdosPolicy.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DdosPolicy {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DdosPolicy.__pulumiType;
    }

    /**
     * Black IP list.
     */
    declare public readonly blackIps: pulumi.Output<string[] | undefined>;
    /**
     * Create time of the DDoS policy.
     */
    declare public /*out*/ readonly createTime: pulumi.Output<string>;
    /**
     * Option list of abnormal check of the DDos policy, should set at least one policy.
     */
    declare public readonly dropOptions: pulumi.Output<outputs.Dayu.DdosPolicyDropOption[]>;
    /**
     * Name of the DDoS policy. Length should between 1 and 32.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Message filter options list.
     */
    declare public readonly packetFilters: pulumi.Output<outputs.Dayu.DdosPolicyPacketFilter[] | undefined>;
    /**
     * Id of policy.
     */
    declare public /*out*/ readonly policyId: pulumi.Output<string>;
    /**
     * Port limits of abnormal check of the DDos policy.
     */
    declare public readonly portFilters: pulumi.Output<outputs.Dayu.DdosPolicyPortFilter[] | undefined>;
    /**
     * Type of the resource that the DDoS policy works for. Valid values: `bgpip`, `bgp`, `bgp-multip` and `net`.
     */
    declare public readonly resourceType: pulumi.Output<string>;
    /**
     * Id of policy case that the DDoS policy works for.
     */
    declare public /*out*/ readonly sceneId: pulumi.Output<string>;
    /**
     * Watermark policy options, and only support one watermark policy at most.
     */
    declare public readonly watermarkFilters: pulumi.Output<outputs.Dayu.DdosPolicyWatermarkFilter[] | undefined>;
    /**
     * Watermark content.
     */
    declare public /*out*/ readonly watermarkKeys: pulumi.Output<outputs.Dayu.DdosPolicyWatermarkKey[]>;
    /**
     * White IP list.
     */
    declare public readonly whiteIps: pulumi.Output<string[] | undefined>;

    /**
     * Create a DdosPolicy resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DdosPolicyArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DdosPolicyArgs | DdosPolicyState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DdosPolicyState | undefined;
            resourceInputs["blackIps"] = state?.blackIps;
            resourceInputs["createTime"] = state?.createTime;
            resourceInputs["dropOptions"] = state?.dropOptions;
            resourceInputs["name"] = state?.name;
            resourceInputs["packetFilters"] = state?.packetFilters;
            resourceInputs["policyId"] = state?.policyId;
            resourceInputs["portFilters"] = state?.portFilters;
            resourceInputs["resourceType"] = state?.resourceType;
            resourceInputs["sceneId"] = state?.sceneId;
            resourceInputs["watermarkFilters"] = state?.watermarkFilters;
            resourceInputs["watermarkKeys"] = state?.watermarkKeys;
            resourceInputs["whiteIps"] = state?.whiteIps;
        } else {
            const args = argsOrState as DdosPolicyArgs | undefined;
            if (args?.dropOptions === undefined && !opts.urn) {
                throw new Error("Missing required property 'dropOptions'");
            }
            if (args?.resourceType === undefined && !opts.urn) {
                throw new Error("Missing required property 'resourceType'");
            }
            resourceInputs["blackIps"] = args?.blackIps;
            resourceInputs["dropOptions"] = args?.dropOptions;
            resourceInputs["name"] = args?.name;
            resourceInputs["packetFilters"] = args?.packetFilters;
            resourceInputs["portFilters"] = args?.portFilters;
            resourceInputs["resourceType"] = args?.resourceType;
            resourceInputs["watermarkFilters"] = args?.watermarkFilters;
            resourceInputs["whiteIps"] = args?.whiteIps;
            resourceInputs["createTime"] = undefined /*out*/;
            resourceInputs["policyId"] = undefined /*out*/;
            resourceInputs["sceneId"] = undefined /*out*/;
            resourceInputs["watermarkKeys"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DdosPolicy.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DdosPolicy resources.
 */
export interface DdosPolicyState {
    /**
     * Black IP list.
     */
    blackIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Create time of the DDoS policy.
     */
    createTime?: pulumi.Input<string>;
    /**
     * Option list of abnormal check of the DDos policy, should set at least one policy.
     */
    dropOptions?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyDropOption>[]>;
    /**
     * Name of the DDoS policy. Length should between 1 and 32.
     */
    name?: pulumi.Input<string>;
    /**
     * Message filter options list.
     */
    packetFilters?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyPacketFilter>[]>;
    /**
     * Id of policy.
     */
    policyId?: pulumi.Input<string>;
    /**
     * Port limits of abnormal check of the DDos policy.
     */
    portFilters?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyPortFilter>[]>;
    /**
     * Type of the resource that the DDoS policy works for. Valid values: `bgpip`, `bgp`, `bgp-multip` and `net`.
     */
    resourceType?: pulumi.Input<string>;
    /**
     * Id of policy case that the DDoS policy works for.
     */
    sceneId?: pulumi.Input<string>;
    /**
     * Watermark policy options, and only support one watermark policy at most.
     */
    watermarkFilters?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyWatermarkFilter>[]>;
    /**
     * Watermark content.
     */
    watermarkKeys?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyWatermarkKey>[]>;
    /**
     * White IP list.
     */
    whiteIps?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * The set of arguments for constructing a DdosPolicy resource.
 */
export interface DdosPolicyArgs {
    /**
     * Black IP list.
     */
    blackIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Option list of abnormal check of the DDos policy, should set at least one policy.
     */
    dropOptions: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyDropOption>[]>;
    /**
     * Name of the DDoS policy. Length should between 1 and 32.
     */
    name?: pulumi.Input<string>;
    /**
     * Message filter options list.
     */
    packetFilters?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyPacketFilter>[]>;
    /**
     * Port limits of abnormal check of the DDos policy.
     */
    portFilters?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyPortFilter>[]>;
    /**
     * Type of the resource that the DDoS policy works for. Valid values: `bgpip`, `bgp`, `bgp-multip` and `net`.
     */
    resourceType: pulumi.Input<string>;
    /**
     * Watermark policy options, and only support one watermark policy at most.
     */
    watermarkFilters?: pulumi.Input<pulumi.Input<inputs.Dayu.DdosPolicyWatermarkFilter>[]>;
    /**
     * White IP list.
     */
    whiteIps?: pulumi.Input<pulumi.Input<string>[]>;
}
