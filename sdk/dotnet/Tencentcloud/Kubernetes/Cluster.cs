// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace TencentCloudIAC.PulumiPackage.Tencentcloud.Kubernetes
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ### Create a basic cluster with two worker nodes
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = Pulumi.Tencentcloud;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var defaultInstanceType = config.Get("defaultInstanceType") ?? "SA2.2XLARGE16";
    ///     var availabilityZoneFirst = config.Get("availabilityZoneFirst") ?? "ap-guangzhou-3";
    ///     var availabilityZoneSecond = config.Get("availabilityZoneSecond") ?? "ap-guangzhou-4";
    ///     var exampleClusterCidr = config.Get("exampleClusterCidr") ?? "10.31.0.0/16";
    ///     var vpcOne = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneFirst,
    ///     });
    /// 
    ///     var firstVpcId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.VpcId);
    /// 
    ///     var firstSubnetId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.SubnetId);
    /// 
    ///     var vpcTwo = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneSecond,
    ///     });
    /// 
    ///     var secondVpcId = vpcTwo.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.VpcId);
    /// 
    ///     var secondSubnetId = vpcTwo.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.SubnetId);
    /// 
    ///     var sg = new Tencentcloud.Security.Group("sg", new()
    ///     {
    ///         Name = "tf-example-sg",
    ///     });
    /// 
    ///     var sgId = sg.Id;
    /// 
    ///     var @default = Tencentcloud.Images.GetInstance.Invoke(new()
    ///     {
    ///         ImageTypes = new[]
    ///         {
    ///             "PUBLIC_IMAGE",
    ///         },
    ///         ImageNameRegex = "Final",
    ///     });
    /// 
    ///     var imageId = @default.Apply(@default =&gt; @default.Apply(getInstanceResult =&gt; getInstanceResult.ImageId));
    /// 
    ///     var sgRule = new Tencentcloud.Index.SecurityGroupLiteRule("sg_rule", new()
    ///     {
    ///         SecurityGroupId = sg.Id,
    ///         Ingresses = new[]
    ///         {
    ///             "ACCEPT#10.0.0.0/16#ALL#ALL",
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///             "DROP#0.0.0.0/0#ALL#ALL",
    ///         },
    ///         Egresses = new[]
    ///         {
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///         },
    ///     });
    /// 
    ///     var example = new Tencentcloud.Kubernetes.Cluster("example", new()
    ///     {
    ///         VpcId = firstVpcId,
    ///         ClusterCidr = exampleClusterCidr,
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "tf_example_cluster",
    ///         ClusterDesc = "example for tke cluster",
    ///         ClusterMaxServiceNum = 32,
    ///         ClusterInternet = false,
    ///         ClusterInternetSecurityGroup = sgId,
    ///         ClusterVersion = "1.22.5",
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///         Labels = 
    ///         {
    ///             { "test1", "test1" },
    ///             { "test2", "test2" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Create an empty cluster with a node pool
    /// 
    /// The cluster does not have any nodes, nodes will be added through node pool.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = Pulumi.Tencentcloud;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var defaultInstanceType = config.Get("defaultInstanceType") ?? "SA2.2XLARGE16";
    ///     var availabilityZoneFirst = config.Get("availabilityZoneFirst") ?? "ap-guangzhou-3";
    ///     var availabilityZoneSecond = config.Get("availabilityZoneSecond") ?? "ap-guangzhou-4";
    ///     var exampleClusterCidr = config.Get("exampleClusterCidr") ?? "10.31.0.0/16";
    ///     var vpcOne = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneFirst,
    ///     });
    /// 
    ///     var firstVpcId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.VpcId);
    /// 
    ///     var firstSubnetId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.SubnetId);
    /// 
    ///     var sg = new Tencentcloud.Security.Group("sg", new()
    ///     {
    ///         Name = "tf-example-np-sg",
    ///     });
    /// 
    ///     var sgId = sg.Id;
    /// 
    ///     var vpcTwo = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneSecond,
    ///     });
    /// 
    ///     var sgRule = new Tencentcloud.Index.SecurityGroupLiteRule("sg_rule", new()
    ///     {
    ///         SecurityGroupId = sg.Id,
    ///         Ingresses = new[]
    ///         {
    ///             "ACCEPT#10.0.0.0/16#ALL#ALL",
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///             "DROP#0.0.0.0/0#ALL#ALL",
    ///         },
    ///         Egresses = new[]
    ///         {
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///         },
    ///     });
    /// 
    ///     var example = new Tencentcloud.Kubernetes.Cluster("example", new()
    ///     {
    ///         VpcId = firstVpcId,
    ///         ClusterCidr = exampleClusterCidr,
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "tf_example_cluster_np",
    ///         ClusterDesc = "example for tke cluster",
    ///         ClusterMaxServiceNum = 32,
    ///         ClusterVersion = "1.22.5",
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///     });
    /// 
    ///     var exampleNodePool = new Tencentcloud.Kubernetes.NodePool("example", new()
    ///     {
    ///         Name = "tf_example_node_pool",
    ///         ClusterId = example.Id,
    ///         MaxSize = 6,
    ///         MinSize = 1,
    ///         VpcId = firstVpcId,
    ///         SubnetIds = new[]
    ///         {
    ///             firstSubnetId,
    ///         },
    ///         RetryPolicy = "INCREMENTAL_INTERVALS",
    ///         DesiredCapacity = 4,
    ///         EnableAutoScale = true,
    ///         MultiZoneSubnetPolicy = "EQUALITY",
    ///         AutoScalingConfig = new Tencentcloud.Kubernetes.Inputs.NodePoolAutoScalingConfigArgs
    ///         {
    ///             InstanceType = defaultInstanceType,
    ///             SystemDiskType = "CLOUD_PREMIUM",
    ///             SystemDiskSize = 50,
    ///             OrderlySecurityGroupIds = new[]
    ///             {
    ///                 sgId,
    ///             },
    ///             DataDisks = new[]
    ///             {
    ///                 new Tencentcloud.Kubernetes.Inputs.NodePoolAutoScalingConfigDataDiskArgs
    ///                 {
    ///                     DiskType = "CLOUD_PREMIUM",
    ///                     DiskSize = 50,
    ///                 },
    ///             },
    ///             InternetChargeType = "TRAFFIC_POSTPAID_BY_HOUR",
    ///             InternetMaxBandwidthOut = 10,
    ///             PublicIpAssigned = true,
    ///             Password = "test123#",
    ///             EnhancedSecurityService = false,
    ///             EnhancedMonitorService = false,
    ///             HostName = "12.123.0.0",
    ///             HostNameStyle = "ORIGINAL",
    ///         },
    ///         Labels = 
    ///         {
    ///             { "test1", "test1" },
    ///             { "test2", "test2" },
    ///         },
    ///         Taints = new[]
    ///         {
    ///             new Tencentcloud.Kubernetes.Inputs.NodePoolTaintArgs
    ///             {
    ///                 Key = "test_taint",
    ///                 Value = "taint_value",
    ///                 Effect = "PreferNoSchedule",
    ///             },
    ///             new Tencentcloud.Kubernetes.Inputs.NodePoolTaintArgs
    ///             {
    ///                 Key = "test_taint2",
    ///                 Value = "taint_value2",
    ///                 Effect = "PreferNoSchedule",
    ///             },
    ///         },
    ///         NodeConfig = new Tencentcloud.Kubernetes.Inputs.NodePoolNodeConfigArgs
    ///         {
    ///             ExtraArgs = new[]
    ///             {
    ///                 "root-dir=/var/lib/kubelet",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Create a cluster with a node pool and open the network access with cluster endpoint
    /// 
    /// The cluster's internet and intranet access will be opened after nodes are added through node pool.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = Pulumi.Tencentcloud;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var defaultInstanceType = config.Get("defaultInstanceType") ?? "SA2.2XLARGE16";
    ///     var availabilityZoneFirst = config.Get("availabilityZoneFirst") ?? "ap-guangzhou-3";
    ///     var availabilityZoneSecond = config.Get("availabilityZoneSecond") ?? "ap-guangzhou-4";
    ///     var exampleClusterCidr = config.Get("exampleClusterCidr") ?? "10.31.0.0/16";
    ///     var vpcOne = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneFirst,
    ///     });
    /// 
    ///     var firstVpcId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.VpcId);
    /// 
    ///     var firstSubnetId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.SubnetId);
    /// 
    ///     var sg = new Tencentcloud.Security.Group("sg", new()
    ///     {
    ///         Name = "tf-example-np-ep-sg",
    ///     });
    /// 
    ///     var sgId = sg.Id;
    /// 
    ///     var vpcTwo = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneSecond,
    ///     });
    /// 
    ///     var sgRule = new Tencentcloud.Index.SecurityGroupLiteRule("sg_rule", new()
    ///     {
    ///         SecurityGroupId = sg.Id,
    ///         Ingresses = new[]
    ///         {
    ///             "ACCEPT#10.0.0.0/16#ALL#ALL",
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///             "DROP#0.0.0.0/0#ALL#ALL",
    ///         },
    ///         Egresses = new[]
    ///         {
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///         },
    ///     });
    /// 
    ///     var example = new Tencentcloud.Kubernetes.Cluster("example", new()
    ///     {
    ///         VpcId = firstVpcId,
    ///         ClusterCidr = exampleClusterCidr,
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "tf_example_cluster",
    ///         ClusterDesc = "example for tke cluster",
    ///         ClusterMaxServiceNum = 32,
    ///         ClusterInternet = false,
    ///         ClusterVersion = "1.22.5",
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///     });
    /// 
    ///     var exampleNodePool = new Tencentcloud.Kubernetes.NodePool("example", new()
    ///     {
    ///         Name = "tf_example_node_pool",
    ///         ClusterId = example.Id,
    ///         MaxSize = 6,
    ///         MinSize = 1,
    ///         VpcId = firstVpcId,
    ///         SubnetIds = new[]
    ///         {
    ///             firstSubnetId,
    ///         },
    ///         RetryPolicy = "INCREMENTAL_INTERVALS",
    ///         DesiredCapacity = 4,
    ///         EnableAutoScale = true,
    ///         MultiZoneSubnetPolicy = "EQUALITY",
    ///         AutoScalingConfig = new Tencentcloud.Kubernetes.Inputs.NodePoolAutoScalingConfigArgs
    ///         {
    ///             InstanceType = defaultInstanceType,
    ///             SystemDiskType = "CLOUD_PREMIUM",
    ///             SystemDiskSize = 50,
    ///             OrderlySecurityGroupIds = new[]
    ///             {
    ///                 sgId,
    ///             },
    ///             DataDisks = new[]
    ///             {
    ///                 new Tencentcloud.Kubernetes.Inputs.NodePoolAutoScalingConfigDataDiskArgs
    ///                 {
    ///                     DiskType = "CLOUD_PREMIUM",
    ///                     DiskSize = 50,
    ///                 },
    ///             },
    ///             InternetChargeType = "TRAFFIC_POSTPAID_BY_HOUR",
    ///             InternetMaxBandwidthOut = 10,
    ///             PublicIpAssigned = true,
    ///             Password = "test123#",
    ///             EnhancedSecurityService = false,
    ///             EnhancedMonitorService = false,
    ///             HostName = "12.123.0.0",
    ///             HostNameStyle = "ORIGINAL",
    ///         },
    ///         Labels = 
    ///         {
    ///             { "test1", "test1" },
    ///             { "test2", "test2" },
    ///         },
    ///         Taints = new[]
    ///         {
    ///             new Tencentcloud.Kubernetes.Inputs.NodePoolTaintArgs
    ///             {
    ///                 Key = "test_taint",
    ///                 Value = "taint_value",
    ///                 Effect = "PreferNoSchedule",
    ///             },
    ///             new Tencentcloud.Kubernetes.Inputs.NodePoolTaintArgs
    ///             {
    ///                 Key = "test_taint2",
    ///                 Value = "taint_value2",
    ///                 Effect = "PreferNoSchedule",
    ///             },
    ///         },
    ///         NodeConfig = new Tencentcloud.Kubernetes.Inputs.NodePoolNodeConfigArgs
    ///         {
    ///             ExtraArgs = new[]
    ///             {
    ///                 "root-dir=/var/lib/kubelet",
    ///             },
    ///         },
    ///     });
    /// 
    ///     var exampleClusterEndpoint = new Tencentcloud.Kubernetes.ClusterEndpoint("example", new()
    ///     {
    ///         ClusterId = example.Id,
    ///         ClusterInternet = true,
    ///         ClusterIntranet = true,
    ///         ClusterInternetSecurityGroup = sgId,
    ///         ClusterIntranetSubnetId = firstSubnetId,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             exampleNodePool,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Use Kubelet
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = Pulumi.Tencentcloud;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var defaultInstanceType = config.Get("defaultInstanceType") ?? "SA2.2XLARGE16";
    ///     var availabilityZoneFirst = config.Get("availabilityZoneFirst") ?? "ap-guangzhou-3";
    ///     var availabilityZoneSecond = config.Get("availabilityZoneSecond") ?? "ap-guangzhou-4";
    ///     var exampleClusterCidr = config.Get("exampleClusterCidr") ?? "10.31.0.0/16";
    ///     var vpcOne = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneFirst,
    ///     });
    /// 
    ///     var firstVpcId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.VpcId);
    /// 
    ///     var firstSubnetId = vpcOne.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.SubnetId);
    /// 
    ///     var vpcTwo = Tencentcloud.Vpc.GetSubnets.Invoke(new()
    ///     {
    ///         IsDefault = true,
    ///         AvailabilityZone = availabilityZoneSecond,
    ///     });
    /// 
    ///     var secondVpcId = vpcTwo.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.VpcId);
    /// 
    ///     var secondSubnetId = vpcTwo.Apply(getSubnetsResult =&gt; getSubnetsResult.InstanceLists[0]?.SubnetId);
    /// 
    ///     var sg = new Tencentcloud.Security.Group("sg", new()
    ///     {
    ///         Name = "tf-example-sg",
    ///     });
    /// 
    ///     var sgId = sg.Id;
    /// 
    ///     var @default = Tencentcloud.Images.GetInstance.Invoke(new()
    ///     {
    ///         ImageTypes = new[]
    ///         {
    ///             "PUBLIC_IMAGE",
    ///         },
    ///         ImageNameRegex = "Final",
    ///     });
    /// 
    ///     var imageId = @default.Apply(@default =&gt; @default.Apply(getInstanceResult =&gt; getInstanceResult.ImageId));
    /// 
    ///     var sgRule = new Tencentcloud.Index.SecurityGroupLiteRule("sg_rule", new()
    ///     {
    ///         SecurityGroupId = sg.Id,
    ///         Ingresses = new[]
    ///         {
    ///             "ACCEPT#10.0.0.0/16#ALL#ALL",
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///             "DROP#0.0.0.0/0#ALL#ALL",
    ///         },
    ///         Egresses = new[]
    ///         {
    ///             "ACCEPT#172.16.0.0/22#ALL#ALL",
    ///         },
    ///     });
    /// 
    ///     var example = new Tencentcloud.Kubernetes.Cluster("example", new()
    ///     {
    ///         VpcId = firstVpcId,
    ///         ClusterCidr = exampleClusterCidr,
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "tf_example_cluster",
    ///         ClusterDesc = "example for tke cluster",
    ///         ClusterMaxServiceNum = 32,
    ///         ClusterInternet = false,
    ///         ClusterInternetSecurityGroup = sgId,
    ///         ClusterVersion = "1.22.5",
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///         Labels = 
    ///         {
    ///             { "test1", "test1" },
    ///             { "test2", "test2" },
    ///         },
    ///         ExtraArgs = new[]
    ///         {
    ///             "root-dir=/var/lib/kubelet",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Use node pool global config
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var availabilityZone = config.Get("availabilityZone") ?? "ap-guangzhou-3";
    ///     var vpc = config.Get("vpc") ?? "vpc-dk8zmwuf";
    ///     var subnet = config.Get("subnet") ?? "subnet-pqfek0t8";
    ///     var defaultInstanceType = config.Get("defaultInstanceType") ?? "SA1.LARGE8";
    ///     var testNodePoolGlobalConfig = new Tencentcloud.Kubernetes.Cluster("test_node_pool_global_config", new()
    ///     {
    ///         VpcId = vpc,
    ///         ClusterCidr = "10.1.0.0/16",
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "test",
    ///         ClusterDesc = "test cluster desc",
    ///         ClusterMaxServiceNum = 32,
    ///         ClusterInternet = true,
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///         WorkerConfigs = new[]
    ///         {
    ///             new Tencentcloud.Kubernetes.Inputs.ClusterWorkerConfigArgs
    ///             {
    ///                 Count = 1,
    ///                 AvailabilityZone = availabilityZone,
    ///                 InstanceType = defaultInstanceType,
    ///                 SystemDiskType = "CLOUD_SSD",
    ///                 SystemDiskSize = 60,
    ///                 InternetChargeType = "TRAFFIC_POSTPAID_BY_HOUR",
    ///                 InternetMaxBandwidthOut = 100,
    ///                 PublicIpAssigned = true,
    ///                 SubnetId = subnet,
    ///                 DataDisks = new[]
    ///                 {
    ///                     new Tencentcloud.Kubernetes.Inputs.ClusterWorkerConfigDataDiskArgs
    ///                     {
    ///                         DiskType = "CLOUD_PREMIUM",
    ///                         DiskSize = 50,
    ///                     },
    ///                 },
    ///                 EnhancedSecurityService = false,
    ///                 EnhancedMonitorService = false,
    ///                 UserData = "dGVzdA==",
    ///                 KeyIds = "skey-11112222"[0],
    ///             },
    ///         },
    ///         NodePoolGlobalConfigs = new[]
    ///         {
    ///             new Tencentcloud.Kubernetes.Inputs.ClusterNodePoolGlobalConfigArgs
    ///             {
    ///                 IsScaleInEnabled = true,
    ///                 Expander = "random",
    ///                 IgnoreDaemonSetsUtilization = true,
    ///                 MaxConcurrentScaleIn = 5,
    ///                 ScaleInDelay = 15,
    ///                 ScaleInUnneededTime = 15,
    ///                 ScaleInUtilizationThreshold = 30,
    ///                 SkipNodesWithLocalStorage = false,
    ///                 SkipNodesWithSystemPods = true,
    ///             },
    ///         },
    ///         Labels = 
    ///         {
    ///             { "test1", "test1" },
    ///             { "test2", "test2" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Using VPC-CNI network type
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var availabilityZone = config.Get("availabilityZone") ?? "ap-guangzhou-1";
    ///     var vpc = config.Get("vpc") ?? "vpc-r1m1fyx5";
    ///     var defaultInstanceType = config.Get("defaultInstanceType") ?? "SA2.SMALL2";
    ///     var managedCluster = new Tencentcloud.Kubernetes.Cluster("managed_cluster", new()
    ///     {
    ///         VpcId = vpc,
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "test",
    ///         ClusterDesc = "test cluster desc",
    ///         ClusterMaxServiceNum = 256,
    ///         ClusterInternet = true,
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///         NetworkType = "VPC-CNI",
    ///         EniSubnetIds = new[]
    ///         {
    ///             "subnet-bk1etlyu",
    ///         },
    ///         ServiceCidr = "10.1.0.0/24",
    ///         DataPlaneV2 = true,
    ///         Labels = 
    ///         {
    ///             { "test1", "test1" },
    ///             { "test2", "test2" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Using ops options
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var managedCluster = new Tencentcloud.Kubernetes.Cluster("managed_cluster", new()
    ///     {
    ///         LogAgent = new Tencentcloud.Kubernetes.Inputs.ClusterLogAgentArgs
    ///         {
    ///             Enabled = true,
    ///             KubeletRootDir = "",
    ///         },
    ///         EventPersistence = new Tencentcloud.Kubernetes.Inputs.ClusterEventPersistenceArgs
    ///         {
    ///             Enabled = true,
    ///             LogSetId = "",
    ///             TopicId = "",
    ///         },
    ///         ClusterAudit = new Tencentcloud.Kubernetes.Inputs.ClusterClusterAuditArgs
    ///         {
    ///             Enabled = true,
    ///             LogSetId = "",
    ///             TopicId = "",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Create a CDC scenario cluster
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var cdcCluster = new Tencentcloud.Kubernetes.Cluster("cdc_cluster", new()
    ///     {
    ///         CdcId = "cluster-262n63e8",
    ///         VpcId = "vpc-0m6078eb",
    ///         ClusterCidr = "192.168.0.0/16",
    ///         ClusterMaxPodNum = 64,
    ///         ClusterName = "test-cdc",
    ///         ClusterDesc = "test cluster desc",
    ///         ClusterMaxServiceNum = 1024,
    ///         ClusterVersion = "1.30.0",
    ///         ClusterOs = "tlinux3.1x86_64",
    ///         ClusterLevel = "L20",
    ///         ClusterDeployType = "INDEPENDENT_CLUSTER",
    ///         ContainerRuntime = "containerd",
    ///         RuntimeVersion = "1.6.9",
    ///         PreStartUserScript = "aXB0YWJsZXMgLUEgSU5QVVQgLXAgdGNwIC1zIDE2OS4yNTQuMC4wLzE5IC0tdGNwLWZsYWdzIFNZTixSU1QgU1lOIC1qIFRDUE1TUyAtLXNldC1tc3MgMTE2MAppcHRhYmxlcyAtQSBPVVRQVVQgLXAgdGNwIC1kIDE2OS4yNTQuMC4wLzE5IC0tdGNwLWZsYWdzIFNZTixSU1QgU1lOIC1qIFRDUE1TUyAtLXNldC1tc3MgMTE2MAoKZWNobyAnCmlwdGFibGVzIC1BIElOUFVUIC1wIHRjcCAtcyAxNjkuMjU0LjAuMC8xOSAtLXRjcC1mbGFncyBTWU4sUlNUIFNZTiAtaiBUQ1BNU1MgLS1zZXQtbXNzIDExNjAKaXB0YWJsZXMgLUEgT1VUUFVUIC1wIHRjcCAtZCAxNjkuMjU0LjAuMC8xOSAtLXRjcC1mbGFncyBTWU4sUlNUIFNZTiAtaiBUQ1BNU1MgLS1zZXQtbXNzIDExNjAKJyA+PiAvZXRjL3JjLmQvcmMubG9jYWw=",
    ///         InstanceDeleteMode = "retain",
    ///         ExistInstances = new[]
    ///         {
    ///             new Tencentcloud.Kubernetes.Inputs.ClusterExistInstanceArgs
    ///             {
    ///                 NodeRole = "MASTER_ETCD",
    ///                 InstancesPara = new Tencentcloud.Kubernetes.Inputs.ClusterExistInstanceInstancesParaArgs
    ///                 {
    ///                     InstanceIds = new[]
    ///                     {
    ///                         "ins-mam0c7lw",
    ///                         "ins-quvwayve",
    ///                         "ins-qbffk8iw",
    ///                     },
    ///                     EnhancedSecurityService = true,
    ///                     EnhancedMonitorService = true,
    ///                     Password = "Password@123",
    ///                     SecurityGroupIds = new[]
    ///                     {
    ///                         "sg-hjs685q9",
    ///                     },
    ///                     MasterConfig = new Tencentcloud.Kubernetes.Inputs.ClusterExistInstanceInstancesParaMasterConfigArgs
    ///                     {
    ///                         MountTarget = "/var/data",
    ///                         DockerGraphPath = "/var/lib/containerd",
    ///                         Unschedulable = 0,
    ///                         Labels = new[]
    ///                         {
    ///                             new Tencentcloud.Kubernetes.Inputs.ClusterExistInstanceInstancesParaMasterConfigLabelArgs
    ///                             {
    ///                                 Name = "key",
    ///                                 Value = "value",
    ///                             },
    ///                         },
    ///                         DataDisk = new Tencentcloud.Kubernetes.Inputs.ClusterExistInstanceInstancesParaMasterConfigDataDiskArgs
    ///                         {
    ///                             FileSystem = "ext4",
    ///                             AutoFormatAndMount = true,
    ///                             MountTarget = "/var/data",
    ///                             DiskPartition = "/dev/vdb",
    ///                         },
    ///                         ExtraArgs = new Tencentcloud.Kubernetes.Inputs.ClusterExistInstanceInstancesParaMasterConfigExtraArgsArgs
    ///                         {
    ///                             Kubelets = new[]
    ///                             {
    ///                                 "root-dir=/root",
    ///                             },
    ///                         },
    ///                         Taints = new[]
    ///                         {
    ///                             new Tencentcloud.Kubernetes.Inputs.ClusterExistInstanceInstancesParaMasterConfigTaintArgs
    ///                             {
    ///                                 Key = "key",
    ///                                 Value = "value",
    ///                                 Effect = "NoSchedule",
    ///                             },
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### TKE cluster cloud subnet and CDC subnet are interconnected
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Tencentcloud.Kubernetes.Cluster("example", new()
    ///     {
    ///         ClusterName = "tf-example",
    ///         ClusterDesc = "cluster desc",
    ///         ClusterOs = "tlinux3.1x86_64",
    ///         ClusterMaxPodNum = 64,
    ///         ClusterMaxServiceNum = 256,
    ///         ClusterVersion = "1.30.0",
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///         ContainerRuntime = "containerd",
    ///         RuntimeVersion = "1.6.9",
    ///         IsDualStack = false,
    ///         IsNonStaticIpMode = true,
    ///         NetworkType = "VPC-CNI",
    ///         VpcCniType = "tke-route-eni",
    ///         VpcId = "vpc-i5yyodl9",
    ///         ClusterSubnetId = "subnet-5rrirqyc",
    ///         EniSubnetIds = new[]
    ///         {
    ///             "subnet-5rrirqyc",
    ///         },
    ///         ServiceCidr = "192.168.0.0/24",
    ///         CdcId = "cluster-262n63e8",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Use delete options to delete CBS when deleting the Cluster
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Tencentcloud.Kubernetes.Cluster("example", new()
    ///     {
    ///         VpcId = firstVpcId,
    ///         ClusterCidr = exampleClusterCidr,
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "example",
    ///         ClusterDesc = "example for tke cluster",
    ///         ClusterMaxServiceNum = 32,
    ///         ClusterLevel = "L50",
    ///         AutoUpgradeClusterLevel = true,
    ///         ClusterInternet = false,
    ///         ClusterVersion = "1.30.0",
    ///         ClusterOs = "tlinux2.2(tkernel3)x86_64",
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///         ContainerRuntime = "containerd",
    ///         DockerGraphPath = "/var/lib/containerd",
    ///         Tags = 
    ///         {
    ///             { "demo", "test" },
    ///         },
    ///         ResourceDeleteOptions = new[]
    ///         {
    ///             new Tencentcloud.Kubernetes.Inputs.ClusterResourceDeleteOptionArgs
    ///             {
    ///                 ResourceType = "CBS",
    ///                 DeleteMode = "terminate",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Using disable addons
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tencentcloud = TencentCloudIAC.PulumiPackage.Tencentcloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Tencentcloud.Kubernetes.Cluster("example", new()
    ///     {
    ///         VpcId = "vpc-i5yyodl9",
    ///         ClusterMaxPodNum = 32,
    ///         ClusterName = "tf-example",
    ///         ClusterDesc = "cluster desc.",
    ///         ClusterMaxServiceNum = 256,
    ///         ClusterVersion = "1.30.0",
    ///         ClusterDeployType = "MANAGED_CLUSTER",
    ///         ContainerRuntime = "containerd",
    ///         RuntimeVersion = "1.6.9",
    ///         InstanceDeleteMode = "terminate",
    ///         UpgradeInstancesFollowCluster = true,
    ///         NetworkType = "VPC-CNI",
    ///         EniSubnetIds = new[]
    ///         {
    ///             "subnet-hhi88a58",
    ///         },
    ///         ServiceCidr = "10.1.0.0/24",
    ///         DisableAddons = new[]
    ///         {
    ///             "ip-masq-agent",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// tke cluster can be imported, e.g.
    /// 
    /// ```sh
    /// $ pulumi import tencentcloud:Kubernetes/cluster:Cluster example cls-n2h4jbtk
    /// ```
    /// </summary>
    [TencentcloudResourceType("tencentcloud:Kubernetes/cluster:Cluster")]
    public partial class Cluster : global::Pulumi.CustomResource
    {
        /// <summary>
        /// If set to true, it will acquire the ClusterRole tke:admin. NOTE: this arguments cannot revoke to `False` after acquired.
        /// </summary>
        [Output("acquireClusterAdminRole")]
        public Output<bool?> AcquireClusterAdminRole { get; private set; } = null!;

        /// <summary>
        /// Specify cluster authentication configuration. Only available for managed cluster and `ClusterVersion` &gt;= 1.20.
        /// </summary>
        [Output("authOptions")]
        public Output<Outputs.ClusterAuthOptions?> AuthOptions { get; private set; } = null!;

        /// <summary>
        /// Whether the cluster level auto upgraded, valid for managed cluster.
        /// </summary>
        [Output("autoUpgradeClusterLevel")]
        public Output<bool?> AutoUpgradeClusterLevel { get; private set; } = null!;

        /// <summary>
        /// The number of basic pods. valid when enable_customized_pod_cidr=true.
        /// </summary>
        [Output("basePodNum")]
        public Output<int?> BasePodNum { get; private set; } = null!;

        /// <summary>
        /// CDC ID.
        /// </summary>
        [Output("cdcId")]
        public Output<string?> CdcId { get; private set; } = null!;

        /// <summary>
        /// The certificate used for access.
        /// </summary>
        [Output("certificationAuthority")]
        public Output<string> CertificationAuthority { get; private set; } = null!;

        /// <summary>
        /// Claim expired seconds to recycle ENI. This field can only set when field `NetworkType` is 'VPC-CNI'. `ClaimExpiredSeconds` must greater or equal than 300 and less than 15768000.
        /// </summary>
        [Output("claimExpiredSeconds")]
        public Output<int> ClaimExpiredSeconds { get; private set; } = null!;

        /// <summary>
        /// (**Deprecated**) This argument is deprecated because the TKE auto-scaling group was no longer available. Indicates whether to enable cluster node auto scaling. Default is false.
        /// </summary>
        [Output("clusterAsEnabled")]
        public Output<bool> ClusterAsEnabled { get; private set; } = null!;

        /// <summary>
        /// Specify Cluster Audit config. NOTE: Please make sure your TKE CamRole have permission to access CLS service.
        /// </summary>
        [Output("clusterAudit")]
        public Output<Outputs.ClusterClusterAudit?> ClusterAudit { get; private set; } = null!;

        /// <summary>
        /// A network address block of the cluster. Different from vpc cidr and cidr of other clusters within this vpc. Must be in  10./192.168/172.[16-31] segments.
        /// </summary>
        [Output("clusterCidr")]
        public Output<string?> ClusterCidr { get; private set; } = null!;

        /// <summary>
        /// Deployment type of the cluster, the available values include: 'MANAGED_CLUSTER' and 'INDEPENDENT_CLUSTER'. Default is 'MANAGED_CLUSTER'.
        /// </summary>
        [Output("clusterDeployType")]
        public Output<string?> ClusterDeployType { get; private set; } = null!;

        /// <summary>
        /// Description of the cluster.
        /// </summary>
        [Output("clusterDesc")]
        public Output<string?> ClusterDesc { get; private set; } = null!;

        /// <summary>
        /// External network address to access.
        /// </summary>
        [Output("clusterExternalEndpoint")]
        public Output<string> ClusterExternalEndpoint { get; private set; } = null!;

        /// <summary>
        /// Customized parameters for master component,such as kube-apiserver, kube-controller-manager, kube-scheduler.
        /// </summary>
        [Output("clusterExtraArgs")]
        public Output<Outputs.ClusterClusterExtraArgs?> ClusterExtraArgs { get; private set; } = null!;

        /// <summary>
        /// Open internet access or not. If this field is set 'true', the field below `WorkerConfig` must be set. Because only cluster with node is allowed enable access endpoint. You may open it through `tencentcloud.Kubernetes.ClusterEndpoint`.
        /// </summary>
        [Output("clusterInternet")]
        public Output<bool> ClusterInternet { get; private set; } = null!;

        /// <summary>
        /// Domain name for cluster Kube-apiserver internet access. Be careful if you modify value of this parameter, the ClusterExternalEndpoint value may be changed automatically too.
        /// </summary>
        [Output("clusterInternetDomain")]
        public Output<string> ClusterInternetDomain { get; private set; } = null!;

        /// <summary>
        /// Specify security group, NOTE: This argument must not be empty if cluster internet enabled.
        /// </summary>
        [Output("clusterInternetSecurityGroup")]
        public Output<string> ClusterInternetSecurityGroup { get; private set; } = null!;

        /// <summary>
        /// Open intranet access or not. If this field is set 'true', the field below `WorkerConfig` must be set. Because only cluster with node is allowed enable access endpoint. You may open it through `tencentcloud.Kubernetes.ClusterEndpoint`.
        /// </summary>
        [Output("clusterIntranet")]
        public Output<bool> ClusterIntranet { get; private set; } = null!;

        /// <summary>
        /// Domain name for cluster Kube-apiserver intranet access. Be careful if you modify value of this parameter, the PgwEndpoint value may be changed automatically too.
        /// </summary>
        [Output("clusterIntranetDomain")]
        public Output<string> ClusterIntranetDomain { get; private set; } = null!;

        /// <summary>
        /// Subnet id who can access this independent cluster, this field must and can only set  when `ClusterIntranet` is true. `ClusterIntranetSubnetId` can not modify once be set.
        /// </summary>
        [Output("clusterIntranetSubnetId")]
        public Output<string> ClusterIntranetSubnetId { get; private set; } = null!;

        /// <summary>
        /// Indicates whether `Ipvs` is enabled. Default is true. False means `Iptables` is enabled.
        /// </summary>
        [Output("clusterIpvs")]
        public Output<bool?> ClusterIpvs { get; private set; } = null!;

        /// <summary>
        /// Specify cluster level, valid for managed cluster, use data source `tencentcloud.Kubernetes.getClusterLevels` to query available levels. Available value examples `L5`, `L20`, `L50`, `L100`, etc.
        /// </summary>
        [Output("clusterLevel")]
        public Output<string> ClusterLevel { get; private set; } = null!;

        /// <summary>
        /// The maximum number of Pods per node in the cluster. Default is 256. The minimum value is 4. When its power unequal to 2, it will round upward to the closest power of 2.
        /// </summary>
        [Output("clusterMaxPodNum")]
        public Output<int?> ClusterMaxPodNum { get; private set; } = null!;

        /// <summary>
        /// The maximum number of services in the cluster. Default is 256. The range is from 32 to 32768. When its power unequal to 2, it will round upward to the closest power of 2.
        /// </summary>
        [Output("clusterMaxServiceNum")]
        public Output<int?> ClusterMaxServiceNum { get; private set; } = null!;

        /// <summary>
        /// Name of the cluster.
        /// </summary>
        [Output("clusterName")]
        public Output<string?> ClusterName { get; private set; } = null!;

        /// <summary>
        /// Number of nodes in the cluster.
        /// </summary>
        [Output("clusterNodeNum")]
        public Output<int> ClusterNodeNum { get; private set; } = null!;

        /// <summary>
        /// Cluster operating system, supports setting public images (the field passes the corresponding image Name) and custom images (the field passes the corresponding image ID). For details, please refer to: https://cloud.tencent.com/document/product/457/68289.
        /// </summary>
        [Output("clusterOs")]
        public Output<string?> ClusterOs { get; private set; } = null!;

        /// <summary>
        /// Image type of the cluster os, the available values include: 'GENERAL'. Default is 'GENERAL'.
        /// </summary>
        [Output("clusterOsType")]
        public Output<string?> ClusterOsType { get; private set; } = null!;

        /// <summary>
        /// Subnet ID of the cluster, such as: subnet-b3p7d7q5.
        /// </summary>
        [Output("clusterSubnetId")]
        public Output<string?> ClusterSubnetId { get; private set; } = null!;

        /// <summary>
        /// Version of the cluster. Use `tencentcloud.Kubernetes.getAvailableClusterVersions` to get the upgradable cluster version.
        /// </summary>
        [Output("clusterVersion")]
        public Output<string> ClusterVersion { get; private set; } = null!;

        /// <summary>
        /// Runtime type of the cluster, the available values include: 'docker' and 'containerd'.The Kubernetes v1.24 has removed dockershim, so please use containerd in v1.24 or higher. The default value is `Docker` for versions below v1.24 and `Containerd` for versions above v1.24.
        /// </summary>
        [Output("containerRuntime")]
        public Output<string> ContainerRuntime { get; private set; } = null!;

        /// <summary>
        /// Whether to enable DataPlaneV2 (replace kube-proxy with cilium). `DataPlaneV2` and `ClusterIpvs` should not be set at the same time.
        /// </summary>
        [Output("dataPlaneV2")]
        public Output<bool> DataPlaneV2 { get; private set; } = null!;

        /// <summary>
        /// Indicates whether cluster deletion protection is enabled. Default is false.
        /// </summary>
        [Output("deletionProtection")]
        public Output<bool?> DeletionProtection { get; private set; } = null!;

        /// <summary>
        /// To prevent the installation of a specific Addon component, enter the corresponding AddonName.
        /// </summary>
        [Output("disableAddons")]
        public Output<ImmutableArray<string>> DisableAddons { get; private set; } = null!;

        /// <summary>
        /// Docker graph path. Default is `/var/lib/docker`.
        /// </summary>
        [Output("dockerGraphPath")]
        public Output<string?> DockerGraphPath { get; private set; } = null!;

        /// <summary>
        /// Domain name for access.
        /// </summary>
        [Output("domain")]
        public Output<string> Domain { get; private set; } = null!;

        /// <summary>
        /// Whether to enable the custom mode of node podCIDR size. Default is false.
        /// </summary>
        [Output("enableCustomizedPodCidr")]
        public Output<bool?> EnableCustomizedPodCidr { get; private set; } = null!;

        /// <summary>
        /// Subnet Ids for cluster with VPC-CNI network mode. This field can only set when field `NetworkType` is 'VPC-CNI'. `EniSubnetIds` can not empty once be set.
        /// </summary>
        [Output("eniSubnetIds")]
        public Output<ImmutableArray<string>> EniSubnetIds { get; private set; } = null!;

        /// <summary>
        /// Specify cluster Event Persistence config. NOTE: Please make sure your TKE CamRole have permission to access CLS service.
        /// </summary>
        [Output("eventPersistence")]
        public Output<Outputs.ClusterEventPersistence?> EventPersistence { get; private set; } = null!;

        /// <summary>
        /// Create tke cluster by existed instances.
        /// </summary>
        [Output("existInstances")]
        public Output<ImmutableArray<Outputs.ClusterExistInstance>> ExistInstances { get; private set; } = null!;

        /// <summary>
        /// Information of the add-on to be installed. It is recommended to use resource `tencentcloud.Kubernetes.Addon` management cluster addon.
        /// </summary>
        [Output("extensionAddons")]
        public Output<ImmutableArray<Outputs.ClusterExtensionAddon>> ExtensionAddons { get; private set; } = null!;

        /// <summary>
        /// Custom parameter information related to the node.
        /// </summary>
        [Output("extraArgs")]
        public Output<ImmutableArray<string>> ExtraArgs { get; private set; } = null!;

        /// <summary>
        /// Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it takes effect for all nodes.
        /// </summary>
        [Output("globeDesiredPodNum")]
        public Output<int?> GlobeDesiredPodNum { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to ignore the cluster cidr conflict error. Default is false.
        /// </summary>
        [Output("ignoreClusterCidrConflict")]
        public Output<bool?> IgnoreClusterCidrConflict { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to ignore the service cidr conflict error. Only valid in `VPC-CNI` mode.
        /// </summary>
        [Output("ignoreServiceCidrConflict")]
        public Output<bool> IgnoreServiceCidrConflict { get; private set; } = null!;

        /// <summary>
        /// The strategy for deleting cluster instances: terminate (destroy instances, only support pay as you go cloud host instances) retain (remove only, keep instances), Default is terminate.
        /// </summary>
        [Output("instanceDeleteMode")]
        public Output<string?> InstanceDeleteMode { get; private set; } = null!;

        /// <summary>
        /// In the VPC-CNI mode of the cluster, the dual stack cluster status defaults to false, indicating a non dual stack cluster.
        /// </summary>
        [Output("isDualStack")]
        public Output<bool> IsDualStack { get; private set; } = null!;

        /// <summary>
        /// Indicates whether non-static ip mode is enabled. Default is false.
        /// </summary>
        [Output("isNonStaticIpMode")]
        public Output<bool?> IsNonStaticIpMode { get; private set; } = null!;

        /// <summary>
        /// Kubernetes config.
        /// </summary>
        [Output("kubeConfig")]
        public Output<string> KubeConfig { get; private set; } = null!;

        /// <summary>
        /// Kubernetes config of private network.
        /// </summary>
        [Output("kubeConfigIntranet")]
        public Output<string> KubeConfigIntranet { get; private set; } = null!;

        /// <summary>
        /// Cluster kube-proxy mode, the available values include: 'kube-proxy-bpf'. Default is not set.When set to kube-proxy-bpf, cluster version greater than 1.14 and with Tencent Linux 2.4 is required.
        /// </summary>
        [Output("kubeProxyMode")]
        public Output<string?> KubeProxyMode { get; private set; } = null!;

        /// <summary>
        /// Labels of tke cluster nodes.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>?> Labels { get; private set; } = null!;

        /// <summary>
        /// Specify cluster log agent config.
        /// </summary>
        [Output("logAgent")]
        public Output<Outputs.ClusterLogAgent?> LogAgent { get; private set; } = null!;

        /// <summary>
        /// this argument was deprecated, use `ClusterInternetSecurityGroup` instead. Security policies for managed cluster internet, like:'192.168.1.0/24' or '113.116.51.27', '0.0.0.0/0' means all. This field can only set when field `ClusterDeployType` is 'MANAGED_CLUSTER' and `ClusterInternet` is true. `ManagedClusterInternetSecurityPolicies` can not delete or empty once be set.
        /// </summary>
        [Output("managedClusterInternetSecurityPolicies")]
        public Output<ImmutableArray<string>> ManagedClusterInternetSecurityPolicies { get; private set; } = null!;

        /// <summary>
        /// Deploy the machine configuration information of the 'MASTER_ETCD' service, and create &lt;=7 units for common users.
        /// </summary>
        [Output("masterConfigs")]
        public Output<ImmutableArray<Outputs.ClusterMasterConfig>> MasterConfigs { get; private set; } = null!;

        /// <summary>
        /// Mount target. Default is not mounting.
        /// </summary>
        [Output("mountTarget")]
        public Output<string?> MountTarget { get; private set; } = null!;

        /// <summary>
        /// Cluster network type, the available values include: 'GR' and 'VPC-CNI' and 'CiliumOverlay'. Default is GR.
        /// </summary>
        [Output("networkType")]
        public Output<string?> NetworkType { get; private set; } = null!;

        /// <summary>
        /// Node name type of Cluster, the available values include: 'lan-ip' and 'hostname', Default is 'lan-ip'.
        /// </summary>
        [Output("nodeNameType")]
        public Output<string?> NodeNameType { get; private set; } = null!;

        /// <summary>
        /// Global config effective for all node pools.
        /// </summary>
        [Output("nodePoolGlobalConfigs")]
        public Output<ImmutableArray<Outputs.ClusterNodePoolGlobalConfig>> NodePoolGlobalConfigs { get; private set; } = null!;

        /// <summary>
        /// Password of account.
        /// </summary>
        [Output("password")]
        public Output<string> Password { get; private set; } = null!;

        /// <summary>
        /// The Intranet address used for access.
        /// </summary>
        [Output("pgwEndpoint")]
        public Output<string> PgwEndpoint { get; private set; } = null!;

        /// <summary>
        /// Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        /// </summary>
        [Output("preStartUserScript")]
        public Output<string?> PreStartUserScript { get; private set; } = null!;

        /// <summary>
        /// Project ID, default value is 0.
        /// </summary>
        [Output("projectId")]
        public Output<int?> ProjectId { get; private set; } = null!;

        /// <summary>
        /// The resource deletion policy when the cluster is deleted. Currently, CBS is supported (CBS is retained by default). Only valid when deleting cluster.
        /// </summary>
        [Output("resourceDeleteOptions")]
        public Output<ImmutableArray<Outputs.ClusterResourceDeleteOption>> ResourceDeleteOptions { get; private set; } = null!;

        /// <summary>
        /// Container Runtime version.
        /// </summary>
        [Output("runtimeVersion")]
        public Output<string?> RuntimeVersion { get; private set; } = null!;

        /// <summary>
        /// Access policy.
        /// </summary>
        [Output("securityPolicies")]
        public Output<ImmutableArray<string>> SecurityPolicies { get; private set; } = null!;

        /// <summary>
        /// A network address block of the service. Different from vpc cidr and cidr of other clusters within this vpc. Must be in  10./192.168/172.[16-31] segments.
        /// </summary>
        [Output("serviceCidr")]
        public Output<string?> ServiceCidr { get; private set; } = null!;

        /// <summary>
        /// The tags of the cluster.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// Sets whether the joining node participates in the schedule. Default is '0'. Participate in scheduling.
        /// </summary>
        [Output("unschedulable")]
        public Output<int?> Unschedulable { get; private set; } = null!;

        /// <summary>
        /// Indicates whether upgrade all instances when ClusterVersion change. Default is false.
        /// </summary>
        [Output("upgradeInstancesFollowCluster")]
        public Output<bool?> UpgradeInstancesFollowCluster { get; private set; } = null!;

        /// <summary>
        /// User name of account.
        /// </summary>
        [Output("userName")]
        public Output<string> UserName { get; private set; } = null!;

        /// <summary>
        /// Distinguish between shared network card multi-IP mode and independent network card mode. Fill in `tke-route-eni` for shared network card multi-IP mode and `tke-direct-eni` for independent network card mode. The default is shared network card mode. When it is necessary to turn off the vpc-cni container network capability, both `EniSubnetIds` and `VpcCniType` must be set to empty.
        /// </summary>
        [Output("vpcCniType")]
        public Output<string> VpcCniType { get; private set; } = null!;

        /// <summary>
        /// Vpc Id of the cluster.
        /// </summary>
        [Output("vpcId")]
        public Output<string> VpcId { get; private set; } = null!;

        /// <summary>
        /// Deploy the machine configuration information of the 'WORKER' service, and create &lt;=20 units for common users. The other 'WORK' service are added by 'tencentcloud_kubernetes_scale_worker'.
        /// </summary>
        [Output("workerConfigs")]
        public Output<ImmutableArray<Outputs.ClusterWorkerConfig>> WorkerConfigs { get; private set; } = null!;

        /// <summary>
        /// An information list of cvm within the 'WORKER' clusters. Each element contains the following attributes:
        /// </summary>
        [Output("workerInstancesLists")]
        public Output<ImmutableArray<Outputs.ClusterWorkerInstancesList>> WorkerInstancesLists { get; private set; } = null!;


        /// <summary>
        /// Create a Cluster resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Cluster(string name, ClusterArgs args, CustomResourceOptions? options = null)
            : base("tencentcloud:Kubernetes/cluster:Cluster", name, args ?? new ClusterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Cluster(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
            : base("tencentcloud:Kubernetes/cluster:Cluster", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/tencentcloudstack",
                AdditionalSecretOutputs =
                {
                    "kubeConfig",
                    "kubeConfigIntranet",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Cluster resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Cluster Get(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
        {
            return new Cluster(name, id, state, options);
        }
    }

    public sealed class ClusterArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If set to true, it will acquire the ClusterRole tke:admin. NOTE: this arguments cannot revoke to `False` after acquired.
        /// </summary>
        [Input("acquireClusterAdminRole")]
        public Input<bool>? AcquireClusterAdminRole { get; set; }

        /// <summary>
        /// Specify cluster authentication configuration. Only available for managed cluster and `ClusterVersion` &gt;= 1.20.
        /// </summary>
        [Input("authOptions")]
        public Input<Inputs.ClusterAuthOptionsArgs>? AuthOptions { get; set; }

        /// <summary>
        /// Whether the cluster level auto upgraded, valid for managed cluster.
        /// </summary>
        [Input("autoUpgradeClusterLevel")]
        public Input<bool>? AutoUpgradeClusterLevel { get; set; }

        /// <summary>
        /// The number of basic pods. valid when enable_customized_pod_cidr=true.
        /// </summary>
        [Input("basePodNum")]
        public Input<int>? BasePodNum { get; set; }

        /// <summary>
        /// CDC ID.
        /// </summary>
        [Input("cdcId")]
        public Input<string>? CdcId { get; set; }

        /// <summary>
        /// Claim expired seconds to recycle ENI. This field can only set when field `NetworkType` is 'VPC-CNI'. `ClaimExpiredSeconds` must greater or equal than 300 and less than 15768000.
        /// </summary>
        [Input("claimExpiredSeconds")]
        public Input<int>? ClaimExpiredSeconds { get; set; }

        /// <summary>
        /// Specify Cluster Audit config. NOTE: Please make sure your TKE CamRole have permission to access CLS service.
        /// </summary>
        [Input("clusterAudit")]
        public Input<Inputs.ClusterClusterAuditArgs>? ClusterAudit { get; set; }

        /// <summary>
        /// A network address block of the cluster. Different from vpc cidr and cidr of other clusters within this vpc. Must be in  10./192.168/172.[16-31] segments.
        /// </summary>
        [Input("clusterCidr")]
        public Input<string>? ClusterCidr { get; set; }

        /// <summary>
        /// Deployment type of the cluster, the available values include: 'MANAGED_CLUSTER' and 'INDEPENDENT_CLUSTER'. Default is 'MANAGED_CLUSTER'.
        /// </summary>
        [Input("clusterDeployType")]
        public Input<string>? ClusterDeployType { get; set; }

        /// <summary>
        /// Description of the cluster.
        /// </summary>
        [Input("clusterDesc")]
        public Input<string>? ClusterDesc { get; set; }

        /// <summary>
        /// Customized parameters for master component,such as kube-apiserver, kube-controller-manager, kube-scheduler.
        /// </summary>
        [Input("clusterExtraArgs")]
        public Input<Inputs.ClusterClusterExtraArgsArgs>? ClusterExtraArgs { get; set; }

        /// <summary>
        /// Open internet access or not. If this field is set 'true', the field below `WorkerConfig` must be set. Because only cluster with node is allowed enable access endpoint. You may open it through `tencentcloud.Kubernetes.ClusterEndpoint`.
        /// </summary>
        [Input("clusterInternet")]
        public Input<bool>? ClusterInternet { get; set; }

        /// <summary>
        /// Domain name for cluster Kube-apiserver internet access. Be careful if you modify value of this parameter, the ClusterExternalEndpoint value may be changed automatically too.
        /// </summary>
        [Input("clusterInternetDomain")]
        public Input<string>? ClusterInternetDomain { get; set; }

        /// <summary>
        /// Specify security group, NOTE: This argument must not be empty if cluster internet enabled.
        /// </summary>
        [Input("clusterInternetSecurityGroup")]
        public Input<string>? ClusterInternetSecurityGroup { get; set; }

        /// <summary>
        /// Open intranet access or not. If this field is set 'true', the field below `WorkerConfig` must be set. Because only cluster with node is allowed enable access endpoint. You may open it through `tencentcloud.Kubernetes.ClusterEndpoint`.
        /// </summary>
        [Input("clusterIntranet")]
        public Input<bool>? ClusterIntranet { get; set; }

        /// <summary>
        /// Domain name for cluster Kube-apiserver intranet access. Be careful if you modify value of this parameter, the PgwEndpoint value may be changed automatically too.
        /// </summary>
        [Input("clusterIntranetDomain")]
        public Input<string>? ClusterIntranetDomain { get; set; }

        /// <summary>
        /// Subnet id who can access this independent cluster, this field must and can only set  when `ClusterIntranet` is true. `ClusterIntranetSubnetId` can not modify once be set.
        /// </summary>
        [Input("clusterIntranetSubnetId")]
        public Input<string>? ClusterIntranetSubnetId { get; set; }

        /// <summary>
        /// Indicates whether `Ipvs` is enabled. Default is true. False means `Iptables` is enabled.
        /// </summary>
        [Input("clusterIpvs")]
        public Input<bool>? ClusterIpvs { get; set; }

        /// <summary>
        /// Specify cluster level, valid for managed cluster, use data source `tencentcloud.Kubernetes.getClusterLevels` to query available levels. Available value examples `L5`, `L20`, `L50`, `L100`, etc.
        /// </summary>
        [Input("clusterLevel")]
        public Input<string>? ClusterLevel { get; set; }

        /// <summary>
        /// The maximum number of Pods per node in the cluster. Default is 256. The minimum value is 4. When its power unequal to 2, it will round upward to the closest power of 2.
        /// </summary>
        [Input("clusterMaxPodNum")]
        public Input<int>? ClusterMaxPodNum { get; set; }

        /// <summary>
        /// The maximum number of services in the cluster. Default is 256. The range is from 32 to 32768. When its power unequal to 2, it will round upward to the closest power of 2.
        /// </summary>
        [Input("clusterMaxServiceNum")]
        public Input<int>? ClusterMaxServiceNum { get; set; }

        /// <summary>
        /// Name of the cluster.
        /// </summary>
        [Input("clusterName")]
        public Input<string>? ClusterName { get; set; }

        /// <summary>
        /// Cluster operating system, supports setting public images (the field passes the corresponding image Name) and custom images (the field passes the corresponding image ID). For details, please refer to: https://cloud.tencent.com/document/product/457/68289.
        /// </summary>
        [Input("clusterOs")]
        public Input<string>? ClusterOs { get; set; }

        /// <summary>
        /// Image type of the cluster os, the available values include: 'GENERAL'. Default is 'GENERAL'.
        /// </summary>
        [Input("clusterOsType")]
        public Input<string>? ClusterOsType { get; set; }

        /// <summary>
        /// Subnet ID of the cluster, such as: subnet-b3p7d7q5.
        /// </summary>
        [Input("clusterSubnetId")]
        public Input<string>? ClusterSubnetId { get; set; }

        /// <summary>
        /// Version of the cluster. Use `tencentcloud.Kubernetes.getAvailableClusterVersions` to get the upgradable cluster version.
        /// </summary>
        [Input("clusterVersion")]
        public Input<string>? ClusterVersion { get; set; }

        /// <summary>
        /// Runtime type of the cluster, the available values include: 'docker' and 'containerd'.The Kubernetes v1.24 has removed dockershim, so please use containerd in v1.24 or higher. The default value is `Docker` for versions below v1.24 and `Containerd` for versions above v1.24.
        /// </summary>
        [Input("containerRuntime")]
        public Input<string>? ContainerRuntime { get; set; }

        /// <summary>
        /// Whether to enable DataPlaneV2 (replace kube-proxy with cilium). `DataPlaneV2` and `ClusterIpvs` should not be set at the same time.
        /// </summary>
        [Input("dataPlaneV2")]
        public Input<bool>? DataPlaneV2 { get; set; }

        /// <summary>
        /// Indicates whether cluster deletion protection is enabled. Default is false.
        /// </summary>
        [Input("deletionProtection")]
        public Input<bool>? DeletionProtection { get; set; }

        [Input("disableAddons")]
        private InputList<string>? _disableAddons;

        /// <summary>
        /// To prevent the installation of a specific Addon component, enter the corresponding AddonName.
        /// </summary>
        public InputList<string> DisableAddons
        {
            get => _disableAddons ?? (_disableAddons = new InputList<string>());
            set => _disableAddons = value;
        }

        /// <summary>
        /// Docker graph path. Default is `/var/lib/docker`.
        /// </summary>
        [Input("dockerGraphPath")]
        public Input<string>? DockerGraphPath { get; set; }

        /// <summary>
        /// Whether to enable the custom mode of node podCIDR size. Default is false.
        /// </summary>
        [Input("enableCustomizedPodCidr")]
        public Input<bool>? EnableCustomizedPodCidr { get; set; }

        [Input("eniSubnetIds")]
        private InputList<string>? _eniSubnetIds;

        /// <summary>
        /// Subnet Ids for cluster with VPC-CNI network mode. This field can only set when field `NetworkType` is 'VPC-CNI'. `EniSubnetIds` can not empty once be set.
        /// </summary>
        public InputList<string> EniSubnetIds
        {
            get => _eniSubnetIds ?? (_eniSubnetIds = new InputList<string>());
            set => _eniSubnetIds = value;
        }

        /// <summary>
        /// Specify cluster Event Persistence config. NOTE: Please make sure your TKE CamRole have permission to access CLS service.
        /// </summary>
        [Input("eventPersistence")]
        public Input<Inputs.ClusterEventPersistenceArgs>? EventPersistence { get; set; }

        [Input("existInstances")]
        private InputList<Inputs.ClusterExistInstanceArgs>? _existInstances;

        /// <summary>
        /// Create tke cluster by existed instances.
        /// </summary>
        public InputList<Inputs.ClusterExistInstanceArgs> ExistInstances
        {
            get => _existInstances ?? (_existInstances = new InputList<Inputs.ClusterExistInstanceArgs>());
            set => _existInstances = value;
        }

        [Input("extensionAddons")]
        private InputList<Inputs.ClusterExtensionAddonArgs>? _extensionAddons;

        /// <summary>
        /// Information of the add-on to be installed. It is recommended to use resource `tencentcloud.Kubernetes.Addon` management cluster addon.
        /// </summary>
        public InputList<Inputs.ClusterExtensionAddonArgs> ExtensionAddons
        {
            get => _extensionAddons ?? (_extensionAddons = new InputList<Inputs.ClusterExtensionAddonArgs>());
            set => _extensionAddons = value;
        }

        [Input("extraArgs")]
        private InputList<string>? _extraArgs;

        /// <summary>
        /// Custom parameter information related to the node.
        /// </summary>
        public InputList<string> ExtraArgs
        {
            get => _extraArgs ?? (_extraArgs = new InputList<string>());
            set => _extraArgs = value;
        }

        /// <summary>
        /// Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it takes effect for all nodes.
        /// </summary>
        [Input("globeDesiredPodNum")]
        public Input<int>? GlobeDesiredPodNum { get; set; }

        /// <summary>
        /// Indicates whether to ignore the cluster cidr conflict error. Default is false.
        /// </summary>
        [Input("ignoreClusterCidrConflict")]
        public Input<bool>? IgnoreClusterCidrConflict { get; set; }

        /// <summary>
        /// Indicates whether to ignore the service cidr conflict error. Only valid in `VPC-CNI` mode.
        /// </summary>
        [Input("ignoreServiceCidrConflict")]
        public Input<bool>? IgnoreServiceCidrConflict { get; set; }

        /// <summary>
        /// The strategy for deleting cluster instances: terminate (destroy instances, only support pay as you go cloud host instances) retain (remove only, keep instances), Default is terminate.
        /// </summary>
        [Input("instanceDeleteMode")]
        public Input<string>? InstanceDeleteMode { get; set; }

        /// <summary>
        /// In the VPC-CNI mode of the cluster, the dual stack cluster status defaults to false, indicating a non dual stack cluster.
        /// </summary>
        [Input("isDualStack")]
        public Input<bool>? IsDualStack { get; set; }

        /// <summary>
        /// Indicates whether non-static ip mode is enabled. Default is false.
        /// </summary>
        [Input("isNonStaticIpMode")]
        public Input<bool>? IsNonStaticIpMode { get; set; }

        /// <summary>
        /// Cluster kube-proxy mode, the available values include: 'kube-proxy-bpf'. Default is not set.When set to kube-proxy-bpf, cluster version greater than 1.14 and with Tencent Linux 2.4 is required.
        /// </summary>
        [Input("kubeProxyMode")]
        public Input<string>? KubeProxyMode { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Labels of tke cluster nodes.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Specify cluster log agent config.
        /// </summary>
        [Input("logAgent")]
        public Input<Inputs.ClusterLogAgentArgs>? LogAgent { get; set; }

        [Input("managedClusterInternetSecurityPolicies")]
        private InputList<string>? _managedClusterInternetSecurityPolicies;

        /// <summary>
        /// this argument was deprecated, use `ClusterInternetSecurityGroup` instead. Security policies for managed cluster internet, like:'192.168.1.0/24' or '113.116.51.27', '0.0.0.0/0' means all. This field can only set when field `ClusterDeployType` is 'MANAGED_CLUSTER' and `ClusterInternet` is true. `ManagedClusterInternetSecurityPolicies` can not delete or empty once be set.
        /// </summary>
        [Obsolete(@"this argument was deprecated, use `ClusterInternetSecurityGroup` instead.")]
        public InputList<string> ManagedClusterInternetSecurityPolicies
        {
            get => _managedClusterInternetSecurityPolicies ?? (_managedClusterInternetSecurityPolicies = new InputList<string>());
            set => _managedClusterInternetSecurityPolicies = value;
        }

        [Input("masterConfigs")]
        private InputList<Inputs.ClusterMasterConfigArgs>? _masterConfigs;

        /// <summary>
        /// Deploy the machine configuration information of the 'MASTER_ETCD' service, and create &lt;=7 units for common users.
        /// </summary>
        public InputList<Inputs.ClusterMasterConfigArgs> MasterConfigs
        {
            get => _masterConfigs ?? (_masterConfigs = new InputList<Inputs.ClusterMasterConfigArgs>());
            set => _masterConfigs = value;
        }

        /// <summary>
        /// Mount target. Default is not mounting.
        /// </summary>
        [Input("mountTarget")]
        public Input<string>? MountTarget { get; set; }

        /// <summary>
        /// Cluster network type, the available values include: 'GR' and 'VPC-CNI' and 'CiliumOverlay'. Default is GR.
        /// </summary>
        [Input("networkType")]
        public Input<string>? NetworkType { get; set; }

        /// <summary>
        /// Node name type of Cluster, the available values include: 'lan-ip' and 'hostname', Default is 'lan-ip'.
        /// </summary>
        [Input("nodeNameType")]
        public Input<string>? NodeNameType { get; set; }

        [Input("nodePoolGlobalConfigs")]
        private InputList<Inputs.ClusterNodePoolGlobalConfigArgs>? _nodePoolGlobalConfigs;

        /// <summary>
        /// Global config effective for all node pools.
        /// </summary>
        public InputList<Inputs.ClusterNodePoolGlobalConfigArgs> NodePoolGlobalConfigs
        {
            get => _nodePoolGlobalConfigs ?? (_nodePoolGlobalConfigs = new InputList<Inputs.ClusterNodePoolGlobalConfigArgs>());
            set => _nodePoolGlobalConfigs = value;
        }

        /// <summary>
        /// Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        /// </summary>
        [Input("preStartUserScript")]
        public Input<string>? PreStartUserScript { get; set; }

        /// <summary>
        /// Project ID, default value is 0.
        /// </summary>
        [Input("projectId")]
        public Input<int>? ProjectId { get; set; }

        [Input("resourceDeleteOptions")]
        private InputList<Inputs.ClusterResourceDeleteOptionArgs>? _resourceDeleteOptions;

        /// <summary>
        /// The resource deletion policy when the cluster is deleted. Currently, CBS is supported (CBS is retained by default). Only valid when deleting cluster.
        /// </summary>
        public InputList<Inputs.ClusterResourceDeleteOptionArgs> ResourceDeleteOptions
        {
            get => _resourceDeleteOptions ?? (_resourceDeleteOptions = new InputList<Inputs.ClusterResourceDeleteOptionArgs>());
            set => _resourceDeleteOptions = value;
        }

        /// <summary>
        /// Container Runtime version.
        /// </summary>
        [Input("runtimeVersion")]
        public Input<string>? RuntimeVersion { get; set; }

        /// <summary>
        /// A network address block of the service. Different from vpc cidr and cidr of other clusters within this vpc. Must be in  10./192.168/172.[16-31] segments.
        /// </summary>
        [Input("serviceCidr")]
        public Input<string>? ServiceCidr { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// The tags of the cluster.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Sets whether the joining node participates in the schedule. Default is '0'. Participate in scheduling.
        /// </summary>
        [Input("unschedulable")]
        public Input<int>? Unschedulable { get; set; }

        /// <summary>
        /// Indicates whether upgrade all instances when ClusterVersion change. Default is false.
        /// </summary>
        [Input("upgradeInstancesFollowCluster")]
        public Input<bool>? UpgradeInstancesFollowCluster { get; set; }

        /// <summary>
        /// Distinguish between shared network card multi-IP mode and independent network card mode. Fill in `tke-route-eni` for shared network card multi-IP mode and `tke-direct-eni` for independent network card mode. The default is shared network card mode. When it is necessary to turn off the vpc-cni container network capability, both `EniSubnetIds` and `VpcCniType` must be set to empty.
        /// </summary>
        [Input("vpcCniType")]
        public Input<string>? VpcCniType { get; set; }

        /// <summary>
        /// Vpc Id of the cluster.
        /// </summary>
        [Input("vpcId", required: true)]
        public Input<string> VpcId { get; set; } = null!;

        [Input("workerConfigs")]
        private InputList<Inputs.ClusterWorkerConfigArgs>? _workerConfigs;

        /// <summary>
        /// Deploy the machine configuration information of the 'WORKER' service, and create &lt;=20 units for common users. The other 'WORK' service are added by 'tencentcloud_kubernetes_scale_worker'.
        /// </summary>
        public InputList<Inputs.ClusterWorkerConfigArgs> WorkerConfigs
        {
            get => _workerConfigs ?? (_workerConfigs = new InputList<Inputs.ClusterWorkerConfigArgs>());
            set => _workerConfigs = value;
        }

        public ClusterArgs()
        {
        }
        public static new ClusterArgs Empty => new ClusterArgs();
    }

    public sealed class ClusterState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If set to true, it will acquire the ClusterRole tke:admin. NOTE: this arguments cannot revoke to `False` after acquired.
        /// </summary>
        [Input("acquireClusterAdminRole")]
        public Input<bool>? AcquireClusterAdminRole { get; set; }

        /// <summary>
        /// Specify cluster authentication configuration. Only available for managed cluster and `ClusterVersion` &gt;= 1.20.
        /// </summary>
        [Input("authOptions")]
        public Input<Inputs.ClusterAuthOptionsGetArgs>? AuthOptions { get; set; }

        /// <summary>
        /// Whether the cluster level auto upgraded, valid for managed cluster.
        /// </summary>
        [Input("autoUpgradeClusterLevel")]
        public Input<bool>? AutoUpgradeClusterLevel { get; set; }

        /// <summary>
        /// The number of basic pods. valid when enable_customized_pod_cidr=true.
        /// </summary>
        [Input("basePodNum")]
        public Input<int>? BasePodNum { get; set; }

        /// <summary>
        /// CDC ID.
        /// </summary>
        [Input("cdcId")]
        public Input<string>? CdcId { get; set; }

        /// <summary>
        /// The certificate used for access.
        /// </summary>
        [Input("certificationAuthority")]
        public Input<string>? CertificationAuthority { get; set; }

        /// <summary>
        /// Claim expired seconds to recycle ENI. This field can only set when field `NetworkType` is 'VPC-CNI'. `ClaimExpiredSeconds` must greater or equal than 300 and less than 15768000.
        /// </summary>
        [Input("claimExpiredSeconds")]
        public Input<int>? ClaimExpiredSeconds { get; set; }

        /// <summary>
        /// (**Deprecated**) This argument is deprecated because the TKE auto-scaling group was no longer available. Indicates whether to enable cluster node auto scaling. Default is false.
        /// </summary>
        [Input("clusterAsEnabled")]
        public Input<bool>? ClusterAsEnabled { get; set; }

        /// <summary>
        /// Specify Cluster Audit config. NOTE: Please make sure your TKE CamRole have permission to access CLS service.
        /// </summary>
        [Input("clusterAudit")]
        public Input<Inputs.ClusterClusterAuditGetArgs>? ClusterAudit { get; set; }

        /// <summary>
        /// A network address block of the cluster. Different from vpc cidr and cidr of other clusters within this vpc. Must be in  10./192.168/172.[16-31] segments.
        /// </summary>
        [Input("clusterCidr")]
        public Input<string>? ClusterCidr { get; set; }

        /// <summary>
        /// Deployment type of the cluster, the available values include: 'MANAGED_CLUSTER' and 'INDEPENDENT_CLUSTER'. Default is 'MANAGED_CLUSTER'.
        /// </summary>
        [Input("clusterDeployType")]
        public Input<string>? ClusterDeployType { get; set; }

        /// <summary>
        /// Description of the cluster.
        /// </summary>
        [Input("clusterDesc")]
        public Input<string>? ClusterDesc { get; set; }

        /// <summary>
        /// External network address to access.
        /// </summary>
        [Input("clusterExternalEndpoint")]
        public Input<string>? ClusterExternalEndpoint { get; set; }

        /// <summary>
        /// Customized parameters for master component,such as kube-apiserver, kube-controller-manager, kube-scheduler.
        /// </summary>
        [Input("clusterExtraArgs")]
        public Input<Inputs.ClusterClusterExtraArgsGetArgs>? ClusterExtraArgs { get; set; }

        /// <summary>
        /// Open internet access or not. If this field is set 'true', the field below `WorkerConfig` must be set. Because only cluster with node is allowed enable access endpoint. You may open it through `tencentcloud.Kubernetes.ClusterEndpoint`.
        /// </summary>
        [Input("clusterInternet")]
        public Input<bool>? ClusterInternet { get; set; }

        /// <summary>
        /// Domain name for cluster Kube-apiserver internet access. Be careful if you modify value of this parameter, the ClusterExternalEndpoint value may be changed automatically too.
        /// </summary>
        [Input("clusterInternetDomain")]
        public Input<string>? ClusterInternetDomain { get; set; }

        /// <summary>
        /// Specify security group, NOTE: This argument must not be empty if cluster internet enabled.
        /// </summary>
        [Input("clusterInternetSecurityGroup")]
        public Input<string>? ClusterInternetSecurityGroup { get; set; }

        /// <summary>
        /// Open intranet access or not. If this field is set 'true', the field below `WorkerConfig` must be set. Because only cluster with node is allowed enable access endpoint. You may open it through `tencentcloud.Kubernetes.ClusterEndpoint`.
        /// </summary>
        [Input("clusterIntranet")]
        public Input<bool>? ClusterIntranet { get; set; }

        /// <summary>
        /// Domain name for cluster Kube-apiserver intranet access. Be careful if you modify value of this parameter, the PgwEndpoint value may be changed automatically too.
        /// </summary>
        [Input("clusterIntranetDomain")]
        public Input<string>? ClusterIntranetDomain { get; set; }

        /// <summary>
        /// Subnet id who can access this independent cluster, this field must and can only set  when `ClusterIntranet` is true. `ClusterIntranetSubnetId` can not modify once be set.
        /// </summary>
        [Input("clusterIntranetSubnetId")]
        public Input<string>? ClusterIntranetSubnetId { get; set; }

        /// <summary>
        /// Indicates whether `Ipvs` is enabled. Default is true. False means `Iptables` is enabled.
        /// </summary>
        [Input("clusterIpvs")]
        public Input<bool>? ClusterIpvs { get; set; }

        /// <summary>
        /// Specify cluster level, valid for managed cluster, use data source `tencentcloud.Kubernetes.getClusterLevels` to query available levels. Available value examples `L5`, `L20`, `L50`, `L100`, etc.
        /// </summary>
        [Input("clusterLevel")]
        public Input<string>? ClusterLevel { get; set; }

        /// <summary>
        /// The maximum number of Pods per node in the cluster. Default is 256. The minimum value is 4. When its power unequal to 2, it will round upward to the closest power of 2.
        /// </summary>
        [Input("clusterMaxPodNum")]
        public Input<int>? ClusterMaxPodNum { get; set; }

        /// <summary>
        /// The maximum number of services in the cluster. Default is 256. The range is from 32 to 32768. When its power unequal to 2, it will round upward to the closest power of 2.
        /// </summary>
        [Input("clusterMaxServiceNum")]
        public Input<int>? ClusterMaxServiceNum { get; set; }

        /// <summary>
        /// Name of the cluster.
        /// </summary>
        [Input("clusterName")]
        public Input<string>? ClusterName { get; set; }

        /// <summary>
        /// Number of nodes in the cluster.
        /// </summary>
        [Input("clusterNodeNum")]
        public Input<int>? ClusterNodeNum { get; set; }

        /// <summary>
        /// Cluster operating system, supports setting public images (the field passes the corresponding image Name) and custom images (the field passes the corresponding image ID). For details, please refer to: https://cloud.tencent.com/document/product/457/68289.
        /// </summary>
        [Input("clusterOs")]
        public Input<string>? ClusterOs { get; set; }

        /// <summary>
        /// Image type of the cluster os, the available values include: 'GENERAL'. Default is 'GENERAL'.
        /// </summary>
        [Input("clusterOsType")]
        public Input<string>? ClusterOsType { get; set; }

        /// <summary>
        /// Subnet ID of the cluster, such as: subnet-b3p7d7q5.
        /// </summary>
        [Input("clusterSubnetId")]
        public Input<string>? ClusterSubnetId { get; set; }

        /// <summary>
        /// Version of the cluster. Use `tencentcloud.Kubernetes.getAvailableClusterVersions` to get the upgradable cluster version.
        /// </summary>
        [Input("clusterVersion")]
        public Input<string>? ClusterVersion { get; set; }

        /// <summary>
        /// Runtime type of the cluster, the available values include: 'docker' and 'containerd'.The Kubernetes v1.24 has removed dockershim, so please use containerd in v1.24 or higher. The default value is `Docker` for versions below v1.24 and `Containerd` for versions above v1.24.
        /// </summary>
        [Input("containerRuntime")]
        public Input<string>? ContainerRuntime { get; set; }

        /// <summary>
        /// Whether to enable DataPlaneV2 (replace kube-proxy with cilium). `DataPlaneV2` and `ClusterIpvs` should not be set at the same time.
        /// </summary>
        [Input("dataPlaneV2")]
        public Input<bool>? DataPlaneV2 { get; set; }

        /// <summary>
        /// Indicates whether cluster deletion protection is enabled. Default is false.
        /// </summary>
        [Input("deletionProtection")]
        public Input<bool>? DeletionProtection { get; set; }

        [Input("disableAddons")]
        private InputList<string>? _disableAddons;

        /// <summary>
        /// To prevent the installation of a specific Addon component, enter the corresponding AddonName.
        /// </summary>
        public InputList<string> DisableAddons
        {
            get => _disableAddons ?? (_disableAddons = new InputList<string>());
            set => _disableAddons = value;
        }

        /// <summary>
        /// Docker graph path. Default is `/var/lib/docker`.
        /// </summary>
        [Input("dockerGraphPath")]
        public Input<string>? DockerGraphPath { get; set; }

        /// <summary>
        /// Domain name for access.
        /// </summary>
        [Input("domain")]
        public Input<string>? Domain { get; set; }

        /// <summary>
        /// Whether to enable the custom mode of node podCIDR size. Default is false.
        /// </summary>
        [Input("enableCustomizedPodCidr")]
        public Input<bool>? EnableCustomizedPodCidr { get; set; }

        [Input("eniSubnetIds")]
        private InputList<string>? _eniSubnetIds;

        /// <summary>
        /// Subnet Ids for cluster with VPC-CNI network mode. This field can only set when field `NetworkType` is 'VPC-CNI'. `EniSubnetIds` can not empty once be set.
        /// </summary>
        public InputList<string> EniSubnetIds
        {
            get => _eniSubnetIds ?? (_eniSubnetIds = new InputList<string>());
            set => _eniSubnetIds = value;
        }

        /// <summary>
        /// Specify cluster Event Persistence config. NOTE: Please make sure your TKE CamRole have permission to access CLS service.
        /// </summary>
        [Input("eventPersistence")]
        public Input<Inputs.ClusterEventPersistenceGetArgs>? EventPersistence { get; set; }

        [Input("existInstances")]
        private InputList<Inputs.ClusterExistInstanceGetArgs>? _existInstances;

        /// <summary>
        /// Create tke cluster by existed instances.
        /// </summary>
        public InputList<Inputs.ClusterExistInstanceGetArgs> ExistInstances
        {
            get => _existInstances ?? (_existInstances = new InputList<Inputs.ClusterExistInstanceGetArgs>());
            set => _existInstances = value;
        }

        [Input("extensionAddons")]
        private InputList<Inputs.ClusterExtensionAddonGetArgs>? _extensionAddons;

        /// <summary>
        /// Information of the add-on to be installed. It is recommended to use resource `tencentcloud.Kubernetes.Addon` management cluster addon.
        /// </summary>
        public InputList<Inputs.ClusterExtensionAddonGetArgs> ExtensionAddons
        {
            get => _extensionAddons ?? (_extensionAddons = new InputList<Inputs.ClusterExtensionAddonGetArgs>());
            set => _extensionAddons = value;
        }

        [Input("extraArgs")]
        private InputList<string>? _extraArgs;

        /// <summary>
        /// Custom parameter information related to the node.
        /// </summary>
        public InputList<string> ExtraArgs
        {
            get => _extraArgs ?? (_extraArgs = new InputList<string>());
            set => _extraArgs = value;
        }

        /// <summary>
        /// Indicate to set desired pod number in node. valid when enable_customized_pod_cidr=true, and it takes effect for all nodes.
        /// </summary>
        [Input("globeDesiredPodNum")]
        public Input<int>? GlobeDesiredPodNum { get; set; }

        /// <summary>
        /// Indicates whether to ignore the cluster cidr conflict error. Default is false.
        /// </summary>
        [Input("ignoreClusterCidrConflict")]
        public Input<bool>? IgnoreClusterCidrConflict { get; set; }

        /// <summary>
        /// Indicates whether to ignore the service cidr conflict error. Only valid in `VPC-CNI` mode.
        /// </summary>
        [Input("ignoreServiceCidrConflict")]
        public Input<bool>? IgnoreServiceCidrConflict { get; set; }

        /// <summary>
        /// The strategy for deleting cluster instances: terminate (destroy instances, only support pay as you go cloud host instances) retain (remove only, keep instances), Default is terminate.
        /// </summary>
        [Input("instanceDeleteMode")]
        public Input<string>? InstanceDeleteMode { get; set; }

        /// <summary>
        /// In the VPC-CNI mode of the cluster, the dual stack cluster status defaults to false, indicating a non dual stack cluster.
        /// </summary>
        [Input("isDualStack")]
        public Input<bool>? IsDualStack { get; set; }

        /// <summary>
        /// Indicates whether non-static ip mode is enabled. Default is false.
        /// </summary>
        [Input("isNonStaticIpMode")]
        public Input<bool>? IsNonStaticIpMode { get; set; }

        [Input("kubeConfig")]
        private Input<string>? _kubeConfig;

        /// <summary>
        /// Kubernetes config.
        /// </summary>
        public Input<string>? KubeConfig
        {
            get => _kubeConfig;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _kubeConfig = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("kubeConfigIntranet")]
        private Input<string>? _kubeConfigIntranet;

        /// <summary>
        /// Kubernetes config of private network.
        /// </summary>
        public Input<string>? KubeConfigIntranet
        {
            get => _kubeConfigIntranet;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _kubeConfigIntranet = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Cluster kube-proxy mode, the available values include: 'kube-proxy-bpf'. Default is not set.When set to kube-proxy-bpf, cluster version greater than 1.14 and with Tencent Linux 2.4 is required.
        /// </summary>
        [Input("kubeProxyMode")]
        public Input<string>? KubeProxyMode { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Labels of tke cluster nodes.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Specify cluster log agent config.
        /// </summary>
        [Input("logAgent")]
        public Input<Inputs.ClusterLogAgentGetArgs>? LogAgent { get; set; }

        [Input("managedClusterInternetSecurityPolicies")]
        private InputList<string>? _managedClusterInternetSecurityPolicies;

        /// <summary>
        /// this argument was deprecated, use `ClusterInternetSecurityGroup` instead. Security policies for managed cluster internet, like:'192.168.1.0/24' or '113.116.51.27', '0.0.0.0/0' means all. This field can only set when field `ClusterDeployType` is 'MANAGED_CLUSTER' and `ClusterInternet` is true. `ManagedClusterInternetSecurityPolicies` can not delete or empty once be set.
        /// </summary>
        [Obsolete(@"this argument was deprecated, use `ClusterInternetSecurityGroup` instead.")]
        public InputList<string> ManagedClusterInternetSecurityPolicies
        {
            get => _managedClusterInternetSecurityPolicies ?? (_managedClusterInternetSecurityPolicies = new InputList<string>());
            set => _managedClusterInternetSecurityPolicies = value;
        }

        [Input("masterConfigs")]
        private InputList<Inputs.ClusterMasterConfigGetArgs>? _masterConfigs;

        /// <summary>
        /// Deploy the machine configuration information of the 'MASTER_ETCD' service, and create &lt;=7 units for common users.
        /// </summary>
        public InputList<Inputs.ClusterMasterConfigGetArgs> MasterConfigs
        {
            get => _masterConfigs ?? (_masterConfigs = new InputList<Inputs.ClusterMasterConfigGetArgs>());
            set => _masterConfigs = value;
        }

        /// <summary>
        /// Mount target. Default is not mounting.
        /// </summary>
        [Input("mountTarget")]
        public Input<string>? MountTarget { get; set; }

        /// <summary>
        /// Cluster network type, the available values include: 'GR' and 'VPC-CNI' and 'CiliumOverlay'. Default is GR.
        /// </summary>
        [Input("networkType")]
        public Input<string>? NetworkType { get; set; }

        /// <summary>
        /// Node name type of Cluster, the available values include: 'lan-ip' and 'hostname', Default is 'lan-ip'.
        /// </summary>
        [Input("nodeNameType")]
        public Input<string>? NodeNameType { get; set; }

        [Input("nodePoolGlobalConfigs")]
        private InputList<Inputs.ClusterNodePoolGlobalConfigGetArgs>? _nodePoolGlobalConfigs;

        /// <summary>
        /// Global config effective for all node pools.
        /// </summary>
        public InputList<Inputs.ClusterNodePoolGlobalConfigGetArgs> NodePoolGlobalConfigs
        {
            get => _nodePoolGlobalConfigs ?? (_nodePoolGlobalConfigs = new InputList<Inputs.ClusterNodePoolGlobalConfigGetArgs>());
            set => _nodePoolGlobalConfigs = value;
        }

        /// <summary>
        /// Password of account.
        /// </summary>
        [Input("password")]
        public Input<string>? Password { get; set; }

        /// <summary>
        /// The Intranet address used for access.
        /// </summary>
        [Input("pgwEndpoint")]
        public Input<string>? PgwEndpoint { get; set; }

        /// <summary>
        /// Base64-encoded user script, executed before initializing the node, currently only effective for adding existing nodes.
        /// </summary>
        [Input("preStartUserScript")]
        public Input<string>? PreStartUserScript { get; set; }

        /// <summary>
        /// Project ID, default value is 0.
        /// </summary>
        [Input("projectId")]
        public Input<int>? ProjectId { get; set; }

        [Input("resourceDeleteOptions")]
        private InputList<Inputs.ClusterResourceDeleteOptionGetArgs>? _resourceDeleteOptions;

        /// <summary>
        /// The resource deletion policy when the cluster is deleted. Currently, CBS is supported (CBS is retained by default). Only valid when deleting cluster.
        /// </summary>
        public InputList<Inputs.ClusterResourceDeleteOptionGetArgs> ResourceDeleteOptions
        {
            get => _resourceDeleteOptions ?? (_resourceDeleteOptions = new InputList<Inputs.ClusterResourceDeleteOptionGetArgs>());
            set => _resourceDeleteOptions = value;
        }

        /// <summary>
        /// Container Runtime version.
        /// </summary>
        [Input("runtimeVersion")]
        public Input<string>? RuntimeVersion { get; set; }

        [Input("securityPolicies")]
        private InputList<string>? _securityPolicies;

        /// <summary>
        /// Access policy.
        /// </summary>
        public InputList<string> SecurityPolicies
        {
            get => _securityPolicies ?? (_securityPolicies = new InputList<string>());
            set => _securityPolicies = value;
        }

        /// <summary>
        /// A network address block of the service. Different from vpc cidr and cidr of other clusters within this vpc. Must be in  10./192.168/172.[16-31] segments.
        /// </summary>
        [Input("serviceCidr")]
        public Input<string>? ServiceCidr { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// The tags of the cluster.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Sets whether the joining node participates in the schedule. Default is '0'. Participate in scheduling.
        /// </summary>
        [Input("unschedulable")]
        public Input<int>? Unschedulable { get; set; }

        /// <summary>
        /// Indicates whether upgrade all instances when ClusterVersion change. Default is false.
        /// </summary>
        [Input("upgradeInstancesFollowCluster")]
        public Input<bool>? UpgradeInstancesFollowCluster { get; set; }

        /// <summary>
        /// User name of account.
        /// </summary>
        [Input("userName")]
        public Input<string>? UserName { get; set; }

        /// <summary>
        /// Distinguish between shared network card multi-IP mode and independent network card mode. Fill in `tke-route-eni` for shared network card multi-IP mode and `tke-direct-eni` for independent network card mode. The default is shared network card mode. When it is necessary to turn off the vpc-cni container network capability, both `EniSubnetIds` and `VpcCniType` must be set to empty.
        /// </summary>
        [Input("vpcCniType")]
        public Input<string>? VpcCniType { get; set; }

        /// <summary>
        /// Vpc Id of the cluster.
        /// </summary>
        [Input("vpcId")]
        public Input<string>? VpcId { get; set; }

        [Input("workerConfigs")]
        private InputList<Inputs.ClusterWorkerConfigGetArgs>? _workerConfigs;

        /// <summary>
        /// Deploy the machine configuration information of the 'WORKER' service, and create &lt;=20 units for common users. The other 'WORK' service are added by 'tencentcloud_kubernetes_scale_worker'.
        /// </summary>
        public InputList<Inputs.ClusterWorkerConfigGetArgs> WorkerConfigs
        {
            get => _workerConfigs ?? (_workerConfigs = new InputList<Inputs.ClusterWorkerConfigGetArgs>());
            set => _workerConfigs = value;
        }

        [Input("workerInstancesLists")]
        private InputList<Inputs.ClusterWorkerInstancesListGetArgs>? _workerInstancesLists;

        /// <summary>
        /// An information list of cvm within the 'WORKER' clusters. Each element contains the following attributes:
        /// </summary>
        public InputList<Inputs.ClusterWorkerInstancesListGetArgs> WorkerInstancesLists
        {
            get => _workerInstancesLists ?? (_workerInstancesLists = new InputList<Inputs.ClusterWorkerInstancesListGetArgs>());
            set => _workerInstancesLists = value;
        }

        public ClusterState()
        {
        }
        public static new ClusterState Empty => new ClusterState();
    }
}
