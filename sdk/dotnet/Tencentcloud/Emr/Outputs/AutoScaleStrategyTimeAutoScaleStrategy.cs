// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace TencentCloudIAC.PulumiPackage.Tencentcloud.Emr.Outputs
{

    [OutputType]
    public sealed class AutoScaleStrategyTimeAutoScaleStrategy
    {
        /// <summary>
        /// Compensation expansion, 0 means not enabled, 1 means enabled.
        /// </summary>
        public readonly int? CompensateFlag;
        /// <summary>
        /// Default configuration group.
        /// </summary>
        public readonly string? ConfigGroupAssigned;
        /// <summary>
        /// Elegant shrink switch.
        /// </summary>
        public readonly bool? GraceDownFlag;
        /// <summary>
        /// Graceful downsizing waiting time.
        /// </summary>
        public readonly int? GraceDownTime;
        /// <summary>
        /// scaling group id.
        /// </summary>
        public readonly int? GroupId;
        /// <summary>
        /// The cooling time after the policy is triggered. During this period, elastic expansion and contraction will not be triggered.
        /// </summary>
        public readonly int IntervalTime;
        /// <summary>
        /// Maximum usage time, seconds, minimum 1 hour, maximum 24 hours.
        /// </summary>
        public readonly int? MaxUse;
        /// <summary>
        /// Expansion resource calculation methods, "DEFAULT", "INSTANCE", "CPU", "MEMORYGB".
        /// "DEFAULT" means the default mode, which has the same meaning as "INSTANCE".
        /// "INSTANCE" means calculation based on nodes, the default method.
        /// "CPU" means calculated based on the number of cores of the machine.
        /// "MEMORYGB" means calculated based on the number of machine memory.
        /// </summary>
        public readonly string? MeasureMethod;
        /// <summary>
        /// Rule priority, the smaller it is, the higher it is.
        /// </summary>
        public readonly int Priority;
        /// <summary>
        /// Time expansion and contraction repetition strategy.
        /// </summary>
        public readonly Outputs.AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategy RepeatStrategy;
        /// <summary>
        /// When multiple rules are triggered at the same time and some of them are not actually executed, retries will be made within this time range.
        /// </summary>
        public readonly int RetryValidTime;
        /// <summary>
        /// Expansion and contraction actions, 1 means expansion, 2 means shrinkage.
        /// </summary>
        public readonly int ScaleAction;
        /// <summary>
        /// The number of expansions and contractions.
        /// </summary>
        public readonly int ScaleNum;
        /// <summary>
        /// Start process list.
        /// </summary>
        public readonly ImmutableArray<int> ServiceNodeInfos;
        /// <summary>
        /// Node deployment service list. Only fill in HDFS and YARN for deployment services. [Mapping relationship table corresponding to component names](https://cloud.tencent.com/document/product/589/98760).
        /// </summary>
        public readonly ImmutableArray<int> SoftDeployInfos;
        /// <summary>
        /// Policy unique ID.
        /// </summary>
        public readonly int? StrategyId;
        /// <summary>
        /// Policy name, unique within the cluster.
        /// </summary>
        public readonly string StrategyName;
        /// <summary>
        /// Rule status, 1 means valid, 2 means invalid, and 3 means suspended. Required.
        /// </summary>
        public readonly int StrategyStatus;
        /// <summary>
        /// Binding tag list.
        /// </summary>
        public readonly ImmutableArray<Outputs.AutoScaleStrategyTimeAutoScaleStrategyTag> Tags;
        /// <summary>
        /// Destruction strategy, "DEFAULT", the default destruction strategy, shrinkage is triggered by shrinkage rules, "TIMING" means scheduled destruction.
        /// </summary>
        public readonly string? TerminatePolicy;

        [OutputConstructor]
        private AutoScaleStrategyTimeAutoScaleStrategy(
            int? compensateFlag,

            string? configGroupAssigned,

            bool? graceDownFlag,

            int? graceDownTime,

            int? groupId,

            int intervalTime,

            int? maxUse,

            string? measureMethod,

            int priority,

            Outputs.AutoScaleStrategyTimeAutoScaleStrategyRepeatStrategy repeatStrategy,

            int retryValidTime,

            int scaleAction,

            int scaleNum,

            ImmutableArray<int> serviceNodeInfos,

            ImmutableArray<int> softDeployInfos,

            int? strategyId,

            string strategyName,

            int strategyStatus,

            ImmutableArray<Outputs.AutoScaleStrategyTimeAutoScaleStrategyTag> tags,

            string? terminatePolicy)
        {
            CompensateFlag = compensateFlag;
            ConfigGroupAssigned = configGroupAssigned;
            GraceDownFlag = graceDownFlag;
            GraceDownTime = graceDownTime;
            GroupId = groupId;
            IntervalTime = intervalTime;
            MaxUse = maxUse;
            MeasureMethod = measureMethod;
            Priority = priority;
            RepeatStrategy = repeatStrategy;
            RetryValidTime = retryValidTime;
            ScaleAction = scaleAction;
            ScaleNum = scaleNum;
            ServiceNodeInfos = serviceNodeInfos;
            SoftDeployInfos = softDeployInfos;
            StrategyId = strategyId;
            StrategyName = strategyName;
            StrategyStatus = strategyStatus;
            Tags = tags;
            TerminatePolicy = terminatePolicy;
        }
    }
}
